physical design cache one university two mellon university abstract performance proxy cache serve large number crucially dependent physical design current otherwise physical design depend cation representative proxy cache however inadequate since change rapidly remarkably show proxy cache astronomy federation receive continuously evolve present novel physical design adapt balance performance bene physical design cost implement include competitive incremental optimize combine cost query evaluation make physical design change general make underlie schema incoming preliminary experiment demonstrate improvement response time physical design continually adapt use algorithm compare introduction performance application crucially depend underlie physical design physical design often determine use representative however many proxy cache one two three content distribution network four serve continuous stream query identify representative cult physical design five six seven useful enable exploration physical design suit current however current otherwise nature invoke system administrator use representative provide static design entire bene physical design detect change adapt physical design automatically particularly interest physical design bypass cache eight proxy cache nine federation astronomy fact performance bypass cache critically depend upon physical design bypass cache store object table close provide dramatic reduction network c query response time eight however physical design cache object static mirror design instance belong physical table also store together cache group manner translate poor query execution performance cache may offset response time bene serve query locally particular several vertical partition ten eleven index selection five apply improve physical design vertical partition attractive solution improve physical design bypass cache construction auxiliary data structure indices materialize view present allocation cache space create auxiliary structure cache data vertical partition achieve performance bene query group logical table separate nonoverlapping physical thus vertical partition reduce amount io incur without introduce redundant data compete cache space however application current vertical partition cult require cation representative find representative hard astronomy exhibit considerable evolution ie manner attribute group query change drastically within week paper analyze physical design issue associate bypass cache develop vertical partition sensitive evolution use bypass cache case study examine sensitivity physical design determine degree evolution quantify cost vertical partition cache also describe vertical partition solution inspire task twelve task general capture cost transition two state addition cost execute task give state transition cost prevent state suboptimal long run include algorithm two group attribute also provide incremental algorithm vertical partition n possible minimize combine cost query execution make physical design change general improve physical design use vertical partition proxy cache make underlie physical design incoming step towards evaluate al query mediator bypass cache n l n w fig one proxy cache query execution performance p e e cache w cache zero response time fig two average response time query implement use query compare solution vertical partition tool experiment show seventeen improvement average query response time single relation continually reorganize manner adapt change currently implement solution within expect similar performance bene compare approach vertical partition bypass cache section describe bypass cache application eight explain cache provide interest case study physical design consider advantage physical design examine degree evolution bypass cache proxy cache reside mediator site federation figure one cache manifest participate member federation query submit mediator divide member either locally cache bypass remote query one access cache else bypass vertical partition module collocate cache suggest physical design change independently module see subset query receive cache since bypass due cache federation possess complex schema design often comprise several schema initial public release data thirteen remain static thereafter thus change schema do outside repository publish schema bulky group together instance two frequently access p f consist respectively belong relation logically relate astronomy query use together moreover use together query change time make physical design become cult figure nine appendix show frequent query three consecutive access together week change differ drastically group present original schema cache lower response time instead table cache quantify impact vertical partition bypass cache measure query response time figure two compare performance cache give two instance vertical partition apply cache group accord physical design group use ten tool vertical partition experiment maintain cache thirty size use month long sloan digital sky survey fourteen participant federation figure two illustrate advantage vertical partition perform manner suit experiment bypass cache use manner cache object prior incoming query use recent single query input result demonstrate improvement response time bypass cache solely attribute vertical partition take account cost implement physical design change overhead run partition tool cost become column group change drastically time column group per query basis figure two next experiment examine periodicity frequency column group change take plot matrix column group basic premise occur together similar group together relation fifteen figure three show matrix ten attribute single table grid entry correspond frequency pair attribute access together order attribute along row column figure three demonstrate column group change weekly basis mean time bene query performance bypass cache static analysis show group change weekly basis entirely different may change within span day thus cult ascertain time span regroup algorithm weigh bene amongst various column group incoming query decide make change section provide formal framework make vertical partition problem include cost change physical transition cost may data release three flag type r z frequency zero fig three matrix frequency ten select attribute p table r h e n e e r g v zero two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen one attribute fig four average cache resident time organization vertical partition eleven sixteen similar query execution cost transition cost term io bypass cache cost consider along cache resident time column vary across figure four instance little advantage reorganize amortize transition cost longer period time result figure four show many fall latter category relate work physical design de several proxy cache one two seventeen cache table two table column materialize view declare use declarative cache table construct similar available seventeen de cache group one use view schema materialize cache cache adapt change vertical partition group access together order improve memory disk performance ten eleven fifteen eighteen nineteen twenty early work fifteen derive indicator group together group apply cluster value however value actual io cost thus poor query performance recently cost estimate analytical model capture io use evaluate vertical partition ten eleven nineteen instance ten commercial obtain cost estimate query however exist require representative provide single static physical design entire identify representative easy fairly stable three ie generate query however exist astronomy even representative find process evaluate run physical design tool dependent current research emphasize need design tool continuously adapt physical design change seven tool study index selection sixteen vertical partition vertical partition provide formulation vertical partition capture cost physical design addition query evaluation let q sequence query let c set possible vertical partition section refer vertical partition two c con let query incur cost evaluate con two c let transition con two c two c incur cost finally let function one c con prior evaluation give cache space constraint initial con goal vertical partition problem minimize cost process q cost q one n x zero formulation similar task introduce al twelve task research extensively particularly transition cost form metric cost symmetric form metric provide con necessarily equivalent true sequence ie insertion deletion table require make physical design change exhibit different cost algorithm choose con c without see complete q particular prior evaluate query decide con c use knowledge query say competitive exist constant b every query sequence q query initially zero zero c current c opposite one two three four five k c c k k k one k g k k zero transition c fig five algorithm two con cost q cost q b optimal entire knowledge q remainder section describe algorithm scenario extend solution n con simplicity analysis restrict partition single table scenario give relation n attribute restrict solution two con con attribute store separate physical con attribute merge single physical relation term query evaluation reduce cost scan unused attribute minimize join overhead query access many attribute make transition cost al twelve give general algorithm metrical task extend task nonmetric present algorithm design scenario main observation transition opposite con remain current con incur substantial amount extra cost query execution let denote current query c c denote current opposite con respectively penalty k remain c de c c ie difference cost evaluate c compare opposite con c let query transition occur onwards j j k k de ne cumulative penalty j k p x de ne maximum cumulative penalty k j k j k interest cumulative penalty incur contiguous sequence query j k maximize word j zero j k j zero provide figure five make transition evaluate current query k theorem one proof consider query sequence q query modify q sequence query correspond cost word subtract cost con cost con mean cumulative penalty monotonically increase transition incur easy verify ratio cost cost least large correspond ratio respect q rest proof consider instead q query happen con query incur cost may incur cost depend con account cost assume incur cost query irrespective con without loss generality assume start let make k zero k even transition end con transition k incur cycle migrate con back result transition cost additionally incur total query evaluation cost k follow de transition occur maximum cumulative penalty exceed thus incur cost k transition lower bind cost incur k transition note incur cost long con opposite migrate incur transition cost remain con incur cost prior decision change con thus always better move opposite con con summary cost k transition transition cost incur hence cost three time b n con scenario extend n con describe two deal exponential number con n con scenario n algorithm must consider incoming query n one possible transition respect current con require track cumulative penalty remain current con relative every alternative pick one bene query performance let x two c current con two c alternative six x de ne k maximum cumulative penalty remain x rather transition query penalty remain x x scenario transition make k exceed constant threshold n threshold longer constant function con immediately prior x alternative con consider let z con immediately prior x threshold require transition alternative con z x x decision transition new con n greedy n transition con es k z x x n transition immediately con cumulative penalty exceed threshold greedy approach susceptible among con exhibit low migration cost problem particular n may transition con yield bene respect query performance overlook con higher cumulative bene incur large onetime transition cost practice expect minor n perform almost well con choose astronomy exhibit rapid change hourly basis furthermore con separate low migration cost tend yield similar performance query since con change perform exhaustive evaluation every alternative con incoming query infeasible trillion ways exist vertically partition table twenty attribute adopt two restrict search space first consider con x two c partition attribute one logical relation separate physical table let physical group attribute logical relation denote fragment thus two con set fragment next de ne neighbor relationship describe easiness term migration cost transition con denote set neighbor con respect x con two consider neighbor x transition x require coalesce two fragment x split exactly one fragment x two disjoint fragment provide x current con heuristic consider set con transition vertical partition eighteen ten provide intuition neighbor con instance ten start con attribute separate fragment enumerate candidate con coalesce exist fragment pairwise manner search space restrict small current con iteration produce gradually reduce expect query io cost approach vertical partition produce con perform well practice neighbor con similar transition change two fragment current con incur high io cost however restrict immediate solution neighbor prevent exploration entire space albeit via small incremental transition neighbor con also provide two desirable first since cost transition neighbor relatively low lower threshold overcome allow n respond quickly change moreover transition base small current con amortize io impact partition physical table limit disruption normal n introduce prune heuristic reduce set neighbor con partition ten invoke query estimate io cost query hypothetical con cost estimate use evaluate candidate con similarly accurately calculate penalty cost query consult incoming query every neighbor con since set neighbor order cost estimation major overhead system query response time often less second approach minimize query identify promise con base group attribute use frequently cost estimation perform con expect large impact query performance prune heuristic base observation attribute group order dominate astronomy allow us large pool neighbor con many query set change time new introduce gain importance approach similar association rule mine es set relate store base purchase pattern illustrate prune heuristic consider relation consist four attribute let ak denote set attribute access query set attribute g attribute group g ak thus g indicate potential group bene keep attribute g physical table lower cost evaluate give query access prune heuristic enumerate attribute group produce identify group guide transition ignore rest attribute group show transition neighbor con reduce cost evaluate include split fragment reduce cost scan extraneous attribute merge fragment reduce join cost select data several attribute illustrate process let current con consist three fragment attribute group import support coalesce fragment reduce join cost support split fragment eliminate cost scan attribute attribute group ignore correspond exist fragment indicate better alternative prune avoid double count physically manifest group require change two fragment current n weight c n n two neighbor query c current configuration initially neighbor zero neighbor c one two n neighbor three four five six seven eight nine ten k c n n k k n n neighbor c n transition n n neighbor neighbor neighbor n k c n k one k g fig six algorithm n con con recall neighbor form coalesce two fragment split one exist fragment attribute group evaluate neighbor con import find weight assign neighbor bene weight capture change relative importance respect expect bene query performance neighbor query evolve time n use io cost evaluate query current con weight transition neighbor weight expect greater impact query performance neighbor less weight thus support neighbor n n weight c c current con calculate weight base current con help bias optimization toward query bene namely group query perform poorly current con continue incur high io cost neighbor bene query receive higher weight n optimization focus neighbor may weight overcome threshold transition figure six provide n line fourteen employ prune heuristic weight neighbor bene neighbor accumulate weight consider transition line three threshold c n cost previous transition c current con line update maximum cumulative penalty neighbor transition neighbor n satisfy threshold n k c n v experiment section present initial evaluation algorithm prove validity generality algorithm conduct experiment query still process evaluate algorithm size complexity require robust framework currently work establish partition algorithm evaluate con secondary indices drop raw isolate bene vertical partition query performance decision support query take subset query reference order relation include query order relation consist row eight attribute one column particular comment occupy half relation total size access vertical partition perform order table use two query consist eight query type rand query generate randomly query occur equal probability second dom represent query access pattern closely match query dominate equal probability certain length query sequence current query dominate initial query sequence query dominate next one third query sequence dominate last dominance factor eighty evaluate algorithm ten partition tool unpartitioned order relation serve base table use query response time metric compare performance approach make comparison fair adapt cost estimation module evaluate query various candidate con thus module provide query estimate x x candidate con rely query estimate io cost query various con con virtual cost module create schema candidate con populate con data ensure accurate estimate cost estimation tool supply query system table statistics partition schema statistics generate full table scan estimate virtual con track closely real con ten account transition cost assume cost every transition logical page read page size logical page read allow us compare directly io cost query execution rely cost still develop framework estimate transition cost particular cult accurately estimate migration cost include write overhead cost data de ie alter table estimate obtain query experiment con run server main machine main memory two disk performance reason assign log one disk store second disk figure seven show average query response time partition algorithm compare rand perform slightly better algorithm due time require algorithm migrate con e e n p e r g v zero c e e none zero partition strategy query sequence fig seven query performance partition strategy fig eight estimate io cost query dom obtain run algorithm incur seven con change prior arrive stable con remainder dom algorithm outperform seventeen fact suggest con able detect change sequence contrast algorithm make thirteen con change course evaluate dom adapt con base query dominate sequence figure eight show algorithm estimate io cost subset query dom data point correspond estimate io cost query sequence vertical line denote con change better illustrate performance impact transition plot io cost third sequence second third third recall evolve query dominate initial third differ dominate second last third algorithm detect change adapt physical con accordingly seven transition occur initial third con oscillate rapidly query algorithm attempt regroup attribute unpartitioned order relation similarly second third algorithm detect change make appropriate transition early result illustrate two algorithm successfully detect change adapt change con remain relatively stable thereafter without first result provide initial validation approach impact cache ignore column cache algorithm may change performance transition cost experiment limit single table eight attribute leave several question unanswered observe low optimization overhead dozen con evaluate unclear algorithm scale diverse table since contain several hundred attribute also assume migration cost experiment yet explore proper metric cost migrate con cost accurately estimate thus derive accurate cost estimate low overhead remain important focus summary future work paper show need physical design solution bypass cache vertical partition important technique physical design improve physical design without add redundant data bypass cache receive continually evolve astronomy therefore need vertical partition technique present vertical partition problem balance query execution performance cost physical design change effectiveness physical design depend good cost estimation module cache take account fact object exhibit vary cache resident time cache constrain cost estimation must accurate plan integrate fast cache query plan improve cost estimation currently suit index selection vertical partition attractive solution physical design cache may useful consider construct indices object plan study impact index selection give indices also compete cache space construct indices reduce response time query object cache increase response time query object evict bypass address crucial integration indices reference one p j h j cache server two c c h b cache table pave way adaptive cache three q c h b g h woo l brown cache web application four l wang k park r pang v l reliability security content distribution network five v r index selection tool server six v r selection materialize view index seven e v automatic physical design tune sequence eight malik r burn bypass cache make c good network nine malik r web service approach federate ten schema design large c use data partition eleven v r b yang integrate vertical horizontal partition physical design twelve n e optimal algorithm metrical task system j vol four thirteen j gray p malik j c j public access sloan digital sky server data fourteen sloan digital sky survey available fifteen g j vertical partition design vol nine four sixteen n approach physical design seventeen team cache approach eighteen hammer b heuristic approach attribute tune nineteen w w approach vertical partition relational vol nineteen eight twenty w p effective approach vertical partition physical design relational vol sixteen two w r algorithm design metrical task soda w l l j uniform metrical task limit number state process vol four x wang malik r burn unit cache replacement cache r swami mine association rule set large available dash use query design appendix date top two query e r e q k seven one four one two zero eight zero two zero e r e q k nine one one two two zero five one two zero e r e q k nine one eight two two zero two two two zero select cast twenty cast twenty pi n p select distinct n p select pi p inner join phototype leave join leave join order select ra type flag status run rerun field type six ra ra select cast twenty cast twenty pi n p select ra type flag status run rerun field type three ra ra attribute field g r ra rerun run type z field flag g r ra rerun run status type z field flag g r ra rerun run status type z fig nine top two frequent query type week rightmost column list attribute relation access query