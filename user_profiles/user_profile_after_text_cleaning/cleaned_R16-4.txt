eliminate voltage via code janapa smith brook university kim hazelwood university recent circuit reliability modern become increasingly important shrink feature size diminish supply make circuit sensitive supply voltage result natural variation processor activity execute leave unattended voltage lead time even transistor lifetime issue article present collaborative approach mitigate voltage mechanism rectify voltage violate maximum tolerance layer reschedule program instruction stream prevent recur program location layer combine propose algorithm remove sixty minimal overhead thereby significantly improve overall performance solution radical departure ongoing approach circumvent issue altogether optimize voltage flux compromise power performance efficiency severely especially look ahead future technology exist conservative approach severe ability deliver efficient propose technique reassemble traditional reliability problem performance optimization problem thus allow us design typical case operation build intelligent prevent recur subject performance reliability reliability test general term performance reliability additional key word phrase voltage noise inductive noise voltage author address v j smith brook university k hazelwood university permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy show notice first page initial screen display along full citation copyright work own must honor abstract credit permit copy otherwise republish post redistribute list use component work work require prior specific permission fee may request two plaza suite new york one c architecture code optimization vol seven two article twelve pub date twelve v j al reference format v j smith brook hazelwood k eliminate voltage via code code seven one article twelve page one introduction power supply noise directly affect robustness performance use ever lower supply aggressive power management clock gate result large current swing become inevitable current swing couple parasitic subsystem voltage violate processor operate drop voltage lead due slow logic overshoot voltage degradation transistor reliable correct operation processor large voltage swing also call voltage avoid traditional way deal voltage system accommodate voltage swing recent paper analyze supply noise processor jam al show need operate greater twenty nominal voltage nominal voltage conservative processor design large time ensure robustness however conservative design either lower operate frequency sacrifice power efficiency instance bowman al show remove ten operate voltage margin lead fifteen improvement clock frequency alternative conservative design propose design operate condition provide mechanism guarantee correctness presence voltage mechanism enable aggressive time order maximize clock frequency even improve energy efficiency expense penalty occur architecture either take measure prevent potentially impend voltage emergency al operate reactively recover correct processor state emergency corrupt machine execution al traditional hardware exploit effect program structure figure one show number unique static program responsible simulate platform see section total number contribute lifetime program stack distribution plot indicate average program responsible use event categorization algorithm describe al identify instruction give rise emergency architecture code optimization vol seven two article twelve pub date voltage via code fig one small set static program responsible nearly voltage voltage cross beyond four operate margin consider emergency experimental setup describe section several even ideal hardware technique need activate mechanism per emergency exploit fact emergency code responsible nearly additionally scheme must ensure performance gain operate reduce margin outweigh therefore rely tune mechanism underlie processor power delivery system al combine implementation cost potential change traditional architectural structure challenge like delay al design validation become increasingly difficult article present collaborative approach handle voltage hazelwood brook suggest potential collaborative scheme demonstrate evaluate implementation collaborative approach rely mechanism infrequently possible handle layer dynamically smooth machine activity via code transformation prevent frequently occur ideally mechanism activate per static emergency location therefore time show figure one transformation prevent form performance optimization prevent aggressive lead better performance due reduce layer rely feedback hardware identify eliminate program address similar present day virtual machine target performance optimization use feedback hardware performance counter schneider al al future envision treat reliability class dynamic performance optimization architecture code optimization vol seven two article twelve pub date v j al dynamic optimization al well suit ninety execution time spend ten code figure one show similar behavior respect contrast hardware scheme exploit fact program static hot spot scheme dynamic compiler eliminate large fraction dynamic emergency count demonstrate issue rate stagger technique reduce apply reschedule exist code inject new code dynamic instruction stream program unlike hardware scheme solution require package dynamic compiler inherently adapt environment collaborative design holistic technique handle voltage compare prior hardware therefore solution allow us easily harness benefit improve energy efficiency performance improvement aggressive enable primary article follow one design implementation dynamic system sup press recur voltage two algorithm prevent voltage stagger issue rate three demonstration hardware useful infrequently tolerate voltage aggressive operate combine hardware approach rest article organize follow section two present structure propose collaborative approach along design detail individual hardware section three present code transformation algorithm employ smooth voltage execute program region identify section four discuss performance result section five discuss relate work section six conclude article two collaborative framework mitigate voltage noise benefit collaborative approach twofold first recur avoidable via code transformation second collaborative scheme allow hardware relax time margin reduce number net effect better energy efficiency improve performance section first present overview collaborative architecture work highlight critical follow present detail hardware architecture code optimization vol seven two article twelve pub date voltage via code fig two diagram propose architecture deal voltage overview figure two illustrate operational flow system emergency detector continuously monitor execution detect emergency activate hardware mechanism assume mechanism restore execution previously know valid processor state whenever emergency detect recovery detector notify layer voltage emergency operate lazy mode wait emergency hardware whenever notification arrive profiler extract information recent processor activity event history tracker maintain information cache miss pipeline flush profiler use information identify code region correspond emergency subsequently profiler call compiler alter code responsible cause emergency attempt eliminate future program location hardware design hardware support mechanism consist voltage emergency detector identify emergency occur mechanism engage every emergency provide rollback mechanism event history tracker use communicate component emergency detector detect operate margin rely voltage sensor detector invoke mechanism architecture code optimization vol seven two article twelve pub date v j al detect emergency recovery detector invoke layer profile code transformation eliminate subsequent mechanism scheme allow voltage occur order identify code transformation therefore require mechanism recover corrupt processor state use recovery mechanism similar find reactive processor error detection correction propose handle soft wang patel agarwal al primarily base rollback use explicit scheme already ship production al al explicit rely explicitly save architectural state processor architectural register update memory state substantial overhead associate restore register state additional cache miss time recovery buffer memory update assume update line mark volatile moreover robust explicit mechanism noise margin must independent sensor delay fall violation subsequent detection due sensor delay must consider corrupt therefore provide correct recovery semantics require maintain two interval cycle choose explicit evaluation article overall approach independent specific implementation refer section five alternative scheme could use place explicit mechanism event history tracker layer require pertinent information locate instruction sequence responsible emergency order code transformation purpose require processor maintain two circular structure similar already find exist like first branch trace buffer maintain information recent branch resolve target second data event address register dear track recent memory instruction address correspond effective address cache translation buffer miss extract information whenever receive notification emergency design component consist profiler convert information gather hardware event history tracker particular location code compiler analyze modify program prevent future profiler profiler notify whenever hardware emergency occur profiler identify program architecture code optimization vol seven two article twelve pub date cache flush ten eight six four two thirty twenty ten one n e v e r e c r p e r e n e r r c e g l v cache flush ten eight six four two thirty twenty ten one voltage via code optimization optimization data dependence long latency operation cause pipeline activity stall rapid issue rate cause steep optimization reduce issue rate thereby cause smaller steep cause voltage drop minimum margin smaller prevent voltage emergency fig three execution snapshot sieve show impact pipeline stall due long latency operation processor current voltage operate margin four assume ie maximum minimum optimization show stall trigger emergency issue rate ramp quickly operation complete b optimization demonstrate code reschedule slow issue rate operation eliminate emergency illustrate compiler optimize record time frequency emergency addition recent event activity extract performance counter use information profiler locate instruction responsible emergency use event categorization algorithm al algorithm work machine important note compiler sensitive algorithm effectiveness algorithm responsible direct compiler appropriate code location target refer problematic instruction instruction rely robustness algorithm provide prior work identify correctly event categorization identify base understand along give rise pipeline stall burst activity follow stall voltage drop minimum operate margin due sudden increase current draw violation minimum voltage margin definition voltage emergency figure three illustrate scenario use experimental setup describe section data dependence operation stall processor activity operation complete issue rate increase rapidly several dependent successively allocate different execution give rise voltage emergency sudden increase current draw categorization algorithm associate operation root since cause burst activity give rise emergency generally several cause voltage range cache miss branch miss characterize architecture code optimization vol seven two article twelve pub date v j al evaluate later section profiler equip detect root type work focus eliminate lead emergency rather focus smooth activity follow event prevent emergency since reality impossible eliminate every event real system compiler figure three illustrate voltage depend issue rate machine therefore slow issue rate machine appropriate point prevent voltage achieve goal alter program code give rise execution time without large performance compiler try exploit pipeline delay reschedule decrease issue rate close instruction pipeline delay exist raw war waw hardware optimization like register rename machine optimize away war waw raw dependence kind force hardware execute sequential order compiler try exploit raw already exist program slow issue rate place dependent close one another follow section discuss two approach explore inject pipeline delay level outline one simple approach consist insert well sophisticate approach exploit exist raw later section four evaluate approach turn injection simple way compiler slow pipeline insert specify instruction set architecture dynamic instruction stream program however modern discard decode stage therefore instruction affect issue rate machine instead real compiler generate sequence contain raw effect since perform useful work approach often degrade performance compiler attempt construct instruction sequence utilize dead register however always feasible case compiler spill content live register need code generation follow creation insertion code appropriate location compiler fill back live register state return control back original program code instruction sequence therefore addition waste cycle due code execution system may experience additional performance loss due register spill fill better way smooth processor activity exploit raw already exist original control flow graph program constrain burst activity machine resume execution stall prevent emergency whether compiler architecture code optimization vol seven two article twelve pub date voltage via code fig four effect code reschedule loop sieve emergency consistently occur basic block three along dot loop path four one two three b move instruction b block one block two put dependent closer together thereby constrain issue rate prevent subsequent basic block three successfully move create sequence raw depend whether move code violate either control data high level compiler instruction break data work around control clone require move around original program semantics still maintain illustrate approach figure four present simplify sketch code correspond activity show figure three operation illustrate figure three correspond divide instruction show basic block four figure four emergency repeatedly occur basic block three along dot loop path four one two three categorization algorithm identify divide instruction correspond c b basic block four instruction compiler identify use branch history information extract profiler counter recognize move instruction b basic block one two constrain issue rate machine sequence raw compiler also recognize result b live along edge one three clone instruction new basic block basic block five along edge ensure correctness result effect reschedule illustrate figure three b activity figure slightly offset right five clock cycle figure three due subtle change loop structure code reschedule nevertheless stall event still occur program location slight change current activity cycle result code reschedule dependent pack close one another basic block two issue rate figure three b spike high figure three pipeline activity resume stall architecture code optimization vol seven two article twelve pub date v j al table type algorithm target depend event responsible emergency description instruction identify hardware emergency event type recent instruction write back stage pipeline first instruction along speculative path prior detect include instruction code reschedule alter current voltage profile therefore must careful simply displace one location another arbitrarily move code far away retain original activity algorithm search raw start basic block contain instruction use anchor point code enlarge search window iteratively find raw dependence exploit reach scope function body point give execution complicate instruction reschedule machine bypass raw dependence chain generate compiler enough code available execution hardware schedule window handle choose raw candidate set compute subset element raw dependence chain move require location target long raw dependence chain compiler increase chance machine schedule window fill dependent code reduce issue rate otherwise compiler must generate multiple set smaller raw dependence chain follow section present detail description algorithm specific general concept propose prevent issue rate use raw dependence chain three algorithm give instruction constrain instruction issue rate different point within transform code differently depend whether emergency cause branch simple case emergency cause sudden burst activity follow cache miss event stall illustrate figure three target instruction last instruction successfully remove table describe instruction type indicate event condition code target consider two particular prevent issue logic intelligently bypass raw dependence chain put place prevent emergency hardware may discover instruction sequence also ready execution sequence could lead burst activity emergency thus render architecture code optimization vol seven two article twelve pub date voltage via code algorithm one routine perform instruction schedule prevent voltage input emergence type input instruction r input last instruction l input wrong instruction w l switch case branch emergency r w w otherwise r function input instruction l length zero end ineffective therefore conservatively target two constrain issue rate emergency cause branch must take account speculative set execute machine experimentally discover constrain issue rate pipeline flush event along wrong path significantly increase chance prevent emergency therefore prevent target instruction last instruction well first instruction along speculative path execute prior detect branch algorithm one illustrate compiler invoke transform code point emergency ie instruction r take input three input describe profiler mechanism illustrate figure two identify algorithm invoke function transform code order constrain issue rate specific instruction algorithm constrain issue rate last instruction regardless emergency type every successor instruction however depend emergency type decide successor constrain issue rate case emergency constrain issue rate architecture code optimization vol seven two article twelve pub date v j al well take path thereby smooth voltage along speculative path well determine code motion function discover schedule raw chain input parameter instruction locate raw chain invoke function function define scope range basic block within function attempt construct raw dependence chain fail instance dependent find enlarge range basic block consider process repeat return value link list l successfully schedule list null function note already visit use function visit previously schedule subsequently reschedule would perturb invalidate previously schedule raw chain could lead schedule thrash perform code motion upon identify useful raw chain function call migrate necessary set one location another base standard global code schedule algorithm aho al briefly algorithm clone necessary move discover necessary set clone mean compute use instruction predominate instruction b instruction always execute instruction b instruction b instruction instruction b always execute execute instruction end instruction schedule say b target instruction predominate b instruction clone necessary however b predominate b must clone insert within manner preserve program semantics clone rule well describe literature aho al function attempt construct dependence chain use function intermediate function check see first instruction give input move prior target mean impose within prevent perturb original voltage profile much constructive code become ineffective specifically impose instruction clone rule one head raw chain instruction schedule target assume limit number clone necessary migrate anywhere within scope define function two belong raw chain clone three allow clone increase dynamic instruction program since aggressive clone potentially impact performance architecture code optimization vol seven two article twelve pub date voltage via code function input instruction output link list c end end end return function input instruction set input instruction output link list c mark c c end end j c c c j end end return j c j condition satisfy function return null list force enlarge scope retry welcome relax attempt improve chance find suitable raw dependence chain however risk increase execution time even potentially perturb neighbor code much transform code lead new demonstration algorithm facilitate better understand illustrate functionality algorithm simplify example extract real scenario consider original program relate graph show figure five figure five c respectively instruction four root relate instruction eight correspond wrong path architecture code optimization vol seven two article twelve pub date v j al fig five piece code b reschedule code compiler move remove emergency cause frequently branch location four c correspond original code reschedule algorithm use extract raw dependence chain instruction first instruction execute along incorrectly speculate path order smooth voltage emergency root attempt add raw dependence chain four five four eight last instruction simplicity elaborate step take construct chain four five algorithm start look best raw chain call function give instruction five input function call find raw chain inside present scope interest basic block contain instruction five function return null first invocation consequently enlarge architecture code optimization vol seven two article twelve pub date voltage via code scope function figure five illustrate scope enlargement process use initially small dot inner circle subsequently enlarge scope include basic block subsequent call several additional block choose create raw chain basic block choose within one edge distance away basic block previously consider point algorithm find six candidate one two nine ten eleven fourteen head raw chain hence c one two nine ten eleven fourteen set six potential chain choose raw chain create without violate clone rule find instruction one best candidate move instruction one along sequence one two three four five lead optimum solution chain length three note instruction nine lead raw chain length four choose alternative specify clone increase dynamic instruction program alternative algorithm relax constraint possible improve emergency coverage albeit risk potentially performance transform show figure five b see one three five replicate migrate four evaluation system evaluation demonstrate effectiveness compiler reduce voltage show impact code change performance show compiler reduce sixty section minimal section present performance study section show scheme overcome challenge exist hardware effectively experimental setup give modern hardware support access voltage explore design use hardware simulator together exist compilation infrastructure hardware simulator use simulate four show table modify gather detail current profile use brook al tool architectural simulator estimate power consumption base set power model different hardware structure use resource account model voltage simulator convolve simulate current profile impulse response power delivery subsystem al cycle work focus power delivery subsystem model base four package al exhibit resonance peak impedance finally assume peak current swing architecture code optimization vol seven two article twelve pub date v j al table architecture clock rate ras window branch penalty functional eight four fetch width two two eight latency branch predictor decode width main memory ten cycle bimodal eight latency table description linear system solver base perform forward transform n different complex number measure performance ray tracer scene contain financial simulation use multiplication use sparse matrix method sieve sort array use heap sort algorithm determine virtual machine method call algorithm find prime number give interval perform successive grid compiler infrastructure use al compiler framework optimize compiler dynamically generate native code code execute directly simulator extend compiler include code injection schedule describe section compiler access complete data flow graph utilize optimization use c come suite bull al table present summary description program run extend period time order shorten execution time approximately million hardware simulation overhead exhibit briefly characterize voltage figure six show distribution root cause across majority suite arise stall due long latency cache miss branch category correspond unable successfully attribute specific event likely result burst activity power virus demonstrate al finally miss tend result evaluate suite absolute number per show table v emergency distribution present allow compare traditional architecture code optimization vol seven two article twelve pub date voltage via code fig six aggregate distribution root cause across suite code unavailable spec unable evaluate directly however since distribution number program representative prior work use spec al expect result generalize feel result article outweigh limitation experimental infrastructure effectiveness goal voltage emergency elimination reduce number voltage ensure performance suffer result code first evaluate effectiveness injection code reschedule find choice transformation affect performance transformation introduce new careful follow analysis next section factor cost evaluate performance injection describe injection algorithm insert new program path slow machine issue rate need prevent emergency specific implementation sequence make three form raw chain intermediate representation level code generation find sequence typically grow six eight due register allocation effectiveness scheme show leave bar figure seven bar show percentage remain compiler attempt prevent inject code number reduce fifty method sieve show transformation effective however transformation effective across remain fact number increase twofold loop specific code within compiler target architecture code optimization vol seven two article twelve pub date v j al injection code reschedule method sieve fig seven percentage remain code transformation lower good imply original code otherwise mean transformation lead original code injection code reschedule f e g n e c r e p g n n e r e c n e g r e e zero e c n r f r e p e v e r l e l n e p c n e g r e e w zero method sieve fig eight code performance transformation cost handle show plot isolate effect code transformation performance section evaluate overall performance factor code performance cost along handle extreme register pressure consequently add new code lead frequent spill fill loop iteration memory load store additional cache miss become new root cause lead original code experience analysis reveal injection reduce original program transformation also give rise new compiler generate spill fill code create code sequence adverse effect increase number need simulate also potentially cause architectural like cache miss spill fill code dramatically alter current voltage profile side effect depend number register available use original instruction schedule among condition difficult predict current voltage response activity result inject new code new easy avoid see case additionally performance original program suffer injection code inject code serve original program purpose leave bar figure eight show execution performance program inject code data indicate effect simply add new code prevent severely detrimental performance case sieve performance degrade much large execution indicate transformation effective reduce voltage sieve ten remain compiler must sensitive performance architecture code optimization vol seven two article twelve pub date voltage via code table small percentage static code order need modification eliminate additionally change compiler make minimal impact dynamic instruction count clone move change dynamic method sieve seven twenty two seven thirty forty eight eleven zero one ten zero compiler approach relocate raw follow instruction suffer severely unpredictable behavior inject code prevent code reschedule superior simple injection follow reason first successfully reduce across illustrate bar right figure seven second without dramatically increase execution time program show figure eight analysis also show introduce new compiler inject new code significantly alter current voltage profile instance consider injection transformation transformation eliminate approximately number however effect performance two substantially different injection transformation cause original program take twice long execute whereas code reschedule negligible effect original program performance code waste processor cycle reschedule real program code simply prevent restrict compiler schedule algorithm strict clone rule describe section able effectively limit performance loss inject new table show number add due clone order thus dynamic instruction count program increase result register allocator generate code tiny amount instruction increase especially consider execute millions method dynamic instruction count decrease small percentage code change register allocation lead register spill fill along specialize change performance reschedule code generally noise reduction average architecture code optimization vol seven two article twelve pub date v j al n eighty sixty b r e c r zero twenty forty new persistent eliminate method sieve fig nine eliminate root cause fix compiler find sufficient code construct raw dependence chain also new introduce result make exist code e n l e e c n e g r e e eighty sixty forty twenty zero fourteen sixteen four five six seven fig ten correlation number compiler eliminate average length dependence chain create compiler eliminate create chain approach machine issue width machine smaller around thirty compiler could find enough raw could relocate slow issue rate frequently occur root therefore continue persist make code lead new well figure nine illustrate breakdown careful aggressively modify code surround root see percentage new introduce small fraction ideally schedule algorithm attempt create raw dependence chain long enough block issue width machine find strong correlation length raw dependence chain successfully compiler eliminate figure ten plot average raw chain length x axis percentage eliminate across different present axis simulate machine issue width eight find number eliminate steadily grow toward length raw chain approach issue width machine section mention compiler instruction target three specific point interest emergency instruction last instruction case architecture code optimization vol seven two article twelve pub date one eight six four two zero e v e r e c n e g r e e f n c r f voltage via code wrong path wrong path last method sieve fig eleven figure justify use three program point resolve voltage combination instruction wrong path instruction last instruction result ability identify resolve nearly voltage encounter branch emergency first instruction along speculative path make qualitative argument three point provide good coverage eliminate successfully quantitatively justify claim assume three point cover figure eleven show effective compiler remove increase number point target examine three point cumulatively start root claim disjoint graph normalize one indicate utmost number able eliminate use algorithm number correspond code reschedule bar show figure seven leftmost bar figure eleven show effect target instruction since higher value mean observe instruction alone insufficient effectiveness increase consider last wrong path point especially case program control intensive method arise branch therefore ignore issue rate incorrectly speculate path impact however cover speculative execution path well efficiency improve sixty method nearly eighty finally exception method cover take account last point general consensus program highly data intensive control flow change throttle issue rate last instruction positive effect benefit last transformation sieve eliminate result focus last instruction transformation overhead compiler recompile therefore incur rollback whenever compiler execute include scenario compiler generate new dynamic code well compiler architecture code optimization vol seven two article twelve pub date v j al table v number arise compiler generate application code run versus compiler run either generate newly request dynamic code transform exist application code prevent number compiler application code method sieve method sieve sixteen two zero sixteen zero code ten twenty ten one table distribution execution time spend handle compiler versus run application execution time compiler application code transform exist code prevent table v show distribution compiler generate application code data strongly indicate fraction encounter compiler execution less one average across since fraction small rollback overhead base result overhead code transformation fix eliminate appear figure one show number static program therefore compiler rarely invoke execution transform code table substantiate claim demonstrate percentage execution time spend run generate application code substantially time spend compiler execute reschedule algorithm architecture code optimization vol seven two article twelve pub date voltage via code table increase handle voltage net performance improvement scale operate margin factor scheme mechanism mechanism code reschedule throttle forty thirty overhead performance gain upper bind performance improvement assume margin scale eighteen four result average measure across performance evaluation reduce operate voltage allow frequency improve energy efficiency however mechanism associate handle voltage section demonstrate dynamic compilation strategy complement recovery voltage enable aggressive operate processor performance gain collaborative approach within four percentage point throttle scheme result present table bowman al show remove ten operate voltage margin lead fifteen improvement clock frequency indicate fifteen scale factor operate voltage margin clock frequency assume aggressive operate margin four experiment compare eighteen base fifteen scale factor four operate voltage margin assume article correspond six loss frequency similarly conservative voltage margin eighteen sufficient cover drop lead lower frequency take conservative margin reduce eighteen margin four avoid voltage result ideal clock frequency improvement could set upper bind frequency gain achievable make simplify assumption frequency directly translate higher overall system performance mechanism explicit scheme recover emergency roll back execution explicit scheme suffer penalty roll back useful work do whenever voltage emergency occur restart penalty direct function sensor delay system time require detect margin violation explicit scheme incur additional overhead associate restore register assume eight cycle register four write port memory state volatile line flush additional miss occur time rollback assume rollback penalty per recovery explicit scheme incur average increase evaluate performance gain scale operate margin four minor three minimal improvement performance imply worst voltage drop observe power delivery package eighteen architecture code optimization vol seven two article twelve pub date v j al explicit handle voltage successfully aggressive mechanism performance gain use minimal gain mechanism combine propose counterpart two compiler discuss section evaluate transformation since appear promise technique effectively reduce number without detrimental performance impact profiler identify scheme initiate amount rollback penalty associate initially discover transformation thereafter however compiler optimize permanently prevent subsequent program location reschedule algorithm ineffective fix certain emergency point rollback may still arise point show figure seven discuss section combine explicit compiler assistance reduce overhead substantially translate net performance gain twenty performance comparison scheme several propose spread sudden increase current via execution throttle several throttle propose al evaluation purpose compare performance scheme frequency throttle mechanism quickly reduce current load frequency system halve whenever throttle turn result performance loss compare throttle scheme throttle per emergency always successfully prevent emergency result oracle scheme suffer rollback cost suffer performance loss due throttle prevent throttle enable improvement performance tighten four percentage point better scheme course scheme represent practical design scheme always successfully prevent important remember realistic suffer tight feedback loop involve detect imminent emergency activate throttle mechanism timely manner avoid emergency either current voltage trigger certain threshold cross indicate violation likely occur unfortunately delay require achieve acceptable sensor accuracy inherently limit effectiveness scheme operate must remain large enough allow time loop respond al contrast collaborative approach suffer scheme leverage hardware architecture code optimization vol seven two article twelve pub date voltage via code already ship production al al reduce voltage aggressive enable performance gain five relate work mechanism unique one consider choose mechanism one relevant work involve balance complexity hardware recovery scheme impact performance machine execute smoothly al propose scheme base delay commit rollback speculatively buffer processor update machine state verify noise margin occur within time take detect emergency guarantee system correctness mechanism distinguish state state state machine know free corruption cause inductive noise complete result buffer reorder buffer rob store queue verify reflect effect noise buffer time implicit scheme determine emergency detector sensor delay take time voltage across chip detect droop event subsequently broadcast error signal across processor initiate recovery however delay order clock cycle therefore impact performance machine execute smoothly small even negligible moreover cost restore state scheme effectively low flush pipeline due branch overall design greatly simplify complexity hardware since leverage exist traditional structure therein lie problem scheme intrusive require change traditional structure increase design cost validation time moreover highly custom solution deal voltage applicability comparison explicit use mechanism less intrusive addition exist processor design likely useful purpose suppress voltage several propose variety diverse use hardware wang patel al al al al al use recovery handle inductive noise collaboration another novel application hardware explicit however use handle voltage performance large discuss section prior work suggest prevent alter machine behavior via execution throttle al stagger issue rate architecture code optimization vol seven two article twelve pub date v j al pant al hardware face increase sensor delay reduce aggressively feedback loop delay detect engage preventive mechanism become limit factor aggressively reduce operate voltage comparison mechanism propose allow occur recover eliminate thus avoid sensor delay issue altogether prior effort kim demonstrate static compiler target voltage however voltage result complex application execution engine power delivery subsystem therefore static easily across different platform application mechanism dynamically discover emergency adapt effectively scheme robust deployment come era design reliable become increasingly challenge six conclusion primary contribution work design implementation collaborative approach handle voltage collaborative approach reduce hardware associate handle voltage dynamic compiler permanently fix code region responsible hardware provide guarantee via mechanism layer identify code reschedule code prevent compiler eliminate sixty average therefore dramatically reduce recur overhead mechanism show scale operate margin conservative eighteen aggressive four set achieve twenty higher performance within four percentage point throttle scheme reschedule algorithm general framework first step toward expose voltage noise stack even couple hardware reduce complexity make readily feasible play integral role assist hardware issue instance rather try dynamically construct dependence chain throttle issue rate machine hardware hook allow compiler directly request temporary issue width would greatly simplify algorithm compiler would need identify path along issue throttle request trigger worry find dependence chain integrate effort recoup increase operate voltage margin use assistance code architecture code optimization vol seven two article twelve pub date voltage via code reference agarwal r j e adaptive incremental massively parallel proceed annual international conference new york aho v r j tool prentice hall upper saddle river h k muta al proceed annual design conference new york simulation control power supply voltage variation proceed international symposium computer architecture ca seven k hill j k k levin power delivery tech j nine v e dynamo transparent dynamic optimization system proceed conference program language design implementation new york bowman k al detection instruction recovery circuit dynamic variation tolerance proceed international circuit conference ca brook v watch framework power analysis proceed annual international symposium computer architecture ca bull smith l henry r practical g c parallel dynamic compiler k k smith brook towards approach mitigate voltage proceed international symposium electronics design new york k k smith brook delay commit rollback mechanism handle inductive noise proceed international symposium computer architecture ca v j smith brook approach handle inductive noise proceed conference design test new york hazelwood k brook eliminate voltage via voltage control feedback dynamic optimization proceed international symposium low power electronics design new york jam n p j b b comparison supply proceed international circuit conference ca r brook control eliminate voltage proceed international symposium computer architecture ca n j early load retirement proceed international symposium computer architecture ca j hind b performance audit use hot without get burn proceed conference program language design implementation new york mart j f j c j cherry early resource recycle proceed annual international symposium new york architecture code optimization vol seven two article twelve pub date v j al g b continuously record program execution deterministic replay proceed international symposium computer architecture ca pant pant p will v architectural solution inductive noise problem due proceed international symposium electronics design new york n pipeline muffle current ramp architectural reduce inductive noise proceed international symposium electronics design new york n exploit resonant behavior reduce inductive noise proceed annual international symposium computer architecture ca schneider f payer gross r drive hardware performance monitor proceed program language design implementation new york k v ultra defect protection proceed international conference architectural support program operate new york j r check b c b w c li w design h j j al micro nineteen two j martin k hill wood fast support speculation hardware fault tolerance tech rep university power analysis instruction schedule reduce execution core thesis state university wang n j patel j restore soft error detection depend secure three four mar j hazelwood k approach heterogeneity reliability proceed international conference formal model new york kim j modulo schedule proceed international symposium electronics design new york receive accept march architecture code optimization vol seven two article twelve pub date