dynamic compilation framework control energy performance dan w computer science electrical engineer university electrical computer engineer colorado boulder lab corporate tech group corporation engineer apply science university abstract dynamic voltage frequency scale effective technique control energy performance exist primarily base hardware os however substantially greater gain realize control also explore dynamic compilation environment several advantage deploy manage use dynamic compiler importantly dynamic compiler drive adaptive current environment paper present design framework general dynamic compilation system prototype implement integrate dynamic compilation system obtain optimization system deploy real hardware platform directly measure voltage current accurate power energy read experimental result base physical forty spec olden show energy save achieve little performance degradation benefit energy save seventy five performance loss addition show energy save five performance loss save performance loss olden save performance loss average technique lead energy delay product improvement better static voltage scale nine better report result prior static compiler work propose technique effective method voltage frequency control design framework methodology describe paper potential address energy power issue thermal control one introduction dynamic voltage frequency scale effective technique energy power control implement many modern four eleven current practice control power schedule management ie os select new voltage set new application task schedule processor switch state four ten work focus instead voltage scale program execution take advantage application phase change research devote control base hardware sixteen nineteen os seven static compiler fourteen brief description exist available section two little do explore control dynamic compilation optimization environment paper consider dynamic compiler optimize application binary code insert control program execution time dynamic compiler system compile modify optimize program instruction sequence run recent dynamic compilation become increasingly important foundation optimization binary translation information security dynamic compiler base include dynamo two daisy eight three pin eighteen since allow direct control via mode set access special mode set register dynamic compiler use insert mode set application binary code run time exist execution slack ie idle cycle wait memory scale voltage frequency save energy little impact performance use dynamic compiler drive offer unique feature advantage present approach importantly hardware os interrupt base scheme also adaptive environment static compiler section two give statistical result motivate dynamic compiler drive discuss advantage disadvantage paper present design framework dynamic compilation environment key design issue consider include code region selection decision code particular propose new decision algorithm base analytic decision model prototype implement integrate dynamic optimization system variant pin system eighteen obtain optimization system deploy real hardware platform development board processor allow us directly measure current voltage accurate power energy read evaluation base experiment proceed annual international symposium micro five average cache miss average memory bus fifteen ten five n h e two l zero zero one three two four five time million figure one number cache miss every million retire execution number one five mark five memory characteristic phase symbol figure mark recur point program phase forty spec olden evaluation result show energy efficiency achieve example seventy energy save five performance loss accomplish spec average technique lead energy delay product sixty olden average result better static voltage scale sixty three better nine report static compiler scheme fourteen overall main paper twofold first design implement deploy real hardware physical power optimization system effective term energy performance efficiency compare exist approach second knowledge one first develop dynamic compiler voltage frequency control previous work twelve provide partial solution method virtual machine provide complete design framework apply general dynamic compilation environment general structure rest paper follow section two motivate dynamic compiler section three present design framework section four describe implementation deployment system follow experimental result section five section six highlight relate work section seven discuss future work finally offer section eight two dynamic compiler drive section discuss detail unique feature advantage disadvantage dynamic compiler drive compare exist advantage hardware os exist hardware os base typically monitor system statistics issue queue occupancy fix time decide future time seven nineteen since time predetermine independent program structure control may efficient adapt program phase change one reason program phase change n c n r r e zero one one input size millions ten one fifty figure two average number memory bus per function different input size different input pattern random input versus input generally cause invocation different code observe fifteen thus hardware os may able infer enough application code attribute find effective adaptation point another reason program phase change often recurrent ie loop case hardware os scheme would need detect adapt recur phase change repeatedly illustrate reason figure one show example trace program phase change trace part program million number cache miss every program execution result section obtain use hardware performance counter processor setup describe section five figure see five distinct memory phase characterize different cache miss value duration show section five phase actually correspond five distinct code function program also see phase change recurrent show mark point figure compiler drive scheme static dynamic apply code adapt naturally program phase change hardware scheme fix lack adaptation advantage static compiler exist compiler work primarily base static compiler fourteen typically profile use learn program behavior analysis linear program fourteen use decide code one limitation static compiler due different profiler actual program set obtain static compile time may appropriate program reason dependent program memory boundedness ie slow wait memory operation completion program behavior term memory boundedness turn dependent system configuration program input size pattern example cache configuration memory bus speed may affect much slack idle time exist also different program input size pattern may affect much memory use go use illustration figure two show average number memory bus per function proceed annual international symposium micro five table one different memory behavior spec program reference train input average cache miss per mem average memory bus per sweep mean loop function sweep reference train code region sweep mem mem curve random input different input size curve input figure two show average number memory bus vary significantly different input size input pattern surprisingly input size lead cache miss thus memory bus example small program illustration table one show different memory behavior spec program reference train input show average number cache miss average number memory bus per example code similarly see number may become different input change reference train vice base observation see different input size pattern different might need best result example figure two aggressive ie lower set use large input size like take advantage memory boundedness program save energy conversely conservative ie higher set use small input size like avoid excessive performance spec table one code region function sweep might need different different input set empirical experience processor show assume performance loss constraint four code region clock reference input clock maximum train input inherently difficult static compiler make adaptive factor dynamic compiler utilize system information make disadvantage challenge discuss advantage would like point dynamic compiler also disadvantage one dynamic optimization technique every cycle spend optimization might cycle lose execution unless perform sideline chip five therefore one challenge dynamic compiler drive design simple inexpensive analysis decision order minimize optimization cost three design framework decision section present design framework dynamic compilation optimization environment start consider key design issue start dispatcher monitor dynamic cold code execution hot code execution os hardware figure three overall block diagram show operation among different dynamic compiler optimization system general give detail design new decision algorithm key design issue candidate code region selection like dynamic optimization want optimize frequently execute code hot code order cost effective addition since relative slow process voltage transition rate typically around also want optimize code design choose function loop candidate code since dynamic optimization already equip lightweight profile mechanism identify hot code example profile every possible loop target five extend exist profile infrastructure monitor identify hot function loop candidate code region important step decide whether beneficial apply ie whether operate lower voltage frequency save energy without impact overall performance appropriate set mention dynamic optimization system analysis decision algorithm need simple fast minimize overhead thus analysis use static compiler fourteen typically appropriate work design fast decision algorithm base analytical decision model use hardware feedback information code insertion transformation candidate code region find beneficial mode set insert every entry point code region start every exit point code region restore voltage level one design question many adjust want program exist static compiler choose single code region program fourteen avoid excessively long analysis time design multiple provide energy save become complicate two nest child region nest parent region child may know set parent exit point provide two design one maintain relation graph run time allow parent region scale one stack parent child scale addition proceed annual international symposium micro five code insertion dynamic compiler also perform code transformation create energy save one example merge two separate small memory bind code one big one course need check code merge hurt performance correctness program exist among conventional performance overall operation block diagram block diagram figure three show overall operation different dynamic compiler optimization system start dynamic dispatch patch original binary code deliver code execution hardware moment system execution mode cold code execute dynamic optimization system monitor identify frequently execute hot code optimization apply hot code either conventional performance conduct hot code region optimization apply per program execution multiple time call periodic lastly code transformation desirable query regular performance check feasibility code transformation next describe detail key design component decision algorithm decision make first insert test decision code entry exit point candidate code region candidate region view single entry multiple exit code region test decision code collect information number cache miss memory bus code region enough information collect decide appropriate set candidate code region base collect information setup decision make remove test decision code prepare possible code insertion transformation test step assume candidate code region relatively stable give input therefore obtain decision base test information valid rest program execution valid next point choose periodic note assumption show reasonable valid practice study key test step decision make mention order beneficial code region first need easily check harder question long run code region decide whether beneficial appropriate set answer question first look analytical decision model analytical decision model discussion analysis model section assume goal energy control minimize energy consumption subject performance note analytical model different objective thermal control might different general scale voltage frequency certainly reduce processor power consumption also slow execution speed result energy delay product improvement might low even negative key insight beneficial save energy little memory operation operation f f execution time figure four analytical decision model mem asynchronous memory access time number execution cycle concurrent operation number cycle dependent operation f frequency performance impact exist asynchronous memory system independent clock many time therefore identify execution slack ie stall idle cycle wait completion memory scale voltage frequency save energy without much performance impact base rationale figure four show analytical decision model extension analytical model propose figure four processor categorize two group memory operation operation since memory asynchronous respect frequency f denote time memory operation mem operation time separate two part part one run concurrently memory part two depend final result pending memory since operation time dependent frequency f denote concurrent operation time number clock cycle concurrent operation similarly denote dependent operation time note actual program execution memory operation operation either concurrent dependent interleave somehow however analytical model abstract execution model lump category together treatment figure four see overlap period memory bind ie exist slack time define mem f slack time mem f one ideally concurrent operation slow consume slack time model want decide frequency scale factor candidate code region original clock frequency f new clock frequency f voltage scale accordingly assume execution time candidate code region categorize accord figure four frequency scale two effect operation first increase concurrent operation time reduce slack time second dilate dependent operation time performance loss unless zero next give detail method select compute scale factor proceed annual international symposium micro five selection method introduce new concept call relative slack time base definition slack time one define relative slack time mem total time two total time total execution time figure four memory bind case total time mem figure four see relative slack frequency reduction system without affect overall performance frequency reduction ie one proportional relative slack time one mem total time total time three constant coefficient note value choose either relatively large aggressive energy reduction relatively small preserve performance therefore take account effect maximum allow performance loss replace three one mem total time total time four intuitively equation mean scale factor negatively proportional memory intensity level term mem positively proportional intensity level term time equation estimate use hardware feedback information hardware performance counter example processor two time equation estimate eleven mem total time mem bus retire total time retire five six five first event number memory bus transaction use section two measure memory busyness second event total number retire ratio two use estimate relative memory busyness similarly six first event number instruction retire outstanding memory operation second event also number retire ratio two event use estimate concurrent busyness like three constant depend machine estimate reset installation time dynamic compiler method compute directly hardware information simple fast downside formulation relatively especially way consider constraint also develop alternative method precise handle performance constraint complicate compute use two separate detail omit due space limit see alternative method complement method four implementation deployment methodology experience implement prototype propose integrate real dynamic compilation system evaluate result present physical power start instrument code region profile function plus loop main execute code region become hot instrument loop inside function yes yes make decision check memory boundness function loop memory bind bind medium case yes yes remove profile instrumentation insert instruction remove profile instrumentation application execution figure five operation flow diagram prototype implementation implementation use pin system eighteen basic platform implement algorithm develop pin dynamic instrumentation compilation system develop publicly available pin system use base regular pin modify suit convenient dynamic convenience refer ie optimization pin compare standard pin package add feature support dynamic adaptive code replacement ie instrument code update replace run time trace code region selection addition unlike pin execute generate code eighteen take approach execute mix original code generate code example configure first patch instrument profile original code coarse granularity function call run time selectively generate code profile optimization dynamically compile code loop inside function therefore less operation overhead compare regular pin one figure five show operation flow graph prototype implementation system start instrument function call program loop main function order monitor identify frequently execute code strongly connect call graph treat single nod candidate code region find hot ie execution count greater hot threshold test decision code start collect information decide memory bind code region code region find memory bind remove instrumentation code insert mode set resume program execution hand code region find bind insert still medium case candidate code region may exhibit mix memory behavior likely contain case check function contain loop copy function proceed annual international symposium micro five run system measurement signal condition unit noise reduction data acquisition unit sample read data log unit process unit b c figure six processor power measurement setup setup consist four conservative higher one course available better control effectiveness deployment real system deploy system real run system hardware platform use development board processor show figure processor use maximum clock frequency two cache one unify cache board bus ram six express pair voltage transition rate base os kernel update implement two kernel provide user level support control read form system call system allow accurate power overall procedure power first collect sample point voltage current value compute power trace total energy sample point figure six show processor power measurement setup include four detail run system measurement unit unit isolate measure voltage current signal reason isolate measure power instead power whole board want deterministic accurate result affect random factor board figure seven system diagram show voltage current measurement point mark development board see figure use output sense main voltage regulator precision measure current go ie measure voltage drop use use bulk capacitor measure voltage note show figure seven simply measure power supply line go voltage regulator obtain power read undesirably include power consume io hub signal condition unit unit reduce measurement noise get accurate read measurement noise inevitable noise source like board particular since voltage drop across sense resistor figure figure seven system diagram show voltage current measurement point mark development board dynamically generate loop inside function instrument process continue selection method section use check memory boundedness code region select set require equation five number memory bus number retire among countable provide processor seventeen core hardware platform discuss next subsection however event equation six estimate time ratio available instead approximate estimation six new ratio obtain available several ways choose implementation use ratio number retire number retire base empirical experience find ratio concurrent code region note section five actually show inverse ratio ie average number per retire total time base scale factor obtain decision algorithm choose actual set code region ie new f old f since exist limit number set point six eight pick set point close desire set desire set two available set point pick one identify loop loop analysis twenty use implementation reduce analysis overhead simple fast heuristic use likely loop identify conditional branch go higher address lower address experience show heuristic work quite well practice proceed annual international symposium micro five one two three four five seven nine one b c e f g e e g j g k l g n two p q r q v w b z z z b c table two statistical result obtain spec average number per name mean loop name total region name total total hot four three five zero two zero two one loop main loop main loop main loop main check jacu average average cache memory miss mem candidate primal net simplex mem candidate average set seven order noise order practice noise system ten time measure signal noise typically much higher frequency measure signal use filter reduce measurement noise include national instrument ni signal condition module simple filter show figure filter able reduce relative noise error less one data acquisition unit unit sample read voltage current signal order capture program behavior especially fast sample rate require use ni data acquisition system maximum sample rate aggregate show figure since three measurement channel need two current one voltage set sample rate channel total use give sample length channel give minimum voltage transition time twenty eleven sample length adequate data log process unit host log machine process sample data every one second unit send collect data host log machine via cable channel sample first store internal buffer unit send log machine process receive data use regular run ni process data configure various task monitor raw data record computation five experimental result experimental setup experiment use hardware describe previous section optimization system set performance loss constraint five use result frequency would lower allow aggressive energy save conversely smaller would lead conservative candidate code region hot threshold choose four ie code region hot execute least four time find result sensitive value vary three twenty since voltage transition time different machine eleven set threshold code region describe algorithm section three cycle processor make least bigger voltage transition time nest function handle use relation graph describe section three evaluation use since previous static compiler work fourteen use also include suit addition include olden six popular integer study program memory compiler use get application binary compile test ref input set run completion power performance result report average result obtain three separate run illustrate give insight operation table two show statistical result obtain system spec table give total number hot code program total number identify code region show total number retire code region single invocation average cache miss average number memory bus average number retire per obtain base average number memory bus average number retire general higher two number lower set take example see number contribute final quantitative relationship number set base section three since six available system obtain need round available frequency point overall see number identify range large low small order look closely operation next exam two olden manipulate seven different data structure range link list heterogeneous choose first seven cover seven data study proceed annual international symposium micro five two four six sixteen fourteen twelve one v e g l v eight zero w r e w p ten five zero zero four two time second six figure eight partial trace voltage power spec run detail one particular recall section two observe recur memory phase behavior analysis reveal phase change mainly cause five different function show table two five function different memory behavior term average number cache miss average number memory bus note observation consistent behavior show figure one insert instruction directly code adjust voltage frequency adapt program phase change frequency two two last region figure eight show part voltage power trace run compare figure figure section two interest see adjust adapt recur phase change show figure one lower clock correspond higher cache miss power trace also interest initially fluctuate around value due different system switch program execution enter code power drop dramatically level low show experimental result section optimization apply code lead considerable energy save little performance loss five energy performance result view addition regular dynamic performance optimization system show figure three isolate contribution optimization first report energy performance result relative system without ie want mix effect optimization underlie dynamic compilation optimization system develop heavily colorado one addition comparison also report energy result static voltage scale simply scale supply voltage frequency statically get roughly table three average result suite versus suite performance degradation energy save product olden static improvement static seventy seven sixty three static amount average performance loss result choose f static voltage scale voltage set point system get average performance loss close five figure nine ten show performance loss energy save energy delay product improvement result olden note result take account optimization overhead time cost check memory boundedness code region convenience refer result refer result static voltage scale several interest first term improvement outperform big margin nearly show efficiency design fast effective second energy performance result individual suite vary significantly high end achieve energy save performance loss seventy energy save five performance loss energy save five performance loss energy save performance loss olden health low end see even slightly negative improvement suite understand reason see efficiency control largely constrain memory boundedness application memory bind application energy save relative experimental system figure six large cache show variety memory boundedness lead variety result overall see distribution result concentrate close low end overall distribution olden result spread high end low end average result suite summarize table three show result result average achieve improvement sixty olden represent three five fold better result compare improvement three olden average result relatively lower compare three suit dominantly bind show previous study fourteen nothing intrinsic float versus integer data amount memory traffic also want rough comparison static compiler result fourteen base report energy performance number paper able replicate experiment fourteen compare proceed annual international symposium micro five performance degradation v c one zero one w two zero one r c two three zero one two r h four zero one r g seven zero one l p p zero one one three b r five two one p one four one p p p p f five four one five e v w six four one g v five nine p f w one seven one r g two seven one l p p three seven one e seven seven one l l e g g eight seven one r nine seven one e k q e three eight one c e r e c f seven eight one p eight eight one c l nine eight one three f one nine one k c r x zero zero two p one zero three g v p f k two energy save seventy v c one zero one w two zero one r c two three zero one two r h four zero one r g seven zero one l p p zero one one three b r five two one p one four one p p p p f five four one five e v w six four one g v five nine p f w one seven one r g two seven one l p p three seven one e seven seven one l l e g g eight seven one r nine seven one e k q e three eight one c e r e c f seven eight one p eight eight one c l nine eight one three f one nine one k c r x zero zero two p one zero three g v p f k two improvement twenty eighteen sixteen fourteen twelve ten eight six four two zero fifteen five five sixty fifty forty thirty twenty ten zero ten e w p w eight six one e w p w eight six one fourteen e w p w eight six one v c one zero one w two zero one r c two three zero one two r h four zero one r g seven zero one l p p zero one one three b r five two one p one four one p p p p f five four one five e v w six four one g v p f five nine w one seven one r g two seven one l p p three seven one e seven seven one l l e g g eight seven one r nine seven one e k q e three eight one c e r e c f seven eight one p eight eight one c l nine eight one three f one nine one k c r x zero zero two p one zero three g v p f k two figure nine performance degradation energy save product improvement leave right show result voltage scale report result fourteen average performance loss energy save ninety improvement achieve average much energy save amount performance loss apart dynamic versus static benefit describe section two two key factor contribute different result first static compiler algorithm fourteen pick single code region program avoid excessive analysis time design identify multiple code program long beneficial illustrate table two second decision algorithm fourteen base time profile code region algorithm orient directly use information environment hardware performance count overall result figure nine ten table three show propose technique promise address energy performance control problem attribute promise result efficiency design advantage dynamic compiler drive approach basic overhead dynamic optimization system basic overhead ie time spend basic setup frequently execute code overhead must offset amortize subsequent performance optimization gain see net performance improvement show dynamic aggressive performance proceed annual international symposium micro five performance degradation p z g four six one r p v five seven one c c g six seven one f c one eight one f r c six eight one r e r p seven nine one n e two five two k b l r e p three five two p g four five two x e r v five five two two p z b six five two f l w zero zero three g v n k two h b r b three e h l e h r e w p r e e r e p g v n e l energy save p z g four six one r p v five seven one c c g six seven one f c one eight one f r c six eight one r e r p seven nine one n e two five two k b l r e p three five two p g four five two x e r v five five two two p z b six five two f l w zero zero three g v n k two h b r b three e h l e h r e w p r e e r e p g v n e l improvement twenty fifteen ten five zero fifteen five five sixty fifty forty thirty twenty ten zero ten p z g four six one r p v five seven one c c g six seven one f c one eight one f r c six eight one r e r p seven nine one n e two five two k b l r e p three five two fourteen p g four five two x e r v five five two two p z b six five two f l w zero zero three g v n k two h b r b three e h l e h r e w p r e e r e p g v n e l figure ten performance degradation energy save product improvement leave olden right show result voltage scale performance gain various two five system use infrastructure include implement performance use infrastructure implement performance like loop unroll data beyond scope paper compare native application basic system negative performance gain word performance energy overhead associate basic infrastructure next give complete picture work also show result relative native figure eleven show performance energy overhead basic infrastructure compute relative native see individual performance overhead low five like high fifteen like average performance overhead eighteen five olden energy overhead value similar note value significantly lower basic overhead regular pin system eighteen implementation describe section four look result scheme compute inherit infrastructure overhead number lower last subsection expect average improvement inherit overhead fourteen proceed annual international symposium micro five overhead performance energy v c one zero one w two zero one r c two three zero one two r h four zero one r g seven zero one l p p zero one one three b r five two one p one four one p p p p f five four one five e v w six four one g v p f five nine e w p w eight six one w one seven one r g two seven one l p p three seven one e seven seven one l l e g g eight seven one r nine seven one e k q e three eight one c e r e c f seven eight one p eight eight one c l nine eight one three f one nine one k c r x zero zero two p one zero three g v p f k two overhead performance energy twenty eighteen sixteen fourteen twelve ten eight six four two zero twenty eighteen sixteen fourteen twelve ten eight six four two zero r p v five seven one c c g six seven one p z g four six one g v n e figure eleven performance energy overhead basic infrastructure without apply k b l r e p three five two g v n k two r e r p seven nine one f r c six eight one two p z b six five two n e two five two p g four five two f c one eight one h l e h r e w p three e r b zero zero three r e p f l w h b r e e x e r v five five two l olden general clearly still promise result discussion experimental result section would desirable potential number show far result number however still open research question effectively accurately compute result one possible way estimate upper bind extend mathematical formulation optimize multiple sequential scale point optimize multiple code leave possible future exploration experimental result section promise could improve support available one possible support could logic identify predict execution slack propose nine would make computation easier accurate another possible support could hardware monitor counter monitor power consumption processor unit voltage addition could make design effective experience show many code force select unnecessarily high set due lack middle step current six six relate work mention introduction nearly exist scheme base hardware nineteen os seven static compiler fourteen little do direction dynamic compiler drive one piece relate work along direction virtual machine present twelve work similar sense use decide application however work differ follow aspect first use virtual machine target granularity method use general dynamic optimization system target general granularity include code like loop second algorithm take account memory boundedness code region assume execution time code region always scale linearly frequency matter memory bind also algorithm assume sort time budget call project time compare current execution time decide much scale treatment might suitable predetermine frame might suitable general contrast algorithm consider memory boundedness code region work well general third power evaluation twelve base simulation evaluation base physical power seven future work several possible future work focus work new concept dynamic compiler drive overall design framework direct work would look specific design issue depth code transformation periodic also analysis could do experimental result breakdown different contribute factor however since use real system oppose simulation challenge break proceed annual international symposium micro five effective way another possible future work implement conventional performance like loop unroll data study energy performance system addition new allow memory bus well possible future direction generalize analytical decision model algorithm paper case memory eight work present paper represent recent develop dynamic compilation framework energy performance control focus dynamic voltage frequency scale specifically give reason statistical result highlight unique feature advantage dynamic compiler drive exist present design framework general dynamic compilation system describe methodology report experience implement deploy optimization system experimental result base physical show spec benefit seventy energy save five performance loss average result forty spec olden show technique lead energy delay product improvement better static voltage scale better report static compiler scheme attribute promise result efficiency design make multiple code advantage dynamic approach term phase adaptation ability utilize accurate information propose technique effective method voltage frequency control design framework methodology describe paper generalize emerge issue thermal control pilot study thirteen already show dynamic compiler feedback information collaborate hardware control system provide novel approach tackle problem overall feel propose dynamic compilation framework great potential address energy performance power control problem modern would like thank kim hazelwood helpful development work anonymous useful comment paper work support part grant nine reference one pin august two v e dynamo transparent dynamic optimization system proceed june three l wang execution layer dynamic translator design support micro four b brock k dynamic power management embed proceed soc conference five garnett infrastructure adaptive dynamic optimization proceed three march six j h l j early experience olden proceed international workshop parallel compute august seven k r soma dynamic voltage frequency scale precise energy performance base ratio access computation time proceed date eight k e r daisy dynamic compilation architectural compatibility proceed june nine b field r hill slack maximize performance technological proceed may ten n shamir processor power estimation budget optimization validation technology journal seven two eleven r al processor performance technology journal seven two twelve v c v virtual machine drive dynamic voltage scale technical report university ca thirteen k hazelwood brook eliminate voltage via voltage control feedback dynamic optimization proceed four august fourteen design implementation evaluation compiler algorithm energy reduction page june fifteen j j positional adaptation application energy reduction proceed june sixteen c j v formal approach frequent energy june seventeen corporation ca architecture developer manual volume three system program guide eighteen r r muth r muth h g k hazelwood pin build program analysis tool dynamic instrumentation proceed five june nineteen use dynamic voltage scale workshop complexity effective design canada june june twenty steven advance compiler design implementation morgan national instrument data acquisition hardware g g dynamic frequency voltage control multiple clock domain micro page f process cruise control clock scale dynamic power management proceed case two f malik bound power save use dynamic scale exact algorithm heuristic approximation august fen malik dynamic voltage scale limit june j fang accuracy initial prediction dynamic binary proceed four march proceed annual international symposium micro five