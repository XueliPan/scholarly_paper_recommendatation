avoid syntactic n c shih institute information science framework technology group r department wang trend micro abstract far user data document typically construct scratch specific generic interactive component generate user consider unusual editor avoid instead detect syntactic paper cover model adopt always keep work document compliant give schema approach gain follow benefit first avoid syntactic altogether free user syntactic concern second system generate element slot process document construction serve prominent guide user produce valid document third simple edit process support enable generation simple user interface regular finite automata edit graph address correspondence institute information science one introduction extensible markup language emerge standard electronic data interchange many application form define interchange data among within application management get mature may even become standard information model future enterprise application increase number emerge apparently need construct user data document within give vocabulary effectively far user data typically construct scratch specific approach costly consider typically contain even attribute user interface must take care dynamic data structure syntactic presentation layout contrast relational data current tool support user data far adequate variety simple interactive grid navigation control use construct user relational data conveniently user interface tool data widely available motivate development interactive component generate user share many common function three six twenty use interact edit document differ interactive component one invoke consider lightweight editor use end knowledge generic component build user take schema input allow user create update data compliant input schema component must take care two main issue handle syntactic impose schema produce presentation layout simple use specific current paper deal former issue leave latter later report thirteen many take approach syntactic three twenty user allow violate syntactic process edit produce valid document user must correct syntactic document report validity checker unfortunately approach require user knowledge syntax document impractical assumption end target hand one might wish system correct syntactic automatically turn infeasible either since typically multiple ways correct syntactic violation system way guess user want quite different approach take action avoid syntactic altogether would like always keep work document free syntactic however syntactic violation valid document free syntactic course converse true intuitively start empty document may take many element work document become valid work document construct halfway consider free syntactic subset two valid document thus define document subset valid document formal definition give section four indeed editor ie editor always keep work document order maintain user somehow control system provide accurate guidance hint user process document construction major portion current work establish model base automata graph one eight ten compute appropriate guidance hint editor follow novel feature first system avoid syntactic altogether thus free user syntactic concern consequence require user knowledge second since work document free syntactic make sense system generate require require element slot user add automatically process document construction serve prominent guide user produce valid document third propose model abstract able support user various type particular simple edit process support enable generation simple user interface place control user edit action leave enough freedom user construct desirable valid document system impose minimal order user add principle give schema permit child user add child work one iteration time consistent user usual edit behavior three paper use data document interchangeably unless distinguish otherwise propose model applicable general work use term instead emphasize focus syntax next section review relate work section three lay require theoretic regular finite automata section four depict model maintain describe process generate element slot section five section six consider major implementation issue user interface support briefly demonstrate section seven current status project report section eight together future plan finally conclude remark make section nine four two relate work many available present handful emerge long list short post longer run though shall refer edit collectively point section one many edit take approach syntactic fundamentally different avoidance approach take provide guidance hint user edit process however guidance hint provide typically inaccurate loose guarantee validity result document major reason need validity checker user edit three type user base text view tree view presentation view system may support multiple view text view allow user edit tag text editor four tree view display hierarchical structure document tree provide insert delete tree nod twenty grid view consider variant tree view generalization grid control use show tabular data three presentation view result apply document order present desirable user interface user two six edit system support presentation view may appear differently depend transformation support general case support program edit system would principle able generate desirable user interface six however effort technical skill develop presentation view would excessive two type presentation five view restrict emerge view hide tag document frequently appear extension visual text editor word form view display hierarchy form contain control interact user seventeen eighteen form view view may modest effort generate user consider form generator base data model specify schema conventional form base relational data model use extensively fourteen sixteen nineteen however adapt data general since structure much complicate edit process support fall within scope edit edit research extensively eighty eleven fifteen observe two fundamental edit edit eighty former deal structure document latter focus program one edit program strong tendency one produce program statement sequentially edit take advantage trait contrast edit structure document user must far freedom select action necessarily produce document sequential order hand program use perhaps nonprofessional user interface target end despite many available edit model publish far author know current work relate rita early editor prototype manipulate structure document concept six introduce report regard rita seven refer rita establish automaton model propose base multiple order maintain document perhaps consider document model general approach inadequate term efficiency completeness consequence include rita system eventually author outline regard previous paper twelve current work refinement work perspective component full exposition implementation seven three automata document nest hierarchical structure purpose syntactic validity sufficient consider syntactic constraint impose element child separately content type element define regular expression determine valid sequence child element type adopt notation express regular let us start simple regular regular expression e finite alphabet simple symbol xi appear e language l specify e recognize deterministic finite automaton g know automaton e one five ten define follow final state respectively one every symbol state g g two additional state f start two transition function xi xi follow xi ie immediately follow xi string l first e ie first symbol string l xi f xi last e ie xi last symbol string l f l contain empty string special end symbol append every string note function first e last e follow xi compute easily traverse tree structure e take simple expression e b c example first e b c last e c follow follow b b c follow c automaton g e show figure one eight edge automaton g several type two e sequence ie e g contain sequence edge v every last every v first regular expression e natural tree representation e correspond tree representation e sequence edge edge start state edge final state f refer forward edge collectively e g contain iteration edge v every last every v first general edge may sequence edge well iteration edge iteration edge sequence edge refer backward edge g figure one c b c sequence edge well forward edge b c c f forward edge b b b b iteration edge well backward edge e let denote set cover instance b b let reachable denote set state g reachable state ie reachable z exist path g z forward path path consist forward edge let denote set state g reachable forward edge ie z exist forward path g z make follow lemma one forward edge g form cycle proof label e label increase order leave right forward edge always smaller label label thus form cycle lemma two let e x exist first v last x v x nine proof lemma trivial symbol sufficient prove lemma basis child satisfy lemma three case one iteration ie satisfy lemma since first first last last satisfy lemma two choice ie satisfy lemma x either x x say x case x symmetric since satisfy lemma exist first v last x v x since first first first first last last last last prove lemma three sequence ie satisfy lemma x either x x say x case x similar since satisfy lemma exist first z last x z x since first first first since satisfy lemma exist w first v last last v w since sequence edge z w find forward path x z w finally v last complete proof lemma lemma three let e two v v reachable reachable v proof lemma two exist first last v v hand exist iteration edge iteration edge ten find cycle connect v back complete proof consider regular expression e finite alphabet ym general one map e simple regular expression e alphabet rename occurrence symbol e distinct symbol let origin denote original symbol represent let g construct e one construct automaton g know automaton e one five ten g recognize language l specify e treat automata label graph g construct g replace label edge g origin different g g automaton general since multiple may origin xi origin consider regular expression e b e map simple regular expression e b c rename second occurrence e c construct g e show figure one thus automaton g e construct g replace label c edge g label result show figure two notice automata g g label edge determine target state edge thus ignore temporarily internal g g become identical case label edge g significant present user label edge g use represent document save disk even though automaton g general regular expression e general specification impose constraint eleven regular use define content model element type must deterministic compatibility word automaton g must deterministic use recognize valid document efficiently c b c c b b b c f figure one automaton g b c b b b b c f figure two automaton g b twelve four maintain assume regular expression e alphabet ym use content model element type ym child element type let e simple regular expression associate e alphabet make sense distinguish multiple child element type instance paper content model specify e section section one define e use distinguish two section e let g g automata regular e e respectively construct last section shall use g maintain state work document upon interactive edit use g store restore document state definition automata apparent valid document correspond path g g start state final state f vice goal produce valid document end guarantee always produce valid document process construction initially empty document typically valid instead insist system always maintain document subset valid document precise document child element form subsequence valid child element sequence word document correspond subsequence path g f take regular expression b c e example string valid since subsequence string valid thirteen use editor like user start empty document make element control system work document always user delete arbitrary element work document result document still apparently user iterate process element addition deletion complete desirable valid document eventually model work document correspond sequence state g reachable actual document sequence origin origin origin main issue user insert element pair consecutive state say compute appropriate set candidate user select insertion select element result document formal system compute candidate state set c user select user select state x c element origin x insert work document without loss generality assume user intend insert element two state v v reachable candidate state set c representation possible connect v necessary condition state z c satisfy z reachable v reachable z however condition sufficient consider automaton g regular expression e b c e show figure three due outer iteration e every state reachable every state except f state c satisfy necessary condition c would contain state case necessary condition loose give accurate thus aim compute minimal candidate state set involve cycle detour unnecessary fourteen backward edge general cycle involve candidate state set restrict case follow lemma characterize direct v lemma four let v state g v reachable assume v exist e cover v w w last v z z first construct acyclic path p connect v choose one cover v path p refer minimal backward path proof let e cover v assume contrary iteration ie sequence choice consider ancestor may induce forward edge state leave state right however v cover one thus forward edge induce nothing whether v forward reachable word whether v forward reachable depend choice since v cover two respectively reach v contradiction case sequence two case v reach v contradiction v reach v forward edge apply lemma two also contradiction derive case thus must exist iteration cover v lemma two exist w last w z first v z since w z iteration edge find path p connect v fifteen prove p acyclic assume contrary p visit state p since connect w z v respectively forward p appear two connect p p v form forward path connect v contradict assumption v thus p acyclic compute candidate state set c two give state v v reachable distinguish two case v h document locally v h document valid locally h edge set g algorithm case v h c compose intermediate state acyclic v determine lemma four user want path cycle always construct acyclic path first add cycle later algorithm support algorithm v v h v c x x v x else let iteration e cover v c x x v x philosophy behind algorithm user add minimal set v order render current document valid locally let us illustrate automaton g figure three state pair e satisfy e thus c b c state pair c reachable c forward edge c must reach e thus c e sixteen give two state v v reachable v h algorithm compute candidate state set c v forward edge iteration edge v forward edge c first compute hand end v begin iteration v backward edge new iteration may insert v add c algorithm v v h v forward edge c x x v x last iteration e let one x v x c c v first iteration e let one x x c c else v backward edge let iteration e satisfy last v first c consider automaton g figure three state pair b c seventeen indicate element insert b state pair b c c state pair b c since c first c c c allow user iterate c state pair c c backward edge c c user add iteration c two state pair e f since e last e e last e e outer iteration c b c e user may want add inner iteration outer iteration system provide user lemma five completion state x candidate state set c x reachable v reachable x three proof lemma come computation c support lemma two theorem one support algorithm user always produce document construct desirable valid document document subset word approach sound complete proof lemma five system always produce document hand valid document contain document correspond subsequence thus one construct add set user repeat process add forward backward edge add backward edge user much freedom though eventually complete complete proof lemma six consider section take linear time linear size automaton g eighteen proof function compute linear time initially lemma one state g label forward edge state smaller label state label thus one compute x every state x reverse ie decrease order state label single pass algorithm take linear time apparently algorithm restrain guarantee leave enough freedom user principle user add arbitrary order within one iteration however user add new iteration right right exist iteration user add new iteration middle exist iteration believe one iteration time work style consistent user common edit behavior far rely user distinguish multiple child element type ie user fill element slot select candidate state set c hand may case need distinguish multiple element type case occur frequently multiple element cause iteration bound case candidate state set c map candidate element list c c origin x x c user fill element slot select element c system pick arbitrary state x c x insertion work document consider interactive edit document another issue regard restore document editor like rely heavily state information nineteen work document easy system parse valid document reconstruct state sequence since automaton g deterministic however way reconstruct state sequence document general regular expression simple solution write valid document contain work document present work document mark special attribute indicate nonexistence document describe may able restore document produce tool consider limitation reasonable dedicate produce valid document document require syntactic beyond scope b c f e figure three automaton g b c e twenty five generate element slot work document never contain syntactic thus highly likely current document indeed subset target valid document user desire case make sense system generate element slot user add automatically base state current document approach follow benefit first generate require element slot serve prominent guide user produce valid document second generation element slot reduce user third user see effect element insertion quickly insertion want user may able detect undo editor like generate require automatically upon insertion element element require present valid document contain current document policy certainly apply empty document initially particular require generate initially must present valid document normally delete unless parent element delete example consider regular expression b c initially require element element b c insert c b become require element consider state sequence representation work document last section give two state v v reachable require element v correspond state z v pass state know articulation point graph theory eight well know one apply maximum algorithm find articulation point separate v ie find require v multiple articulation point maximum algorithm execute multiple time algorithm take linear time linear size automaton g generate also element slot give two consecutive v current document v h h edge set g every valid document contain current document contain least one element v element slot thus generate automatically v user fill element slot refer require element slot since user typically provide appropriate order render current document valid generate require element slot system also compute associate candidate state set c use algorithm user fill require element slot select desire state element c candidate element list c consider content type define regular expression b c system generate require element also generate require element slot follow together candidate element list contain b c user select general require element slot appear prominent hint user indicate current document valid system guide user produce valid document generate require element slot user fill iteratively user fill require element slot system generate require element slot work document become valid additional generate require element slot automatically editor generate optional element slot upon user request user may ask system show optional element slot show optional element slot near select reference position give two state v v reachable v h system compute candidate state set c use algorithm generate optional element slot v c empty user fill optional element slot way fill require element slot select c candidate element list c consider regular expression b initially system generate b require result state sequence apply algorithm pair consecutive state result candidate state set c pair b c b pair b f thus system may generate optional element slot one b f none b summarize support edit process consist three phase system generate require require element slot user fill require element slot make work document valid user request system display optional element slot fill optional element slot complete desire valid document eventually user typically necessarily edit document order also user fill element slot system may generate require require element slot result iteration three phase consider case element hand user delete element work document system try generate require though may generate require element slot place element delete insist principle work document valid require element slot generate user fill note element slot display user interface rather real work document one element slot display two consecutive make little sense show one element slot two consecutive user element slot would effect neighbor slot one exist element slot highly dependent consecutive consecutive element delete element slot delete system new element slot may generate describe section take approach generate element slot user fill avoid conventional insertion two approach differ latter support edit process former clearly exhibit user legal position believe former approach user case six implementation edit process describe previous section essentially form abstract edit model document practice must able handle construct schema add many detail abstract edit model section report main implementation particular relate syntax handle give regular expression e automaton g g construct time naive implementation one n size e propose sophisticate implementation take time size g five note schema typically compose large number regular ie n small thus adopt naive implementation represent function value first last follow bite approach achieve simple program structure well effective run time proportional point last section require generate initially must present valid document normally delete unless parent element delete however note difference element type element instance element type may multiple instance input document part iteration expression multiple regular expression element type require initially instance require thus leave freedom user element delete element type require initially instance element type current document consider previous section attribute treat simple type element attribute consider precede child attribute always appear order declare input schema even though attribute exhibit behavior child represent sequential impose regular explicitly minimize overhead set automata principle complex type serve simple type serve however complex type exception content well contain attribute make simple treat element complex type pure container contain attribute well child element latter stand content element addition normal regular support bound apparently one convert iteration expression bound regular expression without bound bound e e e p time e q unbounded e e e p time e e e time q result regular expression may much element original expression though fortunately p q typically small practice justify simple conversion schema element may declare mix content allow child interleave character data take care mix content upon computation candidate state set c candidate element list c element mix content system compute c c pair child special element text always add c c user select text serve interleave character data support special group operator group may appear may appear order since group use together group implement separate procedure independently syntactic model describe previous section display many require element slot number require group initially user fill optional element slot may display pair consecutive implement material paper program execute explorer generate form user interface code together browser component encapsulate within active control constitute component browser platform allow presentation style form specify external style sheet free drudgery handle presentation style seven user interface establish abstract comprehensive edit model document top one implement user interface interactive edit principle abstract edit model support user base tree view presentation view among three type edit review section two choose build user interface form easy use well accept little computer skill emerge typical user interface follow take schema paper extreme markup conference nine example demonstrate user interface figure four show form empty paper create form display three level paper two require child front body front two require child title author author four require child body contain require element slot child user fill require require element slot generate system automatically one may fill data field surname one usually form system parameter three case determine number level form may contain element bottom level form address case appear may child one click display child form show child grandchild attribute edit child form may child form child form may nest indefinitely notice large form essentially tree view believe tree view deep structure confuse visually difficult conceptually nontechnical thus typically set small number form appear like conventional form tree view moreover set one may adjust depth nest form suppose one want add form show figure four one display optional element slot around select element say author one move pointer element author small plus icon pop near pointer user click icon optional element slot immediately current element display show figure five otherwise current plus icon pop pointer move another element user fill element slot select menu candidate generate system also show figure five minus icon like plus icon user move pointer element attribute element slot minus icon may pop near pointer click minus one remove current element attribute element slot icon plus minus icon pop element focus adjacent optional element slot allow remove plus minus may pop able support sophisticate layout form figure six show layout child occupy single column entire row layout report later report time thirteen illustrate provide simple user interface enhancement familiar form minimal edit command philosophy keep form simple usual form possible component offer essential interactive edit function additional edit function desire leave application support collection application program interface application enhance user interface virtue user interface support lie layout child element consider element content type specify regular expression e b c approach lay child introduce two control radio button grid control represent choice iteration respectively result structure seventeen eighteen general except simple approach tend clutter form many control complex structure contrast edit process enable produce form layout minimal edit command hand support variety control data field thirty figure four form figure five optional element slot figure six layout eight current status future work far complete preliminary version simple editor valid editor latter small application show section seven invoke component use vehicle test test editor among schema paper extreme markup conference nine use editor create edit current paper convey perform herein report test result regard valid editor schema experimental result report later paper thirteen extensive test complete complex type process contain child element type total element type appear multiple type count multiple time attribute count since part regular valid editor take second load build automata compute function twelve ram run server ie six four also observe response time upon edit edit process editor take five second respond user insertion operation include compute require slot update data structure display additional extensive test ongoing work provide layout style user interface instance data field parent element may align better appearance system provide option display part data table data regular structure like relational data hand support need refine continually anticipate apply different would help refine improve long run plan build visual development environment development environment allow application developer specify layout presentation style component visually addition developer specify apply data include permute child element split merge regular would make use easier enable produce flexible versatile user nine conclude remark many define interchange data among within different application build user costly task develop generic interactive component generate user unique feature avoid instead detect syntactic always keep work document compliant give schema approach gain follow benefit first avoid syntactic altogether free user syntactic concern second system generate element slot process document construction serve prominent guide user produce valid document third simple edit process support enable generation simple user interface fall within area edit focus theoretic major contribution work establish automata graph handle syntactic base regular would potentially render robust work partially support remote soft contract grateful wang helpful comment work reference one v aho r j tool two designer three four international editor five regular finite automata theoretical computer science six blast radius seven e w g g de v smite rita editor user interface manipulate structure document electronic publish four three sept eight even graph computer science press nine extreme markup ten v abstract theory automata math survey sixteen eleven j e urban edit issue feature apply compute march twelve wang n c shih handle syntactic editor document engineer thirteen n c shih generate user preparation fourteen oracle form prentice hall fifteen f r h edit engineer journal three two march sixteen pole automatic form generation practice experience seventeen office eighteen builder nineteen j program net press twenty turbo cascade style sheet level two recommendation may twelve extensible markup language ten recommendation ten query schema part one structure recommendation may two schema part two recommendation may two ten recommendation registry