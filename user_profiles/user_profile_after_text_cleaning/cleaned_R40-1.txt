international conference engineer complex computer implement evaluate model checker transactional memory computer laboratory university memory promise technique address difficulty parallel program since take responsibility concurrency control highly vulnerable subtle correctness due difficulty fully prove correctness many use without formal correctness guarantee paper present flexible model check environment verify correctness various aim model close implementation level reveal many potential bug possible example accurately model version control mechanism addition flexibly model use additional hardware support nest parallelism use model several include industrial hybrid use hardware support nest parallel demonstrate use find previously unreported correctness bug current implementation also verify strong isolation guarantee finally quantitatively analyze understand practical issue motivate research model check introduction transactional memory sixteen emerge promise technique simplify parallel program address difficulty parallel program allow simply declare certain code block guarantee execute atomic isolate way respect code block many propose use hardware fourteen nine fifteen hybrid three six take responsibility manage access share state extreme attention must pay performance result subtle fast favor simpler even though make result difficult prove correct central position however mean severity bug magnify address problem recent work attempt formally verify correctness use model check seven al propose formal method verify correctness similar fourteen use model checker nineteen thirteen al prove important reduction theorem state verification problem reduce general problem two thread two share evaluate system satisfy set certain condition verify correctness abstract model several nine fifteen finally al verify correctness use spin model checker seventeen however still exist research issue require first model close implementation level reveal many potential bug possible example model thirteen model version control mechanism use require hand proof abstract model equivalent actual implementation second model check extend wide range use additional hardware hybrid support nest parallelism third transactional memory access model investigate subtle correctness issue weak isolation order finally quantitative analysis perform understand practical issue sensitivity state space various system motivate research model check paper present flexible model check environment verify correctness multiple aim model close implementation level example version control mechanism accurately model use technique furthermore flexibly model use additional hardware support nest parallelism addition transactional memory also model specific work propose flexible model check environment use verify correctness various consist three one architectural state space explorer two model three test program generator model several include nine hybrid six accelerate use hardware assume initially atomic atomic abort read b speculative dirty read fig one strong isolation support nest parallel two introduce technique accurately model version control mechanism describe case study actually find subtle unreported correctness bug current implementation report bug use verify guarantee every possible execution every possible program two thread execute one transaction perform three transactional memory also verify provide strong isolation test program describe perform quantitative analysis understand practical issue model check first investigate sensitivity state space system number concurrent thread second study multithreaded reduce latency verification third investigate performance correctness verification various approximation apply model quantitative analysis also motivate research reduction theorem thirteen dynamic partial order reduction twelve verify nest parallelism rest paper organize follow section review correctness criteria evaluate paper section describe design implementation section v present main correctness result quantitative analysis section review relate work section conclude paper correctness criteria main correctness criterion use paper conflict discuss verify every possible execution program section iva strong isolation system provide strong isolation isolate memory access twenty implement strong isolation unattractive performance impact code although acceptable performance report use static analysis dynamic recompilation four provide strong isolation contrast hardware hybrid three six include investigate paper provide strong isolation low use hardware support provide partial isolation guarantee implement efficiently strong isolation eight examine paper provide isolation access need evaluate partial guarantee implement strong isolation efficiently figure one present two strong isolation discuss figure one illustrate read expect program behavior two read x observe value however since update x without use write barrier detect conflict x therefore two read x may return different value lazy eager vulnerable figure one b illustrate speculative dirty read read may observe value speculatively write transaction expect program outcome however since eager speculatively update share memory place write ie may observe value speculatively write set two transaction abort update x value already update two contrast lazy invulnerable update make transaction invisible ie buffer outside transaction commit refer discussion weak isolation lazy eager evaluate lazy maintain write buffer perform lazy nine use global version clock establish use hash function memory object associate lock either act lock store version number indicate value global version clock time memory object write commit transaction transaction read memory object first check write buffer find write buffer check version number associate check conflict conflict detect address memory object insert read set transaction transaction write memory object buffer update write buffer commit transaction perform follow two step one acquire memory object write set two validate memory object read set two step fail transaction abort otherwise transaction write back buffer update version number acquire finally release lazy fig two overall architecture evaluate paper ie eager provide weak isolation eager contrast lazy eager five ten maintain undo log perform eager place read barrier similar one lazy need check write buffer transaction write memory object attempt acquire associate acquisition fail transaction abort otherwise transaction update memory object place insert previous value undo log commit transaction validate memory object read set fail transaction abort roll back speculatively write memory object release acquire otherwise transaction version number acquire release b extend eager support parallel two follow model allow transaction execute active ie transaction concurrently run contrast eager extend encode version ownership information time transaction read memory object check owner memory object owner ancestor transaction abort otherwise check version number check conflict transaction write memory object attempt acquire associate owner memory object ancestor acquisition fail transaction abort transaction acquire validate validation fail transaction abort otherwise transaction update memory object place commit transaction validate memory object read set validation fail transaction abort restore value memory object associate write set previously observe value otherwise transaction successfully commit version number acquire transfer ownership memory object parent c lazy hybrid accelerate use hardware six hardware conservatively represent read write set addition hardware continuously snoop coherence message provide conflict detection strong isolation lazy use write buffer perform lazy read write lazy operate similarly lazy except read write set replace hardware commit transaction perform validation acquire exclusive ownership cache line hold memory object write buffer validation fail transaction abort otherwise transaction successfully commit write back buffer update eager contrast lazy eager five use undo log perform eager read barrier simply insert address read signature read memory value write barrier immediately attempt acquire exclusive ownership cache line hold memory object acquisition fail transaction abort otherwise update memory object place insert previous value undo log commit transaction simply reset hardware like lazy eager provide strong isolation design implementation figure two present overall architecture consist follow three one architectural state space explorer two model three test program generator implement scala program language one decide use scala language feature allow us implement concise way discuss three approach architectural state space explorer illustrate figure two architectural state space explorer ase consist two main one architectural simulator two state space explorer architectural simulator model internal architectural state architectural state space program model space f f false f one procedure explore two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen false true air air false air false f fig three state space explorer simple share memory system consist store buffer share global memory processor simulator model processor program counter register file register return stack every update share memory make via bound store buffer may retire store order provide memory consistency model similar total store order explicit memory fence instruction instruction flush size set zero simulator model sequential consistency use sequential consistency work leave verification relax consistency model future work finally system number share memory size fully second component ase state space explorer state space explorer state represent persistent tree state transition pure function produce new state without alter old figure three illustrate state space explorer perform search one determine possible final execute small program use model reduce state space implement simple optimization merge successor instruction dynamic execution read write value since intermediate value affect outcome optimization affect correctness model check verify system first perform state space exploration single processor active time active processor change transaction active directly enumerate serial schedule terminal state produce use valid terminal state augment architectural state record value observe transactional read value overwrite transactional write vow vow retain state space explorer base highly implement multithreaded state space explorer parallelize main loop ie line five figure three dynamically assign chunk thread time quantify section v assume initially atomic atomic x st st x st st test code valid result b invalid execution fig four detect violation use value observe transactional read assume initially st st st vow vow atomic atomic st st st vow vow vow vow test code valid result b invalid execution fig five detect violation use value overwrite transactional write vow commit addition ensure every store test program write unique value establish map value record vow conflict read write perform record vow final memory state correspond every serial execution valid terminal state next perform state space exploration explore every possible memory access interleave terminal state reach check vow final memory state terminal state identical one valid terminal state produce figure four illustrate detect violation use final memory state figure four show simple test program set valid terminal state produce figure four b illustrate invalid execution trace invalid terminal state produce report violation detect terminal state reach match valid terminal state figure four test use final memory state guarantee view enforce conflict add vow key observation behind use vow view conflict schedule contain blind write vow allow us check order write terminal state long self return self return ax return value list zero new ten new ten else forty assign twenty new read ax read thirty new ret forty new read fifty new ax read sixty new one read else seventy seventy new read ax read eighty new ret map e fig six comparison style style model lazy b model code reach identical one produce serial execution figure five demonstrate example detect conflict violation still view execution use vow finally similar verification check strong isolation follow give test program produce possible expect discuss section perform perform explore every possible execution test program unexpected outcome detect report strong isolation violation b model one model model ase augment additional state include global version clock read write set global version clock model globally visible access multiple system contrast read write set transaction model lazy eager specify use language embed scala figure six compare c model specify scala lazy figure six clearly demonstrate aim model evaluate system implementation level reveal many potential bug possible also model similarly note challenge accurately model include infinite number state correspond different value address state space explosion problem introduce key observation behind technique relative order among value important order transactional exact value unimportant spirit step fig seven example two model present anywhere architectural state three step one compute set value present anywhere architectural state two sort three replace value ordinal position sort set global version clock register hold value figure seven give example note least digit decimal register value encode ownership information addition state introduce model model use additional state include doom bite rollback counter commit lock per processor furthermore additional fork join provide initiate terminate execution nest thread unlike read write set processor also model globally visible access child run different two finally since rollback counter may also state space explosion perform addition three model model ase augment additional state represent hardware state information transactional state information doom bite model zero one zero one zero one visible atomic read else repeat process necessary fig eight skeleton transaction code use test assume initially atomic st atomic st x zero one two three two four five six seven lock unlock fig ten execution detect buggy eager memory one procedure two three four five six seven eight nine unlock value fig nine simple test program use test buggy eager globally visible state access unlike unnecessary model additional memory also model include load store currently model use interconnection network expect prior work model check cache coherence eighteen use extend current hardware model leave future work c test program generator verify test program generator use skeleton code show figure eight transaction execute specify number transactional memory memory operation three consider one whether perform two type memory operation ie read write three access memory location generate either randomly random test systematically exhaustive complete test also note value write write operation unique respect write value finally verify strong isolation guarantee manually cod problematic scenario describe case study problem showcase effectiveness present case study find unreported bug available implementation eager verify correctness eager model perform exhaustive test use test report violation test program figure nine generate problematic include one show figure ten investigate problem analyze invalid execution figure ten execute code execute code step zero sample current value address step one two acquire fig eleven bug line six find eager write value two execution step three read speculatively write ie two value step four five execution restore memory value previously observe value step six statement test whether value read step zero match current value ie since already restore value previous value ie value test step six fail ie therefore assume memory value read step three still valid successfully commit end execution scenario invalid outcome figure nine produce analyze invalid execution identify subtle correctness bug line six code show figure eleven avoid problem abort transaction must increment value acquire instead merely restore previous value report bug addition note may difficult find kind subtle bug perform random test use implement code real machine one increase possibility reveal bug random test insert randomize delay various code step zero three figure ten however require programmer potential bug would contrast reveal potential bug without require programmer explore every possible execution program even unlikely e discussion state space reduction implement simple optimization merge locally visible step reduce state space interest open question implement aggressive partial tot time time state table total average execution time average number explore state require verify anomaly ow n n n n n n n n n n n n n n n n n n n order reduction twelve note traditional directly apply due conservativeness global use model particular note interest extend dynamic eleven context model check model address state space explosion problem due use kind counter straightforward model model hybrid hardware augment additional state model hardware use evaluate open question model asynchronous hardware without cause state space explosion verify liven could extend verify liven detect cycle state transition graph existence cycle indicate execution scenario program never terminate infinitely abort restart note evaluate paper know admit attempt provide liven use randomize scheme v evaluation section first discuss main correctness result describe progress verify present quantitative analysis understand practical issue model check specifically investigate one sensitivity execution time number explore state test program size number thread two multithreaded three performance correctness verification approximation apply model perform experiment two r r share memory use kernel server sun environment build use heap model check heap model check finally use scala compiler version compile code table summary weak isolation satisfy follow one two thread program two one transaction per thread three three transactional memory ie read write per transaction four memory program ie purely transactional addition assume underlie system two share memory word provide sequential consistency run generate test program model verify report therefore make follow statement lazy eager guarantee every possible execution every possible program run two thread execute one transaction perform three transactional memory table summarize execution time number explore state require verify system take less second run test exhaustively verify system possible test program table show explore state space verify lazy smaller since read set write buffer lazy model optimization merge locally visible step effective reduce state space contrast less effective read write model globally visible table also demonstrate explore state space model check eager significantly since value even transaction abort avoid problem unique state associate value generate explore verify eager strong isolation investigate strong isolation guarantee manually cod test program present test seven nine include read intermediate lose update intermediate dirty read speculative lose update speculative dirty read overlap write ow buffer write omit solve level higher table summarize result every possible execution test program lazy eager produce unexpected final outcome contrast successfully detect weak isolation summary able mechanically verify use configuration inspire approach discuss correctness result verify first generate possible test program fig twelve sensitivity execution time number explore state test program share memory size fig thirteen sensitivity execution time number explore state number thread use memory transactional model b quantitative analysis sensitivity system investigate sensitivity execution time number explore state verify various system focus program share memory size number thread figure twelve illustrate result program share memory size program size represent number memory perform transaction share memory size denote number share memory word system first result data set collect scale program size share memory size fix two ie two share memory word system contrast second result data set collect share memory size one program size two configuration program share memory size set two result normalize result finally result configuration collect run randomly generate test program lazy model figure twelve show execution time number state increase rather slowly program size increase small share memory size operation conflict high probability limit number possible interleave operation due conflict therefore state space grow relatively marginally even transaction perform contrast share memory size operation execute independently respect due lower contention therefore interleave produce state space grow much faster program share memory size increase also investigate sensitivity execution time number state number configuration thread check figure thirteen present sensitivity result different number configuration thread specifically configuration two run generate add child generate add child sibling repeatedly generate similar manner transaction execute two read reduce state space figure thirteen show execution time number state require verify increase explosively number thread rise note figure thirteen log scale one interest observation increase new sibling thread add due fact order dependency sibling thus interleave produce contrast new single child thread add increase relatively smaller newly add child order dependency parent thus number possible interleave limit instance run fork suspend active result figure thirteen clearly motivate need reduction theorem applicable nest parallel two thread two prove sufficient thirteen guarantee completeness available check since state space explosively grow increase number thread nest level model check may feasible small example test program use thread configuration currently possible verify use even physical memory due state space explosion finally dynamic state space reduction also investigate make feasible model check nest commodity machine multithreaded investigate multithreaded use test program thread configuration model avoid state space explosion transaction test program perform two read vary number concurrent thread one eight measure divide execution time multiple thread one one thread show figure fourteen multithreaded wo mem scale mem scale wo mem scale mem scale size mem per twelve eleven twelve norm thread test program base one two three four five six time state fidelity n table average execution time number explore state fidelity approximate model execution time number state respectively table also summarize fidelity approximate model bug discuss section intentionally inject inject bug model approximation one report error ie false negative merge step make impossible produce invalid execution similar one show figure ten surprise approximate model show false negative least bug set test program use prove particular approximation affect correctness model check use effective tool reduce state space relate work large amount previous work relatively little work do formally verify al seven propose formal method verify correctness similar fourteen use model checker nineteen al thirteen prove important reduction theorem state verification problem reduce general problem two thread two share evaluate satisfy set certain condition addition verify correctness abstract model several include insightful prior theoretical work model evaluate rather abstractly example thirteen model version control mechanism use require hand proof abstract model equivalent actual implementation contrast aim model evaluate close implementation level aggressively find potential bug model al verify correctness use spin model checker seventeen work similar sense work attempt model implementation level work however significantly differ follow three first extend use case model check investigate range include industrial hybrid use hardware support nest parallel second model transactional memory en fig fourteen multithreaded one two three four five six l c c description atomically read mem value atomically release atomically release atomically insert entry write mem value atomically rollback mem value except one table apply model l c denote show reasonable model check eight thread performance correctness one technique reduce state space apply merge several step model algorithm one obviously careless use may affect correctness verification investigate performance correctness verification apply set verify table summarize example approximation one merge step read value memory object ie step zero three figure ten assume happen atomically another example approximation two release acquire commit single step ie loop atomically execute table summarize average execution time number explore state verify approximate model result collect use ten randomly generate test program thread configuration use transaction execute two memory table show approximation two effective reduce state space commit transaction tend write set execute memory therefore approximation two effectively reduce state space merge step algorithm contrast apply abort barrier effective abort transaction tend less write set often fail execute memory therefore apply abort barrier less effective merge step summary approximation six except approximation one reduce thread able study subtle correctness issue weak isolation order finally provide quantitative analysis understand practical issue motivate research model check finally al propose axiomatic formulation model formal specification system use random test find bug evaluate system work differ sense aim formally verify correctness model check possible conclusion paper present flexible model check environment verify correctness various aim model implementation level reveal many potential bug possible use find subtle unreported correctness bug current implementation eager also verify strong isolation guarantee quantitatively analyze understand practical issue model check finally quantitative study motivate research investigate reduction theorem dynamic partial order reduction verify nest parallelism without cause state space explosion would like thank anonymous feedback also want thank sun make code available support scholarship graduate fellowship work support award number pervasive parallelism lab research center reference one scala program language two w n c k implement evaluate nest parallel transactional memory submission three l n c use hardware memory protection build hybrid transactional memory proceed annual international symposium computer architecture four n g c k barrier optimization strongly isolate nine proceed annual symposium program page new york five c j c k stamp transactional eight proceed international symposium characterization six c j n j c k effective hybrid transactional memory system strong isolation guarantee proceed annual international symposium computer architecture june seven j w r l verify correctness transactional proceed international conference formal design page eight l l strong isolation weak idea transact nine workshop transactional compute nine dice n transactional lock disc six proceed international symposium distribute compute march ten dice n understand transactional memory seven proceed international symposium code generation optimization march eleven c p dynamic reduction model check five proceed symposium program page new york twelve p verification concurrent approach problem new york thirteen r b v singh model eight proceed check transactional conference program language design implementation page new york fourteen l v wong b j b k prabhu h c k transactional memory coherence consistency proceed international symposium computer architecture page june fifteen v n transactional memory data structure three proceed annual symposium distribute compute page new york press sixteen j e b moss transactional memory architectural support data structure international symposium computer architecture page proceed seventeen g spin model checker primer reference manual professional eighteen r joshi l j check form two nineteen l specify language tool hardware engineer twenty j r transactional memory morgan synthesis series c h c k test transactional memory pact six proceed international conference parallel compilation page new york k e j j hill wood transactional memory international conference computer architecture j e b moss nest transactional memory model workshop preliminary architecture sketch synchronization concurrency university j b r model check transactional memory spin distribute compute international conference b ar r l c b high performance transactional memory system multicore six proceed symposium practice parallel program new york march press f schneider v ar dynamic optimization efficient strong atomicity eight proceed conference program new york v ar r l k b enforce isolation order seven proceed conference program language design implementation june h con new york c international architecture manual version nine upper saddle river