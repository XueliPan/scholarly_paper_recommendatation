code transformation instruction set extension c v university demand flexible embed short lead development extensible allow instruction set usually identify plain c source article propose combine exploration code identification result performance combination measure two suit result demonstrate combine code yield average performance outperform apply isolation extreme case yield subject performance reliability performance analysis design aid embed optimization general term design performance additional key word phrase instruction set extension design space exploration reference format c r v b n code transformation instruction set extension eight four article page one introduction high performance short two major factor embed design goal deliver best performance give cost possible design time recent processor address develop extensible arc arm pro series core provide system author address institute compute architecture school university forum ten street unite kingdom permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy show notice first page initial screen display along full citation copyright work own must honor abstract credit permit copy otherwise republish post redistribute list use component work work require prior specific permission fee may request two plaza suite new york one c embed compute vol eight four article publication date c al thus reduce risk involve cost new processor design large flexibility also offer instruction set may help improve performance result specialization optimize processor derive generic processor template order explore different design stage trade various partially contradictory design performance power chip area tool support indispensable exist commercial arc international academic al tool analyze application write c identify candidate instruction modify application source code insert handle newly create general overall effectiveness approach depend designer ability generate complex instruction replace sufficiently large number simple machine b frequently execute c efficiently implement article address b show selection good instruction strongly dependent shape c code present generation tool propose novel methodology combine exploration program instruction use transformation tool generate many semantically input program present generate program integer linear program base tool program set new generate along profile base estimate execution time code size result exploitation new use approach achieve remarkable performance average across intensive embed demonstrate approach enable generation powerful traditional capable produce additional tool effort eleven motivate example example consider code excerpt figure one function core kernel implement fast transform key feature code loop nest three level deep amount code spend perform complex address present code current technology see section four generate new instruction result performance improvement figure one b main due code figure one show code functionally equivalent outperform code figure one factor transform code hoist apply follow common elimination code relate address calculation get hoist eliminate array index move array index common place algorithm able generate complex address calculation embed compute vol eight four article publication date code transformation instruction set extension fig one original implementation application result best combine performance b embed compute vol eight four article publication date c al fig two complex instruction generate transform code figure one b show figure two commercial digital signal hand design engineer often contain specialize address interest note construct specialize address calculation generation base transform code figure one b result improvement transform code total combine certain part performance gain directly attribute code rest due enable effect generation see transform code possible get improve performance processor gain provide increase case short example demonstrate interaction two make difficult predict best transformation sequence give application perform combine exploration hardware design space generate significantly better solution isolate optimization approach could produce article present empirical evaluation design space interaction show performance achieve explore combine optimization space rest article organize follow section two discuss large body relate work section three present background research discuss problem combine design space exploration section four describe methodology experimental setup section five discuss result section six conclude article two relate work article seek broaden understand potential know transformation improve quality instruction set embed compute vol eight four article publication date code transformation instruction set extension fig three methodology design space exploration selection current state art describe section follow description context embed section large field summarize exploration actively study recent lead number al al al al derive partition hardware work still underway define full space exploration even purely arithmetic instruction set design work include better model tool allow better performance feasibility current exploration approach use range tool operate canonical describe exploration al originally motivate al discovery iterative methodical exploration design beneficial decrease cosy ace associate compiler processor designer tool feature many figure three illustrate combination compiler binary assembler linker profiler simulator generate single golden model write twenty may use evaluate performance architecture describe model application model intend compile assemble link simulate profile statistics tool run application determine set effective add model designer select subset add able use generation framework embed compute vol eight four article publication date c al generate new performance analysis program designer free modify impose tool register file repeat loop explore design space application specific processor describe golden model way designer free many inherent design space exploration without framework may directly test impact design decision without need manually simulation compilation approach design exploration evaluation prove successful case study cite al combine code transformation target flow graph transformation toward efficient arithmetic structure operate post directly contribute design space search improve upon result show exploration successful enable better perform motivate approach perform comprehensive systematic study article demonstrate effectiveness transformation embed due inherent portability large scope use various field within embed code target io performance wang energy efficiency al kulkarni al formal verification winter notably single multicore performance optimization intensive embed respectively rise al tool build transformation tool optimization c c use serial loop parallel message pass brown al empirical study digital subject comprehensive study context adaptive compilation find al al active research area inspire subsequent work electronic system level design al al comprehensive summary research approach tool find work cover broad scope issue typically range analysis system evaluation design verification contrast work focus specific individual problem namely embed compute vol eight four article publication date code transformation instruction set extension partition context extensible three background extensible extensible base premise processor speed die area power consumption improve architecture processor extend include feature approach require ability extend architecture implementation well compiler associate binary support may extend statically dynamically processor extend statically augment description processor prior synthesis incorporate design fabricate modify extend dynamically extensible processor must implement either wholly partly form field logic fabric use stretch stretch form extension perhaps properly consider form configuration make cache associate bus structure embed core provide capability adjust cache size sometimes also block size memory bus width impact performance die area power consumption also relatively easy exploit require change architecture true architecture begin capability add custom instruction set form may pack arm include various flavor application specific arc instruction set arc international paper concern concept processor vendor instead identify system integrator analysis application allow incorporate processor pipeline must extension interface allow operator information export extension logic result information return processor figure four extension may share operand regular thus limit two source one two destination however greater scope exist identify useful register operand relax allow two input output addition allow extension also extend processor state define extra register increase map fragment application directly hardware practical extensible embed compute market embed compute vol eight four article publication date c al fig four simplify view family architecture demonstrate core connection custom register arithmetic arc normally five seven stag permit operate range technology node extension may constrain fit within single clock cycle may operate clock frequency however current dynamically extensible core use implement extension operate speed example extension stretch operate one third clock rate processor representation vary one vendor another essentially describe encode semantics extension instruction ways understand processor generator tool tool follow process translate abstract representation extension instruction perhaps extension simultaneously structural form use hardware description language incorporate overall definition processor synthesize target silicon technology perhaps exploration exploration optimization process design flow soc typically operate multiple performance power energy cost complexity target often multidimensional highly nonlinear optimization space multiple dependent level algorithm design space exploration interaction make difficult employ isolate local search approach require combine effort cross traditional design provide feedback integrate tool embed compute vol eight four article publication date code transformation instruction set extension extensible processor core arc number allow instruction set optimize particular application design concern guide exploration often reduce metrics execution speed power usage die area metrics accompany relevant design space configuration extension domain meet main execution speed requirement mean increase speed generally useful provide overhead development application meet system build around core able communicate process data without stall due miss core execution speed meet focus may switch secondary ax design concern power usage address one axis design concern may make use ax example performance exceed clock speed may reduce reduce power consumption secondary concern additional design space core available explore satisfactory example clock gate dynamic voltage scale unit prune however outside scope instruction set extension cover unfortunately second order effect core extension always beneficial often hard predict accuracy add logic core example increase critical path force reduction overall clock speed complicate web form space explore efficiently aid iterative mean affect three ax design concern guide metric derive often still application execution speed add cover frequently execute section application code intention partition application code cover dedicate service new highly design space several source optimization currently bring bear hardware performance new instruction one parallelism parallel instance arithmetic hardware order perform multiple allow two reduce overhead due increase locality communication within functional unit use represent new instruction three aggregation clock period surplus present arithmetic function particular bitwise function hardware latency far clock period case grow optimization aim ensure represent new instruction achieve maximum speed possible trade embed compute vol eight four article publication date c al die area increase execution speed decrease power usage decrease often correlate frequently execute section code benefit relatively small increase tempt problem remain find way accurately model exist architecture full range potential way efficiently exploration show new search develop control application respect new set inherent compare code generation target would attempt limit increase basic block size due register pressure drive toward possible basic block size analysis combine combine design space question transformation intention demonstrate promise manage design large space also important result framework outweigh sum separate hope actual search combine space remain phase search space individually important factor scenario accuracy detail model employ decision make work attempt contribute understand need make invariantly beneficial extension use compiler transform develop design space exploration must carefully consider disturb context make run prior tool must tool identify otherwise find map without explicitly define manual mean four experiment methodology primary concern experiment determine thereof infer execution speed improvement secondly experiment find limit performance gain loss combine design space define transformation design employ neither information properly focus future research toward beneficial represent transformation design space experiment use transformation tool build upon al compiler framework worth note tool operate transformation tool rather transformation use apply everywhere legal without analysis whether embed compute vol eight four article publication date code transformation instruction set extension likely beneficial tool generate large transform source code sample rapidly definition one source code c purpose variety bench mark test well two transform space definition inclusion exclusion transform permit space plus maximum number transformation phase sample tool support wide array use exploration see appendix consider loop unroll commonly generic common elimination three number sample take transformation space hence number transform source cod produce set either fix limit unbounded example exhaustively enumerate entire transformation space give sequence length use framework conduct two experiment one initially sample take uniform probability random point across entire space potential sample sense represent single point transformation space result order set select sample point apply code first experiment aim investigate scope combine two second experiment exhaustively enumerate transformation sequence reduce set length three arbitrarily select fifteen relevant accord analysis first round experiment thus keep experiment within practical limit use experiment take lee snurt national university research group suit take list table available different process different size use different size overview propose design flow present figure five store entire set transform source cod represent sample point transformation space apply set apply sample also store later correlation analysis set transform source cod form representative sample entire search space sample process profile tool base method al tool operate three phase one instrumentation wherein tool augment intermediate representation application counter profile embed compute vol eight four article publication date c al table description choose snurt suit suite description histogram image enhancement use histogram equalization adaptive differential pulse code modulation algorithm compress fir mult spectral fir adaptive differential pulse code modulation algorithm image compression use discrete cosine transform image edge detection fast transform finite impulse response filter infinite impulse response filter normalize lattice filter least mean square adaptive fir filter linear predictive encode speech matrix multiplication spectral analysis use periodogram average binary search cyclic redundancy check perform fast transform use algorithm perform fast transform array complex number finite impulse response filter number generation accurate integer implementation forward discrete cosine transform use encode least mean square adaptive signal enhancement lower upper decomposition simultaneous linear matrix multiplication matrix inversion select compute root quadratic select nth number list calculate square root series fifty snurt tool emit assembly profile executable assemble run use standard gnu tool chain two execution run instrument binary record execution store file use extension phase three extension augment profile statistics use select top four use algorithm al briefly describe section tool profiler combine latency table give target architecture produce performance metrics original sample metrics generate store alongside transform code definition selection algorithm control transformation input program first experiment simple embed compute vol eight four article publication date code transformation instruction set extension fig five combine phase search transformation experiment methodology flow diagram probabilistic algorithm generate transformation sequence random length give maximum select transformation inclusion sequence uniform probability second experiment without generate skip sequence repeat may result beneficial sequence miss remove allow clearer analysis effect transformation individually duplicate due noneffective filter check see change application reduce set generate program compile run platform output compare original reference match sequence discard case total one allow flip still consider output identical allow small result due move code around output must check make sure code accidentally damage incorrect transformation pass many sequence consider unusual conventional term use uncover latent compiler bug theoretical across fifteen sequence length three repeat within sequence remain remove duplicate sequence remain discard sequence result incorrect code reduce tool fail process embed compute vol eight four article publication date c al identification algorithm use generate conversion basic block set solution program implementation tool build cosy compiler use solve library solve generate set candidate entire program declare basic block generate template one template convex ie path two template include operation template may schedule two input output port meet ie number register input output port sufficient may implement addition goal function also express algorithm goal estimate serial time execution cycle cover template minus estimate critical path template former denote execution time indicative time instruction would take execute unextended architecture latter denote hardware execution time factor cycle time take execute template single instruction cycle time hardware operation specify tool apriori construction allow generate difference hardware execution time gain cycle architecture implement template follow generation basic block check isomorphism one another use graph isomorphism library rank use product estimate usage gain top four record alongside performance estimate inclusion result performance evaluation performance statistics estimate whole program use profile information use rank instruction potential profile provide execution represent number time basic block execute single execution whole program multiply latency basic block result value sum provide number cycle program take execute absence perform full simulation form solid prediction performance wherein data hazard lie every instruction lead instruction latency greater one hardware accelerate performance obtain multiply basic block frequency make basic block sum value get total save cycle make save subtract cycle produce cycle count hardware accelerate application relative reduction cycle hardware versus take improvement note constitute valid analysis face able determine embed compute vol eight four article publication date code transformation instruction set extension absolutely accurate performance since start estimate performance improve gain certain sure avoid result notable omission performance evaluation cache model primary reason include one allow accurate previous use cache model either though without consider compiler less motivation avoid complicate analysis result consider cache would mean would additional cache configuration would potentially obscure effect performance try ensure lack cache model affect result data consider transformation consider loop unroll affect instruction cache also worth note constant memory cost assume evaluation memory quite common many digital consider data cache handle stream data efficiently able estimate improvement code size similar fashion performance although consider code link without analysis system size instruction assume identical achieve implicit large number although complicate register map complex instruction use number original cover sum subtract one get code size improvement total number program sum calculate code size subtract value form code size improvement entire application experimental setup purpose experiment configure processor current embed base upon instruction set port constraint set allow wide range potential avoid result due synthetic set algorithm show possible reduce register file io suit actual therefore sample point one source code transformation two define three record performance cycle apply embed compute vol eight four article publication date c al four record improvement performance metrics generate transform source five aggregation result top four calculate overall benefit transform code control point reference ensure utilize transform transformation space tool produce many find within source code however arbitrarily limit number use result four order allow inclusion expect reveal transformation commercial approach tend use large number small preserve generality entire experiment run machine run course several days order allow sample tool operation speed result generation illustrate figure five five result section present discuss result initially concentrate performance code size due combine transformation next analyze specifically data collect exhaustive enumeration transformation space interest focus detail interaction transformation application look individual transformation performance result figure six seven show achieve selection snurt suit summarize random exhaustive enumeration experiment respectively first three bar represent best improvement see search space technique alone alone combination two peak factor snurt snurt see respectively geometric mean across suit count take best experiment one two respectively comparison previous work average combine performance across suit experiment result geometric mean also see consider experiment one five see combine transformation improvement twenty seven see improvement less fourth bar include figure seven combine achieve transformation sequence result combine ie associate result embed compute vol eight four article publication date code transformation instruction set extension fig six maximum experiment one random sample alone alone combine figure eight one would expect see general code notably suite reason dip performance snurt experiment one two combination apply experiment two addition io code snurt two experiment time spend actually io standard library include performance allow additional verification time spend io relate code within include io code difficult improve account proportion thus core kernel water figure eight eight b show achieve present combine summary experiment one two graph base sample point improvement figure separate transformation sequence find effective reduce peak factor snurt snurt see embed compute vol eight four article publication date c al fig seven maximum experiment two exhaustive enumeration alone alone combine alone alone combination two respectively geometric mean across suit respectively figure six seven eight show average result snurt noticeably higher primary reason snurt smaller potential selection space smaller thus better suit uniform sample although explore tiny fraction overall search space small number random experiment short sequence reduce set exhaustively enumerate space still obtain good result however seem likely explore portion search space yield even better result especially program embed compute vol eight four article publication date code transformation instruction set extension fig eight maximum code size experiment random exhaustive enumeration alone alone combine program also likely benefit direct search technique quickly focus promise search space describe al chow show many case simply choose allow effective use give good overall performance strong one optimal combine performance give set allow improvement combine performance significantly better either alone snurt snurt embed compute vol eight four article publication date c al fig nine performance improvement relation number evaluate sample generate transformation tool evaluation initially show demonstrate many random algorithm require performance improvement achieve look turn identify best transformation sequence result exhaustive enumeration experiment interest find best transformation sequence change influence figure nine show performance best transformation sequence find far point random sample space evaluate figure nine show example snurt kind lead evaluate high number sample transformation space contain several step performance best sequence find far best find several thousand sample evaluate however typical figure nine b example show typical behaviour also step performance best sequence find far much closer together best find run none remain sequence evaluate better suggest consider smaller number sample sufficient produce acceptable result example single transformation responsible majority performance gain consider number sample may find step lead even greater performance though table best transformation sequence per exhaustive enumeration experiment show snurt strike observation clear dominance loop unroll forward propagation dead code elimination notable rule compress inspection source cod reveal benefit contain one nest embed compute vol eight four article publication date code transformation instruction set extension table overall best transformation sequence exhaustive enumeration experiment suite suite transformation transformation snurt compress one histogram one one one ten four sequence fir sequence select computational loop perform linear array contain loop nonlinear array still benefit loop unroll require additional common elimination loop invariant hoist develop full performance line number dedicate toward address computation b large amount redundancy exploit move part address inner loop c remain address make efficient implement program intensive cod hence benefit also noteworthy mention transformation sequence generate optimal result differ size fir also play important role snurt situation less obvious still cod benefit way show example cod style otherwise algorithm lead different optimal transformation sequence analogous manipulation orient cod react different set cod distinct correlation certain code code feature enable performance gain suggest may possible exploit relationship example employ machine learn predict good transformation sequence without need costly exploration optimization space however outside scope article embed compute vol eight four article publication date c al fig ten achieve every transformation sequence search space selection version program three value show raw performance transformation raw transform performance combine transformation combine performance point performance technique unmodified code code order increase combine performance along evaluation graph figure ten show performance individual technique combination two every sample point search space small selection sample sort performance combine allow ratio transformation performance see also show performance two individual see either performance individual improve point one get better get worse example correlation show leave side figure ten c show separate performance set allow good performance perform poorly overall due performance decrease see transform alone useful example correlation embed compute vol eight four article publication date code transformation instruction set extension show motivate example common elimination loop invariant hoist sequence make use mark short vertical bar figure ten see sequence make use performance improve greatly either turn figure ten b show almost ideal set result snurt best set transformation sequence consider alone also allow gain optimal sequence overlap way combine performance high go peak individual peak combine snurt figure ten show result almost none overall improvement come almost entirely one however graph still show poor code shape limit second exhaustive set result allow transformation evaluate individually get apply fix number time shorter sequence mean less along side good figure eleven show transformation exhaustive result many good sequence appear compare bad good mean performance better show figure eleven eleven b show figure eleven c eleven graph present term improvement greater mean code smaller figure eleven eleven see pure transformation without relative ten figure eleven b eleven see combine relative performance identity code contain bad sequence use orient toward performance rather result present table respectively full name transformation id may find appendix end article usage column refer many valid sequence transformation appear within five best column percentage sequence contain give transformation result performance least good best sequence may may contain give transformation percentage see description risk factor give transformation higher percentage lower risk sequence contain transformation perform poorly column list best improvement achieve use combine column list best improvement achieve apply follow two number necessarily relate transformation sequence finally expect column estimate combine performance base take product best pure transformation improvement embed compute vol eight four article publication date c al fig eleven distribution good bad sequence contain transformation good bad performance identity code difference combine performance show average enable disable effect sequence contain transform first row table show performance across sequence without regard contain result show many first across sequence combine performance slightly higher expect average show overall additional enable factor however single transformation show improvement expect performance consider sequence across though bound comparison substitution notably worse expect performance consider result basis however see number make average amount variance many present highlight common elimination expect give improvement snurt improvement actually embed compute vol eight four article publication date code transformation instruction set extension table improvement information transformation use exhaustive experiment per transformation transformation usage within five best combine expect four four seven thirteen one nine sixteen zero eight thirteen one twelve fourteen seven zero five nineteen seven zero seventeen table improvement information transformation use exhaustive experiment per transformation usage within five best combine expect achieve however improvement expect improvement actually achieve four loop unroll factor four expect give snurt achieve improvement snurt achieve improvement expect general result may see well forward constant propagation dead code elimination four loop unroll mostly likely part good transformation sequence improve embed compute vol eight four article publication date c al consider combine improve forward constant propagation dead code elimination likely involve good sequence induction variable detection four loop unroll line compiler writer intuition six article describe methodology improve generation combine exploration generic source identification demonstrate effective provide much scope performance improvement generation isolate technique integrate generation unify framework efficiently optimize hardware design space extensible empirical evaluation design space exploration framework base model processor snurt suit successfully demonstrate approach able outperform exist approach give average compare previous work cover much array exist get global picture potential transformation improve addition demonstrate exist dependence generate justify design space future work investigate integration machine learn base program feature design space exploration algorithm target commercial extensible processor platform appendix section provide complete list together short description function experiment two make use reduce set section six experiment one use appendix aim experiment one consider everything see effect many section six pure dismantle perform lower also ever apply consider target code feature find consider first experiment list description transformation please refer documentation embed compute vol eight four article publication date code transformation instruction set extension important bound comparison substitution replace upper lower bound loop inside loop body know result comparison common elimination simple common elimination control simplification simplify one branch always execute remove loop never execute dead code elimination simple dead code loop normalize loop lower bind zero step size one less equal test guard add nod around tree nod ensure whenever tree node execute land pad first iteration always execute hoist move certain nod code allow test eliminate imperfectly nest loop conversion turn imperfectly nest loop nest perfectly nest loop nest pull far possible induction variable detection simple induction variable detection replace use induction variable within loop loop index move induction variable outside loop lift call expression take call within expression tree expression tree loop invariant hoist move calculation ex outside loop body loop unroll x unroll loop x time value x limit move loop invariant move inside loop outside outermost loop control flow simple control flow remove unreachable code remove label target branch remove label follow unconditional jump remove branch target natural control flow invert condition branch simplify control flow full copy forward propagation composite transformation perform copy propagation forward propagation constant fold local constant propagation constant extraction order iteratively stop change consider individually experiment two composite use instead additional array array turn array multidimensional embed compute vol eight four article publication date c al bite pack combine local use single pack together type break load constant instruction break load constant symbol nonzero offset explicit addition offset call reference replacement replace scalar vari chain array reference attempt chain together multiple array refer series single array reference instruction constant propagation propagate forward definition constant fold fold wherever possible copy propagation propagate forward copy simple local default perform default pass design use immediately front end turn nonstandard produce standard dismantle array instruction dismantle array explicit base plus offset dismantle div instruction dismantle dismantle div instruction dismantle dismantle empty tree dismantle tree empty dismantle instruction dismantle integer min dismantle instruction dismantle dismantle branch dismantle branch body dismantle non constant dismantle tree unless upper bind step loop dismantle tree block dismantle tree block dismantle tree block without symbol table dismantle tree block empty symbol table dismantle tree dismantle tree dismantle tree modify index variable dismantle tree index variable might modify tree body dismantle tree spill index variable dismantle tree spill index variable dismantle tree loop dismantle tree loop eliminate enumeration type replace use enumerate type correspond plain integer type embed compute vol eight four article publication date code transformation instruction set extension eliminate copy get rid structure copy whether copy pair eliminate sub remove replace use use root appropriate offset explicit load store put explicit load store access local nonstatic nonvolatile without take flag set extract upper array bound attempt extract upper bind information array reference array reference find build tree nod tree loop nod suitable index variable bound find fix address take set take flag variable true false depend whether address actually take strictly fix bad nod fix bad nod use part default expansion front end fix type put correct type load constant load symbol address global variable code help global across call local static change static local global file symbol table improve array bound try improve array bind information replace use array bound look constant start scope array type kill redundant line mark remove mark con tain nothing line information loop flatten loop unroll unroll loop completely small enough contain many ref put tree pointer conversion add array reference place pointer every variable list annotation arithmetic possible tree summation loop reduction detection find simple instance reduction move replace constant replace use constant base static information turn local array element use array load store know aggressively constant array reference overlap array ref constant index scalar variable embed compute vol eight four article publication date c al reference ace associate compiler ace cosy web site f e j b f j c k use machine learn focus iterative optimization proceed annual international symposium code generation optimization arc international arc white paper arc international architect product brief k g c integer linear program approach identify proceed international conference system synthesis f h l c metropolis integrate electronic system design environment computer four mix integer program solver solve p n l p iterative generation technique fast fourteen seven p l code transformation extensible embed proceed international conference architecture synthesis embed case new york v framework write c program crossroads twelve three three brown w j overture framework solve partial differential overlap proceed conference object orient scientific compute chow k selection characterization compiler proceed workshop feedback direct optimization new york e l g energy efficient source code transformation base value profile proceed international workshop operate new york processor designer h p source code optimization data flow dominate embed academic h arm b array recovery embed two two b combine program recovery locality analysis c program embed proceed international conference parallel compilation b j g probabilistic optimization embed program proceed conference tool embed new york h methodical design space r r register pressure sensitive redundancy elimination lecture note ration signal process three computer science vol h k r g h architecture exploration efficient application specific embed processor design embed compute vol eight four article publication date code transformation instruction set extension processor embed compute k malik newton j design concern design nineteen kulkarni c f man h code low power cache embed proceed international parallel process symposium lee c g r k design flow embed optimize instruction set extension synthesis proceed design test date six v l array regroup use compile embed one b user guide r architecture l p g automatic instruction set extension utilization embed proceed international conference new york l k p exact approximate extension embed processor instruction set aid seven l p exploit relax port proceed international conference synthesis embed case five new york j k en ca j architecture proceed joint modular conference berlin national university research group stretch architecture reference compiler solution code performance challenge k p improve use representation synthesis complex arithmetic circuit proceed international conference design k p towards automatic exploration arithmetic circuit proceed design conference six wang improve io data partition proceed international workshop storage network architecture parallel r p r c p j w k hall w lam j l infrastructure research parallelize optimize notice twelve winter b improve formal verification proceed international conference computer design receive revise accept embed compute vol eight four article publication date