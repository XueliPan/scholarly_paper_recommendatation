shoestring probabilistic soft error reliability cheap amin advance computer architecture laboratory university michigan ann arbor mi shoe abstract aggressive technology scale provide ever increase budget faster unfortunately trend accompany decline individual device reliability become increasingly susceptible soft quickly approach new era resilience soft longer luxury reserve even use compute soon require protection however due profit reliable operation must come little cost paper present shoestring minimally invasive solution provide high soft error coverage little overhead enable deployment even commodity shoestring reliability budget leverage intelligent analysis compile time exploit error detection shoestring able focus protect portion program code shoestring effectively apply instruction duplication protect segment code subject soft error likely result fault without first exhibit symptomatic behavior shoestring able recover additional soft undetected approach achieve overall failure rate sixteen reliability improvement come modest performance overhead subject performance reliability reliability test fault tolerance program general term design experimentation reliability compiler analysis error detection fault injection introduction one critical aspect computer system reliability expect perform task quickly also correctly whether trade stock watch latest video expect experience although impossible build completely reliable system hardware target failure rat imperceptibly small permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten march copyright c one pervasive computer system failure focus paper soft soft error transient fault induce electrical noise particle strike result cosmic radiation chip package unlike manufacture design defect persistent transient fault name suggest sporadically influence program execution one first report soft come corporation chip package contaminate uranium nearby mine thirteen cypress semiconductor report number arise soft one incident single soft error crash entire data center another soft cause automotive factory halt every month since susceptibility soft error directly relate size operate voltage current scale trend suggest dramatic increase soft error rat ser inevitable traditionally reliability research focus largely server market historically gold space nonstop three rely large scale modular redundancy provide fault tolerance research focus provide fault protection use redundant eight seventeen thirty hardware checker like diva six general expensive term area power require redundant computation applicable outside design computer commodity electronics market differ substantially server domain space area power primary will pay additional cost term hardware price performance loss reduce battery lifetime adopt server space time demand reliability regularly tolerate drop phone call video playback crash commonly cause bug key challenge face consumer electronics market future deep submicron provide enough coverage soft effective fault rate raw ser scale available coverage remain level people become accustom examine coverage achieve cheap goal paper garner statistically high soft error coverage low propose shoestring approach detect correct soft shoestring build upon two prior research fault detection instruction duplication detection scheme recognize often exhibit anomalous behavior presence transient fault eleven include memory access branch even cache miss although detection amount coverage obtain approach typically limit address limitation leverage second area prior research instruction duplication approach duplicate result validate within single thread execution solution advantage purely require specialize hardware achieve nearly coverage however term performance power quite high since large fraction application replicate key insight shoestring exploit majority transient fault either ignore ultimately propagate application level easily cover lightweight detection address remain fault compiler analysis utilize identify portion application code susceptible soft ie likely corrupt system state statistically unlikely cover timely appearance portion code protect instruction duplication essence shoestring intelligently select rely judiciously apply instruction duplication optimize coverage performance manner shoestring transparently provide solution soft target consumer electronics market however unlike provide provable guarantee coverage shoestring provide opportunistic coverage therefore suitable paper follow transparent solution address soft commodity incur minimal performance overhead provide high fault coverage new compiler analysis quantify likelihood fault corrupt instruction cover fault detection selective instruction duplication approach leverage compiler analysis identify replicate small subset vulnerable fault injection experiment demonstrate effectiveness shoestring term fault coverage performance overhead two background motivation soft error rate vulnerability individual soft continue grow device dimension shrink new technology generation traditionally soft major concern memory due higher sensitivity change operate condition however protect memory relatively straightforward use parity check error correct cod hand combinational logic fault harder detect correct furthermore al report ser expect remain stable ser logic steadily rise factor motivate flurry research investigate protect core transient fault body relate work address section six figure one show ser trend range silicon technology report term time per chip leverage data present al ser trend processor logic scale deep submicron similar do five generate curve one number observe per one billion operation figure one soft error rate trend processor logic across range silicon technology nod nominal curve illustrate past present trend l h curve assume low medium high amount respectively voltage scale future deep submicron failure rat highlight sixteen calculate assume mask rate figure two fault coverage versus dynamic instruction penalty two exist fault detection scheme detection instruction detection also indicate region solution space target shoestring map fault coverage failure rate dash horizontal line respect single chip sixteen technology node aggressive voltage scale h label nominal note exponential rise ser new technology generation exacerbate ser challenge fact future aggressive voltage scale static dynamic require meet envelop presence unprecedented transistor curve l h illustrate potential impact low medium high amount respectively voltage scale ser fortunately large fraction transient fault mask corrupt actual program state mask occur circuit level experiment consistent prior find wang patel show mask rate around collectively source account mask raw ser present technology node translate one failure every month population chip typical user likely imperceptible however future nod like sixteen fault rate could high one failure day every chip potential dramatic increase effective fault rate necessitate incorporate soft error tolerance even commodity solution landscape shoestring previously discuss soft error solution tailor commodity user space need cheap minimally invasive capable provide sufficient fault coverage figure two conceptual plot fault coverage versus performance overhead two type fault detection scheme form foundation shoestring one base instruction duplication bottom region plot indicate amount fault coverage result intrinsic source soft error mask available free remain unmask fault detection able cover fraction without incur appreciable overhead mostly detect hardware however inclusive set consider overall coverage improve performance overhead increase substantially expect since scheme rely monitor set rare treat occurrence symptomatic soft error initiate rollback lightweight set monitor limit rarely ever occur condition hardware performance overhead negligible however set expand include common like branch cache miss overhead associate increase contrast coverage versus performance curve far less steep instruction duplication since instruction duplication scheme achieve fault coverage replicate computation validate original duplicate code sequence amount coverage easily tunable coverage increase almost linearly amount duplication horizontal line figure two highlight three fault coverage map effective failure rat one failure per day week month context single chip sixteen aggressive voltage scale h fault coverage provide intrinsic source mask translate one failure day clearly unacceptable achieve tolerable failure rate one fault per week even month comparable source failure consumer electronics power supply amount fault coverage must significantly improve note although detection solution cheap minimally invasive fall short achieve coverage similarly although instruction duplication capable meet reliability target sacrifice considerable performance power execute dynamic although neither exist technique alone provide desire performance coverage hybrid method shoestring able exploit ultimately provide technique position within solution space three shoestring main intuition behind shoestring notion reliability always necessary fact commodity presence resilience may go unnoticed shoestring exploit reality advocate use minimally invasive provide enough resilience transient fault achieve rely error detection supply bulk fault coverage little cost fruit harvest judicious two require symptom detection employ shoestring already exist modern support performance speculation see section four global array process global macro one index zero two stop three four five six seven eight nine end process index process index one process index two process index three index index four stop index three ten cleanup code eleven index index twelve thirteen end process index figure three representative example performance optimize code loop unroll cation instruction duplication leverage target remain fault never manifest first order program execution consist data computation traverse control flow graph correct program execution strictly speak require one data compute properly two execution proceed right ie compute data correctly compute correct data work definition previous reliability scheme like swift assume program execute correctly user perspective store program perform properly essentially redefine correct program execution one store correct data correct address two perform right store implicit assumption sphere replication scope beyond technique tolerate fault limit process core fault cache external address efficiently protect like nine shoestring make similar correct program execution however unlike swift scheme target complete fault coverage relax coverage constraint free shoestring protect portion program order guarantee correctness afford shoestring flexibility selectively protect store likely impact program output least likely already cover symptom furthermore acknowledge recent work wang al show many forty dynamic branch outcome tolerant affect correct program behavior force incorrect path author demonstrate many result partially dead control ie data dependent outcome tolerant majority time leverage insight shoestring also would overhead require ensure always properly traverse instead focus protect subset control flow impact figure three show snippet code manipulation array data structure perform computation perform within tight loop use process macro manipulate array data performance loop unroll four time line two nine additional cleanup code line eleven thirteen also insert maintain program semantics note example computation essential correct program behavior instruction line eight determine early loop termination condition meet instruction compute stop subject transient fault unroll loop could exit prematurely although early exit degrade performance program correctness still maintain contrast properly update variable index line seven preliminary classification shoestring initial characterization pass iterate program identify clarity classification describe separate compiler pass however practice identification perform part vulnerability analysis pass symptom consider prior detection work broadly separate follow eleven define instruction set architecture must already detect hardware implement page fault overflow fatal subset never occur normal user program execution segment fault illegal anomalous behavior occur normal program execution also symptomatic fault branch cache miss relative usefulness dependent strongly appearance correlate actual fault ideal occur rarely normal execution minimize overhead due false always manifest wake fault therefore maximize experiment section five evaluate shoestring implementation consider elicit second category fatal potentially symptom generate since normal execution user program never arise incur performance overhead absence fault although additional coverage glean evaluate inclusive set prior work show additional coverage often justify accompany cost example wang patel present result use branch branch symptom gain additional three coverage eight performance penalty nonfatal like data cache miss also similar coverage overhead profile ideally would like consider impact program output however give analysis necessary provably make impractical intractable must employ currently potentially impact global memory consider addition produce pass function call especially library call also include provide truly transparent solution shoestring present assume user available assist instruction classification future could leverage theory fourteen refine instruction selection process even exploit work li twelve prune impact soft program output although investigate sophisticate identify promise avenue future work beyond scope current paper vulnerability analysis preliminary instruction classification complete shoestring analyze vulnerability instruction determine whether figure four standard compiler flow augment shoestring code generation pass program correctness assume course variable however since index also use base address access probability fault corrupt index would manifest symptomatic memory access exception give proper detection scheme could decrease effective vulnerability computation line seven identify critical program correctness prune set already cover detection focus remainder section compiler overview implement cost effective mean deploy instruction duplication require detail compiler analysis shoestring introduce additional code generation pass standard compiler figure four highlight pass context typical program compilation shoestring compilation pass schedule program already lower representation register allocation first two pass preliminary classification vulnerability analysis design categorize base expect behavior presence transient fault briefly describe consume corrupt input likely produce detectable consume corrupt input likely produce output result program corruption safe naturally cover safe instruction expectation transient fault propagate arise execution high probability one generate symptom within acceptable latency slat vulnerable safe consider vulnerable follow initial characterization pass third pass code duplication perform selective instruction duplication protect inherently cover duplication pass minimize waste effort protect likely impact program output duplicate along graph safe performance overhead dramatically reduce without significantly impact reliability follow section describe detail use analysis duplication pass b c figure five example data flow graph illustrate shoestring vulnerability analysis data flow edge number represent distance two statically schedule code shade nod represent dash circle highlight dash edge represent control flow safe state previously safe instruction one enough fault corrupt result likely exercise symptom within fix latency slat instruction number first tabulate base distance give producer consumer pair define distance c number intervene within statically schedule code use estimate symptom detection latency consumer trigger symptom give instruction number distance ni consider safe ni greater fix threshold st value threshold parameter st control selectivity safe instruction classification use trade coverage performance overhead see section five slat figure five correspond case study illustrate vulnerability analysis heuristic apply sample number along edge represent distance c two nod shade nod indicate nod highlight dash circle case study slat st two case study one direct figure instruction analyze safeness one two three direct two three already identify three also instruction example would vulnerable one consumer within distance slat instruction two case study two indirect figure present interest example include direct well indirect analyze direct indirect identify also contribute however reduce scale factor account potential partial fault mask figure three four five symptom generate since three direct consumer fault corrupt result instruction three generate symptom course however fault would propagate instruction two reach indirect consumer instruction four allow possibility fault may mask two actually reach four example soft error flip upper bite result instruction two mask upper fault would never visible instruction four reduce ability manifest symptom however instruction one would still consume taint value potentially write memory corrupt system state therefore due potential mask indirect consumer less likely direct consumer cover exact fault ultimately respect figure give eight one eight since ni greater threshold st two safe case study three minimize analysis overhead figure present complete example illustrate use avoid redundant computation rather identify indirect every instruction maintain global table ni value every instruction traverse fashion guarantee instruction process instruction encounter create entry table label table figure every instruction analyze ensure node need visit three although optimization beneficial program large function even naive recursive analysis evaluate work appreciably increase compilation time example assume vulnerability analysis begin shoestring analyze follow order four seven six eight five one two eventually mark safe analysis pass reach instruction three determine classification directly without identify indirect since table entry instruction five already populate analysis pass correspond table entry three compute scale ni five adjust correspond distance add two finally account potential instruction five table entry instruction three would contain one eight instruction three would subsequently also safe obviously traversal complicate presence loop present figure circular exist traversal could loop indefinitely never reach leaf node consequently whenever shoestring encounter loop force traversal backtrack distance instruction currently process instruction bottom loop exceed slat guarantee relevant account also ensure forward progress case study four control flow examine far limit analyze instruction control large extent ignore although shoestring take relax approach respect enforce correct control flow branch take consideration perform vulnerability analysis figure show example instruction analyze id basic block highly bias branch scenario although instruction five consumer basic block unlikely execute provide dependable coverage id therefore contribution every consumer ni scale respective execution execution extract profile execution provide experiment section five profile data unavailable generate static lastly although wang al show execution wrong direction many branch ultimately correct execution path figure branch terminate corrupt cause execution proceed instead time control reconverge instruction four potentially corrupt system state therefore shoestring also selectively protect duplicate input operand chain branch edge instruction sake brevity standard algorithm identify edge present important note branch influence whether instruction four execute protect branch effectively nearest instruction four possess requisite edge protect leave rest away likely reconverge vulnerable code duplication process insert redundant code single thread execution well study past nineteen general process involve duplicate computation along path replication insert comparison synchronization point memory control flow determine fault manifest since last comparison perform section highlight shoestring code duplication pass depart exist practice reader encourage examine prior work detail description mechanics code duplication b figure six example data flow graph illustrate shoestring code duplication pass nod label represent safe dash circle highlight shade portion graph represent code duplication chain b show new duplicate insert shade nod nod label represent checker code duplication pass begin select single instruction set proceed duplicate produce value duplication terminate one exist two safe instruction encounter three producer already previously duplicate case guarantee every vulnerable could possibly influence data consume duplicate comparison insert right verify computation input figure present section three nod six seven eight three safe nod label five vulnerable nod fifteen example start instruction six begin duplicate producer instruction three next attempt duplicate three notice one safe terminate code duplication path producer three instruction two however vulnerable duplicate two continue along producer chain duplicate instruction one well subsequent attempt duplicate one encounter safe point vulnerable code relevant instruction six duplicate shoestring move next instruction repeat process instruction seven point instruction three already duplicate result protect instruction six nothing need do next instruction eight consider result duplication instruction four figure show new duplicate shade nod checker nod insert note six seven checker compare result instruction three redundant copy three although six seven consume value rely single checker instruction six detect fault corrupt three result could leave seven vulnerable fault corrupt result three six already execute depend far apart six seven execute vulnerability window could nevertheless common also execute close proximity need duplicate checker also avoid however optimization investigate work four experimental methodology give paper target coverage fault induce soft commodity would ideally conduct electron beam experiment use real hardware run code instrument shoestring give limit popular alternative beam experiment statistical fault injection detail register transfer language processor model however since shoestring exploit fault mask application level full program simulation also require since simulate realistic model extremely slow common practice literature rely provide appropriate compromise simulation fidelity speed fault model injection framework fault injection result present paper generate use simulator able run native host machine well within detail simulator able effectively switch native hardware execution simulation enable fast highly detail simulate modern high performance processor model run detail processor configuration find table one fault model assume single bite flip within physical register file although explicitly model fault portion processor eventually manifest corrupt state register file make attractive target injection furthermore wang al show bulk dominate introduce register file nevertheless methodology may fully capture ability shoestring handle fault combinational logic large experimental result show paper produce monte start monte trial random physical register bite select injection show memory footprint significantly smaller full size virtual address space four perform fault register file limitation evaluation infrastructure limitation shoestring fault coverage reality shoestring detect soft strike part process core well table one processor detail configure model processor core fetch queue size reorder buffer size issue queue size issue width commit width queue size physical register file size physical register file size sixteen sixteen three cache cache unify main memory memory three cycle lat ten cycle latency cycle lat allow fault occur register would increase likelihood result symptomatic exception consequently cover shoestring therefore although simulate register file limit fault lower avoid artificially inflate shoestring coverage result injection site determine program simulation allow run native mode run real hardware reach representative code segment identify use manual source code inspection point switch detail mode warm simulator randomly select number cycle elapse fault induce predetermine injection site detail simulation continue commit time copy architectural state back host machine resume simulate remainder program native mode course assume fault result fatal exception program crash prior end every simulation log file analyze determine outcome monte run describe next section outcome classification result monte trial one four one mask inject fault naturally mask system stack include fault architecturally mask well mask application level two cover inject fault result anomalous program behavior symptomatic transient fault assume system able trigger recovery lightweight detail assume mechanism describe next section three cover duplication fault category result inject code selectively duplicate shoestring comparison end every duplication chain would trigger function call initiate recovery four fail work definition failure limit simulation run complete prematurely terminate data although definition failure use paper may seem unconventional consistent recent work appropriate context evaluate shoestring main premise behind shoestring philosophy cost ensure reliable computation reduce focus cover fault ultimately noticeable end user therefore figure merit number fault propagate architectural state rather fraction actually result system support briefly discuss previous section shoestring scheme general rely ability rollback processor state clean result present section five assume mechanism recover state past already require aggressive performance speculation consistent wang patel shoestring assume fault manifest symptom within window commit safely detect recover proper selection slat parameter describe section closely tie size window expect generate symptom within window consider identify safe similarly fault detect instruction duplication would also trigger rollback recovery result present section five assume interval consequently slat value although small window may seem modest comparison assume work notably li al eleven appropriate give shoestring provide minimally invasive low cost protection increase size window would unfairly inflate coverage provide shoestring since accommodate large require substantial overhead however large eventually find way use shoestring easily tune exploit additional support provide even greater coverage compilation component shoestring implement compiler ten code generation pass describe section integrate part code generation six integer suite crafty gap vortex use representative experiment compile standard minimize initial engineer effort evaluate suite one compile standard without shoestring two simulate correctly exhibit desirable behavior similarly minimize engineer effort apply shoestring library call common practice literature assume dynamically link library call protect mean ie outside see section three result present section five adhere practice avoid library call lastly due evaluation framework study shoestring context give treat cache outside majority challenge pose share memory would impact efficacy shoestring however memory multithreaded could potentially attenuate coverage due reduction performance memory access greater utilization simultaneous multithreaded could also reduce amount mask see fault coverage b latency distribution detection figure seven result preliminary fault injection experiment show percentage fault intrinsically mask mask cover symptom cover result corruption fault strike register lastly identify exact core trigger symptom well orchestrate rollback recovery challenge multiple thread run different core interact share data however challenge beyond scope current paper leave interest future work five evaluation analysis section begin result initial fault injection campaign quantify amount opportunity available shoestring exploit proceed examine compilation describe section three finally present analyze fault coverage shoestring experimental result include section derive monte preliminary fault injection figure seven present result initial fault injection purpose preliminary experiment identify amount fault inherently mask throughout entire system stack accumulation source mask application layer essentially amount coverage available free show mask segment stack bar correspond roughly average across account another actual account remain mention section three coverage useful trigger within small window cycle figure eight percentage static figure nine percentage static safe st vary slat follow fault symptom latency exceed slat likelihood state corruption occur symptom manifest increase note portion chart label segment fraction lead instruction slat window expire without expensive accommodate longer case must also consider figure examine different perspective distribution base detection latency although majority manifest within instruction threshold roughly would require much aggressive scheme need performance speculation alone furthermore remain could exploit without accompany heavyweight attendant cost remainder paper assess shoestring ability minimize integrate coverage intelligent code duplication program analysis gain insight selective instruction duplication actually apply shoestring examine describe section three context figure eight show percentage identify within discuss section potentially modify global memory produce value function call consider average roughly static meet criteria become focus shoestring code duplication safe figure nine present percentage safe function heuristic parameter st section value n st indicate instruction consider safe ie cover must possess least n within distance slat along potential path execution note average even st relax allow nonzero threshold zero static safe mainly due conservative decision consider potential aggressive heuristic could potentially identify safe set monitor inclusive however would come cost false subsequent experiment value slat fix explain section value figure ten percentage static code duplication perform shoestring st vary id nine section also determine produce best heuristic behavior fix experiment duplicate figure ten show percentage static duplicate shoestring st sweep zero note direct relationship st number duplicate attributable fact code duplication begin terminate first safe instruction encounter see section therefore safe less likely duplication chain terminate early extreme case st safe result fully duplicate producer chain every instruction fault coverage next examine overhead protect shoestring selective code duplication figure show st vary zero performance overhead shoestring range obtain native simulation core two processor execution full duplication scheme swift also include sake bar label full since shoestring position reliability cheap solution maintain low overhead paramount importance evaluate amount coverage obtain shoestring five cite swift conservative consider target wide machine would incur substantially overhead give less processor performance overhead six relate work contribute shoestring total fault coverage note average selective duplication cover additional unmask fault would slip base scheme notice also segment label category result place source code actually detect erroneous behavior program follow fault injection observation suggest perhaps modest investment require enhance conventional assertion check information could improve shoestring program analysis section examine shoestring context previous work table two present quick overview shoestring sit within soft error solution space ability achieve high level fault coverage low performance overhead without specialize hardware set apart previously propose scheme category alternative address detail redundancy spatial temporal redundant execution long cornerstone detect soft hardware redundancy redundancy choice however cost relegate server nonstop series three two machine diva one less expensive alternative full hardware duplication utilize small checker core monitor perform rather employ full hardware replication recent work also interest use smaller lightweight hardware structure target individual processor fifteen rely series hardware checker perform invariant check ensure correct application execution reddy propose simple checker verify functionality decode fetch compare dynamically generate small trace identical extend idea introduce additional checker structure although area overhead like diva significantly lower full still remain expensive choice commodity nevertheless partial provide greater fault coverage shoestring provide bound detection latency redundant introduction simultaneous modern give another tool redundant execution paper first introduce concept core basic idea use processor extra run two copy thread lead thread trail thread lead thread place result buffer trail thread verify result commit execute subsequent work improve upon scheme optimize amount duplicate computation introduce redundant thread seven also attempt level cheng al eliminate need architectural support rely compiler generate redundant thread run chip multicore evolve use two discrete core within mimic behavior reunion reliability forty two recent allow idle core within leverage redundant thread execution chief attraction approach high b fault coverage figure eleven fault coverage performance shoestring function st figure twelve detail coverage breakdown shoestring configure st fix zero least amount performance overhead remainder section value st fix zero figure present coverage result shoestring configuration also include coverage number instruction duplication duplication st illustrate propose solution sit respect upper lower bound coverage number value st include requisite simulation effort although investigate sophisticate instruction classification vulnerability analysis potential garner even coverage note shoestring already able recover would otherwise go unmask cause data lastly figure twelve take closer look fault coverage achieve shoestring stack bar highlight individual solution redundancy redundant instruction duplication detection register file protection shoestring yes yes yes table two shoestring compare exist soft hardware support support overhead area overhead high maybe yes yes low high high low low low coverage high high high high none none none moderate moderate moderate high provide include throughput degradation loss context entire core hardware potentially double power consumption execution instruction duplication redundant execution also achieve without create independent thread show reis al propose swift fully compiler base approach fault tolerance swift exploit wide schedule original duplicate execution thread validation code sequence also insert compiler compare result original correspond duplicate craft profit improve upon swift solution leverage additional hardware structure architectural vulnerability factor analysis eighteen respectively case instruction duplication also deliver nearly complete fault coverage add benefit require little hardware cost however order achieve degree fault coverage like swift double number dynamic program incur performance power detection mention previous section wang al first exploit anomalous behavior detect presence fault lightweight approach detect soft restore leverage include memory branch cache miss concept anomaly detection explore al twenty propose verify data value range data bite lastly li al eleven extend fault coverage apply detect diagnose permanent hardware fault strength detection lie ease application unfortunately achievable fault coverage limit appropriate high register file protection scheme register file hold portion program state consequently execution program accomplish without protect fault main memory augment register file content also protect apply process optimize protect live program usually occupy fraction register file like one present al sixteen build upon insight maintain register likely contain live value similarly al four propose register value cache hold duplicate live register value important note scheme general detect fault occur valid data write back register file contrast shoestring also detect fault part corrupt instruction output write back register file correction cod properly generate seven conclusion technology scale continue exacerbate challenge pose transient fault research community remain focus reliability must devote also develop new innovative commodity paper introduce shoestring transparent reliability solution leverage detection well selective instruction duplication minimize induce soft total performance penalty shoestring cover additional fault undetected conventional scheme allow sixteen fault manifest data corruption shoestring mean provide acceptable soft error resilience cost average commodity system afford eight thank anonymous referee valuable comment also owe thank amir mark feedback initial work well emery berger shepherd research support national science foundation grant arm limit reference one diva reliable substrate deep submicron design annual international symposium page two w l commercial fault tolerance tale two dependable secure compute one one three b p r j international j nonstop advance architecture conference dependable network page june four j soft error protection embed international conference architecture synthesis embed page five design reliable unreliable challenge transistor variability degradation micro six six f bower j mechanism diagnosis hard fault annual international symposium page seven opportunistic detection annual international symposium computer architecture page june eight c n recovery chip annual international symposium computer architecture page nine j kim n k b j c hoe error tolerant cache use error cod annual international symposium ten c v compilation framework lifelong program analysis transformation international symposium code generation optimization page eleven li p k v v understand propagation hard international resilient system design conference architectural support program operate page twelve x li correctness impact fault tolerance international symposium computer architecture page thirteen may soft dynamic electron one fourteen quantitative information flow network flow capacity eight conference program language design implementation page june fifteen comprehensive error detection simple core micro one sixteen p w j use register lifetime protect register file soft international conference dependable network page seventeen k detail design evaluation redundant annual international symposium computer architecture page eighteen c weaver j systematic methodology compute architectural vulnerability factor high performance international symposium page nineteen n oh mitra e j error detection diverse data duplicate two twenty p k fault screen international symposium computer architecture page v reddy e understand partial redundant thread fault tolerance international conference architectural support program operate page v reddy e inherent time redundancy use program repetition fault tolerance international conference dependable network page june v reddy e coverage fault check regimen processor international conference dependable network page june k transient fault detection via annual international symposium computer architecture page june g reis j chang n r august swift implement fault international symposium code generation optimization page tolerance g reis j chang n r august fault tolerance architecture code optimization two four e approach fault tolerance international symposium fault tolerant compute page e g b automatically tenth international characterize large scale program behavior conference architectural support program operate page new york p l model effect technology trend soft error rate international conference binational logic dependable network page june thirty j j kim j hoe b efficient resource share concurrent error detect annual international symposium page j c b gold b j c hoe reunion multicore redundancy annual international symposium page l parallel enterprise server fault tolerance historical perspective journal research development six n j bridge j chang r g j g august rifle architectural framework security annual international symposium page c wang h kim v redundant transient fault detection international symposium code generation optimization n wang patel restore symptom base soft error detection international conference dependable network page june n j wang j patel come fork road take international conference parallel compilation page n j wang j patel restore soft error detection dependable secure compute three three june n j wang j j patel characterize effect transient fault processor pipeline international conference dependable network page june c weaver fault tolerant approach design international conference dependable network page computer society forty p well k g multicore reliability international conference architectural support program operate page cycle accurate full system simulator symposium performance analysis page j f h trend challenge guide design memory cypress semiconductor corp