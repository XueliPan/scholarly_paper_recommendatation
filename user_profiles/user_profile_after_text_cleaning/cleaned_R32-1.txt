exploratory study evolve program liana one computer department university sao sao brazil two department pontifical catholic university rio de rio de brazil three compute department university unite kingdom four department science technology federal university sao brazil five school science technology federal university rio natal brazil six computer science department federal university rio natal brazil seven department compute university brazil eight federal university brazil abstract paper present result exploratory study program analyse fault collect three evolve different application analysis develop two different angle firstly measure impact obliviousness property evaluate result show forty report fault due lack awareness among base code second analysis regard main program namely result indicate present similar consider overall system find reinforce mean statistical test general result contradict common intuition state use main source fault subject engineer test program diagnostics code language construct feature general term measurement experimentation verification program test one introduction development become increasingly incremental aware contemporary implementation permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten may cape town south copyright presence change particular recent adoption program spring require better understand fault cause program technique aim improve robust implementation concern cut across multiple classical crosscut concern usually implement log exception handle concurrency certain design pattern crosscut concern achieve complementary set program advice declaration would addition basic property associate obliviousness property imply core functionality need aware anticipate design code advise fifteen obliviousness also influence quantification ie ability declaratively select set point via execution program expressive language support obliviousness provide new model language constantly emerge case leverage different obliviousness seventeen twenty optimistic benefit show one two example previous research indicate use certain violate module encapsulation one even introduce new type fault two particular claim fault likely amplify presence evolutionary change however empirical knowledge actual impact remain limit even core program concern issue present first exploratory analysis analysis develop term three follow question one obliviousness influence presence fault program two impact specific three whether certain concern correlate introduction fault best knowledge first initiative systematically tackle question base exploratory analysis previous research mainly focus define fault test approach base main current two three four ten twelve however find limit empirical evidence fault occur practice achieve select three different application analyse mean various test static analysis throughout study fault report two mean one system development evolution afterwards two independent report fault main find study obliviousness controversial property since early research analysis confirm lack awareness base aspectual tend lead incorrect despite modern support provide ides uncertainty module still remain presence within system interestingly find contradict common intuition state use main source fault ten twelve main currently available namely present similar overall system consider number internal show good fault consider set within implementation separately case number fault associate concern directly proportional number use implement concern addition gather result study support find statistical significance remainder paper follow section two relate research section three describe study configuration include research hypotheses description target evaluation follow section four bring collect data data analyse discuss section five section six discuss work finally section seven present conclusion future research two relate work difficulty perform evaluation mainly twofold yet several release document fault project available analyse introduce new obliviousness quantification wide range often use implement different crosscut concern previous research limit evaluate benefit different angle design stability thirteen sixteen system robustness five nine fourteen however program yet phenomenon date limit empirical knowledge impact correctness spite present piece one hereafter use term concern refer crosscut concern general define al work believe mostly relate basically distribute two discuss follow fault program number fault bug pattern program find recent literature two four nine twelve al two propose first study fault main contribution possible source fault specific program base source al also define fault taxonomy mainly focus feature fault build top four either include new fault type refine already exist however none evaluate date al twelve fault study present paper use fault find target far identify single attempt evaluate program coelho al nine present exploratory study robustness study analyse flow five different whose code result show increase number uncaught ie cross system without handle also number unexpected handler action differently work coelho al focus analysis exception handle focus general crosscut concern al eleven perform empirical study provide evidence suggest crosscut concern defect author examine concern three project find scatter implementation concern likely defect find recommend use crosscut concern order reduce number fault potentially cause however al investigate study study also analyse crosscut concern although different angle aim evaluate impact specific concern system also highlight contrast order find approach result less fault relate crosscut concern three study set section describe study configuration section present hypotheses section provide overview target section explain evaluation apply select system associate tool support goal statement research hypotheses objective evaluate apply evolve program particularly interest observe underlie reason introduction fault first analyse whether key property obliviousness facilitate emergence fault evolution condition moreover aim analyse specific concern impact program example investigate internal implementation detail concern line code use specific correlate presence fault base define two research hypotheses null alternative hypotheses follow grain change functionality table one show general three target information reader may refer respective previous report thirteen sixteen hypothesis one table one key target obliviousness exert impact fault proneness evolve program obliviousness exert impact evolve program hypothesis two difference among among main main achieve need apply number evaluation analysis embrace twelve release three different application include wide range heterogeneous concern implement evaluation follow describe target three use study significantly different application first one call open source framework data map originally develop release available sixty second sixteen typical information system first release allow register health issue third evaluate system product line mobile call thirteen originally develop allow manipulate image file different mobile evolve support manipulation additional media file file application every release give system counterpart particular release derive build available use implementation alignment hand evolve base sequence plan change give release develop concurrently thirteen sixteen release experience exhaustive assessment code revision test section independent order achieve well align original system hereafter refer target simple name ie four release consider evaluation namely one thirteen fifteen two also analyse four release one four seven ten four release one two three six release choose encompass wide range different coarse two three four reference make explicit throughout text five release correspond original build find respectively application type code availability release select release data mapper framework health watcher health product line application mobile data sixty four ten ten ten ten four eleven four six four three ten interference analysis evaluation procedure test test select main subject illustrative paper order promote coherence complex target system derive data set number fault mostly draw analyse however also refer order highlight recur across three highest number fault expect implementation two yield less data mature originally release four undergo corrective perfective change also target number previous study focus quality attribute nine thirteen fourteen sixteen therefore different stability result originate provide support draw general find evaluation follow different approach evaluate target system evaluation define accord system information available moment study start short aim identify many fault possible give time resource systematically avoid bias evaluate three evaluation evaluation strategy system experience two test phase prerelease test prerelease test aim produce code commit repository test set provide original use phase abnormal behaviour regressively test version give release investigate fault uncover document appropriate detail report section test hand aim assess implementation enhancement original test set enhance test execute give release fault report notice version counterpart procedure ensure process would report analysis introduce fault tool support test case design execution use extension enable six seven thread test measure test coverage use tool allow fast code instrumentation test execution evaluation evaluation strategy test single phase study initial test already perform development time initial test involve people unaware would perform hence test system extend study cover assessment phase thereby improve degree test coverage differently however original test set make available thus full test set build scratch base system specification code documentation order reduce test effort avoid systematic bias test creation test case automatically generate adequate tool support well fault report notice version counterpart uncover fault similarly report tool support use eclipse automatic test case generation program also use lightweight framework test extend provide necessary test implement within system finally use measure test coverage evaluation evaluation strategy well develop awareness evaluation moreover test system evolution maintenance reveal fault relate robustness data input validation however necessarily relate despite evaluate use composition integrity framework six help us identify aspect establish either base code among multiple since product line include mandatory optional alternative feature apply vary able derive set fault result broad range tool support use framework perform static analysis join point shadow able report join point shadow involve specific composition report aspect govern explicit dependency via use declare precedence statement fault report every fault identify either development assessment phase static analysis document report form assessment static analysis phase provide information much possible special attention test case reveal fault applicable fault symptom addition tester provide hint fault location report forward original fault documentation charge conclude eight nine ten fault classification fault documentation step fault accord fault taxonomy propose previous research twelve taxonomy include four fault comprise core one two structure three four base program order systematically every fault take account fault origin classification base first three straightforward instance relatively trivial identify mismatch misuse structure wrong advice type however base fault require extend analysis reason example base code change result break base although might unmatched join point code section five analyse impact fault category overall fault distribution consider target four data collection section present result obtain target system section describe result test execution release number aspect interaction identify section present fault distribution per fault category fault distribution per concern test execution result figure one show test execution result side side original test set comprise test case release respectively final improve test set include test case one thirteen fifteen test release two give release new test case either mine successive release repository design scratch accord figure one number successful test case increase across release might mean code enhancement however discuss next section necessarily mean reduction number fault test set entirely design study support additionally test manually implement base functional total test generate release one four seven ten respectively observe figure one number test fail plus test raise label error legend increase across release suggest number fault increase system evolution however see section necessarily mean number fault successive release figure two present coverage achieve release particular figure show coverage obtain original enhance test set spite test set significantly yield coverage lower due redundant test exercise common part code nevertheless focus creation test exercise part code affect aspectual behaviour follow strategy able uncover fault yet reveal previous system pass fail error twelve nine nine nine eight seven fourteen nine e c e f eight fifteen one thirteen fifteen two atis release one four seven ten h w release figure one test case execution leave right release original test set improve test set generate test set e g r e v c f ninety eighty seventy sixty fifty forty thirty twenty ten zero eighteen nineteen sixteen seventeen ninety eighty seventy sixty fifty forty thirty twenty ten zero one thirteen fifteen two release one four seven ten release figure two test coverage leave right release describe section system evaluate static analysis use framework six activity yield list potential fault relate aspect regard share common join point list include sixteen potential fault vary four evaluate release analysis enable us identify real fault result present next section fault distribution section fault identify along study fault group per category section per concern section fault accordance fault taxonomy program twelve fault distribution per fault category table two three respectively present number report fault report fault group per category lower number fault uncover explain size smaller experience evaluation total fault fault average per release consider document analyse report fault drive discussion present section five table two fault distribution per category fault category relate total release fifteen one one one ten thirteen thirteen two two four one nine one ten five six two two five six four total average eighteen fourteen fifteen ninety table three fault distribution per category fault category relate total eighteen fourteen fifteen one four four zero nine zero six four two twelve total nineteen fault distribution per concern table five present fault distribution per concern analyse distribution consider data set contain amount fault moreover system fault appear distribute concern data set collect two hand limit consider section concern list table five briefly describe table four notice concern release fifteen two section discuss certain implementation concern require may impact specific concern concern concurrency type map design pattern error context exception handle connection session transaction table four concern implement description ensure multiple request could execute within framework consistent manner deal map data different format data retrieve store application check see data content null proceed transaction subset design pattern singleton observer adapter strategy object store data execute data use sometimes print event trace event exception deal erroneous execution flow include finally detect three separate concern regard allow access control transaction query release fifteen two table five fault distribution per concern concern release total average concurrency type map design pattern error context eh exception handle connection session transaction total one zero two two thirteen six zero thirteen zero zero zero five four zero nine fifteen zero zero zero one two seven three zero zero thirteen two one one zero two sixteen ten three three two one three two seventeen six three two five seven three fifteen five five data analysis discussion section perform exploratory statistical analyse measure present section four aim identify faulty section evaluate hypothesis ie obliviousness property impact correctness program presence code evolution section evaluate hypothesis order identify specific evaluate two point view consider overall system implementation specific concern analyse support statistical test yield tend statistical test perform along section use language use test check whether statistically significant difference fault count assume commonly use confidence level threshold five spearman rank correlation test use check fault count correlate mechanism count test use analysis use metrics ie number fault evaluate result correlation test adopt criteria judge goodness correlation coefficient one mean trivial mean minor mean moderate mean large mean large mean almost perfect impact obliviousness obliviousness play central role little empirical knowledge property actually affect usual development analyse impact two obliviousness evolution obliviousness list al result follow present obliviousness evolution consider fault distribution per fault category table two three total number fault relate base code least twice large number fault within three fault cause either perfective evolutionary change within base code lead break represent number amongst fault type report system turn correspond total number fault problem usually refer fragile problem closely relate quantification obliviousness eleven model implement change program require review crosscut ie conflict idea program oblivious apply eighteen find problem magnify realistic development one observe several work parallel project evolve different crosscut concern mean obliviousness present base code aspect oblivious well example aspect advise set join point might aware insert behaviour join point hence rise risk either mismatch event code change partial aid currently provide ides increase awareness aspect effect base code however uncertainty indirectly interfere base code still remain notice problem occur mainly system fault report development assessment phase section evolve functionality necessarily require fix fault identify exist base aspect code hand stable extensively evaluate previous research nine thirteen fourteen sixteen example since first release number incremental perfective change take place sixteen result base crosscut code stable code due proportionally fault category likely due robustness code nonetheless none three evaluate term present paper analyse system use framework six result reinforce find majority fault source code aspect occur example case four nine fault cause due miss declare precedence fault result arbitrary execution order share join point obliviousness clearly main reason introduction fault case successively introduce along development cycle consider scenario naturally enforce make explicit design decision order respective piece behaviour within method obliviousness document fault accord four obliviousness list al summary present table six goal gather evidence impact obliviousness correctness evaluate obliviousness represent different type information hide focus two type obliviousness relevant purpose analysis briefly describe follow obliviousness present local notation code aspect behaviour may insert point feature obliviousness present base code developer unaware feature semantics aspect advise base code even though impossible entirely sure true cause fault follow set decide collect fault likely cause feature obliviousness short behaviour insert join point via advice claim obliviousness seventy present explicit call notation extra behaviour within base code fault cause obliviousness fault likely avoid case explicit local notation present let us consider base code developer follow specific design rule expose certain join point create hook aspect developer without full knowledge implementation detail aspect case obliviousness present feature obliviousness fault relate feature obliviousness order fault avoid attention would need give aspect semantics table six fault associate obliviousness obliviousness category language feature language feature total zero eight four three four four zero four eight zero four zero three zero three three eight system total result show fault relate obliviousness represent around seventy base fault ie see total column table three regard fault relate feature obliviousness mostly find case either directly interact within module share common join point indicate evolve code oblivious vary impact system problem mainly observe fault report evolution release hand experience test nevertheless eleven fault reveal assign obliviousness either feature see total column table six conclude analyse impact obliviousness evaluate provide us evidence support alternative hypothesis obliviousness exert impact evolve program study large amount fault forty could directly associate base code oblivious majority observe evolution many fault observe also relate oblivious miss declare precedence responsible fault find consider fault table three eleven feature although much proportion relate ie result interest might reinforce motivation model base explicit seventeen twenty often assumption use main source fault program ten twelve however limit understand real magnitude fault respect analysis second hypothesis draw term fault present section four null hypothesis state significant difference amongst core analyse overall fault distribution initially analyse value present table two examination data indicate similarity among total number fault find consider first three advice result suggest present similar none stand respect number fault analyse observation statistically first apply test test check probability sample data come population specific distribution reach probability higher say five assert confidence level reason reject hypothesis observe data fit give distribution case confidence level result confirm uniformity fault among fault category evaluate significantly higher five easy see since fault count eighteen fourteen fifteen close fit model category expect approximately number fault case apply test overall fault set consider target ie total fault present table three assume confidence level result corroborate previous find ie fault uniformly distribute three main evaluate significantly higher five also contradict conventional wisdom first evidence support null hypothesis main difference among interest result many strictly focus improve design provide support expressive five eighteen twenty less attention give support robust program classical next section present refine analysis bring additional evidence different point view analyse fault distribution per concern analysis fault distribution per fault category take account overall number fault per category section provide refine analysis consider certain internal detail implementation concern perform correlation analysis gather empirical evidence relationship number defect motivate fact may individual impact module cluster implement give concern full system analysis consider set fault identify since include distribute concern table four moreover also consider base fault order measure impact system whole initially apply spearman rank correlation check overall number per release table seven correlate number fault release result present table eight correlation low consider thus contradict result regard fault distribution per fault category section generally table seven number fault release fault one thirteen fifteen two nine thirteen however perform analysis base internal take account due nature concern usually require use together example exception handler usually require three cod structure expression declare soft statement advice word investigate whether number include implement purpose concern impact number fault present table eight correlation number fault number release metric coefficient zero zero hence check number use implement concern correlate fault distribution per concern measure maximum average number mechanism per concern across release note give concern consider class involve implementation apply spearman rank correlation total average number fault per concern across release compare number maximum average number per concern across release analysis observe whether usage frequency mechanism seem impact fault distribution per concern use maximum average number across release might repeat release release implement exception handle aspect one release may present aspect another release also choose two metrics typically apply program order compare result obtain analysis metrics line code weight per module seven adapt original weight per class metric eight count inside class well aspect ie metrics report good study comprise program nineteen thirty consider maximum average value across release cluster require implementation concern table nine show statistics metrics adopt confidence level table ten eleven present result spearman correlation rank run maximum average number across release total average number fault per concern across release value result comprise metrics also present table note correlation coefficient large take account maximum average number fact observe correlation maximum number advice average number fault per concern significant observe level confidence table ten correlation coefficient vary five six mean correlation average consider confidence level table ten correlation average number fault per metric coefficient correlation significant one level correlation significant five level differently result previous study comprise program nineteen thirty metrics show nonsignificant correlation average maximum number fault study result indicate consider set crosscut concern internal number ie good moreover seem better traditional metrics involve perform analysis present section notice define set must use conjunction implement concern give specific concern implementation usage rate mechanism tend directly proportional table nine number fault per concern concurrency type map design pattern error context exception handle connection session transaction seven two nine twenty two six twenty five two five twenty two ten fault total one three two seventeen six three five seven three fifteen three three fourteen one three five number fault associate concern support correlation test result find support null hypothesis overall fault distribution per main mechanism show uniform addition usage rate mechanism vary independently depend set concern within system table eleven correlation total number fault per concern metric coefficient correlation significant five level six study section discuss study base four validity describe al category include set possible empirical study identify within category might threat study discuss follow category list possible measure take reduce risk conclusion validity identify two case reliability measure subjective make fault classification step specially regard obliviousness level section besides one target evaluate test case section might risk reliability test result random heterogeneity subject evaluate come different application reduce risk design detail fault report form define set follow order systematically fault section regard evaluation base test technique previously yield relevant result see major issue regard risk although heterogeneity consider threat conclusion validity help promote external validity study internal validity detect two possible risk ambiguity direction causal influence complexity concern might make system release faulty history maturation extensively evaluate continuously improve last reduce number uncover fault risk completely avoid functionality differ complexity however reduce develop revise experience use implementation guide design pattern specific applicable moreover systematic regression test help preserve semantics order reduce risk focus analyse consist recent target yield data set analyse construct validity identify follow construct validity inadequate operational explanation construct unclear follow event fault uncover might bias result fault fix fault confound construct level construct different maturity level investigate impact number uncover fault interaction test treatment aware system evaluation reduce risk define clear apply throughout study step particular development strongly base regression test order make code available repository although approach make aware system evaluation enable collect data since early development phase risk hand could avoid due currently available evaluation present different level maturity include vary fault rat important since external validity major risk relate interaction set treatment evaluate might representative industrial practice reduce risk evaluate come heterogeneous application implement one state practice system open source project map even though smaller also heavily base addition extensively use evaluate previous research nine thirteen fourteen sixteen conclude select contrast state practice development represent first step towards achieve result seven paper present exploratory study use implementation evolve program analyse three different application collect data upon perform analyse result reveal negative impact obliviousness program implement hypothesis recent help ameliorate problem approach crosscut program seventeen explicit join point twenty although reduce obliviousness among system approach help improve program comprehension make interaction explicit particular tend reduce obliviousness happen category number fault study far hypothesis concern confirm common intuition define scenario mechanism stand main responsible detect fault also argue correlational study provide good lead probe control experiment nevertheless recent research fault test approach mainly focus key bottleneck three four ten twelve however result obtain hypothesis motivate intensive research test support beyond advice investigate issue provide believe study helpful several ways information harmful support test process pinpoint recur faulty enhance general understand towards robust control experiment derive future research eight would like thank also thank valuable help analyse system framework author receive full partial fund follow project grant cap grant grant distinguish scientist grant productivity grant universal project grant productivity grant burrow grant grant soar grant grant grant author cap brazil nine reference one j open reconcile extensibility information hide splat four workshop two r al towards systematic test program report colorado state university fort three p generation test program eight four j r candidate fault model six five n f c e tame exceptional control flow program eight six g blair l framework manage integrity composition tool nine seven p measure effect workshop aspect reverse engineer eight metrics suite design engineer twenty six nine coelho r al assess impact exception flow exploratory study eight vol ten r b approach develop nine eleven al crosscut concern defect engineer four twelve f j mutation test program eight thirteen e al evolve product line empirical study design stability eight fourteen f c al devil detail six fifteen r e program quantification obliviousness development sixteen greenwood p al impact aspectual design stability empirical study seven seventeen w g al modular design crosscut one eighteen k j arrange language feature robust crosscut three nineteen r siket empirical validation metrics open source fault prediction engineer ten twenty k p bridge explicit join point seven w g new view statistics sport science data mapper r al spring application framework ref manual version c case study implement feature use seven g al program vol g program modular reason five soar e p implement distribution persistence two f paradoxical success aspect orient program six j use delta analysis support evolution five thirty r empirical analysis metrics design complexity defect engineer four k al information hide design five project c al experimentation engineer introduction academic j framework tool support generate test input program six easy language extension six j identify bug pattern program seven c check n crash combine static check test five harman al test data generation program nine