use improve performance compute intensive n computer science federal de brazil state university recently evolve fast parallel capable execute general purpose extremely efficiently time multicore evolution continue today core two trend however follow independent sense aware work consider solve general paper investigate use improve efficiency even use either device independently use anthill environment orient framework decompose set filter event system use either process evaluation use histopathology application use image analysis tumor image neuroblastoma prognosis experimental environment include dual machine augment evaluate approach performance distribute experiment show pure optimization application achieve factor fifteen time improvement single core version depend also show execution reduce factor two use system effectively choreograph execution run single core improve add core previously neglect use ineffectively addition evaluation distribute environment show near linear multiple host work partially support neuroblastoma cancer foundation young investigator award doe grant grant introduction histopathological examination important step diagnosis evaluate prognosis cancer diagnosis however visual examination perform microscope tedious subject considerable inter one use image analysis possible extract quantitative provide precise description tumor morphology therefore may lead accurate consistent clinical develop prognosis analysis digitize neuroblastoma tissue sample two neuroblastoma cancer nervous system mainly affect current gold standard prognosis visual evaluation biopsy sample identify certain morphological degree stromal development grade differentiation mitosis karyorrhexis index microscopic tumor tissue three result digitize image quite large size require efficient computational tool handle image analysis pipeline discuss later idea analyze image whenever necessary perform analyse portion image cost analysis single image couple progressive refinement type make application computational intensive computational cost neuroblastoma image analysis application motivate parallelization effort deal challenge large volume data may fit available machine irregularity application since number refine image thus associate cost data dependent witness growth heterogeneous term computational power parallelize efficient use type process still challenge mainly irregular challenge case lie gather best process unit since core support thread require additional data communication expect large number concurrent thread require explicit communication standard machine memory better suit despite difficulty schedule decision similar require decision take instantaneously consider current load process unit task process schedule moment paper focus scalable efficient parallelization system two relevant realistic application also interest case study term better exploit heterogeneous present paper parallelization application anthill program model detail section heterogeneous platform comprise design evaluation task schedule allow adaptive exploitation computational available heterogeneous performance order achieve use well schedule propose top pure remainder paper organize follow next section briefly describe relevant detail anthill build allow multiple event different section describe detail application port anthill section describe extensive experimental evaluation application different alternative execution schedule discuss relevant relate bibliography section v present future section anthill anthill four five framework inspire program model implement six model use approach decompose set process refer filter data transfer filter use stream allow data buffer transfer one filter next application decomposition process lead task parallelism application become set filter connect like direct graph execution time multiple copy filter compose application several machine system stream connect source transparent copy mechanism allow vertex application graph replicate many compute nod data go filter may partition among copy create data parallelism several natural decomposition cyclic graph execution consist multiple filter application start data represent initial set possible pass filter new candidate create experience develop anthill notice behavior also lead asynchronous sense several candidate possibly different process simultaneously anthill therefore try exploit maximum parallelism use three discuss task parallelism data parallelism divide computation multiple pipeline stag one replicate multiple time parallelism since happen execution mostly bottleneck free regard transparent copy mechanism care take filter replicate state ideally state partition happen incoming message filter need sort respect state update deliver appropriate transparent copy mechanism guarantee anthill call label stream label associate message send stream check label hash function select one copy deliver message guarantee message associate label consequently state deliver always transparent copy filter program abstraction filter process data flow possibly change nature data pass next filter programmer define filter worry transformation function execute data unit turn may internally data forward next filter filter environment decide event raise may process give hardware available long available pending execution may continue filter may build receive input multiple independent stream programmer indicate do upon arrival data stream even different action source filter environment control nonblocking io issue necessary choose right process function event define programmer approach derive heavily program model pioneer seven later extend include explicit coyote eight anthill include several support program depict figure one event layer divide three communication module event queue controller event handler discuss next f l e e n v r n e n e v e n h n l e r e p r c e n g f n c n process event handler relate stream store message send process function e v e n q e e c n r l l e r create event queue relate receive event send message create process function c n c n l e read data stream send message target filter n h l l r n e e fig one overview anthill system communication module responsible monitor input stream send sag target filter instance operation essentially consist create event respective event queue whenever message associate stream arrive satisfy event queue controller responsible control event queue associate filter instance component determine order queue process call appropriate filter process function event handler contain code input stream developer create function process data receive register system whenever event associate give stream trigger register function get execute receive input event handle ie data process keep apart application programmer isolate control assign system make easier schedule load balance implement without affect programmer code special schedule create monitor module event queue controller back without require change application code b support heterogeneous section describe approach towards transparently exploit heterogeneous available distribute memory machine mention idea allow programmer provide different stream execute different component compute node integrate additional filter framework allow anthill automatically choose among available dispatch execution different concurrently event drive model fit nicely scenario least three reason one well define handler function implement language appropriate device target two system use device process stream three system choose fly input ready appropriate device process event decision space within extend anthill broad involve many dispatch parallel first since heterogeneous set may available system must consider event handler define user provide handler must consider performance different available may even finally must consider overall entire execution sake flow optimization give take per event basis may change different even kind allow filter handler different schedule accord availability create flexible environment consider distribute memory machine anthill capable schedule node filter implementation filter anthill schedule concurrently transparently current prototype implementation two event schedule dynamic weight round robin default one next event process queue dispatch first device available implementation event handler second policy divide process accord weight may vary execution time receive value device execution weight use order input queue device certain processor available event process highest weight moment target cod data transfer handle transparently system however framework easily extend support available compute node cell implement additional extend anthill accept association event different hardware wrapper function isolate programmer device memory management figure two depict extend architecture basically create two top filter framework device event executor f l e r e v e n h n l e one e v e n h n l e two e v e n h n l e x r n e e c p n e n e v e n p r c p e e v c e c h e l e r e v e n e x e c r c p h r e g e e v e n p r c p e e v e n e g e f l e e n v r n e n e g e e g e n h l l fig two framework extend architecture device keep track event handler many device specific cod available give event queue determine next event process event executor layer system isolate user provide code specific hardware issue event executor create thread associate different thread contact device whenever idle determine event process within thread neuroblastoma neuroblastoma image analysis system goal neuroblastoma image analysis digitize tissue sample different prognostic significance application concentrate classification stromal development either one morphological prognosis contribute categorization histology favorable unfavorable three slide high resolution first decompose image smaller image tile image tile process independently due employ image analysis approach nine mimic way examine tissue slide microscope image analysis start resolution correspond lower magnification level microscope use higher resolution decision classification require detail information without loss generality image analysis operate image tile follow first decompose image tile original image multiple representation example three layer could construct basic classification strategy start use resolution image stop resolution level classification satisfy predetermine criterion classification achieve base statistical feature characterize texture tissue structure therefore first apply color space conversion switch lab color space color intensity separate difference two value perceptually uniform texture information extract use statistics local binary pattern help characterize color intensity tissue structure nine finally classification confidence particular resolution compute use hypothesis test either classification decision accept analysis resume higher exist result image analysis classification label assign image tile indicate underlie tissue subtype background detail find two b anthill implementation implementation anthill show figure three five filter image reader responsible read tile color space send next step color conversion receive image tile convert lab color space computation statistical feature filter receive image represent lab color space compute feature vector consist statistics classifier filter receive feature vector apply classification hypothesis test decide whether classification satisfactory finally v filter control process flow start send tile process resolution image reader receive tile classification classifier filter classification satisfactory switch send message image reader new resolution otherwise continue subsequent image tile loop continue tile classification satisfactory compute highest resolution input image resolution lab image resolution g e reader color c n v e r n statistical feature compute tile tile id resolution statistics start p classifier fig three filter filter computational intensive task thus stream data arrive filter anthill device choose specific device consequently handler function process receive data c application task analysis schedule section analyze relative performance function input granularity evaluation generate different use fix number tile vary input tile size maintain single resolution level evaluation experiment repeat four time maximum standard deviation hardware use experiment dual describe section p e e p p g p c eighty sixty forty twenty zero tile size square tile fig four application variation increase tile resolution show figure four result present high variation relative performance performance similar tile time faster tile approach exploit heterogeneous implement color conversion statistical poor performance small tile occur due utilization since small task demand enough fully exploit parallel process capacity use imply communication overhead associate transfer data main memory invoke kernel function order improve usage efficiency real execution process task different resolution concurrently active use relative performance information input schedule thus buffer contain tile image receive evaluate user provide function receive event parameter return relative insert stream queue accord return value whenever device available choose suitable event process base estimate use order instance neuroblastoma simply return image tile size best possible order experimental result experiment heterogeneous perform use two cluster one ten connect use switch node core two duo two main memory operate system two four connect use node dual processor main memory operate system result show paper average four experiment experiment use also occupy core responsible manage application performance section evaluate performance single machine available hardware configuration experiment perform use input image fix number tile two resolution level vary recalculation rate tile recalculate higher resolution thus increase recalculation rate tile higher probability second resolution level figure five show application execution time machine use either maximum average standard deviation experiment respectively execution time present strongly affect recalculation rate impact number tile process higher resolution inefficient five ten fifteen twenty tile recalculation rate execution time n c e e n c e x e p e e p zero zero forty thirty twenty fifteen ten five zero zero five ten fifteen twenty tile recalculation rate b fig five application evaluation machine compare two available show better performance although clock almost evaluation present better execution time expect represent generation contain stream figure five b also present machine machine faster machine relative higher result interest two reason one show compare application run use relative may susceptible instance node relative could reduce measure together crease relative performance two different relative interest evaluation test effectiveness task schedule compare obtain schedule hardware incur discuss b heterogeneous environment analysis section evaluate approach execute heterogeneous use hardware describe core two duo machine dual machine one core one core p e e p thirty twenty fifteen ten five zero zero two four six eight ten twelve fourteen sixteen eighteen twenty tile recalculation rate fig six efficiency evaluation figure six present performance analysis use first hardware configuration multiple application collaboratively schedule standard deviation experiment never bigger four three show improvement recalculation rate zero recalculation similar performance low resolution tile recalculation tile take time either device since two instead one case pure version factor two improvement achieve expect table present number task process use zero recalculation see almost schedule consequently incur similar performance increase recalculation rate however see policy still almost double relation pure resolution one core one core zero twelve low high zero zero low high four tile process table achieve almost improvement instance twelve recalculation version application time faster use together incur respectively experiment detail table show profile task process twelve recalculation rate schedule show use process low resolution tile use faster application employ process eighty small tile high resolution figure seven present execution time dual machine execution time use show figure seven reduce increase number thread reduction also higher low recalculation rat tile suitable consequently schedule less influence performance although gain use proportional execution time schedule show figure seven b result better increase recalculation rate show efficiency schedule also present figure eight eight b respectively show slightly increase application performance almost double core high one two three four five six seven low high table low one two five forty dual tile process recalculation rate ten n c e e n c e x e n c e e n c e x e seventy sixty fifty forty thirty twenty ten zero sixty fifty forty thirty twenty ten zero p e e p p e e p ninety eighty seventy sixty fifty forty thirty twenty ten zero ninety eighty seventy sixty fifty forty thirty twenty ten zero p e e p ten nine eight seven six five four three two one zero four eight twelve sixteen twenty zero four eight twelve sixteen twenty tile recalculation rate tile recalculation rate one core two core three core four core five core six core seven core one core two core six core seven core three core four core five core zero four eight twelve sixteen twenty tile recalculation rate b zero four eight twelve sixteen twenty one core two core tile recalculation rate three core four core five core b six core seven core fig seven dual execution time fig eight dual performance gap also explain task profile process device table present number tile process increase number core maintain ten recalculation rate provide schedule number low resolution tile suitable process core much smaller high resolution tile reverse behavior analysis show performance five start compete available core although use five process three remain use reader filter manage anthill process responsible manage communication c distribute environment evaluation order evaluate performance application distribute environment perform experiment use two cluster vary well schedule strategy experiment perform use one copy filter per machine tile image also vary recalculation rate zero twenty result present substantial variation due improve legibility show result ten rate linear use use use one two three four five six seven eight nine ten machine fig nine dual cluster result dual core cluster show figure nine experiment close linear increase number machine finally figure ten present dual cluster see linear use use use four three two p e e p fifteen one one two three four machine fig ten two cluster behavior scale number host experiment perform use four core efficient configuration schedule v relate work recently see growth number project focus develop high performance compute model derive compute model ten six eleven dryad twelve mainly drive need process large amount data several instance image analysis information model inherent parallelism contribute significantly develop new important feature example create transparent copy mechanism replicate process stag provide data parallelism able dynamically add manage stream however focus efficiently exploit modern heterogeneous like cluster approach try maximize application throughput use available efficiently apply schedule choose device suitable handle certain event different work also demonstrate efficiency use single node mar thirteen one implementation program model context mar implement subset order allow development mar demonstrate efficiency fifteen sixteen six previously develop use phoenix mar also perform initial investigation gain use evaluation perform statically divide task stag statically accord phoenix mar process task one mar proposal interest alleviate hard task develop although promise approach solution still limit single machine node fulfill original goal massive distribute compute program framework ten merge framework fourteen another interest program model heterogeneous environment mar propose evaluate use also limit single process node result show mar merge use core together increase slightly application performance proportionally base paper also use collaboratively differently mar merge approach limit single machine show section work effectively exploit device schedule task accord performance available processor show extremely efficient could instance machine double version application add single core use evaluate schedule previously evaluate al fifteen also present first study cluster machine work also address development process include optimization issue work implement use anthill framework enable use show use heterogeneous efficiently bring performance use source cod present fifteen finally see considerable amount work schedule heterogeneous sixteen instance use greedy algorithm classically employ schedule map task parallel execution heterogeneous base expect execution time research like seventeen also investigate application level schedule distribute heterogeneous work mainly differ previous regard least three point investigate schedule modern heterogeneous distribute en propose schedule consider new scenario relative performance fix vary accord input task perform filter level schedule try optimize execution application increase performance filter future work paper present approach use way order improve efficiency even improve anthill framework incorporate decision event filter decide whether event execute invoke appropriate event handler create two simple schedule implement decision mechanism use real world compute intensive application image analysis classification tumor image evaluate approach overall experiment show substantial make application performance measure factor two improvement top implementation also show maintain linearly addition multiple heterogeneous nod execution environment future work intend evaluate impact different schedule heterogeneous study two different schedule paper give us insight importance adequately match profitable device irregular consider try assess create schedule approach combine application filter placement filter schedule heterogeneous employ paper reference one l r promise central pathology review development standardize procedure oncology group pediatric developmental pathology vol ten three two j h v j h n prognosis neuroblastoma image classification stromal development pattern recognition special issue digital image process pattern recognition detection cancer vol six three h l p j v v joshi b terminology morphologic criteria neuroblastic recommendation international neuroblastoma pathology committee cancer vol two four g fireman w r achieve parallelism stream program model parallel process international conference vol zero five r w l b g r g anthill scalable environment data mine symposium computer architecture compute six r filter storage storage available j h archival symposium mass scientific large seven w l l dynamic network architecture vol ten two eight n r w coyote system construct communication service vol sixteen four nine rotation invariant texture classification local binary pattern pattern analysis machine intelligence vol ten j dean simplify data process large cluster proceed sixth symposium operate system design implementation four eleven l amini h r f r king p park c distribute scalable platform data mine six proceed international workshop data mine service new york twelve dryad distribute program sequential build block seven proceed conference computer new york thirteen b w fang q n k wang mar framework graphics parallel compilation fourteen j collins h wang h meng merge program model heterogeneous multicore vol three fifteen v f r image analysis cluster conference sixteen r relative performance various map independent sizable proceed seventh heterogeneous compute workshop computer society p seventeen f r j g schedule distribute heterogeneous network proceed conference computer society p