road take estimate path execution frequency statically university abstract variety static analyse test rely heavily path frequency information use information range optimize bug find path typically obtain profile approach severely restrict require run program indicative environment indicative test input present descriptive statistical model path frequency base feature readily obtain program source code model ninety accurate respect several sufficient select five account half program total demonstrate technique robustness measure performance static branch predictor find accurate previous approach average finally qualitative analysis model provide insight feature indicate hot one introduction law often invoke advice optimization common use case domain program analysis demand hot path identification four six twelve importance hot arise empirical observation execution time typical program spend along small percentage program certain sequence tend repeat often high degree nonuniformity program execution make characterize behavior research support part national science foundation grant air force office scientific research grant well gift research information present necessarily reflect position official endorsement infer important concern task far beyond code optimization proposition diverse maintenance general analysis two result program profile remain vibrant area research six seventeen even many treatment community unfortunately profile severely limit practical concern frequent lack appropriate program questionable degree indicative actual usage inability tool evaluate program individual isolation static context without clear notion relative execution frequency frequency give block code execute unknown without additional information assume equally likely practice questionable particularly analysis design measure affect performance report large amount code exist handle exceptional case code relate error handle eight sixteen contain error handle construct see p four survey error handle code common significantly impact real performance therefore assumption equally likely input space uniform lead inaccurate otherwise suboptimal result program analysis propose fully static approach problem hot path identification approach base two key first observe relationship relative frequency path effect program state second carefully choose right level abstraction consider program precision limit one class program state observe static indicate whether program path intend common alternatively design rare exceptional claim infrequent case typically take one two form first involve error detection follow divergence current path return error code response invalid argument raise exception nine may canada assertion failure second involve program state reorganize data structure reload data file resize hash table conversely common case typically entail relatively small state tend gradually increase available context subtly increase system entropy hypothesize exhibit small impact program state term global term context stack frame likely hot program predict relative path execution frequency definition path critical seminal work graham al note useful execution profiler must attribute execution time way logical structure program well textual decomposition seventeen flat profile helpful accurate base profile consider method class part one uninterrupted path choice allow us precise common code purpose analysis split control flow cross class boundary choice allow us scale large program two form heart static approach predict dynamic execution paper enumerate set static feature control flow feature base structure data flow effect program state employ feature train machine learn algorithm predict path frequency approach report path numerical estimate frequency relative either contain method entire program evaluate prototype implementation use supply grind truth also discuss evaluate relative importance feature main paper technique statically estimate frequency program result use support improve many type static analyse empirical evaluation technique measure accuracy select hot rank frequency demonstrate flexibility model employ characterize run time dynamic branch behavior several top five report account half program static branch predictor base technique hit rate compare previous work section three discuss feature make model section four perform direct model evaluation section five perform time base experiment section six branch prediction experiment section seven finally extract discuss possible model section eight conclude two context motivation section present key relate work review simple example demonstrate application output technique highlight number task analyse could benefit static prediction dynamic path work similar static branch prediction problem first explore ball five show simple useful predict frequency branch take typically involve feature branch compare pointer null compare two predict branch false condition take work achieve modest performance employ feature set neural network learn ten choose focus instead branch two reason first claim frequency useful certain static analysis task see ball al seven discussion second contain much information individual branch thus much amenable process formal model prediction automatic generation one strategy cop lack program trace general technique adapt many generation useful stress test achieve high path coverage show suitable creation indicative contrast attempt model indicative execution recent work test thirty explore execution program systematically select input find subtle bug technique interleave static symbolic execution generate test input concrete execution input symbolic value complex static analysis handle replace concrete value execution approach make static dynamic path execution frequency focus motivate example structure paper follow discuss relate work present motivate example enumerate several potential use technique section two describe process program path enumeration hypothesize information expect behavior imperative program include relative path execution frequency often embed throw new count threshold make sure value null value null one two map specify key specify three value four five public synchronize v put k key v value six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty thirty rehash table threshold exceed rehash create new entry entry k v e tab index tab index tab table index hash new entry k v hash key value e count return null figure one put method version sixteen class code omit illustrative simplicity source code implicit nonetheless predictable way present intuition information manifest figure one show typical example problem hot path identification algorithm case three interest path correspond insertion new entry line presumably common case however also case value parameter null function terminate abruptly line nine well case rehash method invoke line eighteen operation likely expensive example help motivate decision follow within class leverage system paradigm whereby code state information encapsulate together follow within class enable technique discover rehash modify large amount program state trace external method allow scale technique identify path feature throw exception read many class field find indicative path frequency algorithm present successfully discover path merely create new entry common rehash path exceptional path describe might make use information example client optimization refer practice optimize compile binary subsequent observe behavior three eight eighteen technique potential make class optimization accessible first eliminate need second remove time require run record profile information static model relative path frequency could help make compiler current work computational complexity estimation limit analyse sixteen high level task estimate complexity put procedure figure one require identify represent common case thus dominate behavior critical mistakenly assume path along rehash invoke common result overestimate cost put similarly focus path correspond error condition line nine underestimate cost static specification mine one seek infer formal correct program behavior view problem distinguish correct erroneous program contain behavior occur many assume correct may indicate bug fourteen practice static specification use static path count proxy actual execution behavior static model path frequency would improve precision many static analyse produce false alarm statistical rank often use sort error report place likely bug top twenty order often use static proportion count base assumption static equally likely static prediction path frequency would allow bug report infrequent example filter bottom list general program analysis transformation combine static dynamic information could benefit model path frequency disparate program specialization frequency could reduce annotation analysis burden indicate specialize memory bank conflict detection program nine frequency could reduce heavy simulation deployment cost static analysis potential next section describe detail analysis input concrete class output map p method static path set three path enumeration imperative language method comprise set control flow one execute actual invocation goal statically quantify relative frequency path method take analysis work analyze feature along path algorithm operate basis enable consider single class likely assist indicate path avoid large explosion would result fully context sensitive central technique static path enumeration whereby enumerate acyclic target program experimentally validate technique also require process dynamic path enumeration count number time path program execute actual program run static path enumeration static path enumeration begin member function concrete program class static path flat acyclic path start public method class contain within method outside first enumerate method separately combine obtain give method construct control flow graph consider possible turn method loop may unbounded number potential follow back edge ensure path count finite purpose analysis path loop represent take loop one time find level description adequate many client analyse higher bound number loop also possible path definition similar one use efficient path profile six consider certain process record store information path enumerate enumerate merge flatten use algorithm iterate though path invocation sit correspond invoke method clone caller path invoke path process terminate invocation sit resolve since allow statement appear p acyclic one two three end four let five empty six let remove next path p seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty let change false method path path c p let path zero copy path path zero path zero seven path c p p path zero path change true end end end change end end end figure two enumerate static concrete class single path number invocation sit finite process always terminate figure two show static path enumeration algorithm static path definition intuitive show enumeration process path frequency estimate give static enumerate rank path give relative static path definition thus influence result analysis dynamic path enumeration train evaluate model path execution frequency require grind truth often give static path actually execute typical program run dynamic path enumeration approach involve two step first record statement visit program run execute statement record unique identifier include enclose class method one run program yield one single list second partition list static process order simulate call stack split flow control leave currently enclose class statement revisit loop list partition static count number time path occur dynamic count grind truth prediction target static analysis four static path description model hypothesize sufficient information embed code path estimate relative frequency take characterize use set feature use render estimate respect feature set path view vector feature value path path frequency estimation model take input feature vector represent path output predict frequency path choose set feature two primary concern predictive power efficiency power base feature set intuition role program state play engineer practice scale large program choose feature efficiently compute linear time feature consider study enumerate figure three largely design capture behavior hypothesize relate path frequency formulate feature note could easily extend many feature consist static count feature number measure percentage possible appear along path example field coverage percentage total class field appear along path field write coverage percentage field class update along path invoke method refer method path originate count feature discrete unbounded coverage feature continuous close interval zero one give feature use number machine learn model estimate path frequency experiment accurate estimate path frequency arise complex interaction feature view choice feature hypothesis behind final performance model base important particular machine learn technique use fact view advantage multiple learn make use feature perform similarly experiment example perform almost equally well suggest feature quirk learn algorithm responsible accurate count coverage x x x x x x x x x x x x x x x x x x feature new field field write invoke method local local nonlocal return throw x x x x x figure three set feature consider count raw static tally feature coverage percentage measure fraction possible activity occur along path experiment paper use logistic regression accuracy among best try probability estimate produce show high degree numerical separation ie probability estimate show property prove important create rank output large number five model evaluation perform two experiment evaluate predictive power model respect first experiment evaluate model binary classifier label either high frequency low frequency second experiment evaluate ability model correctly sort list frequency experimental setup implement prototype version algorithm describe section four language use soot fifteen parse instrument use weka nineteen machine learn characterize set figure four note program significantly view realistic see indicative test model term program structure however name check compress jack jess total description check feature file compression data management parser generator compiler expert system ray tracer class fourteen twelve three five source code give jack report line version analysis run figure four set program use class count number class count number name check compress jack jess total figure five static path enumeration specifically design indicative real program term behavior figure five detail behavior static path enumeration algorithm see section jack number static despite relatively large size line code jess actually static relatively sparse call graph jack highest number static per method complicate object structure total able enumerate static minute architecture process largely disk bind classifier train formulate problem identification classification task give path belong set high frequency low frequency phrase problem alternatively probability high frequency path machine learn design purpose take form operate instance object case instance feature vector numerical value describe specific static path classifier use base logistic regression supervise learn involve two phase train evaluation train phase generate classifier set instance along label correct answer derive path count obtain dynamic path enumeration section answer binary judgment partition low frequency high frequency consider two ways distinguish approach approach prefer scheme necessarily depend client application experiment first normalize path count method sum path count method become ten label high frequency normalize frequency greater five ie frequency greater method combine experiment consider path high frequency take ten time approach largely insensitive threshold choose achieve similar result two twenty train apply classifier instance see obtain estimate probability belong high frequency class estimate frequency path help mitigate danger ie construct model fit complex comparison amount data always evaluate one time use train data thus avoid train test analysis first quantify accuracy approach information retrieval task evaluate discrete nominal classifier output two relevant success metrics experiment type recall precision recall percentage high frequency correctly high frequency model precision fraction high frequency model actually high frequency accord dynamic path count consider independently metrics make perfect trivially degenerate model always return high frequency perfect recall thus weight together use f score statistic harmonic mean precision recall eleven reflect accuracy classifier respect high frequency x first train dynamic consider figure six f score performance high frequency ten perfect figure seven tau performance model use rank order base predict dynamic frequency zero perfect strong correlation five random chance high frequency x determine dynamic path count also consider equal number low frequency x choose random use model select use equal number high evaluation allow us compare accuracy uniform way across f score well overall average show figure six case f score serve correspond uniform classification predict high frequency perfect classification yield f score ten model achieve three case average obtain f score eight hot nine model thus accurate hot one example application would benefit classifier static specification mine specification miner might treat frequent infrequent differently way previous treat error normal differently greater accuracy however analysis task important able discriminately rank sort base predict frequency next experiment extend model beyond binary classification weight rank analysis experiment evaluate model ability rank sort compare relative execution among rather binary judgment high frequency low frequency use classifier probability estimate high frequency induce order estimate real order give dynamic path count use method data set construction train test evaluation require new metric intuitively dynamic path count indicate four occur frequency order b c prediction b c accurate prediction c b tau thirteen distance metric rank order formalize intuition use evaluation criterion tau equivalent number bubble sort swap need put one list order second normalize size list tau distance metric order list smaller number indicate correlation use normalize tau facilitate comparison list different size list reverse order ie exactly wrong would score ten random permutation would score five average perfect agreement ie order yield zero figure seven show tau value individually well overall average particular case hot jess obtain perfect score zero ie exactly predict real relative order average model yield tau value thirty view number range indicative strong correlation note small order especially among low frequency likely represent concern static branch prediction five program specialization error report rank twenty client analyse could make use rank next section show select top rank sufficient quickly characterize large percentage run time program behavior six path frequency run time show static model accurately predict path frequency section use model hot characterize program behavior term actual run time essence evaluate model temporal coverage metric acquire time data record entry exit time stamp method resolution add average overhead run time compare full dynamic path enumeration combine time data path enumeration calculate total time spend execute path use model sort static program predict frequency select x highly rank calculate percentage total spend along select experiment select x method figure eight x entire program figure nine result indicate strong correlation static model path frequency run time program behavior case select single path method sufficient capture nearly program run time recall average twelve per method furthermore case select five program sufficient fifty temporal coverage average analysis indicate model capable characterize real program run time behavior accuracy likely sufficient improve enable many type program analyse example compiler optimization expensive apply could apply single path predict model high probability improve performance figure eight percentage total run time cover examine top method figure nine percentage total run time cover examine top entire program target choose one frequency estimate achieve comparison start construct control flow graph method method entry node enumerate list method sort list accord frequency estimate traverse control flow graph every node maintain set static could pass node consider example code fragment seven path frequency branch prediction choice point section demonstrate robustness approach coerce static path frequency prediction model static branch predictor static branch predictor one formulate prior run program intuitively make branch prediction ask model rank correspond branch execution currently node correspond line two future execution might proceed along path along path branch node perform one b two c three c e f four five else g h six seven figure ten static branch prediction hit rate heuristic represent path correspond use static path frequency prediction predict branch two action first partition path set enter node two set correspond conform side branch second record prediction branch side highest frequency path available code fragment query model relative order rank higher would record prediction take branch line three finally path model acyclic branch back edge follow standard backward take forward take heuristic always predict back edge follow scheme base observation back edge often indicate loop typically take compare branch prediction strategy scheme approach propose ball five base set nine branch check integer less zero predict branch false condition compare three grind truth run measure success term branch hit rate ie fraction time static prediction correct figure ten report hit rate individually well overall average static branch prediction difficult task even optimal strategy ninety hit rate typically maximal five one strategy perfect case example ball perform well jack frequently employ technique perform quite well compress relatively large number branch two forward target average however static branch predictor base static model path outperform common three result serve indicate frequency model robust multiple use case eight model show model useful estimate frequency program base solely set static feature section present brief qualitative analysis model discuss possible conduct singleton feature power analysis evaluate individual feature importance well principle component analysis access degree feature overlap feature power analysis figure eleven rank relative predictive power feature indicate direction correlation frequency example single predictive feature set number path average imply path less likely take data gather rerun f score analysis train single feature measure predictive power result model normalize data zero one correlation direction compare average value feature high low frequency class prefer singleton analysis analysis feature power measure amount compare feature state update validity one threat validity experiment potential learn model complicate respect data thus fail generalize mitigate threat never test train data test one program train result may fail generalize beyond present choose spec indicative finally result may useful notion static path capture enough essential program behavior since output formulate static client analysis must make query term success build branch predictor top path frequency analysis help mitigate danger program behavior capture notion static general form natural interface nine conclusion present descriptive statistical model path frequency base feature readily obtain program source code static model eliminate need profile predict behavior without require indicative model ninety accurate respect sufficient select five account half total program also demonstrate technique robustness measure performance static branch predictor find accurate average previous approach finally qualitative analysis model support original hypothesis number program state describe path indicative frequency believe many program analyse could directly benefit static model dynamic execution work represent first step direction indebted f c knight insightful engineer temporal work thank anonymous comment draft paper figure eleven relative predictive power feature establish singleton analysis degradation result omit feature feature set due high degree feature overlap indicate find variance explain five principle singleton feature power analysis perfect indicator importance feature offer qualitative insight model example relatively high predictive power statement count particularly assignment would seem support hypothesis large change program state uncommon observe much predictive power train class field metrics suggest update local also important uncommon hand local variable coverage correlate frequent since variable update correlate uncommon model bear intuition common read many local update feature characterize path structure return count show modest predictive power reference one g r j r mine program page two g j r improve analysis path profile five three j fink v sarkar p f comparative study static workshop dynamic adaptive compilation optimization page four baba k design hot path detector loop advance computer science technology page five ball j r branch prediction free program language design implementation page six ball j r efficient path profile international symposium page seven ball p edge profile versus path profile showdown program page eight p j optimization evaluation tool performance analysis page nine boyer k w dynamic analysis program workshop tool multicore ten b j martin b static branch prediction use machine learn program nineteen one eleven r statistical international conference quality page twelve e v profile hot path prediction less eleven thirteen e j w mason new rank correlation coefficient application consensus rank problem journal decision analysis page seventeen department national defence operational research division canada sons fourteen r bug inconsistent behavior general approach infer code symposium operate page fifteen r al soot optimization framework proceed page sixteen f goldsmith measure empirical computational complexity engineer page seventeen l graham p b k call graph execution profiler best four eighteen r e compiler compiler design handbook page nineteen g weka machine learn workbench new conference intelligent information twenty r use statistical analysis counter impact static analysis static analysis symposium page j synthetic generation technique stress test eleven base j r whole program program lan design implementation page p b wah synthetic generation experiment parallel three three c r trick c n j c w profile scheme identify program hot spot support optimization international symposium computer architecture page machine learn hill l ni generation performance characterization conference page computer society press reps ball das j use program profile maintenance year problem note six p j l c automatic program specialization program four k sen test engineer ing page thirty k sen g agha cute unit computer ing explicit path tool aid verification page atom system build program lan program analysis tool design implementation page w g c mine temporal tool error detection construction analysis page w g c exceptional program program reliability thirty two