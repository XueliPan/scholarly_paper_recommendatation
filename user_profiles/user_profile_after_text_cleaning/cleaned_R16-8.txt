dependable secure compute vol six two approach transient fault tolerance multicore student member student member janapa student member member fault emerge critical concern reliability architectural trend point toward multicore design substantial interest adapt parallel hardware transient fault tolerance paper present redundancy technique transient fault tolerance leverage multiple core low overhead create set redundant process per application process systematically compare process guarantee correct execution redundancy process level allow operate system freely schedule process across available hardware use approach transient fault tolerance shift focus ensure correct hardware execution ensure correct execution result many benign fault propagate affect program correctness safely ignore real prototype present design transparent application run program without program operate system underlie hardware system evaluate fault coverage performance machine provide improve performance exist transient fault tolerance percent overhead fault detection set optimize index tolerance reliability transient fault soft redundancy c one introduction transient fault also know soft emerge critical concern reliability computer one two transient fault occur event cosmic particle strike power supply noise device couple cause deposit removal enough charge invert state transistor invert value may propagate error program execution current trend process technology indicate future error rate single transistor remain relatively constant three four number available per chip continue grow exponentially error rate entire chip expect increase dramatically trend indicate ensure correct operation must employ reliability transient fault historically design concern specific compute server machine key system technological institute road j department computer science university colorado campus box boulder computer science university colorado boulder electrical engineer computer science department university st apt da department electrical computer engineer university colorado campus box boulder manuscript receive may accept sept publish information obtain reprint article please send reference log number digital object identifier reliability dependability availability memory easily protect code parity protect complex logic within present significant challenge custom hardware design add twenty percent thirty percent additional logic add redundancy cover upward latch five six approach include specialize machine custom hardware redundancy seven eight however directly adopt compute domain compare compute drive different often conflict set factor factor include application specific result transient error difference life death compute faulty execution may greatly vary fault execution bank transaction would disastrous many case result fault much less severe instance graphics process audio decode playback fault result mere may even notice user thus focus reliability shift provide bulletproof system improve reliability meet user failure rat design time cost compute market low cost quick time market paramount design verification new redundant hardware costly may feasible market publish computer society dependable secure compute vol six two addition inclusion redundant design may negatively impact design product cycle environment system susceptibility transient fault often unplanned appear design fabrication example deployment q national laboratory document high incidence due transient fault two also sun document case fault unprotected cause system crash customer sit one difficult imagine history repeat unforeseen hardware design manifest deployment likewise condition altitude temperature age higher fault rat nine case necessary employ reliability able augment deployment pressure drive compute reliability attractive solution improve reliability face transient fault provide level reliability comparable hardware significantly lower cost zero hardware design cost flexible deployment exist transient fault tolerant approach use compiler insert redundant check computation ten control flow eleven twelve suffer first execution insert decrease performance fourteen slowdown twelve fault detection second compiler approach require recompilation inconvenient recompile source code legacy program often unavailable paper present redundancy technique transient fault tolerance create set redundant process per original application process compare output ensure correct execution redundant process freely schedule operate system os available parallel hardware scale architectural trend toward large machine leverage available hardware parallelism improve performance without additional redundant hardware structure system compute throughput constrain provide alternate method leverage hardware transient fault tolerance paper make follow introduce paradigm transient fault tolerance view system layer must execute correctly contrast typical paradigm view system collection hardware must protect differentiate view use commonly accept sphere replication concept demonstrate benefit approach particular show register propagate show many result benign fault many detect fault propagate approach able ignore many benign fault present real prototype system operate transparently application leverage multiple core transient fault tolerance evaluate fault coverage performance prototype find run set suite percent overhead system represent significant performance improvement previous transient fault tolerance maintain determinism redundant process biggest challenge implement present evaluate approach handle asynchronous signal share memory access across redundant process also evaluate performance impact use maintain determinism rest paper organize follow section two provide background transient fault tolerance section three describe fault detection model section four describe architecture section five show result prototype section six discuss relate work section seven conclude paper two background general fault effect system execution follow thirteen fault benign fault transient propagate affect correctness application consider benign fault benign fault occur number reason include fault idle functional unit fault instruction ie instruction data mask fourteen wang al fifteen show less fifteen percent fault inject register transfer level model processor result visible indicate many transient fault benign fault silent data corruption transient fault undetected propagate corrupt program output consider worst case scenario application appear execute correctly silently produce incorrect output detect unrecoverable error due transient fault detect without possibility recovery consider due split two true due occur fault would propagate incorrect execution detect false due occur benign fault detect fault without recovery false due system unnecessarily halt execution recovery false due unwarranted recovery mechanism al approach transient fault tolerance multicore execute store instruction particular approach work possible emulate processor redundancy redundant however would impossible emulate example alone implement around hardware cache place around layer fault detection paradigm system view layer must execute correctly model use instead hardware define term provide technique natural fault detection also mode make key insight although fault occur hardware level fault matter fault affect correctness change output comparison model shift focus ensure correct hardware execution ensure correct execution benign fault safely ignore system detection cover would propagate incorrect output system detection recovery need invoke recovery mechanism fault affect correctness fig show example place around user space application use act exactly except act instead hardware input replicate execution within redundant data leave compare limit visibility hardware able view fault scope determine effect execution thus approach ignore potential approach section demonstrate ability ignore many benign fault fault injection campaign four redundancy approach transient fault tolerance design run transparently without application os underlie hardware specific describe detail transparency operate transparently user application even though create multiple redundant process per original application process maintain process semantics application also unaware need modify run implement entirely run user space application manner able provide transient fault tolerance without require os underlie hardware addition implementation make extremely fig one transient fault detection model model view system layer place sphere influence around particular layer b transient fault system without transient fault tolerance result benign fault true due error detect raise trap system detection attempt detect true however system may inadvertently convert benign fault false unnecessarily halt execution finally system detection recovery detect recover fault without form due case fault would false may unwarranted recovery mechanism three fault detection commonly accept concept sixteen describe technique logical domain redundancy specify boundary fault detection containment data enter replicate within redundant form leave output data compare ensure correctness execution outside cover particular transient fault must protect mean fault contain within detect data leave original concept use define boundary reliability redundant hardware design call traditional model fault detection model use model view system collection hardware must protect transient fault model place around specific hardware input replicate execution redundant output compare model appropriate awkward apply approach reason naturally operate different level full visibility hardware nevertheless previous approach attempt imitate example swift twelve place around processor show fig without ability control duplication hardware swift duplicate instruction level load perform twice input replication computation perform twice replicate input output comparison accomplish check data store instruction prior dependable secure compute vol six two fault detection recovery watchdog timer attach system call emulation unit use detect case fault cause one redundant process indefinitely redundant process create original process become figurehead process figurehead process real work wait redundant process finish execution forward signal redundant process follow section describe system detail discuss issue transparency maintain determinism among process transient fault detection recovery describe implementation detail challenge attempt stay general possible specific system implementation often use feature terminology however computer typically believe experience mostly translate maintain process semantics create entire group process per original application process however important maintain process semantics expect user case communication specifically interest maintain follow expect process semantics run application one application invoke give specific process identifier exist entire duration application relinquish os afterward two application exit return correct exit code program three signal send valid intend effect example kill process previous version simply fork application multiple time compare execution behavior use system call emulation unit seventeen however assess transparency approach quickly realize violate process semantics suppose original application begin fork twice redundant process transient fault cause original die impossible maintain process semantics although execution application continue original exist execution return correct return code impossible signal order maintain process semantics use figurehead process create redundant process original process relegate figurehead process figurehead perform three function match three rule expect process semantics list first sleep wait redundant process complete execution second upon completion receive application exit value system call emulation unit exit properly third perform signal forward every signal intend application reach figurehead process correct figurehead process need forward signal thus figurehead process fig two overview system architecture three redundant process flexible must reliable run run regularly use approach fault detection around application associate share redundant fault detect result incorrect data exit user space extend check fault detection compare transient fault tolerance allow ignore many benign fault use process provide redundancy replicate entire process virtual address space well process file addition automatically create among redundant process maintain determinism among process detect transient fault recover detect fault operate process level distinct advantage process also basic abstraction os therefore leverage multiple hardware extra hardware thread core simply allow os schedule across available hardware overview overview system show fig two gain control application begin execute begin phase first create monitor process initialize include share memory segment use communication fork application n time n fourteen two minimum fault detection n fourteen three minimum fault detection fault recovery process redundant process actually perform execution application one redundant process label master process label slave process execution redundant process system call emulation unit system io among redundant process general master process allow perform system io slave process emulate system io system call emulation unit also enforce fault detection model implement transient al approach transient fault tolerance multicore well redundant process terminate execution ensure third rule maintain process semantics one complication signal forward figurehead process signal catch signal handler therefore figurehead process would kill figurehead process leave redundant process run handle use monitor process intermittently poll state figurehead process process exist assume kill along rest redundant process parent stop state issue redundant process emulate effect signal within application figurehead monitor process introduce delay receive signal however signal mostly asynchronous nature slight delay problem note maintain process semantics help transparency user perspective perspective may interact target application via communication maintain transparency system perspective example list active system process produce figurehead process well monitor process redundant process process technique use model transient fault detection show fig place around user address space provide redundancy process level replicate application library code global data heap stack file table forth everything outside namely os must protect mean data enter via system call interface must replicate output data must compare verify correctness provide redundancy process level natural basic abstraction os os view hardware thread core logical processor schedule process available logical leverage os schedule redundant process take advantage hardware massive multicore horizon tremendous amount hardware parallelism available future machine compute throughput primary concern provide way utilize extra hardware transient fault tolerance execution one redundant process logically label master process label slave process system call system call emulation unit invoke system call emulation unit perform input replication output comparison recovery emulation unit also ensure follow maintain order operate correctly original process execute system call alter system state execute master process slave process emulate system call execution among redundant process must deterministic system call return data request system time must emulate ensure redundant process use data computation source determinism asynchronous interrupt share memory access must also intercept emulate redundant process must identical address space data file table time transient fault could render one redundant process useless identical process process logically label master process give invocation emulation unit occasion transient fault program suspend watchdog alarm employ emulation unit detect fault upon entrance system call emulation unit timer begin redundant process enter emulation unit amount time watchdog alarm time signal error execution input replication model dictate data enter must replicate ensure data redundant within data pass process receive master process pass slave process system call emulation read data read file replicate copy slave process also return value system call consider input data also replicate output comparison data exit redundant process must compare correctness proceed output data match transient fault detect recovery routine invoke system call emulation write buffer pass outside must compare also data pass system call parameter consider output event leave must also check verify program correctness output deal small amount data accomplish simply copy data share memory segment compare write buffer write buffer check write system call compute locally value compare share memory local computation avoid copy large chunk memory share memory significantly increase overhead execution redundant process must transparent system environment redundant process interact system emulate system call emulation unit responsible input replication output comparison system call emulation data dependable secure compute vol six two transfer input replication output comparison accomplish share memory segment redundant process begin call emulation unit output comparison system call type system call also compare ensure redundant process common system call fault assume cause error control flow call errant system call depend upon system call system call emulation unit perform different task system call modify system state file rename link execute master process case system call actually call process master process original state redundant process emulate operation example emulate system call open new file master process create open new file redundant process simply open file without create share memory share memory access present source potential redundant process read share memory represent input data replicate write share memory represent output data compare correctness problem share memory access masquerade arbitrary load store therefore handle system io system call interface suffice device io share problem share memory access handle share memory io borrow technique virtual machine dynamic binary virtual machine trap execution privilege defer virtual machine monitor emulate privilege instruction eighteen dynamic binary application execute code cache use technique detect code case text section mark code immediate trap notify dynamic binary nineteen along line two ways handle share memory access treat system call regard share memory special case include share memory call share memory map function call flag emulate system call also perform two extra function first update share memory map include share memory include protection mode page second switch protection share memory page disallow read write upon read write one share memory trap occur trap handler decode begin emulate instruction trap occur instruction access data within emulation continue along correct input replication output comparison original trap handler invoke approach incur high overhead require trap os every read write instruction share memory region approach avoid overhead place probe offend instruction trap emulation specific instruction probe simply branch instruction overwrite original instruction branch emulation code emulation begin use memory access address look instruction access share memory region emulate appropriately input replication output comparison copy original instruction execute control branch back original program probe pay onetime cost trap avoid trap subsequent instruction asynchronous signal asynchronous signal present another form potential among redundant process figurehead process take care first part signal process provide correct signal forward signal receive redundant process however still problem execution signal redundant process problem signal call may read write data process address space redundant process call signal precisely point dynamic instruction stream may become handle asynchronous signal insert probe mark specific point code epoch twenty epoch program start end point know identical across redundant process redundant process maintain local epoch counter store number epoch pass execution signal handle defer handle epoch specifically signal handle proceed follow one figurehead process represent entire group process correct receive asynchronous signal two figurehead process send redundant process temporarily stop execution three figurehead inspect epoch counter redundant process pending signal set service epoch count equal current epoch counter plus one four figurehead process resume execution redundant process five redundant process execute epoch boundary check pending signal handle pending signal current epoch count match epoch count set signal handle redundant process transfer control signal handler al approach transient fault tolerance multicore exist program overhead timeliness signal handle example epoch place instruction signal handle immediately performance significantly degrade due check epoch hand large performance impact negligible delay signal handle may meet user implement three placement epoch system call function call backward branch different suitable different application type example policy work well application frequently use system call many function call program develop would work well policy program execute tight within function need approach approach three manage command line switch specify policy use transient fault detection transient fault detect one three ways one output mismatch transient fault propagate incorrect output detect output comparison within emulation unit point data exit output mismatch may occur system call emulation handle instruction access share memory two watchdog two watchdog timer time first case fault cause error control flow call errant system call faulty process entrance emulation unit begin wait process process enter emulation unit error detect system call mismatch mismatch data process continue execution occur second case transient fault cause process indefinitely infinite loop case next system call process except process enter emulation unit eventually watchdog drawback watchdog alarm period exist application make progress experience unload system twelve second sufficient value user specify increase load system load system spurious affect application correctness unnecessary call recovery unit three program failure finally transient fault may program failure due illegal operation segmentation violation bus error illegal instruction forth signal set catch correspond signal error flag next time emulation unit call immediately begin recovery process transient fault recovery transient fault recovery typically fit two broad repair fault mask repair involve periodic execution state fault detect execution roll back previous fault mask involve use multiple copy execution vote correct output support type fault recovery repair functionality already exist need use two process detection defer recovery repair mechanism otherwise fault mask accomplish use least three process majority vote fault mask use follow scheme use recovery use assumption three redundant process one output mismatch output data mismatch occur remain process compare ensure correctness output data majority process agree upon value output data assume correct process incorrect data immediately kill replace duplicate correct process use fork system call two watchdog mention section two case watchdog first case faulty process call emulation unit process continue execute one process emulation unit process emulation unit kill recovery occur next system call second case faulty process process except one emulation unit process kill replace duplicate correct process three program failure case program failure incorrect process already dead emulation unit simply replace miss process duplicate one remain process assume single event upset fault model single transient fault occur time however support simultaneous fault simply scale number redundant process majority vote logic vulnerability fault execution code may unrecoverable error also fault cause erroneous branch code could result undefined behavior finally mean protect os fault os execution may failure first third vulnerability mitigate compile os code fault tolerance maintain process semantics critical figurehead stay alive throughout program execution although represent single point failure figurehead perform almost real work probability transient fault affect execution low single monitor process also represent single point failure dependable secure compute vol six two fig three result fault injection campaign leave bar cluster show fault injection right bar show breakdown detect fault however monitor process concern easily replicate fault tolerance vulnerability usually associate fault checker mechanism although completely reliable partial redundancy may sufficient improve reliability enough meet user vendor reliability five experimental result paper present evaluate prototype build use pin dynamic binary instrumentation system tool use pin dynamically create redundant process use dynamic code patch system program intercept system call prototype evaluate run set compile fault coverage evaluate use fault injection campaign similar twelve one thousand run execute per maintain manageable test input use fault injection fault propagation experiment run dynamic instruction execution count profile application use randomly choose specific invocation instruction fault select instruction random bite select source destination register inject simulate transient error pin tool instrumentation use change random bite specify dynamic instruction utility execution count include within harness use determine correctness program output performance evaluate use reference input performance measure run prototype two three redundant process without fault injection system specifically system four cache six memory run red hat enterprise release four fault injection result fault injection study perform illustrate effectiveness well benefit use model fault detection fig three show result fault injection campaign leave bar cluster show fault injection right bar show detect fault possible give follow one correct benign fault affect program two four correctness incorrect program execute completely return correct return code output incorrect three abort due program return invalid return code fail due program terminate segmentation violation five mismatch occur run case mismatch detect output comparison six occur run case signal handler detect program termination watchdog alarm ignore occur infrequently five percent time general able successfully eliminate fail abort incorrect output comparison detect incorrect abort case turn error detect mismatch case similarly detect fail case turn case occasionally small fraction fail case detect mismatch indicate case able detect mismatch output data failure occur approach effective detect fault base effect execution fault affect correctness generally detect contrast swift twelve currently advance approach detect roughly seventy percent correct fault thereby avoid false however correct case fault injection remain correct detection model would suggest mainly occur particular al approach transient fault tolerance multicore fig four distribution number execute injection detection fault normalize run detect via output mismatch program failure combine show many original correct case fault injection become detect mismatch case inject fault cause output data different data regular run however output difference occur print float point number log file allow certain tolerance float point consider difference within acceptable bound compare raw output detect fault data match issue less effectiveness model relate definition application correctness fault propagation fig four show number execute fault injection detection run show stack bar show breakdown execute fault detect leftmost bar label show mismatch run show fig three middle bar show breakdown run leave bar show detect fault include mismatch general mismatch run tend detect much later point fault injection fault propagation instruction count nearly hand run higher probability detect early across detect run wide variety amount fault propagation range low amount fault propagation even distribution run among various model delay detection fault error certain via program failure incorrect data exit however delay detection also mean fault may remain latent execution unbounded period time future work remain characterize fault propagation well explore bound time fault remain undetected however issue outside scope paper performance result performance evaluate use two redundant process fault detection three process support recovery fig five show performance compile compiler flag performance normalize native execution time provide transient fault tolerance program average overhead percent overhead percent overhead program incur percent overhead percent overhead overhead due fact multiple redundant process system program place higher demand system result higher overhead optimize stress system higher cache miss rate therefore higher overhead number redundant process increase increase burden place upon system memory controller bus well cache coherency implementation similarly emulation call process increase synchronization semaphore usage share memory may decrease performance certain point system saturate performance severely impact case observe run overhead system resource saturation point explain detail section overhead breakdown performance overhead consist contention overhead emulation overhead show stack bar fig five contention overhead overhead simultaneously run redundant process share memory system bus contention overhead measure run application multiple time independently compare overhead execution single run roughly simulate run redundant process without synchronization emulation note overhead purely redundant process figurehead monitor process perform little computation dependable secure compute vol six two fig five overhead run set optimize run include compile b c performance overhead negligible rest overhead consider emulation overhead emulation overhead due synchronization system call emulation fault detection incur set contention overhead significantly higher emulation overhead relatively high cache miss rat lead high contention overhead increase memory bus utilization hand substantially utilize emulation unit result high overhead contention overhead contention overhead mainly stem share memory multiple redundant process study effect contention overhead construct program generate memory request periodically miss cache fig six show effect cache miss rate contention overhead run cache miss rate substantial effect contention overhead less five million cache miss per fig six contention overhead vary cache miss rat contention overhead minimal however second beyond point contention overhead increase greatly ten million cache miss per second incur thirteen percent overhead incur percent overhead result indicate total overhead use highly impact cache memory behavior protect transient fault low overhead may suffer high emulation overhead emulation overhead mainly consist synchronization overhead overhead transfer compare data share memory examine aspect emulation overhead two synthetic program design run first program call time system call rate time one simpler system call support use measure emulation overhead barrier within emulation unit second test program call write system call ten time second write number per system call write call emulation unit transfer compare write data share memory fig seven show effect synchronization overhead synchronization overhead minimal emulation unit call per second less five percent overhead use two three redundant process afterward emulation overhead increase quickly overall result indicate technique might best deploy specific application without significant system call functionality fig eight illustrate effect write data emulation overhead experiment evaluate amount data system call must compare redundant process write data similar system call synchronization achieve low overhead cutoff point case experimental machine evaluate overhead minimal write data rate stay less one increase substantially point al approach transient fault tolerance multicore fig seven overhead vary system call rat demonstrate synchronization emulation overhead simple system call fig nine additional overhead support share memory access receive handle asynchronous signal signal asynchronous nature slight delay manageable however would like avoid large delay signal handle may greatly impact application provide idea delay period signal handle study number execute various within fig ten show breakdown number use describe section good policy general execute system call majority still one billion perform much better reduce within manageable range however still significant amount large reason execute long run loop within function hit epoch often move policy remove limitation provide within consistently analyze additional performance overhead handle signal set two redundant process fig eleven graph show normalize overhead use three overall incur negligible overhead across policy incur higher overhead vary across depend rate backward branch per application example application nearly two time overhead vary greatly incur almost negligible overhead overall policy attractive policy ability handle signal within negligible performance overhead six relate work similar version hardware transient fault tolerance sixteen aim provide functionality wang al propose compiler infrastructure redundant achieve fig eight overhead various data demonstrate overhead compare share memory output comparison share memory support measure performance support share memory develop synthetic periodically write share memory region fig nine show additional performance overhead run synthetic various share memory write rat run two redundant process use low rate share memory access lower access per second performance negligible share memory access rate increase access per second overhead increase reasonable five percent overhead higher access rat result large increase performance overhead note overhead show purely overhead due support share memory addition share memory write rat increase approach outperform approach overhead mostly dominate synchronization communication use probe able reduce trap overhead support asynchronous signal handle asynchronous signal defer signal handle within redundant process epoch approach introduce delay dependable secure compute vol six two fig ten number dynamic execute three support asynchronous signal f b fig eleven additional normalize overhead incur support asynchronous system call use three f b nineteen percent overhead addition special hardware communication queue attain similar overhead rely fact multiple exist addition require source code operate executable thirty explore placement within scheme explicitly check control flow execution eleven approach provide different model transient fault tolerance use equivalent commonly accept model pi bite thirteen check explore follow propagation fault attempt detect fault affect program behavior model accomplish task scale approach similar body fault tolerant work explore use fault tolerance twenty eight body work target hard fault hardware power assume execution processor stop event failure transient fault assumption hold far know provide first performance evaluation overhead breakdown use redundant process multicore recently process propose provide service fault tolerance diehard propose use replica machine tolerate memory exterminator forty use process detect memory diehard exterminator briefly mention use process elaborate challenge shadow profile propose use process parallelize dynamic binary instrumentation use process profile advantage correctness necessary profile information correctly follow execution trend good enough result get away completely handle project extend implement process hard fault apply transient tolerance multicore machine best knowledge robust implementation process ability handle share memory access asynchronous signal fault number previous approach program replication program use three different application tolerate use time redundant technique execute application multiple time use majority vote virtual duplex combine program time redundancy tandem nonstop cyclone seven custom system design use process transaction process chameleon infrastructure design distribute use various armor process al approach transient fault tolerance multicore implement adaptive fault tolerance figurehead process similar respect fault tolerant manager monitor process similar heartbeat armor redundant process similar execution armor however design different mind chameleon provide adaptive fault tolerance distribute design provide transient fault tolerance multicore seven conclusion paper motivate necessity transient fault tolerance propose attractive alternative emerge multicore provide redundancy process level leverage os freely schedule process available hardware addition deploy without application os underlie hardware real prototype support present evaluate fault coverage performance fault injection experiment prove fault detection model effectively detect fault safely ignore benign fault experimental result show run optimize set machine provide fault detection percent overhead performance improve upon exist transient fault tolerance take step toward enable fault tolerant comparable performance hardware work support author would like thank anonymous anonymous comment preliminary work present paper author would also like thank rest architecture research group insightful comment helpful discussion two reference one soft commercial semiconductor technology overview scale trend reliability physics tutorial note reliability se al predict number fatal soft national laboratory q device reliability vol five three sept al impact scale error rat logic process technology digest technical paper three four al scale trend cosmic ray induce soft static latch beyond eighteen circuit digest technical paper five al design micro vol nineteen two seven horst al multiple instruction issue nonstop cyclone processor ann l computer architecture eight redundant primary flight computer vol one j al experiment soft fail computer electronics j research development vol forty one nine ten n oh al error detection duplicate reliability vol one march eleven n oh al check reliability vol one march twelve ga reis al swift implement fault tolerance l code generation optimization thirteen c weaver al reduce soft error rate l computer architecture fourteen n wang al come fork road take l parallel compilation pact fifteen wang j patel characterize effect transient fault processor pipeline l dependable network four june sixteen transient fault detection via simultaneous ann l computer architecture seventeen j da use redundancy exploit multiple core transient fault tolerance l dependable network seven june j smith r virtual machine versatile process morgan eighteen nineteen maintain consistency bound capacity code cache l code generation optimization five march twenty schneider operate system system l transparent compute opportunistic detection l computer architecture k z purser e improve performance fault tolerance ninth l architectural support program operate al pin build program analysis tool dynamic instrumentation program language design implementation al recovery chip l computer architecture al detail design evaluation redundant l computer architecture z purser k e study ann l micro zero e approach fault tolerance ann l compute c wang h kim v redundant transient fault detection l code generation optimization thirty hiller executable detect data embed control l dependable network six h al thirteen fifth generation design three hiller al placement detection data l dependable network dependable secure compute vol six two k z metrics strategic placement l pacific rim dependable compute experimental evaluation two concurrent error detection scheme l compute k cheng recovery use simultaneous l computer architecture borg w w f w fault tolerance computer vol seven one p r p harry p somersault technical report white paper alto ca al sift design analysis computer aircraft control vol ten schneider approach design compute compute vol one three august berger diehard probabilistic memory safety unsafe program language design implementation forty g berger exterminator automatically correct memory program language design implementation seven june peri shadow profile hide instrumentation cost parallelism l code generation optimization k hazelwood parallelize dynamic instrumentation performance l code generation optimization seven march ge e z g j process semantics design high performance compute l j high performance vol nineteen four r approach fault tolerant cluster compute approach engineer vol eleven twelve j j p j experimental evaluation execution application l dependable network k b hardware fault diagnosis diverse l diagnostics dynamic double virtual duplex approach l work dependable compute critical z k chameleon infrastructure adaptive fault tolerance parallel distribute vol ten six june receive degree computer engineer university degree computer engineer university colorado currently candidate electrical engineer computer science department northwestern university research interest include reliability dynamic optimization computer student member receive degree computer engineer university degree electrical computer engineer university colorado currently candidate department computer science university colorado research interest include system reliability dynamic optimization assist parallelization student member receive degree computer science institute technology currently candidate department computer science university colorado research interest include reliability profile optimization janapa receive degree computer engineer university degree computer engineer university colorado currently candidate electrical engineer computer science department university research interest include virtual machine program introspection optimization student member receive degree electrical engineer university professor department electrical computer engineer university colorado research interest architecture computer dynamic optimization compute advance compiler optimization director research group teach nominate eta kappa nu c outstanding young teacher award young electrical computer engineer member information compute topic please visit digital library