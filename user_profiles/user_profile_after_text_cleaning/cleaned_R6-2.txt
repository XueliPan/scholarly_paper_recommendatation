architectural support dynamically avoid atomicity university research abstract paper propose architecture detect dynamically avoid single atomicity violation bug key idea group relate data color monitor access interleave color space enable detection atomicity involve data color leverage support maintain color information efficiently keep recent color access dynamically avoid atomicity insert ephemeral prevent erroneous interleave two operation one mode make detection precise produce false collect information two deployment mode provide robust efficient dynamic bug avoidance less precise detection make useful throughout lifetime program development result show deployment mode able successfully avoid majority atomicity bug well large apache mode detect bug false subject processor multiple data stream program concurrent program engineer test general term design reliability bug avoidance atomicity concurrency data color permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten june copyright one introduction concurrency bug easy create difficult fix addition make bug difficult reproduce complicate test nevertheless ubiquity add pressure write multithreaded code take advantage increase parallelism trend spur interest concurrency bug detection tool many tool propose detect bug lock discipline atomicity eleven however overhead incur high motivate proposal architectural support eleven fourteen fifteen nineteen thirty unfortunately even sophisticate tool thorough test eighteen hard bug still make deployment reason recent research also propose improve reliability multithreaded execution dynamic concurrency bug avoidance fourteen twenty decrease probability concurrency bug actually manifest field past work architectural support concurrency deal bug involve single variable make fundamentally limit help wide variety defect likely reason complexity ie state require number case consider concurrency bug detection grow quickly number involve also long ago belief bug rare however recent work twelve thirteen show concurrency bug much common expect need general single concurrency bug use single set simple architectural moreover justify architecture support must useful system lifetime development deployment gap paper fill work focus atomicity especially challenge pervasive category concurrency occur overlook need atomicity set memory access fail enclose inside critical section allow interleave remote lead wrong behavior make tricky occur even program free accord recent study al thirteen atomicity account concurrency study also show fraction atomicity violation involve multiple however prior work eleven fourteen address atomicity subset atomicity thirty therefore miss fraction important concurrency bug paper make observation combine share variable protect lock l length share char protect lock l thread one lock l temp unlock l thread two lock l temp unlock l temp temp lock l temp unlock l lock l temp unlock l thread one lock l unlock l lock l length unlock l thread two lock l unlock l lock l length fifteen unlock l b atomicity violation concurrent might lose update atomicity violation thread one read inconsistent figure one b atomicity violation example b set color perform check color rather individual allow us detect avoid single atomicity leverage insight assign color synchronization four combine analysis bug detection eleven thirty avoidance fourteen propose combine novel way group color detection mechanism treat set single unit detect erroneous interleave access data fundamentally enable us detect atomicity result provide dynamic bug avoidance use ephemeral prevent unintended interleave different prior work avoidance fourteen require architectural complexity avoid general class bug two operation one mode collect information make detection strict reduce false two deployment mode provide robust efficient dynamic bug avoidance make detection less strict detect potential bug make useful throughout lifetime program development therefore compel processor moreover use almost exactly rest paper section two provide background information atomicity contrast single bug section three describe provide description work section four provide detail description architectural section five discuss framework base section six present evaluation deployment mode section seven discuss relate work section eight conclude two background atomicity consider example show figure one share variable two thread simultaneously read write inside critical section program free however still incorrect write thread two interleave read write thread one counter increment lose example miss atomicity seven since read write atomic avoid unwanted interleave access thread example atomicity violation since involve access additionally interleave say uninterleaved execution access result final state interleave execution al eleven provide list memory single variable contrast consider example figure one b classic example atomicity violation two share length use express relate string thread one read pointer thread two update cause thread one read value length inconsistent value read could later result crash even worse silent data corruption note access individual variable consider separately read write characterize atomicity violation conversely make observation length consider together unit atomicity violation clear two read unit thread one interleave write unit thread two moreover access respect unit since uninterleaved would produce result interleave one ensure figure one behave intend programmer need enclose memory inside critical section instead critical section none whatsoever al provide analysis access involve two work employ idea detect interleave detect atomicity also detect avoid atomicity fundamentally harder elusive next section explain three detect avoid atomicity explain group color enable detection atomicity focus describe conceptual use detect dynamically avoid atomicity section four describe actual architecture implementation paper refer atomicity also imply isolation leverage data color detect atomicity uniquely challenge code may contain atomicity respect single variable recall example figure one b example see atomicity violation consider length single unit data concept consider group together instead single alone cornerstone propose associate color share give relate color monitor interleave access color determine whether contrast past eleven fourteen monitor interleave access individual address example figure one b length would give color since semantically correlate color space example consist two read interleave least one remote write color table one discuss type interleave note case fourteen point view well case five however multiple involve understand case five consider example figure two write thread two interleave write thread one leave consistency length compromise may point length value ten note length give color color access interleave describe case interleave description one two three four five interleave write make second read see inconsistent data w r w second write write data base w w w r w r w w w interleave write leave w stale inconsistent data read get data interleave write inconsistent interleave read get inconsistent data data inconsistent figure two group correlate color perform atomicity violation detection base access color oppose memory address greatly simplify detection atomicity one think reduce high complexity detect atomicity twelve complexity detect atomicity length share char thread one lock l unlock l lock l length ten unlock l thread two lock l unlock l lock l length fifteen unlock l figure two example case five table one length leave mutually inconsistent color data program data structure color either manually automatically one hand manually color data encode precise information data automatic color hand require programmer effort may yield less accurate correlation information main use manual color manual color require source code programmer express semantic relationship reasonable expect programmer manually color data correctly programmer likely start bug report identify data involve bug describe furthermore group relate data manually use past work simplify specification synchronization data atomic set color four lock discipline seventeen past work show express data group excessively difficult since require reason data point declaration contrast correctly implement synchronization write code require complex global reason every access automatic color primarily useful bug avoidance better suit task manual color require programmer anticipate potential bug color involve data instead data color accord heuristic many ways automatically color data example could assign color field block memory allocate call even entire object instance use exhaustively explore different color beyond scope paper however explore manual color automatic color give reader flavor evaluate one automatic color technique give color data allocate together past work address ways find twelve thoroughly address atomicity work complementary use color data detect section explain detect actual interleave mode next section explain deployment mode atomicity violation detection mechanism use consist three conceptual one history access perform local processor local history two history access perform remote remote history three set rule determine whether interleave access history important note interleave necessarily atomicity however atomicity violation manifest necessary interleave happen moreover interleave especially short window strong atomicity violation bug eleven fourteen hence identify likely bug detect interleave since goal detect whether access color access keep term color mean data address memory access need translate color insert history local access insert local history local processor perform remote access build coherence protocol read invalidate request insert remote history table one access interleave color interleave length share char give color red thread one lock l unlock l lock l length unlock l one four thread two lock l unlock l lock l length fifteen unlock l two three thread one history two three red red local history one red four red two three invalidate coherence event processor run thread two red red interleave red case one b history e p l e n local history red red different set compare deployment mode c figure three overview detect atomicity number dark circle denote order happen b processor receive request local remote keep separately retain information relative order group local remote access detect atomicity determine whether interleave table one exist local remote figure three show example process use code figure one b reproduce figure three contain atomicity violation involve two length color red number dark circle denote order access access insert correspond history happen figure three b access two three perform thread two generate invalidate coherence message insert write thread one remote history two three soon access four perform detect access history match case one table one two read interleave write one might wonder long history need capture majority interleave indicate bug recent work thirteen fourteen show many know bug window fairly small order intuitive longer distance atomic higher chance bug manifest test therefore hard bug tend occur short window deployment mode previous section describe call mode detect interleave actually deployment mode attempt dynamically avoid atomicity one detect atomicity violation likely happen two dynamically start special form transaction ephemeral transaction prevent interleave happen deployment mode aim detect potentially interleave relate atomicity avoidance mechanism trigger interleave actually happen prevent happen relax criterion use detect interleave mode cover interleave could potentially happen precisely define potentially interleave pair memory access local history interleave access remote history would accord table one example consider scenario figure three remote write red happen remote history window even actually interleave read red local history would detect potentially interleave figure three c illustrate difference deployment mode intuition behind definition potentially interleave observe interleave almost happen could observe actual interleave future point execution could result atomicity violation manifest try avoid possible potentially interleave fact benign access case effect initiate unnecessary bug avoidance potentially interleave detect color data access insert set call access data whose color trigger ephemeral transaction finite size ephemeral transaction make short period execution begin access appear execute atomically isolation effectively prevent unwanted interleave remote access happen goal ephemeral transaction begin first instruction atomicity violation long enough cover local memory access involve violation consequently prevent manifestation ephemeral dynamically infer correspond program annotation important point ephemeral insert way break semantics program since result interleave access ephemeral still valid interleave respect program semantics section provide detail four architectural support need four basic architectural support data color section recent memory access term color section mean detect interleave base access section bug avoidance way maintain set color involve interleave together support ephemeral section correctness problem typically performance problem either system provide hook programmer disable avoidance action performance sensitive part code support data color represent color data memory tag several support memory tag various purpose security information flow track six support new program model four support choose design similar four base memory protection scheme provide efficient way associate protection information arbitrary memory use hierarchical table use structure store instead permission information call table color table base number color require use experiment use field color table reside memory accessible range address expand keep information desire granularity word line page color buffer directly cache color information color table provide fast look address processor check case miss processor fetch entry color table memory update color information write color table color table write need eventually update immediately tolerate transient color information incoherence since affect program semantics way note provide support data color example propose tag mechanism tag associate whole page necessary expand individual word provide tag scheme would also adequate purpose yet another alternative would add field per cache line basis opt three reason one want allow arbitrary color without force user adjust data layout two color table space efficient three want touch sensitive structure memory hierarchy color access processor store information recent history color access history buffer history buffer hold four type one local read two local write three remote read four remote write keep worth history therefore need way keep use searchable fifo choose encode color access two way four history type signature file organize fifo queue signature memory access arbitrary number dynamic since color instead individual address record amount imprecision low figure four show color access signature file divide execution program arbitrary length sequence consecutive dynamic history item set four one history type contain color access collect epoch figure four b show complete history buffer set history cover last n execution epoch end local remote access start encode next history item summary history item hi consist local read signature local write signature signature reference history item total history window color access signature file read write zero one zero one read write zero one zero one local history remote history b history buffer total history window figure four keep color access history remote read signature remote write signature note sacrifice information relative order within history item information relative order across history preserve though determine history item granularity assume fix total history window one precision versus cost smaller history improve precision preserve relative order information suffer less signature history use less storage comparison logic since history necessary consequently intersection need perform collect local access information local access information easily obtain use mechanism describe section look load store issue locally result encode appropriate local read write current history item epoch complete access start insert next history item collect remote access information record remote color access require minimal additional cache coherence protocol support collect color information remote access augment coherence request without affect coherence protocol functionality way read miss retrieve color information data access actual reference address oppose block address append coherence request send potential processor receive read request remote processor add request current remote read signature likewise invalidate request generate write miss write share miss augment receive add current remote write signature need color information access communication sufficient coherence protocol message detect interleave detect interleave intersect history buffer signature intersection simple bitwise example suppose want detect whether case one table one happen history buffer use figure four b compute j j value k depend whether mode deployment mode figure five discuss shortly result signature empty likely execution contain interleave involve color result set test zero one zero one k zero j one zero one one recent empty report interleave involve mode zero one k add b deployment mode figure five detect interleave mode b deployment mode actual interleave consider test current access local history item remote history k b remote history consider test local history item follow local history item j possible remote history k zero n one remain case table one analogous except applicable type intersect two issue remain one determine evaluate detection expression two choose value k depend whether mode deployment mode wise operation detection result upon memory access processor check whether access start ephemeral transaction prevent potentially interleave ephemeral transaction already progress event ignore ie nest mode mode want detect interleave actually occur also want know instruction address memory operation lead interleave therefore choose k k use set contain recent memory operation issue locally second local set intersection instead possible imply history actually interleave history item hi recent memory operation consider figure five illustrate process result set empty interleave involve memory instruction report include instruction address type interleave case table one note efficiency set need evaluate scratch every memory operation partial intersection local remote history reuse correspond history push history buffer deployment mode deployment mode want detect potentially interleave hence perform consist pair distinct local remote signature regardless whether history actually interleave ie k zero n one show figure five b result set empty add also need know instruction lead potential atomicity violation need color enable dynamic avoidance allow us perform detection end epoch instead memory access significantly decrease frequency intersection implement ephemeral mechanism perspective ephemeral like typical memory nine unlike regular though ephemeral implicit rely code guarantee set dynamic always execute atomically isolation ephemeral provide strong atomicity since must roll back event conflict remote access attempt execute guarantee forward progress provide mechanism recognize repeat reduce size ephemeral transaction able commit fall back execution discussion hardware complexity although require additional hardware support argue cost reasonable leverage well understand technology keep track set address memory tag propose memory protection five use hierarchical data structure map memory tag keep storage manageable buffer logic require handle history simple since base address two additional support coherence protocol involve extra field request message change protocol state machine finally support transactional memory consider actual one support dynamic avoidance variable atomicity whenever potentially interleave happen deployment mode add color involve processor set also encode signature bite five develop methodology mode key idea reduce rate focus likely indicate bug reduction false assume mode run program multiple time type kernel full name description bug ex type update string buffer offset length inconsistent data read read flag conditional write interleave invalidate data update string buffer length inconsistent data read remote read table update flag update interleave make table inconsistent interleave read flag indicate content load pane content load character buffer string length make inconsistent concurrent access update log inconsistent data read signal handler access log order highly concurrent access replay log nineteen fourteen table two bug use evaluate execution buggy observe outcome crash data execution collect output produce set detection compose instruction address interleave detect type interleave table one detection buggy run add execution add produce set contain detection interleave occur buggy run point code developer focus locate bug section show simple technique actually prune false six evaluation evaluate assess well deployment mode dynamically avoid atomicity section performance cost section understand design section section understand usage section assess accurately mode locate bug code section experimental setup develop simulator use pin binary instrumentation framework sixteen simulator model structure include color table translation data address color history buffer interleave detection use signature history support simulator model deployment mode mode produce interleave detection output use framework deployment mode simulator determine often atomicity avoid determine whether violation execute entirely within assess performance impact model conflict use variety consist bug full table two provide description kernel application along portion dynamic execution spend buggy code column four interleave pattern cause bug column five bug segment buggy code extract full extract five various project previously discuss literature twelve thirteen pay special attention maintain original data structure layout code surround bug full use parallel accelerator apache server exercise buggy apache use script repeatedly launch concurrent request exercise bug use version modify execute many concurrent request bug involve signal handler exercise buggy code fetch file network resource interrupt transmission signal experiment manual color describe section perform manual color add explicit code associate color data simulator monitor call memory allocation function assign new color allocate region deployment mode bug avoidance start show able avoid instance atomicity bug experiment total history window ie thirty history table three show number violation instance avoid avoid manual zero zero zero table three avoid bug full use manual data color use different system configuration explain detail bug avoid nearly violation instance use manual color capable avoid almost atomicity effective bug involve access one global variable one dynamically allocate variable allocate together use capture correlation result unable avoid bug table three show avoid nearly violation instance full application run avoid virtually instance violation use manual slightly lower rate avoidance trigger access data unrelated violation end prevent useful proceed run avoid instance violation use manual color bug involve dynamically allocate variable global variable unfortunately unable identify correlation unable avoid violation instance use standard configuration violation nearly long execute entirely within rerun use total history window configuration avoid use manual color use avoidance lower use configuration longer trigger response false positive prevent useful begin much longer window could avoidance happen chance comparison random ephemeral one may wonder whether bug avoidance achieve would possible simply start random point show case consider experiment use use random start five per dynamic rate transaction start use standard avoid eighteen able avoid use configuration perform experiment see random avoid avoid result similar stark contrast show avoidance perform significantly better chance deployment mode impose modest impact performance discuss quantify key source color support leverage exist cache coherence support handle exchange color information result communicate color information impose negligible overhead interconnect traffic overhead associate communicate likely problematic small communicate subset cache miss color information depend scheme underlie free cost minimize use cache information moreover color information mostly ie write allocation time mean additional overhead associate write unlikely affect performance finally regard energy structure use store color information similar like amount small fraction total power consumption main source performance degradation namely bookkeeping overhead due conflict table four report percentage dynamic trigger start number useful prevent atomicity violation useful percentage useless experience conflict useless conflict report number start fraction total number dynamic quantify often overhead start incur fraction useful measure often cost prevent violation fraction conflict useless approximation amount work waste serve purpose still table four also show fraction total dynamic execute inside execute useful useful execute useless conflict useless w conflict report data full execute tight loop around buggy code make unsuitable analysis two important result data first rate trigger low three per five per useful start useless useful conflict useless w conflict two five three ninety five eleven twelve table four rate start useful conflict useless full deployment mode run use color manual color run modify configuration twenty per low frequency start indicate cost start end verify little effect performance also see relatively small fraction execution execute transactionally second little computation waste useless data show fraction useful range first glance may suggest useless frequent hence problematic however rate abort useless low five work waste useless abort amount small fraction dynamic eleven thus useless rarely experience conflict little work waste useful likely abort consider profitable sacrifice small amount performance exchange prevention buggy behavior additionally small fraction execution execute useful incur higher likelihood abort sensitivity ephemeral transaction length table five show avoidance application size vary bug consider except long bug avoidance stable size show size within range insensitivity size show two one large inhibit avoidance capability two flexibility selection design parameter choose default size smaller risk unable avoid modestly large increase chance unnecessary abort avoid table five stable bug avoidance variety size mark run use manual color bug involve global heap run sensitivity history buffer configuration history buffer configuration determine interleave observable affect interleave detect evaluate effect vary granularity history history buffer history history e l f e f e g n e c r e p fourteen twelve ten eight six four two zero inject noise bug kernel simulate concurrent access share data add noise allocate array random unrelated bug kernel randomly one array give color data bug add five extra thread program spin loop repeatedly access noise data iteration make random number access one ten determine whether read write flip coin noise level parameter inverse size array noise data higher noise level smaller array higher noise level higher probability random access array access element color data involve bug figure six show avoidance presence noise fix total instruction history use history data show noise level decrease avoidance improve note though avoidance still effective even highest noise level see improvement noise decrease number trigger access unrelated bug decrease permit useful proceed recall nest history history e v n l v f n e c r e p ninety eighty seventy sixty fifty forty thirty twenty ten zero ten twenty thirty forty fifty sixty seventy eighty ninety noise level figure six atomicity avoid kernel synthetic noise fine history constant history window figure also show use fine rather history improve avoidance reason history encode relative order memory access precisely use coarse history access occur within history item consider simultaneous prevent see interleave access history use able observe interleave enable detection buggy interleave figure seven show proportion useful experiment inverse relationship noise level fraction useful relationship corroborate conclusion avoidance slightly impede presence noise useless occur data also show use history result fraction useful agreement find figure six history lead precise detection characterize size color derive total number necessary color experiment use saw color around color many color use manual color saw single color case five color number represent ten twenty thirty forty fifty sixty seventy eighty ninety noise level figure seven percentage useful synthetic noise total history length vary history item total number color execution choose use twelve represent color manual color twelve provide ample space accord experimental result use capacity issue frequently allocate memory one way handle recycle color associate memory also additional cost could implement field mode locate bug code focus full experiment collect report interleave generate use manual color possible present comparison detection capability deployment mode versus mode show effect detection policy quantify report term code point ie line code inspect use mode report large number detection code point apply process saw mark reduction much smaller set would lead programmer directly bug short would help programmer decide manually color data foresee useful data structure suspect relate bug manually color developer consider reasonable assume programmer would able give standard bug report output use knowledge data structure program realistic assume programmer manually color data require local reason data declare allocate reason sort basis prior focus synchronization model four ten table six show number code point produce use manual color show result deployment mode column two mode column three use invariant approach describe section five column four notably able detect bug two false three code point deployment mode one false positive two code point mode detect bug handful false well deployment mode mode two stand amongst data first decrease deployment mode mode mode policy determine interleave section reduction approximately code point number code point report seventeen four code point however improvement still desirable even necessary code point leave sift bring us second result reduction report result apply process dramatic prune eliminate false leave forty code point analyze package million line reduce number code point report eight show couple manual color approach lead false virtually none reason invariant base approach work well many run buggy run term interleave filter approach leave relevant deployment three two twenty two eight forty table six number code point report use deployment mode mode mode invariant seven relate work several major prior work architectural support concurrency bug detection first provide general solution support atomicity violation detection second detect also dynamically avoid atomicity field finally set use deployment make useful throughout lifetime system fourteen leverage observation execute program continuum implicit three nine decrease amount interleave memory access thread potentially avoid atomicity detect atomicity manipulate implicit avoid address general problem atomicity detect rely continuous implicit rather ephemeral simpler less costly addition drastically false eleven one first architectural support atomicity violation detection useful monitor interleave extend cache inherently limit atomicity contrast use history buffer color access cache use train run extract interleave check hold future run inspiration framework twelve propose static analysis detect data address atomicity twenty avoid concurrency happen one thread correctly follow lock discipline thread detect condition determine atomicity critical section violate via analysis similarly detect programmer annotate code declare lock discipline avoidance mechanism use base keep shadow copy data speculatively update commit end critical section violation detector thirty heuristically infer atomic section base control data detect atomicity atomicity infer section author briefly mention technique could use hardware support avoid bug via global restart detect avoid class bug inclusive analysis data correlation information also differ avoidance prevent potential bug without costly global interleave constrain share memory bug avoidance technique base build test use architecture support enforce run time encode set static memory use avoid bug encode correlation memory cornerstone require train phase enable avoidance whereas moreover require check whether memory access allow proceed author claim do binary rewrite hardware support finally focus avoidance unclear whether false would tolerable object race detection technique dynamic race detection track access level object object race detection detect atomicity relate track whole object similarly use color data color however general need follow object tie specific category four architecture support program model base data color programmer group relate color system automatically infer critical section dynamically al propose implementation model object orient group data atomic set compiler infer critical section two piece work relate use data group convey information none use information bug avoidance recently concurrently work hammer al eight use atomic set violation detection program require go beyond group object atomic set also require annotate expect atomicity work detect automatically high accuracy eight share memory parallel program challenge believe extremely important provide support program still likely bug elude make bug avoidance field appeal advocate support bug detection also enable dynamic bug avoidance make useful throughout lifetime propose architecture provide cise detection dynamic bug avoidance general cover single atomicity could extend support form bug key idea group correlate color monitor access interleave color space enable detection bug involve set single variable two operation mode produce detail information atomicity may happen deployment mode perform less strict detection automatically start ephemeral avoid erroneous interleave without affect semantics program result show deployment mode able avoid virtually bug vast majority full apache impose little performance overhead addition mode yield false use simple technique prune spurious report thank anonymous helpful feedback thank group university invaluable feedback manuscript insightful work support part grant research faculty fellowship gift research nine reference one advance synchronization facility propose architectural specification march two l j tuck c j bulk speculative thread international symposium computer architecture three l j tuck p j bulk enforcement sequential consistency international symposium computer architecture four l p c j architectural support synchronization international symposium computer architecture five chang storage architecture program computer six dalton h c flexible information flow architecture security international symposium computer architecture seven c type effect system atomicity conference program language design implementation eight c hammer j f tip dynamic detection international conference engineer nine l v wong b j b prabhu h c k transactional memory coherence consistency international symposium computer architecture ten c monitor operate system structure concept international conference architectural support program operate twelve park c x w z li r automatically infer access detect relate semantic concurrency bug symposium operate system thirteen park e learn comprehensive study real world concurrency bug international conference architectural support program operate fourteen b j k l detect survive atomicity international symposium computer architecture fifteen b l find concurrency bug communication graph international symposium sixteen c r r muth h g v k hazelwood pin build program analysis tool dynamic instrumentation conference program language design implementation seventeen b f gay e brewer synchronization inference atomic section symposium program eighteen chess systematic stress test concurrent international symposium program synthesis transformation nineteen j use speculation data race multithreaded cod international symposium computer architecture twenty g v k dynamically ensure isolation concurrent program international conference architectural support program operate p b r k detect tolerate asymmetric race annual symposium practice parallel program k de fully integrate practical system computer l yen hill k implement transactional memory international symposium savage burrow g nelson p eraser dynamic data race detector multithreaded program computer e f r p j smith implement international conference pervasive service f tip j associate synchronization data language symposium program eleven j f detect c gross object race detection atomicity via access interleave conference program b international symposium computer architecture e j cat k memory protection international conference architectural support program operate thirty r hill violation detector server program conference program language design implementation j case interleave constrain international symposium computer architecture n h dalton c hardware enforcement application security use tag memory symposium operate design implementation p r hard race detection international symposium computer architecture