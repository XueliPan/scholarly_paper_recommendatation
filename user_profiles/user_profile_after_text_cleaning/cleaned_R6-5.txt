find concurrency bug communication graph department computer science engineer university abstract incorrect thread synchronization often lead concurrency bug manifest difficult detect fix past work detect concurrency bug address general problem fashion focus mostly data race atomicity use graph represent multithreaded program execution natural nod represent static edge represent communication via share memory paper make fundamental observation basic graph encode enough information enable accurate bug detection propose communication graph new kind communication graph encode global order information embed communication build bugaboo simple generic framework accurately detect complex concurrency bug framework collect communication graph multiple use detect graph build two bugaboo fully implement suffer rely custom architecture support negligible performance degradation require modest commodity multicore processor use deployment evaluate use apache parsec several result show bugaboo identify wide variety concurrency bug include challenge bug often zero unnecessary code subject processor multiple data stream engineer test program concurrent program general term design reliability permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee micro nine new york copyright one introduction multithreaded become ever important need enable productively write concurrent program motivate development several tool concurrency several concurrency bug main discuss literature data race lock discipline atomicity order past work concurrency error typically cover category separately example seventeen detect data race provide replay nine ten detect atomicity use base identify interleave eraser eighteen detect lock discipline use algorithm greatly help identify concurrency bug address general problem piecemeal way moreover current tool adequately address less class bug order bug involve multiple eight communication graph convenient representation basic communication graph program execution nod represent memory edge represent communication via concurrency lead abnormal communication may therefore manifest communication graph multithreaded execution consequently bug manifest intermittently different lead different graph examine many graph possible identify anomalous communication consequently bug likely biggest advantage approach general rely specific class bug key challenge however build communication graph enough relevant information encode insufficient information encode bug may render graph paper make fundamental observation basic communication graph encode enough information enable general concurrency bug detection address problem propose communication graph new kind communication graph use communication context encode access order information communication form capture sequence recent communication observe thread develop bugaboo complete system leverage graph provide efficient accurate bug detection useful development deployment paper make follow one propose communication graph two propose two approach process communication graph accurately locate bug code one fully automatic one semi length protect lock l char protect lock l thread one lock l unlock l lock l length unlock l thread two lock l unlock l lock l length fifteen unlock l thread one thread two void q q do true q delete q void q q do return zero b atomicity violation thread one read inconsistent order violation thread one call thread two wait conditional variable program crash figure one atomicity violation order violation dash represent buggy interleave automatic three describe implementation bugaboo propose base set architecture commodity multicore system bring performance collect communication graph nearly zero four show use production run five evaluate show able identify complex bug include require code programmer remainder paper organize follow section two describe common type concurrency section three show communication graph limit generic bug detection explain communication graph solve problem section four describe bugaboo implementation section five elaborate framework section six evaluate bug detection accuracy characterize finally section seven discuss relate work section eight conclude two concurrency bug several type concurrency well know data race data race occur two memory different thread least one write access memory location order relationship synchronization absence data race however imply lack concurrency defect major type concurrency bug atomicity order occur absence data race atomicity four happen memory suppose execute atomically enclose inside critical section figure one show atomicity violation involve multiple update thread two atomic interleave read access thread one get inconsistent data old value new value order happen memory access figure one b thread happen unexpected order show example thread one call immediately thread two wait conditional variable call program crash correct execution call final iteration do true loop thread two order call thread one constraint absent code al eight comprehensive study concurrency bug appear apache study show vast majority concurrency bug either atomicity order moreover study point concurrency bug involve multiple previous work concurrency bug detection focus data race fifteen seventeen lock discipline violation eighteen atomicity nine ten nineteen general bug order thoroughly address prior work aim provide completely general framework concurrency bug detection rely specific one type bug three communication graph overview approach concurrency bug detection explore involve collect communication graph multiple process detect likely result concurrency bug many ways process graph depend fact presence absence certain edge distinguish correct execution graph incorrect execution graph way graph directly reflect buggy communication figure two illustrate concept figure two show order bug take figure two b show communication graph obtain correct top incorrect execution bottom incorrect execution communication store thread one load thread two thread two read data compare graph directly point communication anomaly execution discuss graph process detail section five key use communication graph bug detection build graph consequently information encode show basic communication graph encode sufficient information general approach bug detection show new graph abstraction propose address problem thread one thread two id id status order violation bug thread one initialize incorrect thread two read data initialize graph multiple correct incorrect b figure two view detect concurrency bug base communication graph represent memory involve share data communication insufficient basic communication graph concurrency bug may lead edge present graph buggy therefore simple graph might point bug example consider bug figure three extract read access thread two interleave two write thread one bug manifest figure three b show communication graph result union graph correct incorrect execution bad interleave lead edge dash b appear buggy even though graph use detect bug use detect many bug many buggy interleave lead edge also present graph correct figure four show typical concurrency bug pair update atomically read access thread two get inconsistent data interleave write access thread one however figure four b show interleave lead unique edge communication graph make impossible detect bug consider graph summary edge communication graph result bad interleave also present graph correct execution miss basic communication graph notion relative order communication nod solely represent static notion order edge embed order communication graph one direct way guarantee enough order information communication graph node represent dynamic memory operation clearly impractical graph size would unbounded grow execution time propose new kind communication graph encode information relative order communication bound size significantly basic communication graph key aspect graph propose nod represent combination static memory instruction communication context instruction execute call communication graph communication context memory instruction sequence communication observe thread immediately prior execution memory instruction obtain monitor communication observe thread regardless data address involve insert fifo queue four type communication observe lo cal thread one read data recently write remote thread two write data recently read remote thread three remote read data recently write locally four remote write data recently read write locally content fifo queue context note communication make context result access specific data address exactly need want capture notion global order across memory access irrespective data address context size arbitrary longer order information encode graph formally communication graph define g v e v v edge v e pair edge present g execution g construct communicate execute processor context execute processor context node communication graph map multiple nod communication graph execution precisely communication graph execution nod communication graph program execution c nod c number possible memory access instruction execute since four type c context size experimentally determine section context five possible enough capture enough order detect type concurrency bug discuss literature practice addition context mean communication graph time bigger since node execute small fraction possible experiment section never show increase figure five show communication graph use reveal concurrency bug figure five show multiple buggy code figure four execution show memory access interleave parenthesis represent communication context thread point communication happen example refer first execution top figure five first operation leave write execute two remote read receive local node context point context become point next operation leave execute write note context add order information communication graph figure five b show possible distinguish graph communication write read depend execution communication happen unlike basic communication graph figure four b recall basic thread one thread two close close update log else update erroneously ignore atomicity violation bug represent interleave dash arrow represent buggy interleave communication graph dash edge appear incorrect execution b figure three atomicity violation example communication graph reveal bug char share thread one thread two b atomicity violation example communication graph dash edge represent represent possible interleave dash represent buggy interleave buggy communication edge alone distinguish communication figure four basic communication graph often enough detect concurrency bug edge distinguish correct incorrect communication graph limit expose concurrency bug edge present graph incorrect conversely graph edge present graph incorrect four implementation bugaboo use binary instrumentation monitor memory access build communication graph three key one table map memory location instruction address thread id communication context last writer configure use word line granularity memory address two array keep communication context thread three context aware communication graph whenever thread read write memory location whose last writer add new edge graph edge source last writer instruction address context edge sink current instruction plus thread current context policy capture waw raw edge maintain communication context whenever thread access location last write another thread record correspond event identifier context fifo queue thread last write memory location record correspond event context size event fifo queue fix five full element discard architectural support communication track provide acceptable performance collect communication graph purely lead performance degradation describe use set modest hardware reduce monitor communication memory keep track context actual graph process still happen cache coherence protocol typical already provide support need since communication carry happen via coherence message broadly beyond typical coherence protocol offer need information instruction address lead coherence message way store communication happen component periodically read five one context register keep track recent communication two coherence message carry instruction information three keep track context four table store communication edge happen five thin component periodically read graph edge collect figure six show overview commodity keep track context four communication discuss section map directly cache coherence since consider transfer communication give relevant cache coherence event code local read miss local write miss upgrade miss incoming invalidate request incoming read request recall maintain communication context keep fifo queue recent communication context register simple shift register event code shift event happen want encode global communication across address therefore dis thread one context thread two context e x e c n n n b g g e x e c n b g g e x e c n n n b g g ten context writer instruction address tag data typical cache line b commodity figure six architectural shade typical loss limit bug detection capability add cache line keep track instruction address virtual address context line write source communication edge include field store instruction address ie field store context ten data produce ie store instruction execute therefore total overhead per cache line ten per cache figure six illustrate cache line update processor write line exclusive modify state ie write upgrade miss result update frequent miss without loss generality assume underlie system cache coherence protocol augment follow coherence message include information involve communication read reply supplier send correspond line keep track raw communication invalidate reply supplier send line invalidate use keep track waw communication communication table purpose communication table temporarily store communication edge happen component read organize simple queue entry contain instruction address context source destination communication edge thus size entry ten two show figure six b organize either centralize distribute since global consistency need keep processor pose issue three lead write read reply source set supply line destination set instruction address local load instruction cause miss context miss happen capture raw edge instruction address easily hash smaller value overhead issue possible interleave correspond communication code figure four dash correspond bad interleave b communication graph dash edge come bad interleave figure five communication graph example reveal atomicity violation figure four reveal basic communication graph regard data address processor system context register figure six b keep five context context register ten long cache coherence precisely keep track communicate require keep information granularity word potentially whole memory clearly expensive hardware choose two reduce hardware complexity cost information loss first track communication granularity false share might lead edge actual communication second monitor communication happen via transfer might miss edge present actual communication data show section invalidate reply except destination set address local write instruction cause request context request originate capture waw edge read miss service memory source set null destination set local instruction context miss happen capture information typically read share data five bug detection bugaboo use two basic bug detection communication graph label unlabeled label method programmer execution buggy conversely unlabeled method fully automatic programmer need describe method outline leverage deployment bug detection use unlabeled run automatic way use graph bug detection collect graph number determine rare communication likely result bug crucial observation buggy communication rare specifically method base unlabeled run produce rank list code programmer examine rank code point x define set execute x number run code point execute context x total number time execute regardless context across run sort list ascend order summary code point execute rare rank higher section demonstrate method effective detect concurrency spite irrelevant code point get high rank p bug detection use label run method programmer run application multiple time label execution buggy depend whether bug manifest process assist test tool attempt force bug happen twelve fourteen run label produce set graph graph compute take graph difference graph execution label buggy union graph obtain label apply exact rank process use unlabeled method set graph define rank code point set graph highly rank code point likely relate bug demonstrate experimentally section technique locate bug precisely small number label process assume programmer execution depend manifestation specific bug investigate mean programmer need know whether whole execution program correct hard programmer need know whether bug question manifest accordingly reasonable assumption make label simple accurate bug detection use support collect communication graph cause negligible performance degradation therefore use deployment scenario continuously monitor execution detect code point location source code map multiple static binary execution likely buggy deploy application run field spare core system periodically collect graph process detect whether likely deploy application experience new bug provide functionality use combination two describe test developer collect communication graph test case result graph unioned test graph represent observe test therefore consider correct test graph deploy together application graph collect periodically application run field system take difference test graph apply unlabeled method describe section code point rank threshold system send information back developer six evaluation evaluation aim one demonstrate base communication graph detect bug accurately lead unnecessary code two characterize size accuracy graph three characterize four characterize justify design experimental setup methodology evaluate use simulator base pin eleven sixteen simulator model associative cache core cache coherence protocol cache communication context register track protocol communication table layer trap use three full bug synthetic buggy code table one show use full choose base previous literature bug detection eight ten twenty exercise buggy code apache enable buffer log use custom script launch ten simultaneous request static resource experiment enable binary log use include utility modify execute fifty instance parallel decompress compress text file contain communication graph tool fetch archive remote server interrupt interrupt signal add call frequently bug manifest bug extract line extract include buggy code use bug capture essence bug make experimental analysis less cumbersome methodology use successfully prior work area nine ten twenty finally use several synthetic bug several use prior work atomicity violation detection nine ten add synthetic order violation bug efficacy apply label unlabeled describe section five output list code point order rank criterion measure quality output number code point rank higher bug ie number require bug find result present average five label trial collect buggy run run unlabeled trial use run ensure least class name version synthetic na na na na bug kernel full bug type atomicity violation atomicity violation atomicity violation order violation atom atom atom atom order violation atomicity violation atomicity violation order violation atom description two thread try update bank account balance simultaneously update lose many thread remove head queue append tail queue lack atomicity lead incorrect append order log write many thread periodically flush miss atomicity constraint lead log corruption two thread repeat access share variable must interleave code constraint enforce interleave compute string length total number string total string length track update permit become inconsistent cache data structure populate flag indicate cache occupancy set lack atomicity interleave read may read flag inconsistent cache read valid flag conditional test outcome conditional interleave data invalidate update buffer offset buffer text length inconsistent value read interleave read query node id order assignment node id absent order lead incorrect id query reply attempt log data log rotation properly handle log close lead unlogged concurrent update length text buffer drop update lead corruption buffer lead crash log corruption termination worker thread loop order deletion cond data structure access delete cond cause crash value share consistent write output file lack atomicity constraint permit read inconsistent value share signal handler table one bug use evaluate bugaboo one run buggy justify number run section table two list bug whether able detect without context number code point function require find bug use label unlabeled overall result demonstrate technique accurately pinpoint concurrency even large package experiment label graph bug locate many case bug first code point report use unlabeled graph saw comparable result little increase require discuss importance context accuracy effect communication track granularity importance communication context detect concurrency bug column two detect without column three detect table two show one exception bug evaluate find context information exception order violation bug bug detect without context pair communicate buggy run irrespective context bug without context communication edge graph experimental occur buggy make impossible detect use graph dependence context mean find bug example detect atomicity require context use heuristic specific atomicity aware however another approach able detect atomicity table one detect bug label communication graph four six eight table two show number code point find bug use label graph able detect bug require unnecessary case none application require approximately different function reasonable number consider code consist one million line line code number require twelve use use drop average smaller application less line code never code point rank higher bug generally speak compare line granularity show small decrease number require full application decrease expect graph collection less precise consider transfer communication whereas consider memory compare six eight show effect track compare effect number require detect bug unlabeled communication graph five seven nine table two show number code point require method use unlabeled graph result show typically require many case number label method intuitive since unlabeled method rely less information label information user case show opposite result actually get significantly better find disparity surprise turn artifact rank function use relative frequency graph difference use produce graph label method make context buggy code point less relatively rare therefore lower rank somewhat undesirable effect rank function virtue use communication graph however use rank metric learn technique restrict technique propose yes detect without context detect context label fourteen ten twelve ten ten ten ten eighteen ten ten ten fourteen ten ten ten ten ten ten ten unlabeled twelve twenty sixteen ten ten ten ten fourteen twelve ten ten sixteen ten ten code find bug line granularity unlabeled label forty ten twelve ten ten twelve ten ten ten ten ten ten ten ten ten ten ten ten ten sixteen fifty twenty eighteen fourteen ten ten ten ten ten ten fourteen ten ten ten word granularity unlabeled label fourteen twelve twenty ten twelve twenty ten ten ten ten ten ten ten fourteen ten ten ten twenty eighteen ten thirty sixteen ten ten ten ten ten twenty ten ten sixteen ten ten yes yes yes yes yes yes yes yes yes yes yes yes yes table two bug detection accuracy use bugaboo report number code point require correspond bug find number parenthesis show number distinct function note one inspection indicate zero irrelevant code point need inspection since bug find first result average five source irrelevant report two main reason irrelevant code point sometimes highly rank first multithreaded execution may lead potentially rare correct communication sufficiently rare ever observe buggy may rank highly spite correct label graph largely mitigate source false second buggy behavior tend infrequent buggy code execute resultant communication context might also infrequent respect subsequent communicate involve bug lead rare context appear bug rank mitigate use graph run impact graph collection imprecision discuss section trade precision lower complexity compare communication track word granularity two source imprecision one communication track granularity two consider transfer communication quantify imprecision compute number distinct communicate code point present graph collect use word granularity present graph collect use line granularity table three show result consistent across board column two show imprecision add line track range seventeen column three show imprecision add line track twice imprecision introduce apache table three imprecision cause track communication rather detect graph property relative emergent communication set graph manifest even graph collect use line address aberrant communication potential bug still render rare edge word granularity second cache likely impact bug detection capability reason concurrency bug typically manifest interleave lead communication communication capture due cache would result communication long range long enough data evict cache thus unlikely use effect context size table four show bugaboo bug detection ability vary context size note bug find context lower four number require find bug high unless longer context use context grow number irrelevant go expect since order information available distinguish memory access involve bug choose bugaboo default context size five want favor better bug coverage lower unnecessary even cost increase graph size none ten twenty ten twelve ten twenty ten ten ten ten ten sixteen fourteen ten fourteen sixteen ten ten eighteen ten ten ten ten ten eighteen thirty ten ten section show neither source imprecision affect bugaboo ability accurately detect bug two reason first detect bug base absolute graph prop table four bug find result word different context size dash indicate bug find correspond context size e e g e eighty sixty forty twenty zero e e g e eighty sixty forty twenty zero context context context context context context e e g e eighty sixty forty twenty zero zero five one one two two zero five one one two two zero five one one two two zero five zero five zero five zero five zero five zero five additional run additional run additional run b apache c figure seven graph convergence increase number run apache b c show program run number new communication edge contribute additional run decrease rapidly ie obtain convergent communication graph quickly figure seven show number new communication contribute program run fraction total graph size prior run expect longer run necessary reach convergent graph convergence demonstrate sharp new communication reach flat bottom around run data show length context increase time converge increase well increase occur context get longer instruction potentially map number nod run fraction edge add greater smaller context size apparent inversion graph longer percent increase edge contribute run lower graph result show number run require collect convergent graph proportionate length context context size run necessary justify choice run evaluation since sufficient convergence characterization characterization three understand assess performance cost measure typical size communication graph characterization use full table one well parsec one suite since synthetic bug bug suitable characterization main source overhead write cache line write trap full column five table five show number update typically less per memory three one million memory update happen cache miss two three four fully overlap completely critical path therefore impose performance cost number update column six predominantly less per memory update do simultaneously cache coherence operation perform simple fifo buffer insertion impose negligible overhead costly overhead perform trap full column seven show trap happen time per ten million memory sufficiently cost amortize course execution moreover possible dedicate spare core read communication table reduce cost trap handle write simply discard may result small number miss graph edge enable uninterrupted execution trap handle make effectively operation several stand higher cost ten twenty time edge communication graph much higher cache miss rate two three four indicate widespread frequent communication ultimately lead higher frequency trap read communication table still frequency one per million memory column eight show slowdown cause compare application run natively without instrumentation pin expect cause performance degradation since monitor take action every memory operation cost action vary depend frequently communication occur application saw tolerable slowdown cost significantly higher reach three order magnitude case par popular dynamic analysis tool thirteen focus work optimize tool see direct ways reduce use concurrent data structure graph size show size communication graph without context size graph function widespread communication within application code first noticeable trend communication graph eleven twelve significantly communication graph nine ten expect since execute multiple none graph exceed nod edge size use sparse adjacency matrix representation graph never exceed one size low storage overhead support feasibility use since require ship union graph obtain test also since graph small obtain field transmit back developer mop mop mop mop mop trap mop wo context w context nod edge nod edge graph size ferret two zero two zero five eight one five zero zero three eighteen three two one zero sixteen eighty fifteen zero zero zero slowdown x eighty fifteen nineteen thirteen table five characterization communication graph size case study configuration error bugaboo development initial evaluation decide run parsec data structure use build configuration document unsafe multithreaded execution enable dynamic hash resize use collect graph fifty program run use buggy configuration process collect graph use unlabeled process technique examine six code point discover atomicity violation occur buggy configuration use well developer comment describe code safe thread enable document configuration error new bug consider ease find involve code validation effectiveness technique seven relate work base anomalous behavior explore extensively literature include static two dynamic approach three six seven explore use statistical bug detection leverage execution diversity deploy prior work inspire us think use concurrency bug detection nine atomicity violation detection system use approach use set train run infer memory access interleave monitor dynamically violate propose architecture decrease performance cost dynamic monitor tailor bug twenty concurrently develop work bug avoidance technique base build test use architecture support enforce encode set static memory call effect basic communication graph since include form context fundamentally miss bug need context detect communication graph enable detection bug would lead violation note since aim bug avoidance need complex system architecture support validate whether memory access proceed use label run fully automatic unlabeled method hand fully automatic notable architecture support concurrency bug detection hard provide support lock discipline violation eighteen detection ten use hardware detect atomicity detect data race leverage speculative execution key propose architecture compare previous one focus generic mechanism build communication graph two track global communication context three mechanism activate cache miss incur low overhead finally five also propose track communication use machine learn detect potential bug apply fundamentally different category type bug could potentially use notion context increase coverage improve result eight approach bug detection take paper collect communication graph multiple identify graph likely result concurrency bug main advantage approach prior work general key bug detection whether enough information encode graph paper make observation basic graph encode enough information enable detection many bug address issue propose communication graph new type graph embed access order information use communication easily obtain monitor communication use graph develop bugaboo comprehensive framework concurrency bug detection able accurately detect complex concurrency bug irrelevant code describe two bugaboo one one use hardware support decrease overhead graph collection hardware support propose set modest architecture multicore efficiently keep track communication context leverage fact architecture lead performance propose use well thank anonymous helpful feedback thank dan benjamin wood invaluable feedback manuscript insightful work support part grant gift nine reference one c j p singh k li parsec suite characterization architectural pact two b bug deviant behavior general approach infer code three w g quickly detect relevant program four c type effect system atomicity five q f k panda find bug parallel program detect anomaly data six lam track bug use automatic anomaly detection seven b r bug isolation thesis university eight park e learn mistake comprehensive study real world concurrency bug nine j f detect atomicity via access interleave ten b j k l detect survive atomicity eleven c k r r muth h g v janapa k hazelwood pin build program analysis tool dynamic instrumentation twelve ball g p find reproduce concurrent program thirteen n j framework heavyweight dynamic binary instrumentation fourteen park expose atomicity violation bug hide place fifteen j use speculation data race multithreaded cod sixteen j b j tuck w l sarangi p sack k p simulator seventeen k de fully integrate practical system eighteen savage burrow g nelson p eraser dynamic data race detector multithreaded program nineteen r hill violation detector server program june twenty j case interleave constrain p r hard race detection