learn partially observable action model efficient chang amir computer science department university abstract present tractable exact learn action effect precondition partially observable maintain propositional logical representation set possible action model observation action execution perform exact learn precondition effect deterministic action domain include strip action action conditional effect contrast previous rely achieve tractability supply approximation guarantee take time space polynomial number domain feature maintain representation stay compact indefinitely experimental result show learn efficiently practically contain feature state one introduction complex afford partial limit apriori information dynamics act difficult reason important try acquire much information environment dynamics possible current plan approach assume action model specify fully formalism strip al hold even plan partially observable al present efficient learn general deterministic action model partially observable unlike previous approach approximate learn model take input propositional logical formula describe partial knowledge initial state world action model also take input sequence action take receive agent act world work compute set hypothetical action model consistent action take receive previous approach attempt learn deterministic action model automatically recently approach learn action model presence copyright c right reserve association artificial partial observability appear previous approach work amir previous work algorithm track logical representation encode set possible action model approach assume action never fail case precondition learn action map state eleven case size logical representation may grow exponentially number step addition approach learn precondition action efficiently relax use several technical advance provide exact tractable linear time step domain size deterministic maintain alternative logical representation partially know action model present two technical advance amir general algorithm section three represent logical direct acyclic graph dags versus flat leave propositional internal nod logical way may reuse share among parent nod multiple time data structure prevent exponential growth belief state guarantee representation always use fix number propositional symbol nod guarantee number connective nod grow domain size number time step compare representation binary decision diagram explode exponentially size also present efficient represent conjunctive normal form section four consider tractable bind size result applicable strip action possibly fail strip action action precondition know trade expressivity handle first algorithm order maintain belief state compactly representation advantageous readily use conjunction modern inference tool generally expect input relate work number previous approach learn action model automatically study addition work amir approach wang successful fully observable handle partial observability partially observable state world fully know assign effect precondition action become complicate one previous approach addition amir handle partial observability yang approach example plan trace encode weight maximum problem candidate strip action model extract style algorithm use order examine subset data give learner approach approximate nature hide model use estimate stochastic transition model however complex nature problem prevent scale large approach represent state transition matrix explicitly handle relatively small state space likewise structure learn approach dynamic network limit small ten feature jordan koller apply multiple level approximation importantly base approach unbounded error deterministic contrast take advantage determinism domain handle significantly contain feature ie approximately state two transition learn problem section describe combine problem learn transition model track world first give example problem return example introduce formal machinery example consider domain consist several room object agent lock unlock put object inside get carry room room object move agent know agent perform sequence action namely put take goal determine effect action extent theoretically also track world define problem formally borrow amir p r h definition transition system pow p set world state state p finite set subset p contain exactly true finite set action r deterministic transition relation r mean state result perform h ing action state world lock room object room object object action object form domain include action conditional effect press lock cause lock unlock vice also agent result perform always conditional apple hold apple move well otherwise location change strip domain agent observe state world completely know action change order solve maintain set possible world state transition might govern world definition transition belief state let possible transition every transition belief state r set r informally transition belief state set pair agent consider possible agent update r h belief state perform action receive define semantics simultaneous learn filter track world state r r transition belief state ai action definition simultaneous learn filter assume logical sentence p one empty sequence two r h three r h four j h j h h ai r h true call step two progression step three filter short maintain set pair consider possible intuition behind definition every pair r h become new pair result action observation discard state pair involve remove set conclude r possible pair include remove r h r h example agent put take assume one pair belief state actual state action r transition relation assume action affect progress action change accord r receive observation agent eliminate pair belief state three update possible transition model section present algorithm update belief state approach enumerate clearly intractable apply logic keep representation compact learn tractable later show solve logical inference problem define vocabulary action proposition use represent transition propositional let f literal g conjunction term call g transition rule g precondition f effect g g mean g hold execute cause f hold deterministic transition relation describe finite set proposition g formula take zero lock cause lock lock cause lock lock lock cause lock lock cause lock lock cause lock lock lock cause lock lock figure two dag time zero figure three dag time figure four build dag time use time ai procedure input sequence formula p one f two three f new proposition p replace p zero h line thirteen four ai process sequence five return p f base p procedure input observation logical formula p one f two three four five f see two see one poss f six f line fifteen maintain keep new status p line sixteen progress action seven eight procedure input formula one f p replace f figure one line filter observation form split rule term precondition f must term split rule several rule literal effect definition transition rule semantics give r transition relation represent set transition rule define result perform action state f rest change say action possible g r g use logical encode belief state use l belief state use interchangeably p belief state equivalent logical r h r algorithm overview see figure one give formula l first convert formula form include p f f v add new proposition language see remain form throughout algorithm update iterate sequence procedure maintain several direct acyclic graph dag structure one fluent f maintain logical formula formula represent f true every time step update true f currently hold formula update accord line three see detail two also maintain formula store additional knowledge gain perform action assert action possible line two receive observation add line seven make sure involve fluent proposition update insert need call procedure replace equivalent use dag implementation add edge relevant node need copy explanation formula allow us recursive share help us maintain compactness base process sequence return update order make sure model indeed valid model conjoin another formula base g note assume action sequence possible also handle general case agent observe action possible f g f g g f g v v example build dag figure see dag construct focus way update throughout sequence node mark root formula represent time time zero explanation leaf time leaf every proposition dag leaf show progress action dag time one use graph time time one top node figure four true one true leave one node represent case transition rule cause lock activate precondition hold time show one transition rule precondition right child node correspond case lock lock lock activate hold time rule cause note use previous explanation lock whenever refer status time figure reuse three time correctness algorithm theorem correct formula sequence action ai h h r satisfy ai h satisfy r ai h h intuition define effect model action time teff logical formula consist reiter describe ways perform action time affect world show equivalent consequence find restrict language teff finally show calculate define effect model time definition effect model teff p poss f f poss f g v f one two g f f w g g w f assert action occur time mean v w f hold perform action effect model correspond effect explanation closure situation calculus fluent f hold time either exist transition rule g true activate g hold time b f f hold time rule true activate word f true transition rule change also assert action possible two activate rule contradict effect definition reuse notation teff denote vocabulary include time one lemma belief state formula f r p r h h r satisfy satisfy h therefore apply transition belief formula equivalent apply transition belief state proof idea show two set use interpolation theorem propositional logic show compute exactly restrict language denote f formula every occurrence fluent f replace formula r h need compute teff form involve add new proposition language every fluent f every equivalent p f v f f f p p f f v replace fluent g teff explanation p consequence find perform teff p p teff teff g f f v v resolution teff p poss f p f p f v v handle similar g p f g exactly compute proof complexity order keep representation compact algorithm tractable maintain dag instead formula replace f need update pointer rather copy expression space time algorithm zero initial belief zero state total length throughout sequence omit always length sequence k parameter domain minimum number precondition two p p precondition always executable action maintain flat formula instead dag complexity zero inference dags algorithm return formula represent dag would like perform inference formula always flatten dag use sit solver lose compact representation instead use algorithm generalization algorithm recursive algorithm iteration choose variable p update graph case p true propagate assignment throughout dag get smaller graph call function find satisfy assignment return true otherwise try p false succeed backtrack dag size n leaf algorithm take space time exponential n linear four algorithm present previous section encode logical use arbitrary graph case however convenient directly maintain transition belief state many powerful would like able leverage perform logical inference assume input formula include particular modern check ing handle contain many one million ten million al f case exactly one f hold model hold disallow algorithm maintain transition belief f h p procedure input successful action observation term transition belief formula see definition one f two three four five six seven eight nine eliminate subsume ten return f f f set f f f observe f f f f f else f f f f f f f h procedure input action know precondition term p observation term transition belief formula follow factor form j j formula one action fail two li li appear p f l formula equivalent l ie f l l wi f f l f p three j j four else five six seven j factor ai j j p j contain fluent exist b j j j b ai j p eight eliminate subsume nine return j h j j contain b replace figure five strip action section present efficient algorithm figure five progress transition belief inherently less flexible knowledge representation language assume action model learn unconditional strip order still provide compactness guarantee particular certain condition show transition belief stay indefinitely compact f p f f strip action consider simpler propositional vocabulary one define section three define action proposition let vocabulary represent f transition belief state define l f true action intuitively transition relation cause f f hold execute true action affect fluent f f f precondition also let formula f encode inconsistent model possible model f true f p p f form f p f f f formula f contain proposition definition transition belief factor form f f f represent knowledge learn fluent f f observe note form transition belief state contain prior knowledge state world action model give f v f v follow theorem show correctness also give time space complexity result particular note case every fluent observe every k step transition belief formula stay ie indefinitely compact f p f theorem h h formula successfully execute action observation term moreover one procedure take time linear size formula two fluent observe every k step input formula formula stay action section explicitly consider notion action failure action fail precondition meet remove belief state fail action definition become note general case learn deterministic action model section three action handle implicitly add deterministic rule state map precondition take action hold however transition rule compactly express restrict vocabulary section three r h r six h r h algorithm figure five handle case fail action assume observable also assume precondition fail action know beforehand algorithm learn action effect action precondition algorithm utilize another algorithm amir follow theorem show produce safe approximation correct action model never lose give condition produce exact result additionally time space complexity give theorem h h condition hold h h one every transition relation map state eleven two contain prime implicate three one state r r h theorem time space complexity time space find model nineteen four zero one e n e z l r f c e p e zero zero five r f e zero zero nineteen c e p e zero zero five r f e four zero one e n e z r f l zero c e e l zero zero zero number step number step number step figure six experimental result dag algorithm show time require process action space require process action time require extract action model one take time linear size formula change cause right single action observation pair two every fluent observe every k step input formula maximum size precondition formula stay five experimental result evaluate several include block world world variation safe world world domain international plan competition one variation safe world domain test agent must try number different possible order open safe addition action change permute right combination note many world safe world toilet world feature conditional action handle previous learn figure six show time always space result instance block world various size time plot show time require process every action note require less two per action space plot show total space need rightmost graph show time take inference procedure find action model domain nineteen formula produce find action model accomplish simply find model logical formula produce algorithm use inference procedure inference time generally longer complex query middle graph figure seven show time take process action algorithm compare series label ae algorithm amir test instance various size domain algorithm comparable speed constant factor note solve difficult problem learn action precondition figure eight show part action model learn run algorithm safe world domain right change cause right right change cause right right close cause true try cause right figure eight model safe world twenty step twenty step model show first model extract inference procedure logical formula return algorithm particular model algorithm able partially learn correct combination permute change action execute learn rate graph figure seven show learn rat graph show number transition rule correspond action proposition successfully learn fifty randomly select rule domain initially knowledge state world action model first graph show result safe world domain contain twenty latter graph show result domain contain fifteen note test possible learn algorithm completely learn every action affect every fluent certain never change thus impossible learn affect action nevertheless demonstrate relatively fast learn rate different partial observability result show learn rate increase degree observability increase also worth note inference time generally decrease degree observability increase also run algorithm instance domain contain fifty object nearly plan solve randomly create domain generate plan contain average action algorithm yang run plan learn rate filter time learn rate forty thirty twenty ten zero five n r f e n r e l e r n l n r zero zero ae ae ae ae e l ten eight six four two zero full observability sixty observability full sixty forty twenty fifty forty thirty twenty ten zero five f e n r e l e r l zero zero ten twenty number step zero number step ten twenty thirty forty fifty number step figure seven leave right experimental result show learn rat different observability percentage randomly select observe step middle result show time process action algorithm series label ae give initial state plan action take plan goal condition problem simple extension algorithm make handle schematize action algorithm take second process plan use sit solver second require find model hand algorithm yang require second find model thus run time comparable algorithm find exactly action model consistent action algorithm yang guess possibly incorrect action model heuristically goal paper perform exact learn assume probabilistic prior set action model case way favor one possible action model another however introduce bias preference model study reason community apply well six conclusion present new learn deterministic action model partially observable unlike previous handle fully general case arbitrary deterministic action model perform exact learn tractable give theoretical analyse well empirical result demonstrate effectiveness moreover manual construction action model domain tedious painstaking even thus may help alleviate bottleneck plan extend work stochastic present deal purely propositional therefore relational contain many grind action apply naively scale well case build upon present take advantage relational structure better suit amir work support defense advance research project agency grant air force research laboratory award real program second author support fellowship university graduate college reference amir e learn partially observable deterministic action model five p p plan partial observability via symbolic model check one x n koller discover hide structure complex dynamic conformant plan via symbolic model check r n j strip new approach application theorem prove problem solve z jordan factorial hide model machine learn howe c ram weld plan domain definition language version twelve technical report yale center computational vision control learn experimentation incremental refinement incomplete plan w c f l malik chaff engineer efficient sit solver proceed design conference one h l l p learn probabilistic relational plan rule four yang k w learn action els plan incomplete knowledge five press reiter r knowledge action logical describe implement dynamical press amir e learn partially observable action six wang x learn observation practice approach plan operator acquisition