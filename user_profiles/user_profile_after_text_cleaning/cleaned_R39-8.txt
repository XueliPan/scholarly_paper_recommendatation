adaptive test efficient hard fault detection amin advance computer architecture laboratory university michigan ann arbor shoe abstract grow semiconductor integration reliability individual expect rapidly decline future technology scenario would need equip fault tolerance tolerate infield silicon defect periodic test popular technique detect however tend impose heavy test penalty paper propose adaptive test framework significantly reduce test overhead propose approach unique ability assess hardware health apply suitably detail test thus chunk test time save healthy extend framework work fabric provide flexibility group together pipeline stag similar health condition thereby reduce overall test burden modest sensor area overhead propose scheme able achieve eighty reduction test lifetime introduction rapid growth silicon process last significantly improve semiconductor integration level today smaller faster ever however aggressive dimension forthcoming technology pose critical reliability issue lead technology begin warn future silicon technology much less reliable present seven addition extreme process future likely experience field due device time combat scenario future semiconductor need equip tolerate infield ie usage silicon defect host lead silicon defect popular negative bias temperature instability oxide breakdown hot carrier injection three challenge tolerate permanent hardware fault ie silicon defect encounter infield divide three requisite task one defect detection diagnosis two recovery correct system state failure three mechanism prepare system future computation focus work improve efficiency first task defect detection diagnosis recovery second task typically employ mechanism rollback system failure create periodically event failure much useful work lose revive twenty two good finally repair third task typically leverage hardware redundancy replace break component case merely isolate exist range core two pipeline stag twelve within processor defect detection diagnosis broadly divide two broad one continuous constantly monitor logic block two periodic periodically check processor logic work test work test core one core two core three core four create one release one create two release two create three fig one periodic test fault detection vertical strip represent horizontal line show progression thread end every interval test conduct process core show solid horizontal bar continuous detection dual modular redundancy diva four common idea sort redundant computation time space validate execution however impose area latency power energy another mean continuous detection estimate amount device level although variety low level propose one fifteen six limit capability accurately failure contrast periodic detection require redundant execution give sound guarantee fault coverage periodically test system defect case failure rely recovery figure one show snapshot system test conduct end every interval recent periodic detection ace analysis nine vast thirteen unfortunately periodic test time constitute much five thirty total system time nine sort overhead unacceptable high end server typically apply virtual machine consolidation maintain utilization level even case embed great deal time energy save reduce overhead periodic test work propose adaptive test framework significantly reduce overhead periodic test system key insight adapt test process state underlie hardware instance healthy processor within lightly test whereas counterpart need thorough test specific applicable three different one health system vary lifetime due device thus relatively healthy begin deteriorate time two manufacture time process variation form compo differ health level three different amount stress experience depend assign case propose deliver save periodic test effort provide level fault coverage essentially system assess health different appropriately conduct test enable assessment processor health employ population low level fifteen sixteen predict mean time failure error less three area overhead extend application fabric twelve highly flexible compute substrate allow arbitrary group different form logical exploit feature group together different conduct concurrent test main work summarize follow one propose introduce use low level guide test process two achieve reduction overhead periodic test adaptively match test process underlie hardware health three extension flexible fabric achieve benefit four lifetime reliability experiment measure fraction time devote periodic test setup model process variation sensor error device test overhead background provide brief overview latest assess system health conduct test form integral part adaptive test framework propose later section due space provide background conventional periodic test base fault detection thirteen nine monitor challenge problem active area research design propose detect progress various reasonable accuracy fifteen eighteen exist accuracy area overhead use usually design area efficiency primary design criteria allow large number deploy throughout chip monitor overall system health different approach sensor design examine health granularity research involve simple temperature two dozen eleven complex design detection unit six effectively approximate useful life remain module b test goal test detect fault effect system infield number test exist test three important one self test base two functional test three base address test problem comprehensively provide high fault coverage introduce hardware ten embed overhead justify hand functional test use program conduct test challenge generation high fault coverage program process e g r e v c l f ninety eighty seventy sixty fifty forty thirty twenty ten zero zero one two three four five six number seven five x ten fig two fault coverage achieve percentage vary number base self test functional test achieve low fault coverage consider structure base fault model like five link test fault model achieve good fault coverage introduce hardware overhead start generate module specific deterministic test pattern use processor vehicle deliver pattern module input collect processor simply execute test program memory test program length chiefly determine need maximum number test advantage low cost ease application extensibility variety make eight nineteen seventeen considerable success latest seventeen report fault coverage test generation functional test comfortably test size amount fault coverage figure two illustrate amount fault coverage number test execute compatible processor use data seventeen see figure last coverage require maximum test effort number test adaptive test periodic test base fault detection approach suffer constant overhead full test application available process view increase process variation differ amount component lifetime effective optimization match test thoroughness health component propose adaptive test methodology build upon key insight technique leverage low level assess probability failure various system appropriately decide quality test apply primary benefit strategy save test time energy addition traditional extend adaptive test philosophy twelve highly flexible fabric advantage propose technique magnify use architecture rest section provide detail adaptive test framework discuss application traditional architecture adaptive test framework conceptual illustration adaptive test framework show figure three system enhance assess component health design one six equally applicable methodology propose ongoing research base also easily integrate within nevertheless choice direct available data accuracy oxide breakdown sensor sixteen core system enhance data gather process generate sixteen fourteen error base number use current mean sensor read project error calculate probability failure core note higher error estimation translate conservative value probability failure discussion derivation leave interest space process repeat core system generate probability failure array p test allocator task test allocator prepare suitable test program core system every interval test allocator provide two input one coverage target c range zero one two probability failure array p use two value determine test fault coverage f c need individual core coverage target c always meet core term fault coverage imply fraction hardware fault cover test pattern give core interval probability f pi f coverage f one c pi one f word probability periodic test catch fault one c core product fault occur pi get cover one f solve require test fault coverage f one place bound coverage f best coverage ax zero one one c pi one c pi thus give coverage target c higher probability failure pi necessitate increase fault coverage vice final equation also add bound possible value fault coverage zero minimum best coverage best possible coverage use test generation technique employ work propose use base self test conduct test seventeen advantage base test two fold one hardware overhead two fault coverage level flexible propose methodology seventeen allow generation test program meet different level fault coverage number test thus tune per core basis match fault coverage desire figure two show single stick fault coverage achievable compatible core range number test full set test store main memory test allocator use set prepare array test program core case propose methodology tie specific test technique recovery event failure recovery system need get system back fig three adaptive test framework generic system show along need enable adaptive test health assessment responsible gather sensor read produce fault probability array p array take test allocator along target coverage generate appropriate test different process core apply suitable test recover fault use mechanism twenty finally isolate faulty core find end every periodic interval health assessment conduct system correspond failure p determine array turn use test allocator generate suitable test early lifetime healthy low probability failure number test require make sure system operate correctly grow older failure expect rise result need thorough test later section use intuitive argument derive fault coverage metric c measure probability system safe state give fault coverage target c decide optimal number test require per component level core case way test effort reduce healthy system function important block figure three detail health assessment lack knowledge underlie component health primary reason apply full test throughout component lifetime alleviate problem deploy low level measure degradation transistor level primary requirement sensor accurately measure device level take account process variation accumulate lifetime furthermore single sensor enough provide statistically result entire core health therefore would need deploy scenario low area overhead become favorable feature work purpose illustration use oxide breakdown propose e al fifteen sixteen close ideal behavior extremely small area footprint result sixteen demonstrate enough estimate mean time failure entire chip less ten error note propose methodology tie one sensor type variety sensor release zero release one release two release zero release one test fail core one core two core three core four variable test time core one core two core three core four rollback create one create two create three create one create two create three fault scenario b fault occurrence scenario test failure rollback fig four adaptive test efficient fault detection notice one test apply new start two old release test finish successfully operational state isolate break component achieve deploy solution work use revive system twenty revive minimal hardware overhead maintain main memory interval length tune base availability storage target system figure four show two action first scenario illustrate figure four case horizontal line show progression thread execution intersperse regular shade vertical strip test phase show solid horizontal bar follow creation test time vary core core depict adaptive nature test example core one run test worst health core three best health previous release test core complete successfully notice unlike traditional practice test form figure one reverse design choice result variable test time core system order run variable test core start different time add complexity health assessment test allocation test schedule thus test start concurrently new create time core finish test release make available job schedule however create additional run test necessitate two outstanding coexist test run core fortunately include revive maintain log update test phase short length additional update save log due second lead negligible memory burden second scenario illustrate figure four b show case failure core one run job failure detect test follow creation third system roll back operational state use second system coverage metric system periodically test fault three distinct one failure occur last complete interval two failure occur detect test program three failure occur cover test program first two maintain system safe state represent fault escape test however third event unwelcome scenario fault occur without catch let us say multicore chip n core discuss probability core miss fault interval pi one f word fault occur test able expose continue along line average probability miss fault entire n core system within give interval n p miss f pi one f one n sum entire system lifetime average probability system miss fault write one n pi one f therefore average probability lifetime system miss fault ie probability system safe state one pi one f one n refer probability system safe state also understand effective fault coverage system since represent average probability miss fault use metric specify target fault coverage summary primarily benefit term test application efficiency early lifetime process core healthy lot test suffice achieve give fault coverage target time device test overhead gradually rise overall application test multiple advantage one time available actual job execution two save three low fault detection cost visible end user intend application detect permanent fault another possible application use variable reliability instance server tune coverage target system base job run higher financial transaction lower regular web page request discussion far context traditional key observation help adaptive test variation health core spatially temporally follow subsection apply extension fabric highly flexible compute substrate pipeline one fetch decode issue execute fetch decode issue execute failure probability pipeline two fetch decode issue execute fetch decode issue execute pipeline three fetch decode issue execute fetch decode issue execute r e g n n r g f n c pipeline four fetch decode issue execute fetch decode issue execute fig five fabric four weave together use full crossbar interconnect interconnection configuration manage configuration manager within logical construct join set unique pipeline stag fig six shade intensity stag represent deterioration thus stage higher failure probability flexibility allow connect stag similar health form logical health spectrum b adaptive test section introduce fabric twelve architectural concept stag pipeline purpose fault tolerance real strength fabric ability isolate break stag within nevertheless flexibility also assist form core even greater variation health thereby magnify benefit adaptive test rest subsection break two part one introduction fabric two application adaptive test one fabric design highly adaptable multicore compute substrate design network pipeline stag rather isolate core figure five logical core architecture refer form group together lease one pipeline stage type easily isolate adaptively rout around faulty stag event stage failure architecture initiate recovery combine live stag different slice ie salvage healthy form logical refer stage borrow addition underlie stage design permit stag two distinct instance pair even one lose issue stage still run separate thread share remain issue stage refer stage share thus system possess natural redundancy borrow share pipeline stag else equal capable maintain higher throughput duration system life compare conventional multicore design architecture consist three prominent compo basic build block architecture consist pipeline allow convenient granularity stag stag make data forward control handle infeasible furthermore introduction switch heart processor pipeline lead significantly worse performance slowdown due high communication stag fortunately solve well place see twelve application follow performance within eleven pipeline stream identification eliminate control hazard scoreboard track data hazard bypass cache emulate data forward macro amortize transfer time network b interconnection switch role switch direct incoming instruction bundle correct destination stage use rout table crossbar switch allow complete flexibility pipeline stage depth n communicate stage depth c configuration manager give pool stage rethe configuration manager divide source globally optimal set logical lifetime reliability result demonstrate nearly fifty improvement cumulative work compare traditional twelve furthermore high resiliency fabric leverage combat process variation manufacture time defect addition two adaptive test point lifetime manufacture time process variation device different pipeline stag within fabric would exhibit different amount degradation snapshot fabric figure six show vary degradation pipeline stag system sake illustration four health level show shade best health shade worst health let us say health provide probability failure map level fourteen test thoroughness test fault coverage case traditional decide test thoroughness basis component instance even one stage within pipeline badly wear traditional assign thorough test program pipeline go principle pipeline one would apply level two test pipeline two level three test level four test contrast make test efficient group together separately bold line figure show pipeline stag combine form logical first logical would need apply level one test level two level three level four thus achieve reasonable amount test reduction traditional order separate pipeline sort stag type basis health instance figure six fetch stag already sort base health top bottom pipeline stag equal health rank connect form logical health rank stag vary lifetime depend stress experience different stag system fortunately flexibility system allow dynamically segregate every interval evaluation methodology evaluate potential propose approach reduce test overhead conduct lifetime reliability experiment require order measure cumulative reduction amount test system lifetime model consist sixteen compatible configure four group wide block operate frequency set process systematic random process model use oxide breakdown use representative mechanism degradation fourteen choice motivate presence accuracy data low level fifteen variable number deploy within core health assessment lifetime experiment conduct series interval interval simulation update sensor read allocate appropriate size test core base failure pi give fault coverage f determine test allocator number test execute extract data plot figure two maximum achievable fault coverage test bound scheme employ seventeen present result use system fault coverage metric derive section wherever refer coverage target b result figure seven show number use lifetime normalize system apply constant amount test give coverage target target system coverage set best achievable choose scheme seventeen test report accumulate lifetime five sensor error health assessment test save use propose number reduce thereby make read less accurate conservative estimate failure probability possible force adaptive system assign bigger test system however sensor area n c r n e f r e b n e z l r n one eight six four two zero fifty forty thirty twenty ten zero r n e f e h r e v e r zero zero five zero one five zero two five zero three five zero four five sensor error value fig seven number test adaptive test vary amount sensor error number test normalize regular fix periodic test plot also show sensor area overhead use propose approach health assessment coverage target fix n c r n e f r e b n e z l r n two fifteen one five zero zero five two five zero seven six two zero eight eight one zero nine four zero zero nine seven three system coverage value fig eight number test adaptive test vary system coverage target number test normalize need test even higher level sensor error benefit erode gradually propose scheme deliver test time save sensor error believe point offer good sensor area overhead save test instruction count thus scheme depend high sensor accuracy level achieve test reduction figure eight use similar term one present test instruction save range system coverage target sensor error fix result depend upon reliability system coverage target dynamically tune instance move lower coverage target result ninety test save increase divergence go towards higher coverage save obtain use adaptive adaptive also noteworthy expect adaptive well surpass benefit adaptive high coverage target future technology nod higher level process variation base system would capable extract even bigger gain segregate way much would need thorough test result plot far present cumulative value number test entire lifetime next result present data test thoroughness time figure nine plot three dimensional plot average number test instruction execute consecutive simulation range coverage target value plot system sensor error trend number test time reveal interest behavior propose scheme extremely low coverage target say five fifty hardly test apply however higher value coverage target rhythmic pattern test instruction count lifetime number test rise peak peak formation representative core near time failure fail subsequently core reach close failure time adaptive system ramp number test guarantee coverage target core fail system return nominal state since core healthy sixteen peak plot represent die time core overall average number test higher later lifetime due health many core system plot clear demonstration propose adaptive test framework tune test time probability failure contrast traditional periodic test approach exhibit flat surface constant test intensity save report test translate range benefit target system one performance gain spend less time test two power energy save run system simulate sixteen core interval performance seven sixteen test adaptive test adaptive test respectively accord revive twenty interval would require storage average peak storage requirement smaller allocation storage mechanism force even shorter make test time even average number test eighty sixty forty twenty zero zero one eighty sixty forty twenty zero one nine eight seven six system coverage two three time four five six five fig nine plot show variation average number test execute system lifetime range system coverage target v loom reliability challenge future technology infield tolerance silicon defect necessity future compute periodic test although good fit problem impose heavy test time propose adaptive test framework significantly reduce test overhead key insight leverage low level assess failure probability various system suitably apply test way healthy system use fraction test compare another one near time failure lifetime test detail adaptively manage propose solution lifetime simulation system area devote health assessment result eighty reduction test deliver fault coverage extend reduction twelve apply adaptive test architecture test time reduction translate vary level benefit power performance energy depend attribute target system overall believe adaptive test offer economical solution challenge fault detection research support arm national science foundation grant research center one five research center fund focus center research program semiconductor research corporation program reference one agarwal b mitra circuit failure prediction application transistor age test symposium page appear two n p n p j e smith isolation build high availability commodity annual international multicore symposium computer architecture page three j association failure model semiconductor technical report solid state technology association march four diva reliable substrate deep submicron design annual international symposium page five k batcher c instruction randomization self test processor core test symposium page computer society six j detection annual international symposium page seven design reliable unreliable challenge transistor variability degradation micro six eight l dey scalable methodology design conference page june nine k v detection hardware defect architectural annual international support evaluation symposium page ten r das l j p hay test generation use linear test symposium page computer society eleven j al twelve j fabric construct resilient multicore annual international symposium page thirteen h li mitra vast concurrent autonomous international test conference sept fourteen e sylvester reliability model management dynamic large scale integration sixteen four fifteen e p singh sylvester compact monitor oxide degradation international circuit conference sixteen e sylvester analysis reliability factor monitor oxide breakdown device symposium quality electronic design page computer society seventeen th lee hybrid methodology embed processor symposium apply compute page new york eighteen p l goodman product reliability monitor nineteen effective periodic test embed design integrate circuit one twenty z j revive architectural support rollback recovery annual international symposium computer architecture page sarangi b r j j model process variation result time semiconductor manufacture page p c exploit redundancy defect tolerance international conference computer design page martin hill wood improve availability share memory global annual international symposium computer architecture page j v p bose j impact technology scale lifetime reliability international conference dependable network page june