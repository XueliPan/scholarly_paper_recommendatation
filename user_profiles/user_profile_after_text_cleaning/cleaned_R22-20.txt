array recovery university efficient implementation critical many embed optimize application program write c largely focus code generation schedule grow maturity provide diminish return typically make extensive use pointer arithmetic alternative use largely ignore article develop array recovery technique automatically convert array enable empirical evaluation apply three instrument average best transformation give factor improvement across certain case find preliminary result justify pointer array conversion investigation use embed subject program optimization general term experimentation measurement additional key word phrase pointer conversion graph embed one introduction digital signal process media process embed demand performance lead development specialize application program assembly recently cost develop embed system become dominate algorithm development move towards use program particular c compute program c much less time consume assembler come price less efficient implementation compare approach al author address institute compute architecture division university king build permission make copy part material without fee personal classroom use provide copy make distribute profit commercial advantage notice title publication date appear notice give copy permission copy otherwise republish post redistribute list require prior specific permission fee c embed compute vol two two may page array recovery bridge gap application development time one hand performance much interest optimize compiler technology compiler responsible automatically tune program al sair al al work primarily focus efficient code generation schedule however code generation lesser extent schedule fact relatively mature diminish rate return increasingly sophisticate approach al instance develop particular core optimal majority case thus wish continue increase performance worth consider alternative approach one approach examine inherently portable show give performance improvement al yet little empirical evaluation impact embed perhaps due historical approach embed one major difficulty use extensive usage pointer arithmetic al al prevent application analyse indeed al actively encourage use code mistake belief compiler generate better code although one time program may perform well contemporary compiler technology frequently make matter worse current generation optimize precisely analogous development early scientific cod convolute code create cope current become dusty deck make optimization much challenge article develop technique transform program equivalent form open opportunity application extensive use form evaluate impact three different limit work evaluation embed performance focus may easily apply presence consider interaction restrict consider instance investigate wang al evaluation restrict single architecture achieve good result albeit small set program al memory space execution time loop unroll investigate al impact tile power consumption evaluate although power consumption memory size also important issue embed embed compute vol two two may b fig one original array traversal focus work rather focus improve execution time assume fix amount embed memory evaluate impact several al suite three different embed show select appropriate transformation average improve execution time factor justify investigation within embed article organize follow section two provide motivate example illustrate application conversion section three describe program representation use conversion section four describe conversion algorithm section five describe three embed investigate follow section six description analysis result section seven discuss relate work incorporation compiler section eight conclude summary two motivation pointer access array data frequently occur typical program many specialize address generation early unable generate efficient code especially program contain explicit array reference therefore use access pointer arithmetic within program order give hint early compiler use address available instance consider figure one kernel loop pointer increment access encourage compiler utilize address however analysis optimization need code generation formulation problematic rely explicit embed compute vol two two may array recovery fig two conversion explicit array access fig three loop array index cope pointer reference order maintain correctness use conservative limit maximal performance produce code although general array access pointer analysis without intractable al easier find suitable array problem keep result algorithm applicable program furthermore analysis mature analysis within optimize program contain array rather likely efficiently implement article develop technique collect information code order regenerate original access explicit index suitable analyse furthermore translation show affect performance enable application figure two show loop explicit array index semantically equivalent previous loop figure one easier read understand human reader amendable compiler array analyse al form program may also apply figure three show example loop application conversion transformation array access multidimensional array array b c array representation enable aggressive compiler data layout embed compute vol two two may b fig four c code correspond loop tree three program representation section briefly describe program representation use conversion algorithm pointer conversion algorithm transformation require intermediate preserve c construct therefore along standard graph use loop tree morgan loop structure array access pointer arithmetic easily identifiable loop tree represent partial order loop contain relation loop inner loop loop inner loop write relation reflexive transitive antisymmetrical example loop tree representation give figure four convenience innermost embrace loop denote inner x node x outside loop inner x function lower l upper l return lower upper bound loop range l return range normalize loop l case value constant expression symbolic expression return process node loop tree contain loop header contract special summary node type node use summarize effect loop possible inner loop later analysis step summary nod handle way ordinary nod ie single statement embed compute vol two two may array recovery fig five overall algorithm four conversion pointer conversion consist two main stag first stage determine whether program form amenable conversion consist number check check err conservative side ensure program satisfy may safely consider stage second stage gather information array pointer pointer loop nest information use replace pointer access correspond explicit array access remove pointer arithmetic completely overall structure algorithm show figure five algorithm simply change representation memory access largely syntactic change therefore overlap array multiple array often prevent standard program analysis interfere conversion algorithm section describe restrict form program consider scheme check use guarantee compliance follow section description actual conversion algorithm base framework order facilitate pointer conversion guarantee correctness overall requirement break number check first step algorithm structure loop loop restrict normalize iteration range go lower bind zero upper bind step one assume constant propagation al al grove take place upper bind may constant affine expression contain outer loop case loop nest structure loop must property relatively trivial determine loop conform restriction loop normalization simply check loop li two one n upper li affine expression syntactically enclose loop pointer arithmetic pointer assignment arithmetic restrict analysis may initialize array element whose subscript affine expression enclose whose base type scalar simple pointer arithmetic assignment also embed compute vol two two may b allow ensure pointer assignment arithmetic break two stag first syntactic pointer restrict follow syntactic one j j c j constant two assign j array j j array three assign c constant four assign constant note dynamic memory allocation implicitly exclude potentially unbounded complexity dynamic data structure addition pointer use must dominate node contain correspond pointer assignment word pointer use correctly initialize requirement state formally eight p two p use p two p two q dom q p p set use dom usual term refer use variable definition dominance one node another prohibit scheme assignment pointer may side effect relation array difficult identify fortunately rarely find program take conservative approach variable declare pointer assign address consider pointer variable prohibit function call take address pointer may change thus take address pointer prohibit scheme imply function prohibit acceptable program rarely ever use pointer classification scheme realize simple algorithm variable identify pointer either declaration use label pointer set pass call function variable contaminate already recognize pointer also include pointer set address pointer take variable assign pointer value program reject simple pointer classification algorithm describe figure six determine potential pointer present take conservative approach pointer conversion abort potential case find example figure seven show program fragment illustrate legal illegal construct conversion legal statically initialize initialize repeatedly within loop construct array affine subscript illegal block memory dynamically allocate assign whereas subscript b affine expression embed compute vol two two may array recovery fig six analysis fig seven example legal illegal pointer usage finally assignment illegal dominate definition pointer arithmetic restrict scheme constant pointer legal however modification pointer illegal include unknown value finally two pass function also show receive pointer array thus content array embed compute vol two two may b fig eight join control flow meet operator change pointer however may change pointer permissible information program check second stage algorithm gather information pointer usage pointer conversion information pointer store node loop tree particular declare pointer map pointer array include position pointer within array record additionally label node contain recent assignment pointer store data pointer p store form x n array point x index specific element p point n node assignment p occur movement pointer p loop k l number enclose loop function analyse x n carry default value indicate specific information available precisely denote state pointer assign array element conversely value use express conflict different example consider situation figure eight node join control conflict p point along one incoming path p point b along another path resolve set correspond element become clear p assign least along one control path specific map p dependent actual program execution path denote correspond field number pointer must equal across control reach particular statement order pointer reference may replace array reference number different two join denote appropriate field give requirement possible define meet operator combine outcome follow one two distinct point v meet immediately meet operator embed compute vol two two may array recovery formally define follow eight l l l l l l k k otherwise operator use section determine effect pointer usage throughout program flow function flow function model effect execute statement map reach statement node flow function form f l information x n total number declare c function process node n flow function f n define flow function split individual function accord operation contain node n individual function either generate preserve exit function f n n f f one n ti ai xi ni l generate function generate function cover incoming map generate update pointer p general form generate function n x p p l f p eight v zero n p l zero n p l x n p l p v scalar v p array p x array preserve function preserve function handle pointer arithmetic ie pointer relative current position embed compute vol two two may b map update accord operation node n n x p p k p l f p x p p k c one p l p k inner n x p p k one p l p k inner n x p p k c c p l p c k inner n x p p k c p l p c k inner n k l p q q pointer x p p k p l otherwise eight exit function exit function represent transition statement loop level since exit nod occur end loop body exit function task summarize effect single loop body do way overall effect loop pointer map return result n x p p k p l f p eight x p range inner n p l inner n inner inner n l x p f k one p p l n k inner n inner p x p l p p p l k inner n six inner compute total effect statement perform pointer arithmetic loop nest total number individual loop must know give generic loop nest figure nine total number innermost loop f one x f two x f n x one one f k number nest loop one k n way total number inner loop level k embed compute vol two two may array recovery fig nine loop nest pointer express x k f one x f two x f k x one two term frequently encounter analyze loop nest enumerate use omega calculator pugh base give one two total effect pointer pointer p entire loop nest derive follow x n one c post c x n x zero c post p x k c post c x n post size pointer increment loop k exit k c one loop show figure nine rectangular iteration space constant number pointer loop level total number pointer evaluate affine dependent iteration otherwise upper loop bound affine outer index result polynomial function index effect inner loop construct start innermost loop level total effect inner loop determine algorithm progress loop time end loop see summary compute loop nest end loop occur treat usual next end loop terminate next higher loop level turn initiate summary computation loop embed compute vol two two may b equation system flow function specify effect statement locally ie per node statement basis flow function together form equation system whose solution global solution solution representation n n set associate node solve equation start ie eight p x p p l result n equation system solve visit nod reverse begin start node compute n n set follow n f n n n n single iteration require propagate pointer map value thus complexity n n number nod unlike iterative analysis algorithm compute fix point transition statement loop level do end loop body flow function loop node compute pointer conversion second pass step algorithm pointer access arithmetic respectively replace remove replacement base information gather analysis stage information index array access construct pointer reference replace array offset x l unambiguous case f g information require conversion pointer access array access spread throughout compute value necessary construction array access one array name available node contain pointer access two initial offset available node contain pointer access three local offset available node contain pointer access four index available loop exit nod five global offset available exit node array name name array pointer replace refer initial offset constant term specify start position pointer array give initial assignment local global offset specify distance pointer move current outer loop body respectively since start iteration finally embed compute vol two two may array recovery index multiplicative factor specify effect previous current pointer position precisely conversion memory access node n via pointer p require information keep set node n summarize exit nod embrace outer loop let set node n pointer p p x l explicit array access replace n pointer expression original program form name array expression selection single array element index expression sum several partly available node n general expression follow form c c c initial offset local offset determine p n x k inner n global offset expression contain loop index construct data exit nod higher loop level respectively node n global offset p k set exit node loop level k inner n inspect assumption pointer p node loop prior n therefore express sum k ie pointer move many step sum step outer loop see far finally term sum loop index general form j loop index loop level computation j two case must distinguish loop nest without pointer b loop nest contain pointer inner n j j p case pointer assign new value level loop pointer progress least one step loop expression contain zero level j j inner n coefficient level k inner n offset ie number position pointer move loop body multiply number loop outer loop compute sum number pointer j current level total effect inner loop j multiply current loop range case b loop contain assignment pointer p level one assignment zero successfully convert explicit array access throughout entire loop loop nest contain pointer arithmetic remove step modify pointer discard actual pointer access already convert previous step conversion use pointer follow transform loop eliminate pointer conversion algorithm additional statement update pointer take account total effect loop pointer must insert immediately loop embed compute vol two two may b fig ten solution example next section illustrate interpret information convert pointer access array access example figure ten show example array recovery algorithm work solution problem p c program show node program two value represent set keep value compute analysis stage last column figure ten show construct conversion stage algorithm put together describe previous section enable access p c array c node eight replace explicit memory access c k x c name array c initial offset zero local offset zero collect set node eight global offset zero read node nine exit node innermost loop embrace node eight contain pointer access convert loop index f k extract set exit nod nod nine eleven twelve correspond loop since pointer movement f loop coefficient f zero single step loop responsible one contribution finally coefficient index variable k outermost loop x since pointer p c move x position per iteration k loop information gather node twelve entire explicit array embed compute vol two two may array recovery access construct array name index expression result sum different similar way assignment p c zero replace replacement access via pointer p c contain pointer arithmetic p c delete finally ensure use p c remain declaration pointer discard p p b treat similar manner final program show figure two five experimental framework article concern use conversion enable section six focus result execution time behavior briefly describe salient point two float point process pes internal organize two block give word code space program memory respectively sequential mode one two pes active mode second always perform first one different data basically vector processor vector size two order utilize mode pes must simultaneously access different data bank ie program data memory via two independent bus switch require special involve overhead float point processor cycle issue five order exploit parallelism data instruction cache respectively speed data transfer processor core external ram achieve highest performance important compiler schedule many possible instruction use cache efficiently instrument contrast two processor instrument like ti processor two contain four functional register file sixteen register memory structure block program memory two block data memory access parallel external memory connect via external memory interface select al suite eleven contain iterative program structure embed compute vol two two may b select kernel find typical make extensive use pointer arithmetic convert program one base array enable number program consider investigate select base suite loop extensively study area scientific computation select bacon al initially impact conversion evaluate isolation next loop unroll select increase size loop body allow parallelism expose apply array recovery remain rely conversion tile pad allow cache optimize allow exploitation parallelism finally scalar replacement reduce number access memory conversion algorithm develop article implement experimental octave compiler apply manually apply transformation level result code use input c release compiler version instrument compiler version performance data collect execute program six result since interest signal process emphasis execution time give fix memory size code size power consumption important beyond scope article evaluation section examine effect transformation isolation behavior show figure eleven sixteen pointer array conversion convert array base algorithm describe enable often help native compiler perform accurate analysis dependence test successfully apply performance impact vary program program across three often benefit transformation see figure eleven consistently perform worse variable usually beneficial impact case n complex update slowdown program embed compute vol two two may array recovery fig eleven conversion conversion therefore mix impact examine generate assembler main benefit improve analysis nest loop case however generate code frequently identical perhaps due greater maturity native compiler case generate code similar efficiently exploit main benefit however enable discuss apart unroll none remain apply without use conversion furthermore largely negative impact conversion offset rely form program embed compute vol two two may b fig twelve unroll pointer array recover embed compute vol two two may array recovery fig thirteen fig fourteen fig fifteen due pad tile although focus performance rather code size worth note effect conversion vary across give case ten reduction object code size increase one case unroll unroll apply two program without recovery different unroll factor maximum twenty evaluate best result show figure twelve unroll increase machine variable impact performance loop unroll n real update program deteriorate performance small program benefit total unroll ie unroll little beneficial effect usually program slow loop unroll embed compute vol two two may b fig sixteen scalar replacement understand negative impact unroll consider case n real update main loop body array recovery take six utilize execute arithmetic operation parallel memory operation unroll version however complex code size grow factor although compiler able identify sequential traversal array therefore generate loop fix number use mode memory access also generate unnecessary code increment loop induction variable two repeat load change store index register additionally waste cycle result performance unroll loop far worse loop array recovery thus loop unroll even small unroll factor always beneficial especially however unroll generally improve performance best array form program best unroll factor consider performance vary respect unroll unroll increase code size limit amount instruction memory transformation applicable two functional applicable generally give good performance except two case overhead change mode greater work available dot product small trip count cost switch mode outweigh benefit array recovery necessary transformation even though array recovery decrease performance show figure eleven one case give due parallel use vector use bus improve code generation side effect conversion applicable four show figure fourteen contain linearize array embed compute vol two two may array recovery aid dependence analysis especially allow loop data overall generally beneficial costly negative impact performance due slightly complex code generate array access prevent exploitation array pad use reduce data cache conflict suitable improve execution time case applicable see figure fifteen although beneficial case applicable three program one architecture hence may limit general use loop tile increase cache utilization also improve cod ti although contain data cache effect match work set local memory see figure fifteen case slowdown due overhead additional loop offset increase locality scalar replacement figure sixteen generally improve performance applicable variable two summary result show impact performance however impact always beneficial vary depend machine furthermore consider next section look combine impact performance detail evaluation figure seventeen result select set summarize program architecture maximum achieve show figure eighteen list need obtain highlight best performance justify fact embed programmer compiler system would try several different select best one discuss section seven compute product two matrices pointer conversion original program several different analyse apply program subsequent parallelization result transform program utilize processor two memory bank use parallel whereas original program make poor usage available benefit version program loop unroll pad apply transformation apply already increase performance combination observe loop unroll increase flexibility instruction fill five issue slot embed compute vol two two may b fig seventeen best overall best performance since new loop body choose reduce number memory access whereas pad reduce number cache conflict situation similar ti although best performance achieve array recovery loop unroll together execution speed double architecture base matrix multiplication algorithm implementation first last inner loop peel originally intend hint compiler create efficient code available avoid otherwise necessary accumulator clear operation loop transformation prevent embed compute vol two two may array recovery fig eighteen best transformation sequence suite exploitation parallelism since require alignment array data loop violate benefit parallel loop unless back regular form still pointer conversion loop unroll apply yield situation different achieve array recovery pad unroll ti unlike benefit implementation array recovery unroll possible mainly result array recovery unroll contribute small percentage inspection assembly code generate compiler reveal efficient inner loop due higher degree instruction parallelism array recovery number loop smaller number execute parallel higher explicit array access increase efficiency analysis support compiler transformation program compute matrix product three three matrix three one vector simple loop array recovery total loop unroll small loop speed execution factor achieve total loop unroll either pointer version program although loop unroll general increase code size well justify case loop iteration range well loop body small total loop unroll code also account possible performance gain architecture smaller embed compute vol two two may b fir program implementation finite response filter contain single loop array recovery loop amendable loop reversal loop split turn allow parallelization one result loop although single loop parallelize achieve since loop contain memory access align array element loop must execute sequentially order overcome restriction possible beyond standard compiler analysis loop unroll loop give best result unroll result set account achieve smaller ti processor finite response filter theory could parallelize compiler overly restrictive use loop directive sequential execution mode apply array recovery program obtain unlike program improve performance benefit transformation apply across three inner loop redundant memory access remove compiler able remove access without code transformation possible array recovery total unroll three small inner loop version program achieve best performance convert representation allow application array analysis loop unroll program convert back form give overall although small example show possible apply could apply program addition possible go back code appear improve overall performance convolution loop easily parallelize array recovery execution time reduce original time loop unroll best result similarly achieve unroll increase size loop body provide ti compiler increase flexibility instruction schedule reduce number n real update real loop easily parallelize achieve benefit pointer conversion unroll array recovery help compiler prove independence different memory access whereas loop unroll increase number loop body maximum achievable however maximum rather due loop unroll code embed compute vol two two may array recovery n complex update full parallelization fail due overly restrictive compiler still possible take advantage two functional array recovery loop split parallelization one result loop array recovery prove useful support together loop unroll obtain set without unroll also achieve dot product dot original program perform best parallelization applicable overhead involve switch sequential mode back benefit obtain parallel process also loop unroll beneficial increase execution time contrast loop unroll either pointer program result architecture clearly benefit take advantage removal loop construct instruction schedule original loop two cause many branch eliminate complete unroll ti compiler handle loop well unroll code original program decrease unroll n section implement infinite impulse response filter n section parallelization apply program due data dependence loop body however sequential version improve array recovery give factor array recovery unroll give best performance inspection assembly code show much pack machine ie number waste issue slot fill significantly reduce experiment less successful due technical program available simulation environment however initial result show small chance achieve due good performance original code kernel square filter program contain two loop benefit parallelization array recovery loop reversal applicable compiler accept first loop loop overall achieve architecture benefit array recovery loop unroll respectively possible evaluation overall benefit average benefit least somewhere average embed compute vol two two may b one case best optimization program require conversion although show figure eleven alone improve performance major benefit enable pad scalar replacement although unroll useful case require additional bar one case give best performance general benefit application combine mainly due complex architecture particular combination processor cache finally probably benefit part due relatively immature compiler ti benefit least application yet even mature native compiler possible get average four case conversion require get best case optimization give improvement unroll useful expose especially combine conversion unlike smaller transformation sequence seem perform best rarely benefit scalar replacement native compiler largely capable detect redundant memory access two case unlike two previous gain best exploit although conversion always degrade performance isolation combine six case provide performance improvement overly restrictive prevent fuller exploitation summary overall select appropriate give average across three investigate case conversion contribute increase performance three case best performance gain conversion seven relate work discussion little work evaluate impact transformation sequence real al heuristic optimization method present strongly rely information certain compiler specific processor exploit program construct code generation approach restrict sense easily transfer different processor even different compiler processor although aim author present result processor address optimization base sequence show evaluate al optimization rely explicit array access work program algorithm apply preparatory stage embed compute vol two two may array recovery enable optimization although aim experimental result come obvious transformation extend author claim demonstration still outstanding transformation context investigate wang al combine effect different neglect apart two normalization rename loop distribution need evaluation effectiveness present transformation perform single architecture achieve good result albeit small set program effect scalar replacement imperfectly nest loop evaluate song lin simple heuristic method use determine unroll factor result compare loop distribution loop unroll processor serve target architecture experimental evaluation result promise although number program small single architecture consider one main reason little evaluation transformation sequence due nature many previous work develop basic pointer conversion algorithm however restrict unable fully handle nest loop construct function recent work van extend previous work base recognition handle much greater variety recurrence among cover many difficult program type fortunately rarely find practice however limit applicability program without function also little consideration conflict index function presence potential article show array recovery select appropriate transformation combination lead good performance however select right transformation much difficult task much work investigate use static analysis determine best transformation al approach highly attractive context compute analysis typically small fraction compilation time transformation selection base static analysis fast unfortunately frequently inaccurate approach approach prove promise actual data use improve optimization selection project high within iterative compilation framework embed investigate experimental result show approach promise recently investigate use iterative compilation different select evaluate eventual one select al approach much longer compilation time major issue embed compute vol two two may b embed use approach compiler automatically find best show figure eighteen subject ongoing research eight conclusion contribution article introduce new technique transform c code array access explicit array access enable approach implement integrate experimental compiler test suite article also demonstrate usefulness apply across three different select appropriate transformation give average across three investigate program consider relatively straightforward future work investigate determine profitably extend restrict conversion scheme potential scope greater give empirical evidence justify use next step build compiler strategy exploit future work investigate static iterative approach optimization selection consider integration optimization code selection schedule reference r compile c parallelization expansion proceed conference program design implementation ga june hardware reference l v p technique optimization implementation international conference signal process technology de g c code generation digital signal processor dissertation university electrical engineer bacon f graham l sharp j compiler compute four al embed pro r p synthesis code generation signal process circuit digital signal process nine cooper k k l f z c e compiler strategy trade code size performance embed tech rep constant propagation proceed symposium compiler construction p count linear nonlinear analyze transform scientific program proceed international conference pa may press e r practical data flow framework array reference analysis use proceed conference program design implementation embed compute vol two two may array recovery b compiler transformation explicit array access proceed r bier j p evaluation interaction proceed conference signal pacific grove ca grove l constant propagation study jump function proceed conference program language design implementation f r analysis address code proceed design test conference date n j kim h experimental evaluation energy behavior iteration space tile proceed international workshop parallel compute august j improve cache locality combination loop data two p w f p combine selection tile size unroll factor use iterative compilation proceed pact parallel compiler technology press c paulin p address calculation compilation exploration instruction set architecture proceed design conference las r novel code proceed pean education research conference e j l lam effectiveness data dependence analysis j parallel program one morgan r build optimize compiler boston digital signal process web site f p p w integrate loop data global proceed pact parallel compiler technology press pugh w count proceed conference program design implementation press reps precise analysis constant propagation proceed conference sair k w study loop unroll proceed workshop signal process sip song lin loop proceed international conference synthesis embed b wang j loop optimization code generation proceed international conference acoustic speech signal process phoenix van f x b f h f v de man h j high level control flow memory management proceed workshop signal process napa valley ca also signal process v k r w press new york van j jess j conflict model instruction schedule code generation core proceed design conference embed compute vol two two may b instrument digital signal processor van r k efficient algorithm access conversion compile optimize proceed international workshop innovative architecture wang j b nest loop proceed international conference acoustic speech signal process wa v j c h methodology proceed signal process technology conference receive accept may embed compute vol two two may