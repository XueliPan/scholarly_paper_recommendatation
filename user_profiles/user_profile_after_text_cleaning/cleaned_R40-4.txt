implement evaluate nest parallel transactional memory computer laboratory university ca abstract transactional memory promise technique simplify parallel program date design efficiently support parallelism achieve widespread use maximize performance gain must support nest parallelism available many support several program model present system support parallel base block use eager version management conflict detection algorithm target state nest parallel also describe several subtle correctness issue support nest parallel discuss performance impact evaluation quantitatively analyze performance use stamp base concurrent data structure first show performance overhead reasonable parallelism use second quantify incremental overhead parallelism exploit nest level draw useful design environment finally demonstrate nest parallelism improve performance transactional subject program concurrent program parallel program general term design performance transactional memory nest parallelism parallel program permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten june copyright one introduction transactional memory thirteen surface promise technique simplify parallel program address difficulty synchronization allow simply declare certain code segment execute atomic isolate way respect code take responsibility concurrency control potential motivate extensive research hardware hybrid focus approach compatible exist upcoming multicore chip thus far assume code within transaction execute sequentially however real world often include potential nest parallelism various form nest parallel loop recursive function call call parallel number core scale important fully exploit parallelism available level achieve best possible performance spirit several parallel program model support nest parallelism propose one twenty hence maximize performance gain integrate well popular program model must support nest parallelism however efficiently exploit nest parallelism trivial general challenge nest parallelism amortize overhead initiate synchronize balance parallelism five nest parallelism within exacerbate challenge due extra initiate commit nest design system support nest parallel also challenge first conflict detection scheme must able correctly track hierarchical manner instead flat way nest parallel may conflict restart without necessarily abort parent transaction second apart overhead must ensure memory overhead necessary track state nest small third since may use nest parallelism must ensure overhead reasonable single level parallelism use recent work nest parallelism discuss semantics nest parallel provide prototype two four eighteen however follow question still require first algorithm nest parallelism second use detail performance analysis practical issue use nest parallelism answer question also important guide future work paper present support parallel base block use eager conflict detection extend support nest parallel manner keep state small specific work propose system support nest parallelism parallel nest arbitrary manners present several concurrent nest describe correct execution discuss impact performance provide quantitative performance analysis across multiple use first show performance overhead reasonable use single level parallelism second quantify overhead exploit parallelism nest level finally demonstrate improve performance transactional use nest parallelism rest paper organize follow section two review semantics nest parallel section three describe section four discuss subtle correctness issue section five present quantitative evaluation section six review relate work finally section seven conclude paper two background start point block algorithm use eager eleven nineteen approach show performance advantage nonblocking lazy use compiler nineteen environment eleven focus conflict detection find apply perform conflict detection exact code start eager variant six nine maintain undo log data write within transaction use global version clock establish use hash function memory word associate variable either act lock store version number ie clock value word write commit transaction transaction read data insert transaction write data acquire associate lock code read write carefully optimize keep overhead per call part assembly small conflict detect check associate read write commit execute randomize exponential scheme use contention management semantics concurrent nest describe nest parallel ad discussion available two sixteen transaction assign transaction id tid unique positive integer root transaction tid zero reserve represent globally commit state system every transaction unique parent transaction whose parent root transaction follow assumption sixteen transaction allow execute active figure one comparison transactional semantics describe definition conflict discuss two close nest memory object l let l set active l l define similarly transaction access l follow two case conflict read l exist transaction zero zero l zero six zero write l exist transaction zero zero l l zero six zero commit semantics transaction read merely merge parent read otherwise value write become visible read reset abort change make discard previous state restore sixteen three design implementation section describe algorithm execution ex ample main issue relate performance algorithm key design goal keep state small support nest parallel instance want significantly increase memory footprint use multiple set lock global version clock support multiple nest parallel block eager use useful property help us meet goal transaction write ie acquire lock memory object guarantee exclusive ownership object commit abort discuss algorithm describe change lock compare show figure one data structure ie machine encode version owner information associate memory object lock remain store owner information unlock remain store version number encode sufficient support transaction lock memory object allow access object transaction commit abort however correctly access lock object long owner allow ownership information always available consult ancestor relationship time similarly version number also always available serialize conflict owner version number b tid true true self self return fail true one procedure self two three result four five return result six procedure self owner seven self eight root owner owner nine ten eleven procedure self owner twelve self thirteen nil fourteen root owner owner fifteen sixteen seventeen eighteen nineteen return twenty procedure self zero false return success procedure self thirty self owner value memory owner self else self forty else self owner fifty self procedure self false one memory owner sixty six self else return value owner self owner self p p one traverse direction backward traverse direction forward e e return value algorithm one basic function true self owner self one procedure self data two three self four owner five six seven memory eight memory data nine else ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty c self self one repeat id self self six nil self memory memory data return p p one one true self e owner self continue else owner self self thirty procedure self self fetch increment owner forty self fifty owner else p p one self owner self owner self id e algorithm two basic function lock memory object guarantee exclusive ownership object commit abort therefore ensure conflict write object time first attempt write object object guarantee valid throughout execution invalid reader transfer ownership previous owner trigger rollback line algorithm two note validate transaction protect validate transaction avoid problem commit discuss section also note expensive transaction execute deep nest level due search discuss performance issue section transaction doom abort line algorithm two otherwise validate line algorithm two validate merge read parent line algorithm two note avoid problem commit discuss section process validation merge protect parent reduce execution time critical section merge do link instead copy read implement use version number ownership object transfer parent update transactional traverse backward ie roll back memory value traverse forward ie restore value first observe value note release owner memory location transaction line sixty algorithm one avoid problem finally restore restart transaction note call possible similar figure two avoid addition randomize exponential scheme use contention management provide liven example figure three illustrate example simple application use nest parallel execute initially b zero note real implementation simplicity assume one subsequent wall clock time zero start zero time two read b time three four start zero write time five commit one time six thread execute fork start one time seven successfully read time eight attempt write validate call valid doom merge yet therefore successfully write time nine successfully commit two also read merge time ten attempt commit fail three due unsuccessful commit figure two scenario avoid eventual rollback outer transaction enable modify show figure one least use encode owner associate object since tid zero reserve root transaction support one concurrent use ie paper tunable remain store version number since global version clock increase commit transaction saturate faster recent work discuss handle version clock overflow ten one two provide summarize key function barrier almost identical one except return fail doom transaction attempt initiate return value use restart doom ancestor order guarantee forward progress follow conflict definition nest parallel section transaction read memory object owner object ancestor owner safely read memory object without check version number reason explain discussion owner ancestor rely version number ensure owner neither ancestor transaction conflict owner line algorithm one periodically call avoid potential case figure two illustrate example nest ie abort restart none make forward progress memory object still crosswise lock avoid least one abort release acquire memory object purpose periodically check doom note could use precise detection mechanism would also incur large overhead also note similar case exist even finally note use avoid problem discuss section transaction attempt write memory object safely owner memory object otherwise attempt acquire lock memory object owner ancestor fail transaction conflict also periodically call avoid potential line algorithm two successfully acquire lock call consist self owner previous owner object transaction also ancestor owner validate object line algorithm one key insight transaction write ie acquire st large number child simultaneously attempt commit contention parent become critical performance bottleneck quantify performance issue section five four concurrent nest discuss subtle correctness issue encounter develop also describe ongoing correctness liven invalid read problem read barrier read correspond memory value occur atomically eager potentially vulnerable problem transaction may incorrectly read invalid memory value speculatively write abort transaction abort transaction restore original value validation process end read transaction miss problem flat problem simply avoid always value even abort transaction release however technique use due problem abort descendant value memory object ancestor memory object abort due value eventually root ancestor make forward progress solution correctly address time propose scheme abort transaction atomically increase global addition restore value first observe value transaction attempt read memory object first sample value read value associate line algorithm one ensure value remain unchanged line previously sample value compare current value two value match guarantee abort transaction since value read thus possibility invalid read two value differ conservatively avoid problem retry whole process line performance impact since single global use false degrade performance make repeat process several time even actually read invalid memory value furthermore extra code add access read barrier degrade performance possible instead use eager version management scheme lazy scheme use still use scheme avoid problem however performance issue transaction frequently access transaction commit problem figure four illustrate potential violation scenario due commit initially set zero read time three initiate commit time four time five validate time six write time seven commit one time eight start one time ten attempt write call algorithm one validate figure three example application run time twelve restart three time thirteen successfully read owner ancestor time fourteen successfully commit four still two resume execution child thread join time sixteen successfully commit ownership transfer b five qualitative performance analysis table one provide symbolic comparison common time complexity two different one use implement read ancestor relationship check pointer chase two hash table use implement read ancestor bite vector use fast ancestor relationship check assume common case case nest depth small strong temporal locality read write ie transaction write memory object hand assume worst case case nest depth large weak temporal locality read write common case time complexity almost similar nest depth small ie one need look write check validity due strong temporal locality read write however worst case time complexity significantly higher contrast still show comparable time complexity due use hash table current implementation follow implementation part future work addition time complexity three performance issue note first temporal locality lose access transactional nest since child transaction commit merge parent temporal locality new transaction begin core second memory object repeatedly validate across different nest level finally ast st clock time read write commit w w one one link list common case worst case one one hash common case worst case one one w w w table one symbolic comparison common time complexity r w denote size size nest depth respectively figure four potential violation scenario due commit figure five problematic scenario due zombie transaction ie valid doom yet ie merge yet therefore successfully write time eleven merge parent time seventeen successfully commit ownership transfer however violate eventually commit even two read observe different solution problem commit process appear atomic validate call address problem propose scheme scheme nest transaction attempt commit must acquire parent addition descendant validate ancestor call must also acquire validate ancestor ensure commit process transaction child appear atomic validate descendant transaction previous example scheme commit either happen validation first case doom eventually abort second case abort own attempt commit therefore violation occur case performance impact scheme essentially serialize commit child large number child simultaneously attempt commit performance hugely degrade due serialize commit possible could also address problem introduce transaction validation counter every time transaction validate descendant child transaction attempt commit sample value parent validate without acquire parent validation acquire parent compare previously sample value current value two value match safely merge parent guarantee validation descendant parent two value differ release parent conservatively repeat whole process evaluation alternative leave future work zombie problem figure five illustrate problematic scenario due zombie transaction initially b zero time zero start zero time two start zero write b time three four time five commit b one time six start one time seven successfully read b b owner root b however programmer assume always equal b within insert assertion check program unexpectedly terminate fail assertion check note could reach commit would eventually abort thus violation infinite loop also occur currently admit zombie able find efficient solution avoid unmanaged environment st ast st ast feature cache network cache main memory description core line private associative one cycle latency bus split protocol line share associative ten cycle latency cycle latency eight outstanding transfer table two simulate system thread one two four eight sixteen g k l one one one zero one v five thirty table three normalize performance difference relative stamp g k l v indicate genome intruder labyrinth vacation respectively correctness status point hand proof correctness liven algorithm therefore correctness liven algorithm still remain unchecked however hope paper generate formally prove verify correctness liven guarantee establish evidence correctness subject algorithm exhaustive test use model checker three simulator verify every possible execution small program run model configure generate every possible program four thread ie one two eleven twelve run one transaction perform two transactional memory ie read write access one two word explore every possible interleave every possible program thus far report violation currently fail verify thread memory due state space explosion check correctness liven configuration perform extensive random test run small implement algorithm simulator run fourteen concurrent thread ie one two eleven twelve run one transaction perform four transactional read write two word better expose potential bug inject random delay various point code line algorithm one checker compare value observe transactional read final memory state concurrent run test program produce serial schedule check fail checker report violation liven checker check whether test program successfully terminate far pass one million consecutive random test without report liven violation five evaluation methodology use simulator multicore table two summarize architectural except load store ten however detail memory hierarchy time model include contention queue use simulation result main result allow us report result provide detail performance without perturb result figure six execution time stamp one thread evaluation aim answer follow three question overhead due need nest parallelism ie run incremental overhead push available parallelism nest level nest parallelism improve application performance address practicality provide issue system address use seven eight stamp simulation six one use two implement concurrent hash table tree finally use use compose hash table detail provide later section overhead parallelism table three compare run stamp use list normalize performance difference two calculate use follow equation n p overall table three show maximum twenty across thread count exclude bay behavior make difficult compare result across positive mean time base one thread figure seven execution time stamp sixteen thread figure eight execution time ers additional code conditionally skip use investigate exact show execution time stamp figure six seven execution time application normalize execution time one figure six sixteen figure seven thread respectively execution time break busy useful cache miss read write abort time spend abort commit commit overhead work imbalance one thread figure six relatively high ie include large number intruder vacation six mainly due extra overhead amortize case hand overhead negligible large use labyrinth thread figure seven time spend abort several intruder due validation perform first write variable extra validation often detect conflict aggressively lead time spend abort incremental overhead nest study incremental overhead push available parallelism nest level use two perform concurrent access hash table bucket tree among insert write read four flat use perform sixteen four push parallelism use code enclose one big outermost implement add outer repeat manner figure eight nine show execution time execution time normalize execution time flat flat nest different transactional semantics ie whether perform atomically compare investigate performance issue figure nine execution time serialize nest ie perform sequentially transaction addition segment explain section bar contain newly add segment time spend acquire commit lock parent time spend commit observe continue scale sixteen thread example faster subsume version eighteen sixteen thread due number conflict scale well figure eight nine also reveal three major performance challenge first overhead read write nest expensive mainly due cache miss access entry read since previously use read transaction merge parent exploit temporal locality access transactional run nest contrast use locality access performance issue might mitigate use second commit time increase linearly nest level mainly due repeat validation across different nest level alternatively may choose different sixteen time subsume ex concurrent thread version time concurrent thread version figure ten execution time various transaction size figure eleven three serialization depend nest depth achieve better performance finally contention parent become performance bottleneck large number nest simultaneously commit since conflict infrequent even sixteen thread many child simultaneously commit trigger lock conin contrast due frequent conflict sixteen tention thread contention critical issue understand performance impact transaction size measure performance vary transaction size four per transaction figure ten present normalize execution time sixteen thread smaller four portion time spend contention small simultaneously attempt commit performance overhead due contention mitigate time spend abort large study much work require amortize overhead nest compare performance nest flat vary amount computational amount proportional number loop little work high due unamortized overhead repeat validation one possible optimization use lightweight hardware support validation seven sufficient work overhead amortize nest comparably perform flat improve performance use nest parallelism operate structure customer data single hash table multiple hash table hash table store customer information hash table store customer order customer operation must atomic include update level three ways exploit parallelism one outer parallelism hash table across two inner parallelism hash table multiple single customer three nest parallelism level nest parallelism advantageous level alone outer inner sufficient parallelism saturate system experiment figure eleven hash table twenty bucket hash table fifteen bucket randomly generate customer place order three line figure eleven show outer inner nest sequential run without lower thread count four outer perform best due rare conflict low overhead thread synchronization sixteen concurrent thread however nest perform best efficiently exploit parallelism level limit mainly due frequent conflict higher thread count six relate work moss discuss reference model close open nest transactional memory describe preliminary architectural sketch sixteen addition propose simpler model call linear nest nest run sequentially previous work support linear nest fourteen fifteen twelve seventeen work differ since target concurrent nest recently research support nest parallelism two four eighteen al propose theoretical algorithm support nest parallel upper bind time complexity two four al propose practical implementation algorithm achieve time complexity work build upon rather complex data structure concurrent stack could introduce additional especially state four contrast extend propose lazy design support nest parallel eighteen however work extend lazy provide detail performance analysis algorithm differ extend eager lower finally al propose support nest parallelism inside efficiently support nest parallelism low transactional synchronization use serially execute nest parallel use mutual exclusion lock contrast implement concurrent execution nest seven conclusion future work paper present system extend eager parallel design keep state small time sub size per best concurrent also discuss subtle corner case concurrent nest finally evaluate performance across multiple future work focus rigorous correctness argument also investigate improve performance explore alternative contention management lightweight hardware support would like thank anonymous feedback also want thank sun make code available support scholarship graduate fellowship work support award number pervasive parallelism lab research center eight reference one application program interface specification version thirty may two k j j nest parallelism transactional memory eight proceed symposium practice parallel program page new york three w n c k implement evaluate model checker transactional memory ten proceed international conference engineer complex compute march four j p r leverage parallel nest transactional memory ten proceed symposium practice parallel program page new york five r load balance implementation nest parallelism parallel six c j c k stamp transactional eight proceed international symposium characterization seven c j n j c k effective hybrid transactional memory system strong isolation guarantee proceed annual international symposium computer architecture june eight dice n transactional lock disc six proceed international symposium distribute compute march nine dice n understand transactional memory seven proceed international symposium code generation optimization march ten p c dynamic performance tune transactional memory eight proceed symposium practice parallel program page new york eleven optimize memory six proceed conference program language design implementation new york press twelve abstract nest second workshop transactional compute thirteen j e b moss transactional memory architectural support data structure proceed international symposium computer architecture page fourteen j b c h c k architectural semantics practical transactional memory six proceed annual international symposium computer architecture page june computer society fifteen j j k e l yen hill b swift wood support nest transactional memory proceed international conference architectural support program operate page new york press sixteen j e b moss nest transactional memory model preliminary architecture sketch workshop synchronization concurrency university seventeen ni v ar l r l j e b moss b open nest transactional memory seven proceed symposium practice parallel program page new york press eighteen h e e road sibling fourth workshop transactional compute transact nine nineteen b ar r l c b high performance transactional memory system multicore six proceed symposium practice parallel program new york march press twenty group institute technology laboratory computer science reference manual k performance evaluation nest parallelism zero scalable page h ar x r design implementation nest parallelism transactional memory