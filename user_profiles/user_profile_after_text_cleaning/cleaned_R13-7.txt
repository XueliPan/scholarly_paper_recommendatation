logical circuit filter amir computer science department university f g abstract logical filter problem track possible state world belief state sequence action fundamental partially observable dynamic paper present exact logical algorithm tractable deterministic tractability result interest contrast sharply intractability result structure stochastic key advance lie use logical circuit represent belief state prove time representation size linear sequence length input size independent domain size action compact number result formula number state feature also report reason algorithm answer propositional question circuit handle question past time step smooth evaluate extensively method outperform compete sometimes order magnitude introduction one much work ai apply system model whose state change time use model diagnose past predict future behavior make must consider multiple possible state initial state system know state observe fully every time step one fundamental reason task logical filter amir task set state possible belief state sequence action start initial belief state logical filter large deterministic important cult plan monitor diagnosis partially observable deterministic estimate belief state al al part perform estimation cult number state belief state exponential number propositional feature de domain several approach develop represent belief state compactly logic logical filter progression lin reiter update representation however none guarantee compact representation even simple amir instance guarantee compactness tractability sequence strip action whose precondition know hold importantly straightforward approach logical filter decide clause belief state representation time one base belief state time show paper show solve update problem entirety easier do create new belief state piecemeal present exact tractable logical filter algorithm handle deterministic domain importantly time compute belief state space represent depend domain size furthermore number result formula n number state feature compare n number use bound model check al extend circuit internal negation nod show similar space time bound hold restrict representation show reason output circuit include smooth query past result also useful perspective complexity previous negative result representation section intractability result stochastic key advance lie use logical circuit represent belief state instead traditional show update logical circuit formula amount add internal original formula take advantage determinism feature true action action make true already true action change interestingly empirical examination suggest graphical maintain compact representation update apply many require update bound model check plan partial observability attractive nature approach apply standard plan without fear reach belief state large represent two logical filter describe problem logical filter track state world hereby refer filter imagine assembly robot put together order construct machine part randomly orient must bring goal assembly begin part locate belt part drift hit fence perpendicular belt rotate one edge align fence see figure one sensor measure edge provide partial information part orientation partial part edge equal length sensor might noisy robot rotate part certain discrete amount place back belt pick try assemble de ne problem formally de deterministic transition system p set system pow p set world state state contain exactly true set action transition function p r h execute action state result state r r may partial example p touch touch pickup assemble rotate sequel assume implicit transition system g f g f figure one belt triangle drift hit fence rotate edge touch fence measure robot try keep track state world observe completely one possible solution maintain belief state set possible world state every belief state robot update belief state result perform action receive de ne semantics filter de filter semantics amir assume logical sentence p state robot consider possible ai two one filter empty sequence two filter j g three filter two four filter h filter filter ai filter j h r two true g f f j j call step two progression step three every state become r perform action receive observation eliminate every state consistent figure two illustrate update imagine robot isosceles right triangle edge size eleven one currently touch fence two possible b leave part rotate triangle ninety possible state update middle part world state see otherwise expect see observe right part robot eliminate b belief state leave robot know orientation triangle figure two update eleven triangle leave possible initial state middle progress rotate ninety rotate triangle ninety put belt right observe state b eliminate p three circuit filter filter hard problem j belief state na enumeration intractable large follow amir represent belief state logic solution provide research guarantee exact compact representation class model restrict action model canonical form use logical circuit order extend result deterministic section describe representation explain update sequence reason result p state es representation represent logical formula p zero able call formula represent belief state circuit de logical circuit logical circuit direct acyclic graph leave represent internal nod assign logical connective node represent formula one get apply connective node allow exactly one child explain avoid internal nod many corollary use logic represent r domain description set effect rule form cause f g action f g propositional p f conjunction semantics rule follow perform state iterate rule rule precondition g hold effect f nod hold r lead contradiction possible execute rest stay precondition hold state change also make action failure lead sink state consider triangle figure two triangle belt action rotate ninety rotate touch edge change effect rule cause touch touch cause touch touch cause touch touch touch touch touch describe represent present algorithm procedure ai h ai action initial belief state p f domain description zero one two f three two p new proposition g ai h zero process sequence four one five six seven return ai f p f two procedure action f g v update execute thus possible get f explanation cause f f hold effect poss f f effect f one f two three four f two two procedure observation p f g one procedure formula f equivalent circuit time zero p replace f node point one f two return two procedure ai h domain description ai action g f zero extract next value possible one f two three four two ai two h p f f poss f f optional simplify f f one f figure three algorithm algorithm overview present figure three demonstrate section four receive sequence initial belief state formula p domain description output belief state logical circuit algorithm maintain circuit data structure nod pointer node represent formula root node use interchangeably maintain follow one formula constraint base knowledge obtain far sequence receive know action possible execute constrain belief state two every f p formula formula explain f true figure four node mark e explanation formula touch time root node explanation time one keep number representation p allow involve j j time zero way similar regression express value f function initial world state give initial state two f belief state always word possible model satisfy f replace formula p f two v phase extract data domain description procedure line one create node initialize also create circuit initial use nod set pointer line iterate sequence update circuit every time step line see return update belief state closer look circuit construct follow stage extract useful domain description let effect set action might affect f set need know affect f let f formula describe cause f true simply precondition rule cause f hold several take disjunction f none set false j possible execute f hold f de similarly example take rotate ninety effect touch touch touch f g section touch touch touch touch procedure construct formula f evaluate true f hold give previous state intuitively either cause hold already hold affect similarly formula poss f state possible execute regard f ie true false time iterate sequence procedure use update belief state first construct circuit assert action f represent condition f extract domain description see possible correspond poss formula add line two build circuit formula procedure ensure circuit use construct new poss circuit leaf represent previous time step replace equivalent explanation nod circuit implementation crucial replacement instead copy whole formula need update edge graph use way share maintain compactness new circuit build explanation update line four new explanation root correspond circuit build line three see also section deal observation procedure similarly use get formula simply add figure four update explanation touch rotate ninety example figure four show update explanation touch action rotate ninety bottom nod represent explanation time action circuit image formula procedure replace correspond explanation nod node root graph represent state touch action right branch describe case action cause hold leave branch case hold action falsify next iteration pointer touch point node note reuse explanation nod internal nod possibly represent large query answer end formula return update belief state represent logical circuit interest ability query able entailment query j able follow construct circuit correspond query run inference query circuit let arbitrary propositional query formula want check whether able similarly observation add replace new query circuit query usually time circuit structure allow interest query particular smooth query refer past f change value last five step could initial value g true note every every time step correspond node keep track nod replace time step query give advance change complexity otherwise node might take log time note mechanism track previous many interest sit circuit build query circuit check ability traditional approach check convert circuit formula approach either grow representation exponentially duplicate share grow number instead run inference circuit number work show structural information lose encode use give sit performance improvement use circuit sit solve problem effectively original encode several propose recently take advantage circuit structure al al use simple algorithm generalization every iteration variable f choose set true truth value propagate far possible result smaller circuit example f parent set true well call satisfy assignment find backtrack try f false assignment find return take space circuit e j time e j edge l leave j j e j j four extend example give detail example whole process interestingly example demonstrate logical circuit represent compactly belief state one represent compactly use domain include ing sequence action make odd equal parity action one ai de set odd set odd odd odd f formally odd cause odd cause ai cause odd odd odd ai cause odd odd one set odd apply sequence show algorithm maintain belief state throughout sequence odd domain phase extract poss examine action affect odd executable odd odd odd odd odd poss odd easy see hold simultaneously formula true indeed always executable similarly action always possible execute poss equal true odd execute odd set odd odd odd equivalent odd word odd similarly action ai odd set set odd note simplify mandatory representation compact without receive arbitrary one odd execute action imagine sequence perform n action receive observation figure five describe algorithm update sequence time zero create node every another true nod represent value time zero set pointer formula want maintain formula set true initial knowledge explanation formula set correspond node execute arrive time one constraint add since action always executable explanation formula pi change since affect thing change state odd new construct graph update explanation pointer root node note image show gate sake clarity fact replace gate depict execute similar time two construct graph note substitute odd new value odd formula odd time one ie previous time step execute one observe odd example observation alternatively think query whether possible odd hold first process action update planation odd add odd create new circuit update pointer finally return circuit along update belief state answer query show example propagation assume time zero rest set false value propagate result assignment consistent sequence five analysis complexity correctness theorem correct formula sequence action ai h satisfy ai h g satisfy g two filter ai h f two f time initial belief state true b time perform c time perform time perform one observe odd figure five e propagate recall state es formula able section use formula state proof sketch present effect model show update formula model show filter de section two reduce consequence restrict language formula show compute exactly de effect model action de ne effect model time teff f f p poss f two v poss f f f f f f assert action occur time mean f perform result add subscript every formula see section de f effect model correspond effect explanation closure situation calculus reiter robot recognize impossible action drop assumption action possible adopt slightly different effect model recall filter de set state de ne analogue handle logical de let formula teff vocabulary l l l language ie allow subscript lemma result apply two formula represent exactly set state filter j f two p n g f formally let belief state formula filter f es g es g f two two j j de equivalent lack space present proof result compute filter use consequence restrict language however guarantee tractability instead use consequence show compute exactly let teff accord de observe consequence easy keep follow form p f two involve time v show compute furthermore show result formula maintain form need check form initial luckily problem every initial convert form linear time use new proposition let formula form state construct equivalent formula zero every two replace every two notation zero zero teff formula teff zero therefore zero instead note consequence use resolution algorithm resolve use compute zero zero two v let f f p v p poss f two f f p poss f two f v last formula rewrite p two f v note maintain f exactly form namely involve special proposition represent avoid confusion might v think new proposition line two p two also exactly explanation correctly progress action proof handle similar j complexity let zero initial belief state length sequence total length sequence let description action theorem allow time j j space alternatively use hash table take zero time output circuit j size precondition effect j two p j j j j j always drop space complexity precondition maintain formula instead note depend domain size usually j small especially action domain affect small number simple precondition p j j j proof sketch initialize take time handle action add nod edge graph take time worst case assume do need construct graph action cause finally time receive observation add nod j j edge result total j corollary maintain negation nod complexity j zero proof sketch circuit leave represent instead proposition maintain explanation since f de ne take every f f figure six leave filter time sec apply grid different size time linear depend domain size slight graph due implementation right comparison filter time several number represent domain size note formula use replace every literal explanation convert take time linear formula size therefore time space change modulo small constant domain initial belief state sequence action belief state representation exponential initial belief state size result show hold deterministic projection projection problem check property hold action step action system start belief state allow additional result previous section show projection doable apply generate belief state time add query run solver let maximal length single observation plus usually one since include n overall size n check variable assignment model take time thus test ability n instead n size formula n number propositional appear unroll system step use bound model check need guess n variable apply linear algorithm check follow result complexity result theorem projection let domain deterministic action problem answer whether state f satisfy q belief state formula sequence action query q number state n assume q polynomial n representation complexity result theory complexity simple combinatorial argument show belief state n describe use logical circuit size ie strictly smaller linear function nevertheless result show belief state reachable within polynomial number action initial belief state size linear input size initial belief state size action description also amir show every representation belief state note handle transition model however many inherently one natural solution treat action choice several deterministic example coin formula es exactly one hold use binary encode unfortunately number proposition grow linearly handle another limit class without add proposition cause q g g deterministic idea maintain belief p state different form l every literal l six experimental evaluation filter algorithm implement c implementation could also handle domain strip test figure seven list several various size observation model generate long sequence random sequence generator implement lisp run inference result use al circuit sit solver block gripper movie ferry logistics grid figure seven overview experiment step result present filter time model time figure six seven eight present result figure six leave show linear sequence length note figure eight total time model different size number per step time depend domain domain size time almost change even number grow time slight difference graph due implementation instead array circuit size depend implementation right part figure six show comparison compare algorithm one filter amir lisp two filter unroll system step use proposition three base filter base buddy package outperform sometimes order magnitude note graph p j comparison analysis size depend highly variable order even simple circuit representation either linear exponential size depend order optimal order know long process time begin due heuristic try achieve good order good order reach make process faster even could process large filter unroll also could process long sequence large also filter handle limit class unroll suffer frame problem ie need explicitly state change therefore depend domain size however manage handle large take per step figure eight show time model result circuit use version reason time grow linearly allow practical logical temporal sequence unbounded length note agent get constrain belief state therefore take longer satisfy model also formula seven straightforward approach create prime implicate time one belief state representation time previous work show decide clause belong new belief state even deterministic discourage research problem nevertheless work present exact tractable algorithm deterministic result surprise show create representation time one easier create new belief state piecemeal several approach develop past represent belief state logic amir none guarantee compactness key advance logical circuit representation also show maintain result obtain many important expect apply plan monitor control perhaps stochastic plan explore future work support national science foundation career award grant thank anonymous helpful comment reference amir e amir logical three al p heuristic search symbolic model check conformant plan one al em symbolic model check use sit instead r e symbolic manipulation order diagram compute survey conformant plan via symbolic model check al em r bound model check use ability solve formal system design al k p l malik combine sit solver p complexity language lin reiter f lin r reiter progress j buddy binary decision diagram package technical report institute information technology technical university f extend approach plan incomplete information sense press reiter r reiter frame problem situation calculus simple solution sometimes completeness result goal regression intelligence mathematical theory computation academic press al c f walsh ing search practice constraint program update logical press