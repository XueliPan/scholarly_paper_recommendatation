continual computation mellon university eric research abstract autonomous sense reason act extend often need solve stream incoming traditionally effort apply already arrive note examine continual computation allow ideally allocate time solve current well potential future uncertainty first review prior work continual computation present new result include consideration share multiple task present result computational complexity problem provide arbitrary model computational performance finally review special address uncertainty best algorithm apply learn performance consider cost associate delay use result introduction one immerse extend time typically face continue stream competitive afford luxury cease problem solve might typically refer idle time challenge continual computation ideally partition available computation current well future uncertainty nature arrival time future consider best reason reflect recall forthcoming challenge also describe shift computational challenge yet arrive shall review prior work continual computation focus several first consider handle multiple task extend prior work handle stream separate single task explore continual computation share work introduce perform research internship research utility model describe value achieve computational refinement enable tractable composition optimal continual computation tractability approach hinge proof demonstrate greedy optimal utility model show fit paradigm compute tractable relax utility model discuss complexity compute continual computation general utility function introduce polynomial approximation move introduce special continual computation consider include case freshness result important value store result degrade time also consider learn reason performance several model share study continual computation synthetic two background prior result continual computation provide ideal allocate time solve current future whether solution result value unless problem solve completely flexible partial result increase quality produce computation work work also describe include cache reuse result shall briefly review several core continual computation refer detail assume agent infer p see different problem instance next time period within environment e base experience give future challenge agent spend time available challenge work provide minimize time require system solve maximize expect utility computational problem solve take period time available challenge idle time allocate initiate complete solution problem instance ahead time maximum quantity time allocate solve future problem instance time need solve problem completely without delay expect solve future potential prob instance uncertainty agent begin solve completely solve one future advance arrival expect delay next period p p theorem policy minimize computational delay give order problem instance probability p p p pass problem solver next period resource policy minimize expect computation time next period apply likely problem solve next likely cessation idle time solution consideration next period reduction expect delay obtain greedy algorithm apply likely instance solve remove instance consideration make argument iteratively remain n one remain idle time prior work continual computation also provide result minimize expect cost delay give cost function future problem instance cost take instance period time require compute instance follow challenge delay response apply computation begin solve solve completely one potential expect delay arrival tractable specific class cost function introduce example consider case cost increase linearly increase delay solution available cost p cost cost expect value follow arrival challenge maximize allocate idle time available advance challenge commence solve instance associate expect rate cost diminishment p continue solve solve instance next highest expect rate instance solve study continual computation also examine trade apply continue solve already arrive computation might arrive future idea agent might wish slow cease problem solve current problem give expect value might come answer problem expect arrive later probability prior work continual computation include allocate time flexible briefly review assume algorithm refine initial problem instance previously compute partial result new result terminate final complete result reason may often uncertain value associate future computation must consider probability distribution result achieve return investment time condition current partial result procedure select p one study continual computation flexible make use expect value computation al expect value computation change net expect value system behavior refinement one result allocation computational consider probability distribution computation cost computation refine single result si p j si j j cost two value previously compute key concept derive continual computation flexible expect value derivative flux expect potential future problem instance si time p si three flux instantaneous rate expect value future result change point allocate second time solve problem si dev p si four continual computation sequence effort among potential future problem instance compose consider compute integrate flux allocate instance sum together derive problem instance p five zero present prior work several class algorithmic specify time allocate base follow maximal flux note although probability future call key guide allocation computation time take input qualitative order likelihood flux thus probabilistic knowledge use ideally triage idle time three handle multiple task prior work consider stream individual independent first consider among task portion cache later share among task present handle case multiple task arrive key consideration work perform solve one instance might reuse solve another instance situation occur instance share result compute common procedure let set task compose suppose independent solve instance separately proposition policy minimal expect time completion let p p probability next problem instance need give order subproblem instance probability p p p policy minimize expect computation time next period apply likely subproblem solve next likely cessation idle time solution consideration next period relax assumption independent problem become harder suppose example correspond partial precedence order impose graph dag word execute precede complete consider correspond decision problem give total time perhaps fractional subset perform gain expect time least k theorem set arbitrary precedence order decision problem n proof sketch show reduction give graph g v e construct follow instance let v e ie task every edge task every vertex define precedence order edge task pick completion two correspond vertex task let task p v one p e one total time need v one e one let k one k k one one since p represent need normalize end g v e pick correspond vertices edge valid solution valid solution easy see include least k vertices include k one vertices since capacity large enough since ratio p lower one every v fractional vertices lead valid solution well k two k two valid solution therefore must include edge precedence imply edge form k clique choose vertices therefore graph contain k two multiple task prior work continual computation focus case idle problem solve period disrupt arrival single task arrive generalize formulation case multiple task arrive simultaneously let p se probability subset appear want maximize corollary consider set task single task elemental reformulate task therefore greedy approximation describe proposition apply use p p se optimal note greedy algorithm optimal maximize many natural objective function use minimize total response time time since instance pose solve useful hold model hold model well assume future task arrive probability interchangeable conduct experiment evaluate utility continual computation multiple task generate synthetic task task assign probability appear function describe utility partial result increase computation model base analyse do project center application web page study obtain crawl subset web every detail crawl find al take task refresh cache task change significantly two consecutive determine similarity assert active intuitively task refresh local copy web page use data calculate probability activation every task assume task become active independently previous time step task rather assume document provide value completely allow value draw portion document immediately available similar approach take word partial content web page utility function use nonlinear curve capture notion decrease marginal return additional fetch content employ class utility function page scale function different page reflect page popularity word refresh portion popular page higher utility less popular page due diminish return property may prefer start fetch less popular page complete popular simulate different test sequence task pass solver compare value generate traditional reactive algorithm initiate problem solve problem appear versus algorithm keep size web cache constant condition figure one show result experiment figure show two line represent ratio utility generate across cache default reactive procedure time dash line correspond study task arrive mean arrival time fifteen time faster case represent solid line order see rate instance arrival affect utility ratio show reactive proof n p give solution check require polynomial time also n show reduction knapsack problem knapsack problem give n item value weight wi maximum weight carry bag w problem find put bag total value r give instance knapsack problem construct follow instance let w item correspond function fi st fi zero wi fi wi wi wi fi wi solution problem correspond exactly solution knapsack problem let wi correspond instance whose correspond time least weight without loss generalization assume instance wi since utility constant point feasible x wi fi w x x x fi r since wi wi fi wi fi therefore n hard hope optimal polynomial algorithm instead investigate approximation algorithm general utility function show algorithm formulate problem term set cover let monotonic function every instance create xi k k one min xi k represent computation unit spend define reward item r xi k fi k fi k one marginal utility spend extra unit spend already create set si k j si k correspond spend k associate cost k time take compute let denote set set total number set polynomial representation size problem find maximize total reward cover f st cost r x sa cost theorem let greedy solution greedy solution ignore cost f f one e approximation algorithm run n time two one one proof base al note f cost modular will pay also get one one e approximation lazy also speed algorithm figure one ratio utility traditional reactive computation time mean arrival rate instance utility ratio capture dash line fifteen time faster utility ratio capture solid line putation time however perform worse point time continual computation solve future instance rather current investment prove useful time surprisingly perform better longer idle solid line four hardness approximation general utility model prior work continual computation present ideal several class flexible define functional form refinement utility partial result computation class include refine result constant flux piecewise linear flux decrease return smoothly increase utility decrease return natural question arise generalize optimal class show general form problem n give approximation algorithm n start formally define give problem instance correspond utility function definition utility function let set monotonic function say fi utility function instance fi utility partial result spend computation instance work computation assume function n r problem essentially discrete temporal grain size arbitrarily fine also fi zero zero problem find consider decision variant problem definition decision problem give utility fi r find fi r fi st st standard ie binary search allow us switch decision search theorem n five special move special continual computation introduce explicitly model prior study include hard time generation use explicit model learn reason performance model focus value update refresh age result task web cache crawl explore special analyse task hard solution time previous work consider problem reason procedure provide smoothly increase utility decrease return context cost increase constantly time decrease return constant cost continuous process refinement cost weigh computation cease cost computation outweigh benefit additional refinement result contrast smooth process shall consider case continual computation hard let us suppose task associate deadline task complete time appear complete gain nothing computation task maximize probability complete task maximize expect utility associate task complete first note need spend time appear enough time solve spot without loss generalization assume true spend task inequality relationship true make sense spend exactly time exactly knapsack problem knapsack capacity task correspond item size value p also optimize total expect value via approximate greedy attempt maximize overall expect value example approximation partial result order dictate ratio value cost approach use approximation procedure come within factor two maximal value storage policy efficient exist knapsack problem achieve run time n log one four one approximation one explore performance knapsack approximation procedure generate synthetic task hard test quality algorithm run limit amount time like experiment describe base arrival rat instance change rat time need solve instance choose uniformly random make sure use algorithm manipulate number figure two show result point represent ratio value figure two approximation ratio knapsack approximation hard deadline model point represent ratio different trial new random choice completion time task represent approximate solution ratio ten solid line twenty approximation recover solution twenty approximate optimal compute via dynamic program follow ten approximation algorithm achieve good result little twenty result approach take fraction second execute run order magnitude faster solution result freshness time use continual computation date allow arbitrary delay solution use solve challenge continual computation also develop provide special cost time usage result example result might immediately harness agent draw value lest result render worthless arrive time reward obtain fi reward available immediate use reflect amount perform task arrive relate set utility solution diminish amount time pass use situation view force pay rental fee store result memory thus best produce result ready near time need rather produce far advance pay storage example scenario continual computation consider case computer access web page via proxy server server cache copy web page however page change probability every step although know page change fetch new copy guarantee date next step addition popular expect number request arrive page every step reward receive respond user request update page ideal fetch policy wish maximize page fresh time optimal policy periodic since discrete number state finite natural extension seek policy refer reader al derivation study operation algorithm find optimal stochastic periodic policy maximize expect number request polynomial time algorithm problem convex optimization problem probabilistic performance model many involve uncertainty outcome action uncertainty apply problem solve let us assume result spend one unit computation completely system control addition system target run indefinitely environment may want minimize discount reward assume know action model full observability ie know result past action property give state system transition next state independent previous state action decision process provide useful mathematical framework model type situation briefly review framework show model problem define x r p x finite set n state finite set action x r reward function r x represent reward obtain agent state x take action p transition model p x x represent probability go state x state x action let us assume problem instance appear time along every time step either spend computation instance return solution active instance reward receive base amount refinement instance addition storage limit amount refinement store easily model x state system many computation apply instance instance currently active three type action spend next computation free memory last computation submit best current refinement reward illegal action try add something memory full free unit none memory solve problem active reward solve active task base utility function fi number computation apply refine x exist efficient enable us compute optimal update policy however exponential number state thus untractable even small fortunately internal structure model compactly structure exploit representation factor al one approach represent large structure compactly framework state implicitly describe assignment set state dynamic network allow compact representation transition model exploit fact transition variable often depend small number vari furthermore momentary reward often also decompose sum reward relate individual small cluster state represent factor define via set set random yn k xi denote number computation cache task binary denote whether active instance pass solver k xi number cache use action reward version transition deterministic case straightforward cause k xi increase possible cause decrease reset action cause switch zero one probability p never way around case transition formulation slightly different xi denote current point utility function possible model transition model general factor framework flexible many plausible model case immediate response without cost delay case computation reset xi use al efficiently solve large set artificial task learn performance far assume knowledge performance focus support continual computation endow ability learn performance time several class learn use update future stream instance performance instance latter predictive model performance condition attribute instance well provide solution procedure prior current instance solve al focus manage challenge would like balance exploration pursuit new data performance exploitation apply learn policy refine result assume set task might pass solver next instance addition set solver apply example case procedure may name server use task associate subset apply algorithm utility function fa theorem optimal policy multiple know utility function reward profile apply every algorithm know advance greedy policy optimal happen probabilistic linear utility function unknown slope assume full observability every time apply algorithm instance know outcome choose algorithm provide information utility function partial allocate time current future extend deliberation handle multiple interrelate task provide complexity result continual computation general utility model offer polynomial approximation finally describe handle special case include model uncertainty performance hard time compute problem believe continual computational endow immerse open world intelligence allocate computational hope analyse harness increase value computational variety reference al e j resonance web web dynamics revisitation pattern dan r b ken morris e chi page al p n r e gamble rig casino bandit problem z p efficient algorithm probability estimation combinatorial optimization count methodology compute apply probability al c r stochastic dynamic program factor artificial intelligence al parr efficient solution factor nineteen al cooper de reflection action scarce theoretical empirical study al e c h b approach tackle hard computational page think ahead continual computation allocate e continual computation artificial intelligence e l fast approximation knapsack zero al j c c j n glance outbreak detection network seven approximate one knap sack j al e e continual cache crawl technical report note maximize set function subject knapsack constraint research letter figure three regret time learn line represent different choice model noisy process random mean association task regret decrease gambler learn problem solve use bandit problem problem base analogy traditional slot machine bandit one lever pull lever provide reward draw distribution associate specific lever gambler want maximize collect reward sum iterative pull gambler face trial exploitation lever highest expect payoff exploration get information expect lever case hand correspond lever every turn choose highest probability solve yet concentrate subset solve apply instance solve use knowledge gain previous solve next instance typical goal bandit minimize regret regret round define difference average reward associate optimal strategy average collect reward apply simple algorithm achieve regret order n log order evaluate bandit framework generate synthetic consider set task twenty task model fetch scenario task associate randomly select subset algorithm model noisy process different mean choose uniformly random use algorithm al evaluation figure three show regret time three different set randomly select expect regret decrease gambler learn examine result reveal reduction regret come diminish empirical variance performance six summary review key prior work continual computation provide new analyse extend work analyse provide face stream challenge new optimize