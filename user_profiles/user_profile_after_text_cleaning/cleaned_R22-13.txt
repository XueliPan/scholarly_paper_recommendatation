combine processor instruction set exploration embed vincent colin university school institute compute architecture abstract industry demand flexible embed provide high performance short lead development extensible build prove core allow degree instruction set implement functional extend traditional design flow base plain c source target application identification synthesis stag modify source file produce explicit handle new machine code optimization leave compiler paper develop novel approach namely combine exploration identification combine code transformation explore potential benefit combination apply fifty selection seventy synthesize result code result performance measure snurt show instruction generate tool heavily influence source code structure result demonstrate combination instruction set yield average performance outperform instruction set apply isolation extreme case yield subject performance reliability performance analysis design aid embed optimization general term design performance instruction set extension design space exploration permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee seven copyright c june san introduction one high performance short two major factor embed design goal deliver best performance give cost possible design time recent processor address develop extensible arc arm pro series core provide system thus reduce risk involve cost new processor design also offer large flexibility instruction set may help improve performance result specialization optimize processor derive generic processor template order explore different design stage trade various partially contradictory design performance power chip area tool support indispensable exist commercial one academic two tool analyze application write c identify candidate instruction modify application source code insert handle newly create general overall effectiveness approach depend designer ability generate complex instruction replace sufficiently large number simple machine b frequently execute c efficiently implement paper address b show selection good instruction strongly dependent shape c code present generation tool propose novel methodology combine exploration program instruction use probabilistic search algorithm transformation tool generate many different semantically equivalent input program present generate program integer linear program base tool program set new generate along profile base estimate execution time code size result exploitation new use approach achieve remarkable performance average across intensive embed demonstrate approach enable generation powerful unachievable traditional additional tool effort n g n e h r c r c one n g n e h r c r c n g n e char n e c h n n g n e h r n c r c n e c h eight f zero eight n zero f n n one four one two nine e l e n one r e r n n n g n e h r c r c n g n e h r c r c n g n e l n g l e n h r j n n j r e v v r b l e e c l r n f n n one f j zero j j c r c b j c r c one j eight c h zero r c h j c h j four j four f j n zero c h j n c h j n eight e l e f j r e v zero r c h r c h eight f j one j l e n j f j r e v zero r c h l n j l n j c r c b eight e l e f j r e v zero e l e r c h r c h eight r e r n c r c one n g n e h r c r c n zero n n one four one two nine n g n e h r loop n r l l n g f zero eight two f e l e n one r e r n n n g n e h r c r c n g n e h r c r c b p c k n g f p j n j r e v l e n f p f n n one loop l w e r n g j zero c p n f w h l e j two five five b n p c k n g zero two f f two f p p two f p four f p zero c r c b r c h r one l eight f p move l p n v r n f four f p zero c n n l loop l w e r n g c p n f w h l e j eight f p l r l w e r e l p b e f r e e l e f j one f e l e zero four f f e l e p r e r n original snurt implementation b transformation figure one original snurt implementation application result best combine performance b eleven motivate example example consider code excerpt figure one two function part snurt implement cyclic redundancy check input string store array lin key feature code small loop function contain conditional branch perform number manipulation present plain code current instruction set extension technology see section four generate new instruction result performance improvement code figure one b main due code figure one show code functionally equivalent outperform code figure one factor loop unroll apply loop function reduce loop overhead improve flexibility instruction schedule function effect transformation fundamental loop code lower loop important hoist loop invariant apply pack multiple single variable type integer usually degrade performance combine generation however otherwise expensive manipulation pack unpack encode complex fast yield overall performance improvement fact instruction generate example one b generally complex generate code example instruction show figure one implement mention operation move loop invariant conditional outside loop eliminate redundant jump increase performance generation base transform code figure one b result improvement transform code total combine certain part performance gain directly attribute code rest due enable effect generation short example demonstrate difficult predict best transformation instruction set extension give application also show code architecture optimization separate tightly couple combine exploration hardware design space generate significantly better solution isolate optimization approach could produce paper present empirical evaluation design space interaction show probabilistic search algorithm able examine small fraction optimization space still find performance rest paper organize follow section two discuss large body relate work section three present background research discuss problem combine design space exploration section four describe methodology experimental setup section five discuss result section six conclude paper two relate work paper seek broaden understand potential know transformation improve quality instruction set selection current state art instruction set extension describe section follow description section large field summarize figure two complex instruction template generate transform code figure one b figure three methodology design space exploration instruction set extension exploration actively study recent lead number three four five six derive partition hardware work still form define full space exploration even purely arithmetic instruction set design seven work include better model tool allow better performance feasibility eight current exploration approach use range tool operate canonical describe compiler exploration nine originally motivate ten discovery iterative methodical exploration design beneficial decrease cosy eleven twelve tool feature many figure three illustrate combination thirteen combine code transformation target transformation towards efficient arithmetic structure operate post directly contribute design space search improve upon result fourteen show exploration successful enable better perform motivate approach perform comprehensive systematic study paper demonstrate effectiveness transformation due inherent portability large scope use various field code target io performance fifteen energy efficiency sixteen seventeen formal verification eighteen notably single multicore performance optimization intensive embed nineteen twenty respectively rise tool build transformation tool optimization c c empirical study digital signal process subject twenty comprehensive study context base adaptive compilation find active research area ninety inspire subsequent work electronic system level design comprehensive summary research approach tool find work cover broad scope issue typically range analysis system evaluation design verification contrast work focus specific individual problem namely partition context extensible three background extensible extensible contain number variable essentially open design space inside processor core exploration designer system register support arithmetic logic implement outside prefab core latter implement expect basic functionality manner may make best use freedom provide knowledge make unpredictable time change core whole core allow whereas provide either extend implement respect architecture extension interface exploration exploration optimization process design flow soc typically operate multiple performance power energy cost complexity target often multidimensional highly figure four simplify view family architecture demonstrate core connection instruction set extension custom register arithmetic nonlinear optimization space multiple dependent level algorithm design space exploration interaction make difficult employ isolate local search approach require combine effort cross traditional design provide feedback integrate tool extensible processor core arc number allow instruction set optimize particular application design concern guide often reduce metrics execution speed power usage die area metrics accompany relevant design space configuration extension domain meet requirement mean increase speed generally useful provide overhead development application meet system build around core able communicate process data without stall due miss core execution speed meet focus may switch secondary ax design concern power usage address one axis design concern may make use ax example performance exceed clock speed may reduce reduce power consumption secondary concern additional design space core available explore satisfactory example clock gate dynamic voltage scale unit prune however outside scope instruction set extension cover unfortunately second order effect core extension always beneficial often hard predict accuracy add logic core example increase critical path force reduction overall clock speed complicate web form space explore efficiently aid iterative mean instruction set affect three mention ax design concern guide metric derive often still application execution speed add cover frequently execute section application code intention partition application code cover dedicate service new highly design space several source optimization currently bring bear hardware performance new instruction parallelism parallel instance arithmetic hardware order perform multiple allow reduce overhead due increase locality communication within functional unit use represent new instruction aggregation clock period surplus present arithmetic function particular bitwise function hardware latency far clock period case grow optimization aim ensure represent new instruction achieve maximum speed possible trade die area increase execution speed decrease power usage decrease often correlate frequently execute section code benefit relatively small increase tempt problem remain find way accurately model exist architecture full range potential way efficiently exploration show fourteen new search develop control application respect new set inherent compare code generation target would attempt limit increase basic block size due register pressure instruction set extension drive towards possible basic block size analysis combine design space combine design space question transformation intention demonstrate promise manage design large space also important result framework outweigh sum separate hope actual search combine space remain phase search space individually important factor scenario accuracy detail model employ decision make work attempt contribute understand need make invariantly beneficial extension use compiler transform develop design space exploration must carefully consider disturb context make run prior tool must tool identify otherwise find map without explicitly define manual mean four experiment methodology primary concern experiment determine thereof infer execution speed improvement secondly experiment find limit performance gain loss combine design space define transformation design employ neither information well equip properly focus future research towards beneficial figure five combine phase search transform design space experiment methodology flow diagram represent transformation design space experiment use source source transformation tool build upon compiler framework sample take uniform probability random point across entire space potential transformation sample sense represent single point transformation space result order set select sample point apply code tool generate large transform source code sample rapidly definition source code c purpose variety single function test transform space definition inclusion exclusion transform permit space plus maximum number transformation phase sample tool support wide array source source use exploration allow maximum fifty phase sample number sample take transformation space hence number transform source cod produce case set however sequence transformation produce invalid code hence cull result number valid transformation sequence cover section five use experiment take thirty suit take follow snurt fir select edge detect fir fir one histogram four eight one eight one mult ten ten mult four four store entire set transform source cod represent sample point transformation space apply set transform apply sample also store later correlation analysis set transform source cod form representative sample entire search space sample process profile tool base al integer linear program method derivation five tool operate three phase instrumentation wherein tool augment intermediate representation application counter profile tool emit assembly profile executable assemble run use standard gnu tool chain execution run instrument binary record execution store file use extension phase extension augment profile statistics use select top four use algorithm five tool profiler combine latency table give target architecture produce performance metrics original sample metrics generate store alongside transform code definition algorithm control transformation input program probabilistic algorithm derive combine space exploration component focus search algorithm maintain probability vector represent selection probability transformation start uniform probability distribution selection update iteration base transform program algorithm use generate conversion basic block set integer linear program solution program implementation tool build cosy compiler use solve library solve generate set candidate entire program declare basic block generate template template convex ie hole may schedule input output port meet ie number register input output port sufficient may implement addition goal function also express algorithm goal estimate serial time execution cycle cover template minus estimate critical path template former denote execution time indicative time instruction would take execute unextended architecture latter denote hardware execution time factor cycle time take execute template single instruction cycle time hardware operation specify tool apriori construction allow generate difference hardware execution time gain cycle architecture implement template follow generation basic block check isomorphism one another use graph isomorphism library rank use product estimate usage gain top four record alongside performance estimate inclusion result experimental setup purpose experiment configure processor current embed base upon instruction set port constraint set allow wide range potential avoid result due synthetic set algorithm show eight possible reduce register file io suit actual therefore sample point source code transformation instruction set define record performance cycle apply likewise record improvement performance metrics generate transform source aggregation result top four calculate overall benefit transform code control point reference ensure utilize transform sample transformation space tool produce many find within source code however limit number use result four order allow inclusion best perform expect reveal transformation current commercial approach tend use large number small preserve generality work assume core desire entire experiment run machine run course several days order allow sample tool operation speed result generation illustrate figure five result record go make correlation transformation performance space combine form relevant performance measure overall performance five result figure six seven show achieve selection snurt suit three bar represent best improvement see search space technique peak snurt snurt see alone alone combination two respectively average across suit respectively also see consider five see combine transformation performance improvement six see improvement less figure six achieve snurt figure seven achieve figure eight achieve snurt figure nine achieve four eight four eight improvement snurt base run b snurt base run c edge detect base run eight one base run figure ten achieve every transformation sequence search space selection version program three value show raw performance transformation raw transform performance combine transformation combine performance point performance technique unmodified code code order increase combine performance along figure eight nine show achieve graph base sample point improvement figure separate transformation sequence find effective reduce peak snurt snurt see alone alone combination two respectively average across suit respectively see figure six seven eight nine average result snurt noticeably higher primary reason snurt smaller potential selection space smaller thus better suit uniform sample although explore tiny fraction overall search space still obtain good result however seem likely explore portion search space yield even better result especially program program also likely benefit direct search technique quickly focus promise search space one describe show many case simply choose allow effective use give good overall performance strong one optimal combine performance give set allow improvement combine performance significantly better either alone snurt snurt graph figure ten show performance individual technique combination two every sample point search space small selection sample sort performance combine allow ratio transformation performance see also show performance two individual see either performance snurt b figure eleven maximum performance find far point sample space point evaluate ie development best perform program far program generate transformation tool improve point one get better get worse example correlation see leave side figure ten c show separate performance set allow good performance perform poorly overall due performance decrease see transform alone useful example correlation show motivate example snurt bite pack transformation sequence make use transform mark short vertical bar figure ten see best perform sequence make use transformation point change turn turn dip performance rise magnitude transformation performance see transformation performance improve greatly negligible improvement without sequence turn performance recover correct surround bite pack transformation allow code performance good performance figure ten b show almost ideal set result snurt best set transformation sequence consider alone also allow gain optimal sequence overlap way combine performance high go peak individual peak combine snurt sequence give clean result though figure ten motivate example snurt show pattern visible several specifically best performance give find transformation sequence improve code damage potential optimal sequence actually give performance slightly achieve code overall performance high due good transform figure ten show result almost none overall improvement come almost entirely one however graph still show shape limit figure eleven show performance best transformation sequence find far point sample space evaluate figure eleven show example snurt kind lead evaluate high number sample transformation space contain several step performance best sequence find far best find several thousand sample evaluate however typical figure eleven b example show typical behavior also step performance best sequence find far much closer together best find five hundred run none remain sequence evaluate better suggest consider smaller number sample still give acceptable result though consider number sample may find step lead even greater performance regard number sample consider result see figure ten eleven number vary transformation sequence either cause internal correctness check compiler trigger case generate incorrect code sample discard still great many remain use generate result six paper describe methodology improve generation combine exploration source identification demonstrate effective provide much scope performance improvement generation isolate technique integrate generation unify framework efficiently optimize hardware design space extensible empirical evaluation design space exploration framework base model processor snurt suit successfully demonstrate approach able outperform exist approach give average compare previous work fourteen cover much array exist get global picture potential transformation improve instruction set extension addition demonstrate exist dependence generate instruction set justify design space future work investigate integration machine learn base program feature design space exploration algorithm target commercial extensible processor platform reference one arc international architect product brief two r k design flow embed base optimize instruction set extension synthesis proceed design test date three laura paolo de automatic instruction set extension proceed international embed conference four laura iterative paolo generation technique fast fourteen seven five integer linear program approach identify proceed international conference system synthesis five six laura paolo exact approximate extension embed processor instruction set design integrate circuit seven seven k paolo towards automatic exploration arithmetic circuit design conference san proceed eight laura paolo exploit relax port proceed international conference synthesis embed san page nine h k r g h architecture exploration efficient application specific embed processor design design weka ten h methodical design space exploration signal process eleven ace cosy twelve thirteen paolo k arithmetic use compressor tree proceed international workshop electronic design test fourteen paolo laura code transformation case six proceed extensible embed international conference architecture synthesis embed page new york press fifteen wang source level improve io data partition proceed international workshop storage network architecture parallel sixteen e l g de energy efficient source code transformation base value profile proceed international workshop operate low power seventeen c kulkarni f h de man code low power cache embed proceed international parallel process symposium international parallel process symposium page eighteen winter improve formal verification conference computer design proceed international nineteen peter source code optimization data flow dominate embed academic twenty array recovery high level embed compute two two may victor de la array regroup use compile embed one combine program recovery locality analysis c program embed proceed international conference parallel compilation pact three new j architecture proceed joint modular conference c framework write c program crossroads probabilistic embed program proceed conference tool embed five marc use machine learn focus iterative optimization proceed annual international symposium code generation optimization engineer press new york p saman p w k mary w hall lam l infrastructure research parallelize optimize notice twelve snurt thirty g lee compiler solution code performance challenge