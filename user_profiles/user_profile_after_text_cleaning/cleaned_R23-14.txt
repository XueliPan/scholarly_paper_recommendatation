solid university phoenix interactive abstract paper present technique interior watertight model high resolution single render pass develop filter algorithm build density estimate allow deduction model achieve via dense pack information use bitwise arithmetic demonstrate versatility method present several like translucency effect interaction particle morphological speed method open road previously impossible approach grid one billion recent graphics card solid index term data structure data type computer graphics methodology one introduction geometric complexity computer constantly increase consequence render become expensive counterbalance graphics hardware nevertheless many task go beyond pure display interaction become expensive number increase make alternative important one popularity come simplicity regularity general advantage volumetric thirteen seventeen variety field exploit include effect like shadow twelve visibility query collision detection fifteen long time costly task often perform model place volumetric grid approximate store information represent geometry grid entry particular binary use indicate presence matter recent binary eight ten provide better performance solely derive boundary graze angle introduce hole impose several pass eight reduce resolution conservative boundary present fast method deliver solid mark lie interior model important many like path find visibility two paper explain efficiently convert watertight model high definition binary volume representation solid interior approach advantage method share faster previous work two two order magnitude even older hardware memory consumption usually graphics interface conference may canada copyright hold author permission grant publish print form publish eight time lower contrast accurate assure watertight model single render pass show representation well adapt many propose adapt scheme respect parallelism memory derive density function resemble local distance field distance field useful physics allow definition sample surface avoid store float create dense pack information use allow possible result normal information exploit many like particle illumination effect enable interaction scene whilst involve geometry fast pass specifically follow solid extension original algorithm ten conservative boundary also benefit solution estimation efficient computation age local density function explain method illustrate use variety translucency effect object intersection large volume visualization particle collision detection interaction mathematical morphology application illustrate versatility solid improve previous work motivate two fast solid base explain section four derivation normal information consequently method description divide two part section five introduce binary solid section six describe derive density resemble local distance field normal extraction present several section seven general result section eight finally discuss method section nine conclude section ten three previous work early approach base point query model even nowadays practical model sixteen present robust approach deal complicate geometry report computation time order second typical model hold thirty layer depth representation derive count parity center projection direction avoid extract store layer depth image achieve performance accurate point sample approach sample binary response resolution lead binary sample relate standard mostly use hide problem spirit high resolution grid allow capture detail derive smoother density estimate nevertheless hide solve problem alias free present involve expensive distance calculation practice even medical binary representation seem often sufficient situation generalize set might need precision several billion recently approach suggest benefit tremendous performance increase graphics hardware last fang four store binary bite representation use clip plan transfer accumulation buffer normal estimation do replace accumulation texture slice texture become float approach give normal information without costly time memory process even latest card one memory would possible previous work could extract large amount slice normal information nine modern hardware extract small amount property layer one pass currently eight buffer decrease grid resolution increase number pass solution use replace blend avoid incoherent result thus keep last value write fragment blend evidence suggest long time optimization issue thin thus front well back face fall clip region one normal store thin refer scene rely around sixteen layer due performance issue problematic interact side attribute extraction limit uniform base shape lead coherent value al twenty use simple depth map deduce information handle correctly depth peel eleven use arbitrary surface attribute trivially obtain number peel pass unknown object viewpoint dependent imply need high amount texture memory especially extra attribute retrieve also involve costly occlusion query peel typically low depth complexity handle furthermore evaluate efficiently extract layer uniform representation vertices scatter per layer resolution hole may appear graze fragment define one whereas depth range represent might depth peel several try address problem also overwrite concurrent information method handle graze angle automatically solid first present dong al eight propose flood fill along third dimension algorithm fail case two fragment fall ten perform solid single geometry render pass front special texture allow derive enclose space without explicit flood fill ambiguous occur several front fall one recently importance solid show context interaction fluid gas five stencil buffer alternate one zero find parity number towards eye also use four stencil buffer pass one slab next approach limit extraction one layer per render path solution provide binary layer single pass even older hardware six series conservative problem solve recently author derive depth fragment transform use texture conservative also use eighteen approach accurate slow even small one slab create per render pass focus conservative solid case two conservative exist lie entirely interior lie partially interior present section default technique perform artifact free accurate sample center four background boundary build upon work eight ten briefly review binary grid represent via single texture j k value zero one encode bite representation j figure one provide illustration r g b n e l b e n g r e n h c e l b n e n r h c z x fill column slice figure one binary grid represent use texture instead see color separate information interpret one concatenate vector entry correspond position space three dimension grid treat equally texture define dimension representation form column grid define form slice hence term coin ten refer texture obtain suffice render scene fragment depth lie slice shader output color bite activate set blend mode bitwise operation fragment project correctly combine ten approach interest allow keep track fragment single pass rather discard drawback depth quantize whereas depth peel full precision arbitrary information per slice advantage include result single texture number peel step need often neglect issue ten author discuss choice frustum influence grid shape nonuniformity achieve locally optimize basis multiple render target lead higher resolution depth method compatible five solid section explain solid algorithm precisely define input algorithm section provide solution problem solid section figure three non watertight model model hole leave inner wall middle case interior base jordan theorem symmetric difference force right initial one two three four view direction blend blend blend blend blend blend figure two solid column simplify illustration one two bite color channel show leave scene consist two watertight object column along view direction fourteen render fragment arrive arbitrary order fragment upper row compute shader indicate lie front current fragment mask accumulate bottom initialize zero use operation render complete four contain center sample solid grid shift half input algorithm interest fast method watertight model definition watertight follow one thirty model watertight connect component space separate geometry point share classification interior exterior point space consider number model ray originate point jordan theorem definition exclude model usable technique figure three show definition interior problematic leave object exhibit crack hull therefore define proper interior middle object contain supplementary wall separate inner volume two part ray shoot one inner part intersect model pair amount shoot vertically lead single intersection model thus watertight sense hold wall coincide outer hull finally rightmost example illustrate box inner box definition imply inner box empty region coherent model conform limitation method share several previous work eight ten five possible use advance derive coherent model adapt algorithm step could also exploit supplementary knowledge ignore solution information accessible interestingly approach integrate previous work accelerate derivation coherent mesh thirty correction derive implicit representation input model triangulation base march cub always compatible method scene example cape character might well suit solid define interior possible perform separate boundary ten combine efficiently solution solid part compare section seven work even intersect geometry method solid approach relate fill plane three achieve fast solid exploit definition watertightness point lie inside object ray leave point number object surface odd particular condition hold use test point inside shadow volume six therefore determine whether lie inside model amount count fragment fi render front figure two illustrate process let n fragment lie front j k lie inside model n odd n two one consider moment contain integer counter fragment situate front instead let shader output value single one position base fragment depth boundary return one position smaller k add column correspond column counter grid value exactly ray along view direction would intersect incoming fragment maintain real counter per slice impractical current graphics hardware make accumulation work need second observation n two n one denote operation form counter store single bite maintain status incoming base fragment accumulate blend operation practice build fragment shader small texture base fragment depth one two due way perform current card choice accurately sample center grid shift half along imprecision introduce due operator shift come fact choose base fragment fall thus naturally boundary two column offset counteract though add half fragment distance thus virtually shift column supplementary detail shadow must ensure clip near far plan render camera depth clamp depth clamp extension perform operation clamp depth value frustum thus output fragment otherwise would exclude plane count ray shoot away viewpoint remain correct even create inside volume efficient query use recently also expose render texture array extension allow storage slice texture stack efficient access another possibility render texture latter access available longer time unfortunately support bitwise blend need correct accumulation fragment remove previous release exist might reintroduce use texture tile store result pass finally use two instance technique recently expose allow increase resolution single render call limit impose solely memory shader stay almost resolution increase use several pass conservative one consequence point sample thin geometry might pass center thus remain uncaptured technically face side fall create annihilate operation make sense resolution grid lower detail like conservative visibility test seven might sometimes necessary fill even lie partially interior problem address conservative achieve fill scene render algorithm second step conservative boundary add texture lead conservative solid either touch surface thus detect via conservative boundary render point especially center lie approximation come currently problematic depth range derivation compare process involve conservative one create fragment touch provide correspond depth interval solid keep entirely interior one derive conservative overestimate substract conservative boundary blend operation deliver conservative interior without boundary three pass concern implementation propose slight improvement respect small texture use instead allocate large become especially expensive hardware transform two depth encode conservatively activate two shift farther value distance one leave unmodified perform correspond achieve conservative fill column compute shader equivalently substraction older card offset apply farther depth value ensure lie partially two activate finally result blend buffer use blend lead conservative boundary add interior solid simply keep add hull six method estimation solid useful binary nature hinder usage section transform binary grid density representation variety literature focus question choose appropriate filter kernel density estimate good overview give situation speed concern opt section twofold provide solution compute store density adapt manner respect parallelism limit memory overview filter construct density map density map contain value indicate many fill original represent solution general power two kernel obtain simplify concentrate kernel size two perform box filter compute sum adjacent neighbor result like store version volume formally compute j k v l two j n one l v binary value zero one consider consequently take integer value zero eight zero indicate lie entirely outside model eight imply lie entirely inside boundary two take value range one seven division eight lead approximate occupancy model hence name density map implementation complex several reason first longer binary need several store second must organize minimize texture optimize parallelism consequently need intelligently layout density map texture memory detail density map construction assume initial size store one integer texture per color channel thus represent grid size next derive density map size w h contain number eight require four storage instead one combine factor two per axis imply need per density map column thus representation longer fit single texture need spread two w h represent half density map column practice one tile texture texture need half column fill consequence filter result slice first two color channel process one remain focus input represent grid whose density store texture size w h per storage sufficient major challenge fill texture efficiently treat separately extremely slow derive density two step first along column spatially x plane achieve parallel execution observe sum two n store n one higher n one touch add one two n indicate number need store do put two sum actually evaluate two sum parallel hold number concatenate one two observation compute intermediate map via operation store two per encode pairwise sum neighbor column c give c c one denote bitwise integer succeed zero bite introduce mask every copy bite ensure summation pollute solution operation also perform next step sum map four neighbor need combine represent two sum thus need four storage perform place operation instead benefit parallel execution calculate sum even odd two three three iterate four neighbor plane mask recover right bite pair also assure follow two zero need assure correct summation result store density map figure four illustrate step point density map already compute catch alternate along value normal derivation problematic might simplify usage one reorder result parallelize process detail appendix implementation system realization actually simpler step encode use texture map f e g even odd split zero zero zero zero zero zero zero zero e even odd split g even odd split even f odd split e v e n two figure four e f g contain sum neighbor along encode two final density compute sum four neighbor do parallel split even odd sum separately simplify illustration column represent eight note split lead result order base two eight bite give configuration obtain algorithm namely four eight bite contain neighbor bite sum separate two zero value neighbor safely add yield final density normal derivation density follow definition implicit surface compute gradient along three axis via finite derive normal n component value eight eight thus possible remove normalization lead result give total distinct use symmetric kernel need six value around center five sufficient two neighbor column retrieve together simpler kernel center three neighbor would require three lower quality alternative normal discuss seven translucency ambient light base translucency figure five translucency effect even complex model exceed six solid use translucency effect transmittance shadow map ten number fill scene point light position calculate due high grid resolution bite count expensive instead solve arithmetically use dyadic approach two figure five show result volume approximation quite accurate lead better simply take difference front back depth map point ten solution complex could contain intersection test object penetration many work rely complicate data structure numerous occlusion query solid general straightforward object separate render first second blend desire operation figure six show example wo intersect polygonal object intersection volume figure six example operation intersection two complex mesh cost directly link want underline simple work precision several billion low dependence input geometry complexity furthermore density computation present section six allow recover intersection volume rapidly useful collision detection haptic feedback extension tree possible store intermediate result intuitively log n n height tree rearrange tree could optimize number fourteen visualization compactness one interest estimate compensate extent lack binary information allow reflect surface appearance become useful visualize level set large scan usually amount memory would fit card make interactive visualization via slice nineteen impossible would stall pipeline texture transfer march cub feasible resolution either level set small create one slice pass transfer directly display interactive several level set keep time blend together technique use display result figure six eight false color represent normal estimate particle collision apply technique particle system similar although optimize particle render simulation detect make bounce base solid figure seven show approach seamlessly treat concave like complex toboggan scene figure seven right dynamic deformation possible since recompute density every frame whole scene query via single representation computation efficient evaluate particle enter contact surface surprisingly actual bottleneck particle display via simulation run entirely precision high even cross boundary due high velocity large time step detect since represent solid volume perform latter support bite integer write eight single pass represent grid whose resolution x whose theoretical resolution z four eight current seem though unsigned integer format reserve bite possibly value correctly compare via equality activate could issue use technique discuss need minor change appendix b primarily use around memory footprint eight amount prior series integer type support therefore behavior emulate shader value float point matter texture type result eight per color channel possible lead total per texture series four possible thus allow use per render pass texture resolution limit one important implication store information memory consumption least eight time lower approach nine five performance test scene use dragon model almost fill whole frustum second test add four copy lead time show table one case interior less dense contain empty part object increase five cost drop six fifth grid occupy case place small time card show table two resolution sixteen table one solid time resolution nineteen four six six nine eleven sixteen seven five table two solid time respect previous work algorithm perform higher speed see figure nine test frustum fit bound sphere fair comparison optimize five work directly texture use logical without use stencil buffer also follow future work try instance texture tile accelerate approach practice turn instance less interest performance standpoint slightly complicate six nine table three density computation time time table three depend solely resolution initial include reorder comparison expensive contrast reorder free content play role cache come play due dependent practice realize result seem vary little around ten table three summarize time average several model finally table four show time particle include response normal figure seven two use show benefit use context particle stone leave example contain several tunnel hole right example show high resolution fine geometry toboggan capture estimate actual impact point course theoretically still cross thin say show notable advantage compare previous work depth peel might sufficient resolution hole certain clip plane approach restrict information along consequently rely privilege direction whereas uniform sense share quality none easily perform consistent back integration possibility capture object motion directly hand solution combine movement extraction step like nine motion typically sample coarse level rigid motion constant pass directly shader mathematical morphology find erode interior useful many like path find visibility seven often obtain lengthy dilation create hierarchical structure allow rapid query whether neighborhood contain fill binary context simple logical separable one first along x along z direction finally size obtain iteration imply arbitrary rectangular possible bite shift like section six allow treat efficiently care take need adjacent figure eight show example figure eight erosion leave dilation right obtain directly solid represent step involve actual scene geometry make solution fast purely eight result resolution storage test approach implement card simple non hardware fifty zero zero eighty seventy sixty fifty forty thirty twenty ten zero zero ten nine figure nine respect five several lod horse model originally top implementation bottom implementation collision management ten forty table four particle system collision response time independent local per particle nine discussion expose approach solid seem simple efficient single pass exist furthermore approach paper accurate point sample conservative simplicity make appeal contrary eight ten solution accurate even arbitrary number fragment fall single furthermore need front back face separation ten like many base need manifold coherent mesh watertight input suffice method derive interior define jordan theorem two watertight model intersect algorithm assume symmetric difference two mean two concentric box figure three lead hollow representation union consistent definition watertight section section seven show perform general also union solid concern performance implementation difference five remarkable complex model factor thus two order magnitude stem fact several layer extract single geometry pass thus theoretical practice fragment output still cost blend come expense nevertheless even simple cube twelve gain factor around twenty cube kind worst case scenario geometric complexity low high standard render cheap case already run volume drop quickly high polygon model resolution implementation also obtain strong even less complex model card less powerful treat geometry recent generation come part also architecture shade general stream reassign fragment vertex shader accord old generation number vertex fix thus algorithm compare quickly favorable respect five see figure nine finally method also interest even older card without support three show advantage run test deactivate feature without layer still extract per render surprisingly performance remain twice cost compare four model converge towards factor respect five generally come cost one reason difference closer four could sweet spot concern already four impose expect supplementary respect three could explain behavior exact performance depend many factor include choose model measure remain throughout test density density computation fast memory efficient information tightly pack evaluate parallel contrast nine rely mesh define surface key obtain high resolution coherent respect volume describe section kernel use density estimate size find like thirty even small kernel give acceptable quality practice implementation well adapt card four color treat equally process reflect vector would scale hardware texture bite integer would need fit memory break smaller part sixteen bite would still imply two per channel lead total eight four two per bite column case bitwise arithmetic proof efficient density see localize version distance field much work publish area particular exist support distance function allow general usage make preferable local density hand method faster compute interest need limit distance information present section seven method need store explicitly gradient computation costly context one million particle system number issue query much lower size density map practice propose simple scheme lead sufficient precision allow us evaluate fly ten conclusion future work paper present method solid dynamic high outperform previous approach term speed resolution show obtain sample well conservative solution basic method easy implement need knowledge scene geometry depth value produce compatible shader base animation density function quick way derive something resemble local distance field normal estimate base efficient simpler handle depth peel work allow large variety new besides present advance collision detection could benefit representation particle refraction could make use hierarchical representation mathematical morphology section seven would like thank willet h land k e comment paper f moulin stone model thank helpful substantially improve structure content reference one conservative tile journal graphics tool ten three two e bite twiddle hack three c polygon via tree four h fang fast synthetic object journal graphics tool three four new york press five k crane three chapter thirty simulation render six crow shadow computer graphics proceed seven x g f erosion base visibility proceed symposium render eight z dong w h h q complex polygonal model pacific graphics four nine drone advance render graphics game ten e x fast scene course note six eleven c interactive transparency sur twelve fang fast frame buffer map zero proceed symposium volume visualization page new york press thirteen f f beyond volume render visualization haptic exploration physical model object r j van p visualization scientific compute page fourteen j j blister render five triangulate shape paper page new york press fifteen cloth simulation interact deform model poster sixteen n complete polygonal scene journal graphics tool seven three seventeen volumetric virtual eighteen lai tai chang flexible slicer use graphics hardware graphite five proceed international conference computer graphics interactive south east page new york press nineteen j c chapter volume render twenty ea g fast algorithm j graph tool four four kim opacity shadow map l volumetric model repair virtual reality render workshop l build million particle system lecture lee g compute volume integral nine w li z fan x two chapter triangle mesh technical sketch new york press w e h e cline march cub high resolution surface construction algorithm proceed annual conference computer graphics interactive page new york press r r j evaluation reconstruction filter volume render r e proceed visualization page r k r comparison normal estimation scheme vis proceed conference visualization page ca computer society press thirty f g turk simplification repair polygonal model use volumetric visualization computer graphics nine two b r efficient volume measurement use three proceed spring conference computer graphics page new york g j x f x conservative volumetric visibility fusion k akeley editor computer graphics proceed page press c r gross sign distance transform use graphics hardware proceed visualization three page computer society press sud n r interactive distance field computation use linear factorization symposium interactive graphics game press sud fast distance field computation use graphics hardware computer graphics forum w wang e volume sample geometric vis proceed conference visualization page c approximate approach interactive refraction proceed international conference computer graphics interactive new york press l w q conservative visual computer reorder reorder two contain group represent depict figure ten do parallel manner well idea shift group information time whenever possible twenty twenty figure ten parallel reorder interleave group b remark bite need avoid bite seem reserve different purpose minor solid algorithm texture need modify exclude highest bite therefore practice use slice single pass instead computation density function important keep size compatible practice use per color channel biggest multiple four lead instead initial slice compare performance previous work take simulation complex smaller amount slice account eighty