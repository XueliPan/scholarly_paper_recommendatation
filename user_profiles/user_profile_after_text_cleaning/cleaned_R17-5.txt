international symposium computer architecture high performance compute exploit computational distribute heterogeneous fireman computer science federal university fireman abstract witness continuous growth heterogeneous computational cell joint use traditional multicore processor architecture still open question fully exploit computational potential efficiently paper introduce environment program framework support implementation scalable efficient parallel heterogeneous distribute assess issue actual behave regularly irregularly relevant also demand term computation io moreover irregularity well many pose challenge design implementation efficient parallel experimental environment include dual machine augment evaluate framework performance distribute evaluation distribute environment show near linear two data mine performance use improve around compare one introduction design implementation efficient parallel long term challenge propose several level architecture program environment algorithm despite research development level several still search efficient fuel work partially support cap increase amount data process well complex inherent evolution application area recently advance graphic card ie gate array ie enable use beyond image computer hardware emulation make general purpose effective concurrent use available distribute environment also include creation efficient parallel challenge address work several factor add complexity problem necessity multiple program model need adaptive load distribution strategy since relative vary widely depend type computation associate heterogeneous compare cluster single communication cost much smaller need exploit multiple process component paper present first step enable design implementation efficient parallel cluster heterogeneous target design use approach base anthill four eleven program environment support paradigm paradigm algorithm decompose task perform filter communicate stream carry data one filter next parallelize use anthill far scalable efficient despite often irregular performance observe cluster multicore efficiency come fact model favor overlap computation communication even task four approach programmer focus specific portion code instead whole application make easier provide alternate filter may operate seamlessly data single stream develop anthill filter programmer create associate stream call upon data arrival approach explore heterogeneous provide associate multiple handler function give stream thus develop target different associate stream process finally framework choose data stream task suit component since task may execute order besides describe approach evaluate use regular irregular exploit experiment show make effective use available extract available within compute node two data mine eclat achieve order combination implement minor part main extension anthill exploit distribute heterogeneous enable programmer provide multiple data process step target multiple choose automatically system per task basis evaluation two relevant use present gain around compare remainder paper organize follow describe anthill section two three respectively proceed thorough experimental evaluation system present section four finally describe additional relate work section five present section six two anthill anthill four eleven framework system employ program model model decompose pipeline process call filter data transfer process do stream allow data buffer flow one filter another develop application use model task data parallelism expose task parallelism achieve application break set filter independently perform specific pipeline fashion data parallelism hand obtain create multiple transparent copy filter divide data pro among figure one show typical anthill application figure one anthill application anthill moreover introduce third level parallelism model loop anthill often decompose cyclic graph computation execution may consist graph scenario interest execute different loop simultaneously may state associate interdependent piece data reside one filter instance message modify state rout specific instance abstraction anthill call label stream create allow programmer associate label message map function hash associate possible label specific filter instance four filter program anthill programmer provide dependence match function correlate data multiple stream event handle function process satisfy eleven event implement filter process stag asynchronous model mean available multiple may trigger parallel feature fundamental exploit full capability current multicore shield parallelism detail three support heterogeneous section describe approach towards exploit heterogeneous available distribute mem ory machine base solution anthill make full use data flow model expose integrate additional filter framework allow anthill automatically choose among available dispatch execution different concurrently version event may implement either data transfer handle transparently system event drive model fit nicely scenario least three reason one long input output data type associate match make difference application result device execute computation two process task event need satisfy input execute system schedule process available device ready three handler function well define implement high level language appropriate device target decision space within approach broad involve many dispatch parallel since heterogeneous set may available system must consider event handler define user provide handler give take per event basis may change different even kind allow filter exploit different schedule accord availability create flexible environment consider distribute memory machine extend anthill capable schedule node filter implementation filter schedule concurrently transparently extend anthill provide additional associate event different hardware wrapper function abstract programmer device memory management also include function use filter developer register handler system associate stream target device figure two depict architecture extend anthill queue independent build multiple anthill input stream match dependency vector portion implementation similar original anthill eleven process device feed different event device module responsible schedule process filter copy abstract decision event next process happen keep track f l e r e v e n h n l e one e v e n h n l e two e v e n h n l e x r n e e c p n e n e v e n p r c p e e v c e c h e l e r e v e n e x e c r c p h r e g e e v e n p r c p e e v e n e g e f l e e n v r n e n e g e e g e n h l l figure two framework architecture provide user available give time use information choose event process next device prototype implementation default implement next event process queue event executor module responsible manage available dispatch execution compute nod module abstract resource management process context switch specific detail various hardware begin execution detect available ie number core execution assign process run device accord user event executor create thread associate appropriate device thread notify device whenever idle information associate device identify among available handler define device use policy dispatch execution four experimental evaluation evaluate anthill support heterogeneous use two representative among implement use anthill section describe experimental setup result experiment reserve one core manage execution section describe use evaluate system particular choose two data mine representative relevant well quite intuitive briefly describe next section association analysis association analysis consist identify causal frequent name association rule first step compute determine set appear frequently give threshold traditional algorithm solve problem eclat twelve eclat base principle order set k frequent k one must also frequent algorithm start initial set candidate include size one compute actual frequency candidate find frequent combine produce new size two test follow algorithm continue create new fashion new check eclat parallelization present figure three three filter counter filter responsible count frequency candidate verifier filter check whether overall frequency particular give threshold candidate generator filter create new base previous frequent eclat algorithm implement anthill exploit way counter filter may process different typically several simultaneously use different transparent copy counter filter figure three eclat filter development identify counter expensive stage algorithm therefore implement handler version use ten handler receive candidate input calculate local frequency popular data mine algorithm classification classification predictive task want assign class unknown object usually call test set use model base preclassified object train set classic algorithm object classification neighbor first introduce e fix j five base intuition neighborhood object contain similar object thus analyze neighborhood able determine class practice since define neighborhood may hard use k object term attribute explain algorithm denomination anthill implementation use three filter reader classifier merger show figure four reader filter responsible send train object classifier filter train divide among classifier instance test broadcast strategy affect performance algorithm since train usually much test instance classifier filter compute object test base distance object train assign instance select train object send merger filter merger filter receive object classifier instance sort select global object assign object one class figure four filter case expensive task calculate distance object train perform classifier filter create handler function use ten calculate distance object test object train set distance copy k send merge filter finally use document experimental setup experiment perform use two cluster one sixteen connect use switch node core two duo two main memory memory operate system kernel two four connect use switch node dual main memory memory operate system kernel order better understand impact proposal impact significantly performance thus application deliver performance limit implementation ability exploit processor anthill use provide code available device small impact divide experiment two main mar conduct use two single machine analysis analysis employ one machine contain one one main goal evaluate anthill exploit heterogeneous available specifically want assess compare anthill mar seven implementation evaluate use analysis scenario analyze performance distribute version result exploit parallelism use synthetic vary number train set object experiment keep size test set number dimension object fix respectively also create synthetic eclat vary number within fix number attribute use synthetic generator one generate input mine algorithm distribute execution experiment vary number instance counter merger eclat classifier filter since filter case remain filter run single machine never get saturate experiment single machine analysis discuss single machine perform comparative performance study eclat use also conduct comparative study anthill sequential eclat mar implementation graphics framework performance evaluation compare anthill communicate network sequential total execution time anthill twelve sixteen eclat respectively show framework originally implement matrix multiplication application widely use several calculate relationship document implementation take two matrices n input calculate multiplication row column n generate output row column multiplication result similarity score application cluster web document use vector feature represent document base filter compute similarity document pair similarity b b pair document define mar create matrix document calculate distance output distance application result evaluation perform use input generate original mar respectively consider mar anthill achieve respectively performance may explain fact task simpler mar make multiple kernel call application add extra overhead per task mean expensive task mar amortize overhead become negligible eclat evaluation section analyze eclat performance version vary number thread run merger classifier filter costly stag evaluation conduct use contain train object eclat respectively figure five show calculate base execution time version use eight thread show achieve near linear application base version eclat performance present figure five also compare version application use eight core base version achieve finally figure five evaluate use e n c e x e e n c e x e eighty sixty forty twenty zero eighty sixty forty twenty zero one thread eight thread seven thread p e e p forty thirty twenty eighteen sixteen fourteen twelve ten eight six four two zero eclat figure five eclat result show use seven core compare version machine analysis order evaluate performance distribute eclat implement use anthill perform test result show figure six figure seven scale train set object accord number nod fix number test object dimension machine cluster cluster scale train set use fix number test object dimension eclat size vary fix number possible attribute experiment use one machine increase proportionally number nod result show scale near linear dual cluster since execution time remain almost increase number machine size proportionally instance use sixteen machine spend almost time single machine configuration process sixteen time bigger zero two four six eight ten twelve fourteen sixteen number machine eclat one two three four number machine b eclat figure six eclat five relate work recently see grow number project focus develop high performance compute whose model derive compute model three two dryad eight mainly drive need process large amount data several instance stream digital data image analysis web base information model inherent parallelism although contribute significantly develop new important feature example create transparent copy mechanism replicate process stag provide data parallelism able dynamically add manage stream focus use efficiently e n c e x e e n c e x e eighty sixty forty twenty zero sixty fifty forty thirty twenty ten zero one zero two four six eight ten twelve fourteen sixteen number machine two three four number machine b figure seven like cluster anthill first provide application development support distribute best knowledge different work demonstrate efficiency heterogeneous parallelism centralize mar seven one implementation program model context mar application implement subset order allow development work demonstrate efficiency system show fifteen sixteen six previously develop use phoenix work also perform initial investigation gain use evaluation perform divide task stag statically accord ing phoenix mar process task one proposal mar interest also limit single machine fulfill original goal distribute massive compute program framework three paper also develop evaluate system helpful develop run collaboratively anthill framework development scenario distribute heterogeneous multicore include use schedule task dynamically become available merge framework nine another interest program model heterogeneous environment mar propose implementation evaluate use also limit single process node paper also use collaboratively differently mar merge approach limit single machine show section four programmer flexibility develop application process stag suitable device al six present study image analysis application cluster machine work show development process include optimization issue use image process application example work present program system provide abstraction exploit process cluster application present still achieve good six future work paper extend anthill environment efficient exploitation heterogeneous create parallel execution model efficiently exploit heterogeneous machine distribute cluster machine anthill evaluation perform use two regular irregular neighbor search eclat present use respectively also compare anthill mar implementation experiment show better two originally implement mar distribute implement use anthill show near linear future work consider nine j collins h wang h meng merge program model heterogeneous multicore three ten compute unify device architecture program guide eleven g fireman w r achieve parallelism stream program model international conference parallel process twelve j w li new fast discovery association rule h r park knowledge discovery data mine page press extension framework context port study possible dynamic schedule example group task submit reduce communication reference one research center synthetic data generation code sequential pattern two l amini h r f r king p park c distribute scalable platform data mine six proceed international workshop data mine service page new york three j dean simplify data process large cluster proceed sixth symposium operate system design implementation four page four r w l b g r g anthill scalable environment data mine symposium computer architecture compute five e fix j discriminatory analysis discrimination consistency computer science technical report school aviation medicine field six v f r image analysis cluster conference seven b w fang q n k wang mar framework graphics parallel compilation eight dryad distribute program sequential build block seven proceed conference computer page new york ninety