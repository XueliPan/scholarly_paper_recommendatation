green framework support program use control approximation computer laboratory university ca research one way wa abstract compute important several range embed large scale data center several application offer opportunity quality performance reduction energy consumption sometimes take advantage albeit manner often without provide guarantee propose system call green provide simple flexible framework allow take advantage approximation systematic manner provide statistical guarantee green enable approximate expensive function loop operate two phase calibration phase build model loss produce approximation model use operational phase make approximation base specify programmer operational phase also include adaptation function occasionally monitor behavior change approximation model provide strong statistical guarantee evaluate effectiveness green implement system language use phoenix compiler framework experiment use graphics machine learn signal process finance web search engine indicate green produce performance energy consumption small control degradation subject program miscellaneous program language construct feature general term performance measurement design program control approximation part work perform author intern research permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten copyright c june canada introduction one company yahoo build several large data center contain machine provide process capability necessary support web service search shop three surprisingly power large component monthly operational cost run company attempt address locate place power cheap thirteen addition energy often key design constraint mobile embed space give current battery technology several application acceptable provide approximate answer cost require provide precise answer unavailable justify example ray trace infeasible current game employ variety produce realistic look light shadow still render sixty frame per second content image music compress encode various provide size fidelity typically result program perform smaller amount process consequently consume less energy still produce acceptable output often take advantage quality service make use employ variety unfortunately often use manner rarely quantify impact application even case attempt quantify impact use hard maintain keep program evolve add new feature functionality address issue paper propose green show figure one framework support program use loop function approximation green provide simple yet flexible framework program support approximate expensive loop function program allow specify maximal loss tolerate provide statistical guarantee application meet target must provide possibly multiple approximate function function approximation unless direct otherwise green use function return value measure compute loss compare value return precise function version give input loop approximate run loop case programmer must provide function compute enable green calculate loss arise early loop termination figure one overview green system green use information loop function approximation construct calibration program version green run application version set calibration input construct model quantify loss result use approximate version function loop correspond improvement application performance energy consumption green generate approximate version program use model conjunction programmer supply target determine use approximate version function terminate loop early still meet requirement since degradation actual program input may differ observe calibration green also sample loss observe update approximation decision logic meet specify target way green attempt provide statistical guarantee specify meet statistical guarantee become important company provide web service service level typically take form service provide response within request peak client load request per second eight experimental result indicate green significantly improve performance reduce energy consumption several small degradation particular improve performance reduce energy consumption bing search implementation commercial engine respectively degradation three query thousand return search result include least one different document document different rank order also demonstrate green generate robust model relatively small train recalibration enable meet target even use imperfect model model produce green calibration phase also prove useful provide better understand application paper make follow main describe design implementation green system provide simple yet flexible support program use function loop experimental evaluation green system show performance energy consumption little degradation experimental evidence indicate green model robust adaptation support meet target rest paper organize follow section two describe design green system section three discuss implementation green experimental evaluation green describe section four section five provide brief overview relate work section six conclude paper two green design figure one provide overview green system introduce discuss detail section control program approximation expensive function loop present attractive target program approximation modular portion program green consider function use alternative approximate version function loop terminate loop base precise version would like quantify impact program programmer must supply code compute metric application train input train input use calibration phase show figure one train run green monitor record impact function loop approximation program performance energy consumption data use build model subsequently use green decide approximate use precise version order guarantee service level figure two illustrate green approximate loop function still attempt meet require model construct calibration phase use green synthesize decide whether approximation appropriate current situation determine function input loop iteration count since degradation actual program input may differ observe calibration phase green provide mechanism occasionally measure program update approximation green describe green require compute function compute program function approximation original precise function serve purpose synthesize function determine whether perform approximation recalibrate function revisit approximation addition require set train input construct model use synthesize function sla value must meet green compiler approximate discussion tie together illustrate example apply loop approximation main loop simple program estimate pi figure three underline term correspond function supply programmer rest code generate green system since show section four green recalibration mechanism quite effective one might underestimate importance calibration phase attempt solely rely recalibration mechanism however calibration phase still important necessary provide one faster convergence good state two reliable operation even choose avoid minimize recalibration lower overhead three programmer insight application model construct green calibration phase fact green provide consistent feedback model construct provide extremely valuable often unexpected information application behavior green reliance recalibration mechanism ensure desire meet permit approximate multiple expensive loop function within application contrast static approach estimate would account nonlinear effect arise combine multiple current implementation build local model approximate program unit use construct global model application recalibration across three green implementation section describe implementation green system provide simple flexible framework construct wide variety approximation see figure one overview goal provide minimal simple interface satisfy majority provide hook allow expert craft implement custom complex achieve green come couple simple default meet need many enable benefit use control approximation minimal effort time allow override default supply write custom recalibrate still benefit green calibration model capability discuss green interface default provide instance policy green program support loop approximation green support loop approximation new language loop show figure two programmer use loop target loop supply pointer compute function value desire sla indicate whether want use static adaptive approximation addition programmer want avail recalibration must provide sample rate sample perform recalibration programmer wish construct custom policy must also supply custom recalibrate function approximation function approximation green introduce new function show figure two programmer use function target function implementation supply function pointer array contain figure two overview green approximation provide description leave detail discussion next section calibration model green calibration phase collect data require build model require compute application dependent range trivial case use approximate function return value involve computation involve value render screen green use function along set train input construct model relate function input case function approximation loop iteration count case loop approximation loss performance energy consumption model use conjunction provide target sla make approximation approximation come two main flavor loop static variety approximation solely determine model construct calibration phase loop iteration count threshold determine model sla loop iteration count exceed threshold approximation break loop adaptive variety base law diminish return approximation use model conjunction sla determine appropriate measure change amount improvement need continue iterate loop function approximation model use conjunction sla function input determine function approximate approximate version function use recalibration program behavior may occasionally differ observe train input recalibrate provide mechanism detect correct effect case loop approximation use static approximation recalibration update model increase loop iteration count threshold compensate higher expect degradation decrease threshold improve performance energy consumption degradation lower expect similarly use adaptive approximation recalibration appropriately change interval use measure change improvement require continue function approximation recalibration allow green switch approximate version function use one less precise determine observe loss x x f x count count zero break count count zero n f x expensive figure three example apply loop approximation pi estimation program approximate function increase order precision along value desire sla sample rate sample recalibration require function return value provide desire metric programmer must also supply pointer custom compute function function take multiple green require parameter position use build loop custom recalibrate optional need custom green system implementation figure one figure three provide overview green system implementation green compiler first generate calibration version program run calibration input generate data need build model compiler use construct model generate approximate version program run place original synthesize code implement recalibrate one current implementation construct model base single input parameter however extend multiple figure four compute bing search loop approximation compute function use calibration phase tabulate loss result early loop termination loop iteration count specify calibrate compute function follow interface compute return loop count calibrate calibrate search application version show original code static n factor factor thirty calibration code n zero zero one store default static return false else static return true else adaptive approximation approximation code count count n true terminate loop else recalibration log terminate loop zero one one default low else high else nothing return one else return zero one figure five code generate loop approximation figure six calibration data bing search figure four note compute call return unset store compute point return loss flag set compare current store return loss call calibrate flag set end loop calibration mode compute store loss loop terminate early loop iteration count specify calibrate figure six show calibration data generate bing search quantify impact limit document search rather match document throughput calibration data use green model routine implement program program use interpolation curve fit construct function automatically select appropriate approximation level base value desire programmer construct model programmer supply desire value model support follow interface loop odel loop sla static p delta odel loop sla adaptive one two static approximation model supply loop iteration count use early loop termination adaptive approximation case model additionally determine period target improvement require continue iterate loop synthesize code show figure five use generate model perform approximation figure seven code generate function approximation approximation synthesize approximation code store value would generate early loop termination continue run loop many time original precise program version would order compute loss see figure three recalibrate code generate green compare loss target sla either approximation either value early termination loop iteration count static approximation value target delta adaptive approximation function approximation default green use function return value compute unless programmer define separate compute function calibration green generate code compute store loss precision result use family approximation function call site function select approximation current implementation differentiate call sit use function sit figure eight eight b show calibration data generate log function application input argument range observe train input green model routine use data support low interface mi ubi odel f sla return best approximate function version correspond input argument range loss function satisfy specify target sla event none approximate function meet requirement return empty set precise function use synthesize function function show figure seven use three five x eight four eight x eleven precise function x eleven x note five six see figure eight discard provide competitive loss performance improvement ratio recalibrate function replace current approximate function version precise one address low use approximate version address higher necessary two current model scheme work function take numerical data input would need extend handle function take structure data input three approximate log function correspond different series number indicate highest degree polynomial use static return false else static return true else one zero return false true else return false improvement x x five return false else x eight zero else x eleven one false return true function b log function c performance figure eight calibration data custom approximation green allow override default synthesis recalibrate implement custom approximation figure nine show example custom recalibrate use search application bing search compute return loss one top n document return precise approximate version exactly match loss zero otherwise perform recalibration compare target sla form application return identical result query need measure loss across multiple query implement code show certainly possible relax stringent requirement allow document reorder within top n document return use strict requirement search experiment avoid address reorder may affect perceive quality search result return calibration use default code synthesize green bing search application evaluate paper need custom recalibration routine mainly metric compute aggregate set query individual query green support multiple far discuss green support individual loop function approximation section discuss green combine multiple green require application developer provide additional compute function application application sla many case identical compute function already supply loop approximation figure nine recalibrate bing search worse individual log hence combine log bar show figure eight c approximation model global recalibration green perform calibration function loop approximation isolation show figure six eight eight b perform exhaustive search space exploration attempt combine still meet specify application sla figure eight c illustrate process log function application represent combination three four select approximate show figure seven search process result individual approximation change overall application sla still satisfy case local approximation decision use log two change use log four combine approximation use log four able satisfy application note unlike calibration process find combination log function viable application strictly application multiple approximate function loop require recalibration meet sla green initiate global recalibration process entail select subset function loop recalibration perform local recalibration current implementation global recalibration initially assume individual independent additive subsequently detect apply case assumption valid case measure application fall specify sla recalibration rank gain sensitivity per model enable recalibration first apply large change produce small performance change handle case interact produce nonlinear effect green use exponential loss six five four three two log three log four imp two four e three e two e four three four e five e six pee e number monitor query number low monitor set one trigger next consecutive zero low else high else change scheme similar use packet retransmission nineteen scheme individual follow loop use random increase number within acceptable range approximate function replace higher precision random portion input argument range nonlinear effect disappear application sla satisfy approximation disable precise use scheme appear perform well converge fast artificial test construct validate efficacy unable force nonlinear behavior four green evaluation perform two type experiment first show green produce performance reduction energy consumption little degradation next show model green construct robust conjunction recalibration provide strong guarantee evaluation use five include bing search implementation commercial engine four include spec cluster ga fourteen discrete transformation seven parsec suite four choice drive computational finance point matter control approximation appropriate domain employ sophisticate risk analysis model environment use two different machine experiment machine use experiment machine run core two duo three processor four dual channel main memory machine use experiment bing search server machine two quad core eight main memory application compare approximate generate green compiler implement use phoenix compiler framework twenty correspond precise base evaluation measure three key version performance energy consumption loss time start end run use performance evaluation bing search first run set query use measure throughput ie query per second serve test query performance metric measure energy consumption use instrumentation device measure entire system energy consumption periodically sample current voltage value main power cable sample period device one second since execution time study significantly longer sample period acceptable finally compute loss approximate version compare result base metric use application discuss later also measure overhead green call eventually return false find performance indistinguishable base without green code recalibration sample rate set one section provide description discuss green approximation application addition discuss evaluation metrics input use bing search description bing search implementation commercial engine accept stream user query search index document match query rank document return top n document match query rank order web crawl index update disable number place subsequent section additional information bing search application may appropriate protect business interest require us reduce level detail reason performance metrics normalize base version absolute number document process disclose approximation base version bing search process match candidate document instead limit maximum number document query must process improve performance reduce energy consumption still attempt provide high evaluation metrics use performance metric since throughput key server use per query energy consumption metric finally loss metric use percentage query either return different set top n document return set top n document different rank order compare base version input bing search experiment perform production index file production query log obtain data center performance run use two set query one query query warm system two test query query measure performance system graphics description probabilistic ray tracer send n two ray polygonal model among three implement use algorithm twelve approximation main loop iterate n two send ray iteration refine loop iteration count go higher improvement per iteration become marginal case main loop early terminate still attempt meet evaluation metrics measure execution time energy consumption input model quantify loss approximate compute average normalize difference value precise approximate input generate input randomly change camera view use reference input model machine learn cluster ga description cluster ga solve problem schedule parallel program use genetic algorithm fourteen take task graph input execution time task among task communication cost encode use node weight direct edge edge weight respectively refine reach maximum generation g output execution time parallel program schedule approximation depend size problem converge solution even reach g addition similar improvement per iteration become marginal higher iteration count ie generation terminate main loop achieve improvement performance reduction energy consumption little degradation evaluation metrics use metrics performance energy consumption metric compute normalize difference execution time parallel program schedule base approximate input use thirty randomly generate task graph describe fifteen ensure various construct task graph number nod vary fifty communication computation ratio vary one ten randomly generate task graph signal process discrete transform description discrete transform one widely use signal process seven transform signal time domain signal frequency domain approximation core sin cos function heavily use since precise version implement standard expensive especially underlie architecture support complex approximate version sin cos function effectively use provide sufficient implement several approximate sin cos function nine apply application evaluation metrics use metrics performance energy consumption metric compute normalize difference output sample precise approximate input randomly generate different input input sample random real value zero one finance description compute price portfolio use partial differential equation implement method popular technique price approximation core computation make heavy use exponentiation logarithm log function provide series approximate function use correspond series vary number polynomial evaluation metrics use metrics performance energy consumption metric compute difference option price produce precise approximate program input use large simulation data set provide parsec suite train report result use native execution data set train data set price thousand native data set price ten million experimental result bing search figure ten eleven demonstrate loss improvement reduction energy consumption base version current implementation bing four parsec include loop repeatedly compute value option portfolio increase work perform application loop except first skip without affect result approximate loop measure similar loop execute execute number time specify five figure twelve illustrate performance version bing search determine cutoff metric cutoff define success rate query go low show dot line lower search sla consider violate figure ten performance energy consumption various bing search figure eleven loss various bing search figure twelve vary throughput result success rate various bing search search approximate specifically statically terminate main loop process n match document query sample improvement process every document adaptively terminate main loop improvement current period see approximate significantly improve performance reduce energy consumption ie per query little loss example improve throughput reduce energy consumption seventeen loss another interest point use adaptive approximation lead slightly better performance less energy consumption provide better compare version use static norm loss rate norm query per second figure thirteen sensitivity green model bing search size train figure fifteen performance energy consumption various figure sixteen loss various figure fourteen effectiveness green recalibration mechanism bing search approximation potential adaptive optimize bing search study sensitivity green model train size randomly permute test query inject different number query range query build model figure thirteen demonstrate difference estimate loss vary size train model generate much number query close one generate example model generate use query differ one compare one generate use input provide empirical evidence green construct robust model bing search without require huge train evaluate effectiveness green recalibration mechanism perform experiment simulate imperfect model say user indicate desire target two construct model incorrectly supply typically result ten loss thus without recalibration bing search perform poorly meet target figure fourteen demonstrate green provide robust guarantee even supply inaccurate model process every query green monitor next consecutive query ie sample run precise version also compute loss use approximate version query since current model accurate enough monitor result keep report low green recalibration mechanism keep increase figure seventeen sensitivity green model size train accuracy level ie increase value satisfy target figure fourteen green meet target process query user could use period smaller make green adapt faster quick adaptation degradation performance energy consumption cause frequent monitor perform identical recalibration experiment similar result experimental result figure fifteen sixteen show result use randomly generate input similar bing search approximate significantly improve performance energy consumption relatively low loss figure seventeen demonstrate sensitivity green model size train vary train data size estimate train process loss process loss norm loss train figure eighteen performance energy consumption various figure performance energy consumption various figure nineteen loss various figure loss various figure twenty sensitivity green model size train figure performance energy consumption various ten compare estimate loss difference generate model one generate use input figure seventeen provide empirical evidence green model construct robustly relatively small train example model generate use ten input differ twelve compare one generate use input figure eighteen nineteen demonstrate green model use thirty randomly generate input loss reasonable ten significantly improve performance energy consumption respectively figure twenty also present sensitivity green model train size vary number train input five thirty compare estimate loss generate model one generate use thirty input difference estimate loss higher due discrete nature outcome parallel task schedule problem difference still low five even five input use figure show loss improvement performance energy consumption use various approximate generate green specifically version use sin cos function provide different accuracy range base nine accuracy accuracy loss observe due combine sin cos approximation improve performance energy consumption around even use accuracy observe loss low improve performance energy consumption respectively clearly indicate potential approximation use green show model construct also similarly robust accurately generate input norm loss train c c c c c norm c c c c c loss norm three e four e five e six e two three four e two e four support loop approximation pursue goal much aggressively green skip end loop also remove intermediate loop green programmer assist framework base principle carefully optimize small number application loop function control manner provide benefit hand position compiler optimization framework attempt approximate many program loop possible goal believe safely achievable give current state program analysis technology could result unexpected program crash especially intermediate loop skip al propose eon language system embed sensor use eon control flow program may annotate abstract energy state eon dynamically adapt execution adjust frequency periodic task provide high low service level consult annotate energy state predict energy availability green similar eon sense exploit energy consumption loss provide dynamic adaptation mechanism proposal significantly differ three first green build upon probabilistic model enable fast robust convergence desire target second green directly extend allow implement modular loop fully exploit exist code implement contrast eon base language ten compose conventional finally experimentally demonstrate green control approximation mechanism highly effective robust range application ie embed sensor include commercial engine eighteen al discuss imprecise computation technique task produce usable approximate result even presence transient failure overload addition describe conceptual architectural framework allow integration imprecise mechanism traditional mechanism work differ follow ways first green support approximation finer granularity task second green provide calibration mechanism support model sophisticate error function contrast al assume rather simple error function linear convex finally implement evaluate real ie conceptual system quantify effectiveness green control approximation mechanism several research focus approximation one al propose fuzzy one unlike classical instruction fuzzy associate similar input output tong al propose reduction technique learn require representation set signal process reduce power dissipation without sacrifice effective improve performance energy consumption infrequent use benefit scheme significantly addition provide recalibration support statistical guarantee contrast green general target range ie attempt meet specify several research study impact soft compute error tolerance presence defect fault chip six seventeen al demonstrate many figure loss various figure show loss improvement performance energy consumption use various approximate generate green version finally select green use combination approximate function three four different portion input argument range log four function provide performance energy respectively loss less eight result demonstrate green able successfully combine multiple final approximation choice log four automatically refine local log two reduce overall application loss less one model construct also robust train data set use thousand accurately predict loss test data within one five relate work several application machine learn data process exhibit soft compute five common soft compute relax correctness redundancy computation study improve performance energy consumption fault tolerance exploit soft compute however best knowledge believe green first system provide simple yet flexible framework program support control attempt meet specify green similar previous work sense propose probabilistic model ie distortion model exploit performance improvement loss however proposal significantly differ several focus survive fault mechanism guarantee desire goal would meet use coarse granularity approach drop task seem appropriate domain parallel program hand green provide support approximation loop function level addition green provide recalibration mechanism effectively provide strong guarantee even presence degree inaccuracy construct model finally experimentally demonstrate control approximation effective range application ie scientific include engine parallel work al propose framework design exploit use loop approximation eleven contrast green also support function approximation target range ie iterative provide unify framework apply loop function three e four e five e six e two three four two four e due relax correctness base propose design implement chip six li investigate fault tolerance soft perform experiment seventeen demonstrate soft much resilient fault conventional due relax program correctness work differ focus performance energy meet specify instead fault tolerance six paper propose green system support program use control approximation expensive loop function green generate calibration version program execute construct model quantify impact approximation next use model synthesize approximate version program attempt meet target green also provide recalibration mechanism adjust approximation decision logic meet target evaluate effectiveness green build prototype implementation use phoenix compiler framework apply four program include search application experimental result demonstrate green version perform significantly better consume less energy small loss particular improve performance energy consumption bing search respectively degradation also show model construct robust conjunction green recalibration mechanism enable approximate meet target would like thank benjamin lee make paper form productive help evaluation infrastructure support scholarship graduate fellowship reference one c j fuzzy point seven two w j c c k towards soft optimization parallel cognitive symposium parallelism june three l annual technical conference four c j p singh k li parsec suite characterization architectural proceed international conference parallel compilation five p p soft compute convergence emerge reason soft fusion one one six k defect error tolerance presence massive number defect design test three seven e fast transform upper saddle river eight g jampani g p w dynamo highly available store rev six nine j g guide approximation ten n significance two eleven h agarwal use code perforation improve performance reduce energy consumption respond technical report august twelve j render equation graph twenty four thirteen r research compute international week management network service fourteen v one embed international conference parallel process page fifteen task graph schedule parallel process symposium proceed symposium parallel distribute process page sixteen x li exploit soft compute increase fault tolerance proceed workshop architectural support integration seventeen x li correctness seven proceed pact fault tolerance international symposium high performance computer architecture page computer society eighteen j shih lin r imprecise proceed one nineteen r r distribute packet switch local computer network nineteen seven twenty phoenix academic program research probabilistic accuracy bound discard task six proceed annual international conference page new york c use early phase termination eliminate load barrier synchronization point seven proceed annual conference program page new york j corner e berger eon language system seven proceed perpetual international conference embed network sensor page new york standard performance evaluation corporation spec j tong r reduce power optimize necessary arithmetic large scale integration eight three