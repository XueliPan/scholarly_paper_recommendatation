simple algorithm solve linear program research one way wa department mathematics institute technology abstract algorithm develop mainly machine learn literature simple greedy method find feasible solution linear program alternatively learn threshold function spite exponential complexity often quite useful part due also overall simplicity paper show randomize version algorithm periodic run result algorithm linear program elementary description analysis subject theory computation analysis linear program polynomial time one introduction linear program arise many standard form x ax b x zero b c n matrix often convenient view problem find point intersection maximum objective value dual view think row point goal find threshold function ie satisfy give maximize objective threshold support sloan foundation fellowship permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee four june copyright solve linear program include ellipsoid method thirteen fifteen interior point fourteen random walk method two another classical algorithm quite practical arise machine learn algorithm one sixteen eighteen develop solve problem learn algorithm simple greedy method guarantee converge feasible solution one exist could take exponential number worst case nevertheless many useful include certain type noise tolerance four five also relate boost pac model learn nineteen twenty recently show algorithm polynomial high probability randomly perturb linear program three open question whether variant algorithm polynomial worst case besides suggest useful modification basic algorithm practice would give specific sense algorithm simplify matter focus problem find feasible solution give set linear polynomial time optimization problem feasibility version problem thirteen typical approach describe section four paper show randomize algorithm along periodic apply feasible linear program return feasible point polynomial time algorithm use matrix barrier function main theorem theorem strictly feasible linear program solve time log n log one parameter roughly correspond radius ball fit feasible region log one guarantee polynomial input description note complexity algorithm good current best ten hand rather simple inherit algorithm direct consequence get simpler faster solution problem learn noisy linear threshold function four six main idea algorithm maintain update use constraint currently violate convergence algorithm depend separation parameter quantify amount wiggle room available feasible dual view describe correspond primal view think wiggle room radius ball fit feasible region roughly speak analysis algorithm say ball large algorithm converge quickly work four show even ball small simple variant algorithm find nearly feasible solution ie might violate violate much show wiggle room small nearly feasible solution use apply linear transformation fact rank one update expand wiggle room enlarge ball contain feasible region essentially one factor thus n either find feasible point double wiggle room two algorithm section present algorithm linear problem ax zero x zero consist n dimension ie x n section four show use reduce standard form homogenize form algorithm iterative iteration consist three phase phase improvement phase phase phase use classical algorithm improvement phase use modify version basic algorithm modify version describe four figure one depict phase classical algorithm linear feasibility problem find violate constraint move trial solution x one unit direction normal violate constraint repeat necessary step two algorithm rest paper let denote unit vector direction x three analysis let denote initial input algorithm let denote algorithm terminate algorithm terminate produce nonzero vector x ax x zero ie zero desire outer iteration step improvement phase step four may rerun number time terminate quickly high probability lemma thus main question many algorithm make answer define follow quantity measure roundness feasible region min x x ai denote th row unit vector along ai algorithm input n matrix output point x ax zero x zero one let b one two let x origin b repeat twelve time exist row x zero set x x three ax zero output feasible solution stop four improvement let x random unit vector b repeat time exist row set x x x x zero go back step c still row restart step five ax zero output feasible solution stop six set b b seven go back step two feasible region z x z x two one figure one constraint system call radius z unit vector achieve maximum center note radius ball fit feasible cone center ball unit sphere avoid confusion let zero denote roundness input see section four discussion classical analysis algorithm sixteen repeat lemma show classical algorithm phase apply linear feasibility problem radius terminate twelve hard see initially zero exist linear transformation take arbitrarily close one transformation define simple calculation show go one know transformation could apply run standard algorithm equivalent original problem since z feasible point instead algorithm transform use increase steadily main lemma show iteration algorithm small increase expectation multiplicative factor combine main lemma classical analysis yield small get bigger guarantee improvement scale phase big algorithm find feasible point guarantee phase iteration algorithm consist phase improvement phase alternatively one could improvement phase predetermine number step check completion run phase proof algorithm begin analysis standard lemma sixteen classical algorithm phase return feasible point twelve proof consider potential function x z x numerator increase least step x z x z z x z square denominator increase one x x x x x x one since x zero potential function least thus classical algorithm must terminate twelve algorithm terminate must find feasible point next recall analysis modify algorithm improvement phase lemma four let constraint matrix begin improvement phase let z unit vector zero probability eight step least one phase return vector x note update step z x decrease x x z x z x z x z x negative order use update step z zero assumption also n initially x never set imply z x one zero hand x x decrease significantly x x x x x x two x two x x x x x one two two x two thus x one two n two would one happen therefore x every time start algorithm finish probability least eighteen return x x z x one n ready prove main lemma progress iteration find feasible solution lemma suppose let obtain one iteration algorithm one problem solve let radii respectively one one one b probability least one eight one one proof analysis use lemma part lemma say probability one eight vector x end step four b satisfy part b lemma assert vector x end step four b simultaneously satisfy z one n probability least eighteen let ai one row begin iteration let z unit vector satisfy z let improvement phase get vector x theorem statement let matrix obtain step ie ai ai z z z specify shortly although z necessarily center maximum set consider one element set suffice lower bind min min z z every row finally define b x z one n proof proof part similar standard computation show random unit vector x z x n probability least eighteen show one case terminate desire number z one one p one one bind give one x one e x e x two second inequality follow one next observe let value let log ten e x eight e eight en first prove z z small z z z p one three two z one two p one choose one two z one ensure zero substitute z definition z use value choose would remove boundary case choose aid exposition proceed calculate z two one two two two one z two four two three four z consider two case one z one n happen probability view z two quadratic polynomial z x see maximize z x three case z two one two four two twelve one two three use elementary inequality one one find one one one two one one two six one one one two one two one one one two six two z one n happen probability least since eighteen case two four one z two z two three four z two one three two n two four use elementary inequality find one one two one two one three three four n four n two eight two eight one one prove part lemma bind number recall zero value initial input matrix theorem high probability algorithm find feasible solution n log ten proof suffice show least n log ten let xi random variable th iteration value one grow factor one value zero otherwise let x sum xi lemma b satisfy definition high probability analyze case x within expectation one one one x eight eight x one one one one one one eight eight one one one one one one summarize probability least one en grow least one point phase succeed find feasible point finally time complexity matter account theorem high probability algorithm find feasible solution time log n log ten proof inner loop either phase improvement phase require one multiplication time constant number vector time n number time repeat inner loop phase log log n improvement phase bind total number time improvement phase probabilistic show close expectation use bind previous theorem scale phase take time calculate similarly take time previous theorem number n log ten yield overall time bind log n log ten four standard form six reference section discuss reduce standard linear program problem one solve paper typical approach reduce optimization replace x constraint x value binary search use determine nearly optimal value solution feasible problem sufficiently close optimal round optimal vertex solution basis reduction thirteen next show reduce standard form linear feasibility problem ax b x zero linear feasibility problem study technique typically refer homogenization also relate condition number problem homogenization conclude algorithm polynomial traditional sense thirteen introduce variable consider problem ax x zero zero convert solution standard form one homogenize form set one convert solution homogenize form solution standard form divide x rewrite homogenize form let x x x zero x zero b valid solution x zero might zero however classic algorithm phase always produce strict interior feasible region algorithm always return solution zero traditional measure difficulty linear program problem model computation call denote l quantity l essentially input length linear program condition number linear program define normalize distance seventeen apply small perturbation one ensure log condition number polynomial l linear program polynomial log condition number also polynomial l quantity relate condition number eleven seven call minimum width recently nine particular homogenize program n time condition number slight perturbation original program conclude algorithm polynomial l five thank dan smith help formative stag bring twelve attention grateful rob many useful comment one relaxation method linear j math six three two solve convex program random walk proceed annual symposium theory compute three j smooth analysis algorithm linear program proceed annual symposium discrete four frieze r algorithm learn noisy linear threshold function one five learn linear threshold function presence classification noise proceed workshop computational learn theory six e learn noisy polynomial time proceed annual symposium computer science seven f new condition number linear program mathematical program series one eight v linear program freeman nine j teng smooth analysis condition number linear program conference optimization ten r interior point current status future high performance optimization h al academic eleven r j r vera distance condition measure conic linear system math program twelve j linear lower bind unbounded error probabilistic communication complexity sixteenth annual conference computational complexity thirteen l l geometric combinatorial optimization berlin fourteen n new algorithm linear program four fifteen l g polynomial algorithm linear program translation soviet mathematics twenty sixteen l introduction computational geometry seventeen j incorporate condition measure complexity theory linear program journal optimization five three eighteen f book nineteen r pac learn use winnow algorithm journal compute five twenty r smooth boost learn malicious noise fourteenth annual conference computational learn theory p new algorithm minimize convex function convex set mathematical program b evaluation information complexity mathematical program twelve translation thirteen two