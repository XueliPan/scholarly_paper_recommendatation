pin build program analysis tool dynamic instrumentation steven janapa muth harish kim hazelwood corporation university colorado abstract robust powerful instrumentation tool essential program analysis task profile performance evaluation bug detection meet need develop new instrumentation system call pin provide portable transparent efficient instrumentation instrumentation tool call write use pin rich pin follow model atom allow tool writer analyze application instruction level without need detail knowledge underlie instruction set design architecture independent whenever possible make source compatible across different however access detail necessary instrumentation pin mostly transparent application observe application original behavior pin use dynamic compilation instrument run efficiency pin use several include register reallocation liven analysis instruction schedule optimize instrumentation fully approach deliver significantly better instrumentation performance similar tool example pin faster faster count illustrate pin versatility describe two daily use analyze production pin publicly available four r arm ten since pin two release subject engineer test aid trace program incremental general term performance experimentation instrumentation program analysis tool dynamic permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee five june copyright introduction one complexity increase technique insert extra code application observe behavior become important instrumentation perform various stag source code compile time post link time run time pin system perform binary instrumentation goal pin provide instrumentation platform build wide variety program analysis tool multiple result design emphasize portability transparency efficiency robustness paper describe design pin show provide feature pin instrumentation easy use user model similar popular atom thirty allow tool insert call instrumentation arbitrary executable need manually save restore state pin provide rich abstract away underlie instruction set make possible write portable instrumentation tool pin distribution include many sample include cache trace memory bug checker also allow access information pin provide efficient instrumentation use compiler insert optimize code addition standard dynamic instrumentation include code cache trace link pin implement register reallocation liven analysis instruction schedule optimize code fully approach distinguish pin instrumentation tool require user assistance boost performance example rely tool writer insert special intermediate representation order perform similarly six require tool writer manually application register another feature make pin efficient process attach detach like pin attach process instrument collect profile eventually detach application incur instrumentation overhead period pin attach ability attach detach necessity instrumentation large pin instrumentation defer code discovery run time allow pin robust use static instrumentation code patch pin seamlessly handle mix code data statically unknown indirect jump target dynamically load dynamically generate code pin preserve original application behavior provide instrumentation transparency application observe ad dress instruction data value register memory would execution transparency make information collect instrumentation relevant also necessary correctness example unintentionally access data beyond top stack pin instrumentation modify application stack pin first generation pin zero support r second generation pin two extend support fourteen fifteen r thirteen arm sixteen pin two r still development pin gain popularity inside outside since pin two first release paper present description pin organize follow first give overview pin instrumentation capability section two follow discuss design implementation issue section three evaluate section four performance pin instrumentation compare tool section five discuss two sample use practice finally relate pin work section six conclude section seven instrumentation pin two pin make possible observe architectural state process content register memory control flow use model similar atom thirty user add know analysis atom notion application process write instrumentation determine place call analysis analysis architectural state pin also provide limit ability alter program behavior allow analysis routine overwrite application register application memory instrumentation perform compiler input compiler however native executable pin intercept execution first instruction executable generate compile new code code sequence start instruction transfer control generate sequence generate code sequence almost identical original one pin ensure regain control branch exit sequence regain control pin generate code branch target continue execution every time fetch code opportunity instrument translate execution translate code instrumentation save code cache future execution sequence improve performance figure one list code user would write create print trace address size every memory write program main procedure initialize pin register procedure call instruction tell pin start execution program call instruction insert new code cache pass handle decode instruction instruction write memory insert call instruction specify argument pass instruction pointer specify effective address memory operation specify ea number write specify size use file trace print memory write record void void void size trace p w p size call every instruction void instruction void v instrument write use predicate call ie call happen store actually execute main char trace w instruction zero never return return zero figure one trace memory write ensure invoke memory instruction predicate true note source code work user need know bundle various address architecture different form predication support arm string write memory area like push implicitly write memory pin provide comprehensive inspection instrumentation particular example instrumentation do one instruction time also possible inspect whole trace image instrumentation pin user manual twelve provide complete description pin model simpler tool user insert instrumentation add delete intermediate language however equally powerful ability observe architectural state free user need understand instruction set learn intermediate language insert code may overwrite scratch register condition cod pin efficiently save restore state around call side effect alter original application behavior pin model make possible write efficient instrumentation tool regardless whether instruction set combination register reallocation make pin procedure model efficient instrumentation model three design implementation section begin system overview pin discuss pin initially gain control application follow detail description pin dynamically compile application finally discuss organization pin source code one although extension separate architecture many new feature address flat address space twice number register new fifteen system overview figure two illustrate pin architecture highest level pin consist virtual machine code cache address space pin instrumentation virtual machine n c l p p compiler emulation unit r e h c p code cache operate system hardware figure two pin architecture mentation invoke consist compiler emulator dispatcher pin gain control application execute application compile instrument application code launch dispatcher compile code store code cache code cache involve save restore application register state emulator interpret execute directly use system call require special handle since pin sit operate system capture code figure two show three binary program present instrument program run application pin pin engine instrument application contain instrumentation analysis link library allow communicate pin share address space share typically three copy make private avoid unwanted interaction pin application one example problematic interaction application execute function application start execute function try execute code trigger compilation enter execute function enter procedure second time application still execute cause error since separate copy component pin application share data problem problem occur analysis code call analysis routine allow us greatly reduce overhead simple instrumentation inject pin injector load pin address space application injection use obtain control application capture processor context load pin binary application address space start run initialize pin load address space start run initialize request pin start application pin create initial context start application entry point current case attach use mechanism injection allow us attach already run process way also possible detach instrument process continue execute original code tool like six rely environment variable force dynamic loader load share library address space pin method three advantage first work many require second load extra share library shift application share dynamically allocate memory higher address compare execution attempt preserve original behavior much possible third instrumentation tool gain control application loader partially execute method able instrument first instruction program capability actually expose bug loader result reference data stack compiler pin compile one directly arm arm without go intermediate format compile code store code cache code reside code cache original code never execute application compile one trace time trace sequence terminate one condition unconditional control transfer branch call return number conditional control transfer number fetch trace addition last exit trace may multiple conditional control transfer exit initially branch stub redirect control determine target address statically unknown indirect control transfer generate new trace target generate resume execution target trace rest section discuss follow feature trace link register instrumentation optimization current performance effort focus feature implement arm version pin fully functional yet implement trace link improve performance pin attempt branch directly trace exit target trace bypass stub call process trace link link direct control transfer straightforward unique target simply patch branch end one trace jump target trace however indirect control transfer jump call return multiple possible target therefore need sort mechanism figure three illustrate indirect link approach implement architecture pin translate indirect jump move direct jump move put indirect target address register register well show figure three obtain via register reallocation discuss section direct jump go first predict target address map code cache example compare use idiom use six avoid modify conditional flag register prediction correct ie branch execute remain code predict target prediction wrong try another predict target map code cache target find chain branch one search target hash table whose base address chain predict indirect target lea lea miss hit call f call f b f ret b use clone help predict return target ret translate without clone ret translate clone f pop lea b b lea b pop pop b lea b lea b figure three compile indirect jump return example search succeed jump translate address correspond target search fail transfer indirect target resolution indirect link mechanism similar approach take six three important first entire chain generate one time embed translation indirect jump therefore new predict target add onto chain generate contrast approach build chain program run thus insert newly see target onto chain order pin put new target either front end chain new target find chain next time occur without search hash table second difference use global hash table indirect jump whereas pin use local hash table individual indirect jump study kim smith seventeen show local hash table approach typically offer higher performance third difference apply function clone ten accelerate common form indirect control transfer return function call multiple sit clone multiple copy function one call site consequently return clone one predict target chain case illustrate example figure three b implement clone associate call stack trace precisely static context trace discuss section call stack remember last four call sit compactly represent hash address single integer register reallocation frequently need extra register example code resolve indirect branch figure three need three free register instrumentation insert call application must ensure call overwrite scratch register may use application rather obtain extra register way pin reallocate register use application use register allocation pin allocator unique allocation must compile one trace time discover flow graph execution contrast static compile one file time five eight compile whole method one time describe two issue register reallocation scheme must address register liven analysis reconciliation register bind register liven analysis precise liven information register trace exit make register allocation effective since dead register reuse pin without introduce spill without complete flow graph must compute liven trace address compile record liven begin trace hash table use address key trace exit target attempt retrieve liven information hash table compute precise liven current trace simple method introduce negligible space time overhead yet effective reduce register spill introduce pin register allocation reconciliation register bind trace link see section try make trace branch directly register reallocate must ensure register bind trace exit source trace match bind entrance destination trace straightforward method require standard bind register trace example require virtual register value flush memory end basic block approach simple inefficient figure four b show would reallocate register original code show figure four assume virtual bind physical trace one physical trace two virtual save trace one exit modify trace reload use trace two memory allocate hold current value virtual respectively contrast pin keep virtual register physical register across trace whenever possible trace exit e target compile compile new trace use register bind e say therefore e branch directly figure four c show pin would reallocate register original code assume target compile nevertheless target previously compile register bind generate compensation code nineteen reconcile register bind instead compile new trace figure four show pin would reallocate register original code time assume target previously compile different bind virtual practice bind show one two virtual register therefore efficient method design choice encounter put compensation code could place branch exactly situation show figure four two original code b approach trace one one two trace two add one sub two trace one one two one two add one sub two c pin reconciliation need compile trace two use bind virtual physical trace two add one sub two pin minimal reconciliation need trace one compile need recompile trace two simply reconcile bind virtual trace one two one two trace two previously compile add one sub two figure four reconciliation register bind adjust bind place compensation code could place branch case two figure four would place choose approach experimental data show generally result unique bind therefore reduce memory consume compiler place compensation code branch equivalent target register allocation match bind branch target support reconciliation register bind need remember bind trace entry do associate trace static context contain group static hold trace entry register bind one property another example property call stack trace use function clone see section precisely speak trace define pair original instruction address trace entry static context trace compile new trace first search compatible trace code cache two trace patible either identical different register bind case reconcile one register bind exemplify figure four compatible trace find simply use instead generate new trace register spill pin reserve area memory spill virtual register show figure four b two spill area support area thread local pin start application thread allocate spill area thread steal physical register spill pointer point base area point access spill area make spill pointer switch thread spill pointer set spill area new thread addition exploit optimization opportunity come absolute address mode available architecture pin start application assume single thread access spill area make absolute address therefore pin need physical register spill pointer pin later discover application fact multithreaded invalidate code cache recompile application use spill pointer access spill area pin detect intercept system call since common multithreaded hybrid approach work well practice optimize instrumentation performance show section four slowdown instrumentation cause execute instrumentation code rather compilation time include insert instrumentation code therefore beneficial spend compilation time optimize call analysis course overhead execute analysis highly depend invocation frequency complexity analysis complex much optimization however many whose analysis perform simple task like count trace optimize case analysis reduce execution overhead follow without call bridge routine save register set analysis routine finally call analysis routine analysis routine require two call two return invocation eliminate bridge thus save two call return also longer explicitly save register instead rename register body analysis routine allow register allocator manage spill furthermore enable like constant fold analysis routine perform additional optimization architecture analysis modify conditional flag register analysis routine counter hence must preserve original value see application however access fairly expensive must do push onto moreover must switch another stack avoid change application stack pin avoid much possible use liven analysis liven analysis track individual write read instruction frequently discover two use access without involve stack however decide use since two implement current architecture number source file number line include comment generic arm total nineteen nineteen fourteen twenty eighteen fifteen table one distribution pin source among different run code write c remain assembly dead point analysis routine call insert able eliminate save restore finally achieve even better performance writer specify hint anywhere tell pin call analysis routine insert anywhere inside scope instrumentation basic block trace pin exploit number optimization schedule call instance pin insert call immediately instruction overwrite register thereby analysis routine use register without first spill organization pin source code since pin system source code share key minimize development effort first step share basic data structure intermediate twenty static binary previously develop organize pin source generic architecture dependent dependent like code cache purely generic like register allocator contain generic part table one show distribution pin source among different term number source file line combine table one since similar enough share source file number include number include instruction reason borrow two tool library form source data reflect do reasonable job code share among fifty code generic four experimental evaluation section first report performance pin without instrumentation four support report performance pin standard count finally compare performance pin two tool show pin instrumentation performance superior across experimental setup describe table two use compile compile eon version work even without apply pin could use official program execute run suite eleven use reference input arm able run train input due limit physical memory even execute use arm hardware hardware compiler binary cache memory except eon use share eighty static cache memory cache memory compiler eighty static static arm memory static table two experimental setup pin performance without instrumentation figure five show performance apply pin four without instrumentation since pin still development instead use pin zero experiment time normalize native run time ie slowdown pin two similar case average overhead around sixty integer within five float point higher overhead integer side due many indirect branch return slowdown pin zero follow trend generally especially probably architecture performance depend quality code contrast tolerate overhead introduce code pin performance arm worse three indirect link see section yet implement computational memory available one downside dynamic compilation compilation time directly reflect application run time understand performance impact dynamic compilation divide total run time show figure five b pin zero source code instrument hence breakdown code cache denote time execute code store code cache ideally would like component approach divide time three time spend decode encode task architecture time spend register reallocation denote remain time spend last component include time spend virtual machine include instruction emulation resolve indirect control transfer figure five b show mostly small except two instruction footprint execution time relatively short consequently insufficient code reuse pin amortize compilation cost particular pin pay high cost reallocate register compare tool reallocate register nevertheless advantage provide register reallocation outweigh compilation overhead register reallocation make easy provide pin virtual register number physical register support hardware practice performance overhead serious concern case would sufficient code reuse amortize cost register reallocation figure five show different trend arm component e n c e x e e z l r n fifty zero e n c e x e e z l r n fifty zero zero six two zero one two code cache pin total nine nine two two eight one six five one two two one eight zero one seven three two eight nine one one one one one zero one five one one four one one nine zero one one zero one zero zero one two zero one one zero one four zero one three zero one one two one three zero one one zero one six zero one one zero one four zero one zero zero one one one one crafty eon gap parser k vortex ean p art grid w wise f ean wim b pin total code cache six seven three six nine two nine five one four four one eight four one five zero one three eight one zero one one seven zero one zero zero one two one one one one one one zero one one zero one three zero one one zero one two zero one four zero one one one one four zero one one zero one five zero one one zero one three zero one one zero one six zero one crafty eon gap parser k vortex ean p art grid w wise f ean wim c pin seven five three total e n c e x e e z l r n fifty zero three seven one three three one two two one two four one six two one five two one zero two one five zero one five two one four one one nine zero one eight two one five two one three one one five three one seven one nine one nine two four zero one zero one two three four one zero one two one one one one crafty eon gap parser k vortex ean p art w wise f ean wim grid pin code cache total crafty eon gap parser k vortex e n c e x e e z l r n zero ean figure five performance pin without instrumentation four time normalize native run time ie arithmetic mean integer respectively explain section large small register reallocation indirect link yet implement arm result indirect control transfer resolve pin performance instrumentation study performance pin count output execution count every basic block application choose measure tool performance count commonly use extend many tool discuss section also tool simple enough performance largely depend well integrate application hand performance complex tool like detail cache simulation mostly depend tool algorithm case less impact performance figure six show performance count use pin architecture test use four different optimization level without optimization overhead fairly large much slowdown crafty add help significantly average slowdown improve integer float point biggest performance boost come liven e n c e x e e z l r n zero without optimization liven analysis liven analysis schedule three four three six three two four one two two one nine four five two zero five four nine eight one nine seven one eight zero one nine eight four two three one eight four two two six one eight one one one two one four one one zero one one two five one seven two one four four one nine zero one zero one one nine four one five zero one zero one one four zero one seven one three eight three one crafty eon gap parser k vortex p art grid ean wim f ean w wise figure six performance pin count instrumentation architecture analysis reduce average slowdown integer float point schedule instrumentation code reduce slowdown integer float point without instrumentation performance comparison compare performance pin popular instrumentation tool pin reallocate register generally regard performance leader dynamic optimization use latest release tool experiment six run two set experiment one without instrumentation one count instrumentation implement count modify tool package name lackey tool package name show integer result figure seven integer cod problematic cod term slowdown cause instrumentation figure seven show without instrumentation pin significantly outperform faster pin vortex mainly pin spend time three refer back figure five breakdown reallocate register pin faster crafty gap possibly advantage pin indirect link ie incremental link clone local hash table overall twelve faster pin without instrumentation give primarily design optimization fact pin come close quite acceptable consider performance instrumentation show figure seven b pin outperform margin average slow application time time pin time insert call every basic block entry automatically call use update counter nevertheless still save restore explicitly around counter update contrast pin automatically call perform liven analysis eliminate unnecessary clearly demonstrate main advantage pin provide efficient instrumentation without shift burden writer eight eight one one three eight five one seven four seven seven eight five nine three seven three three four three one two two eight one eight three one two two one five zero one eight zero one nine nine two eight seven one seven four eight five five eight eight six five three two six four one four two zero three seven three two three zero two nine zero one one one one eight six one one zero one one zero one one two one five one one eight nine one three seven one three one one four one one four five one two four one five zero one nine zero one crafty gap parser k vortex ean b count one nine zero one zero six eight seven one six six zero six two eight five nine seven four three four six three three two nine five two four three nine eight one three seven three six two one four four seven five zero eight four nine eight one one nine one eight five one eight zero one nine seven one zero two two one three nine seven zero five four six three seven nine one eight zero two five four three eight eight zero five nine eight two zero two three one five two two six one one nine three nine six two four three one e n c e x e e z l r n zero e n c e x e e z l r n zero crafty gap parser k vortex n ean figure seven performance comparison among pin eon exclude work binary omit eon cause two arithmetic mean slightly different show figure five six five two sample illustrate pin use practice discuss two use various group inside first tool study frequency different instruction type program use compare cod generate different second tool pinpoint automatically select representative point execution program use accelerate processor simulation whose source code include pin two distribution twelve simple determine dynamic mix particular execution program statistics break per per routine per image basis conceptually tool implement profiler insert counter begin basic block trace upon program termination walk counter associate start address determine function belong instruction mix basic block output dependent different different implementation source code use four though simple quite useful architectural compiler comparison study example follow analysis reveal compiler performance problem collect statistics image produce two refer b architecture crafty find image produce compiler execute two dynamic image produce compiler b understand extra look instruction distribution data routine show table three significantly different two mark examine cod two reveal due different delta due different register surprise find extra generate compiler figure eight show code generate compiler communicate compiler learn push pop use stack alignment fact unnecessary case result performance problem fix latest version compiler addition spec use analyze oracle performance typically ten oracle process run system want ignore observe single process perform transaction first run oracle natively ie without pin next attach pin single server process perform transaction collect profile pin dynamic instrumentation allow us avoid instrument entire sixty oracle binary attach feature allow us avoid instrument process pinpoint purpose pinpoint otherwise tedious process find program simulate validate representative generate trace two major challenge simulate large commercial program first program long run time detail simulation entire execution time consume practical second program often large resource operate system elaborate make difficult execute address first chal instruction type c n compiler compiler b delta total ret table three dynamic instruction distribution crafty push unnecessary test add lea pop unnecessary figure eight code generate compiler use methodology use phase analysis find representative simulation second challenge use pin collect profile call pinpoint instruction trace eliminate need execute program simulator ease run key advantage pinpoint pinpoint use collect instruction trace wide variety program table four list spec commercial include multithreaded table show commercial order magnitude spec fully simulate would take simulate select pinpoint reduce simulation time days also validate choose represent behavior predict pinpoint typically within ten actual value high prediction accuracy fast simulation time pinpoint use predict performance large future six relate work large body relate work instrumentation dynamic compilation limit scope discussion concentrate binary instrumentation section highest level instrumentation consist static dynamic approach static binary instrumentation pioneer atom thirty follow eel eighteen etch morph static instrumentation many compare dynamic instrumentation serious one possible mix code data executable static tool may enough information distinguish two dynamic tool rely execution discover code run time difficult program description amber fluent spec integer suite eleven spec float point suite eleven spec evaluate multithreaded suite simulation one computational fluid dynamics code fluent two transient dynamic finite element analysis program technology three render application four code size nineteen dynamic count table four analyze pinpoint column three show code section size application binary share report size command column four list dynamic instruction count application input static indirect branch share code two approach dynamic instrumentation approach work dynamically replace original program branch instrumentation code example include seven nine instrumentation transparent original memory overwrite instruction size vary ie replace instruction trampoline occupy instruction overwrite follow instruction implement one level branch incur performance overhead make instrumentation challenge contrast approach suitable instrumentation work dynamically compile binary insert instrumentation code call anywhere binary include strata six diota pin among pin unique way support instrumentation time portable across four efficient due apply seven present pin system provide portable transparent efficient robust instrumentation support r arm run show abstract away detail many work across four little port effort also show pin instrumentation compromise performance automatic do compiler make pin instrumentation even efficient tool use also demonstrate versatility pin two pinpoint future work include develop novel enrich refine instrumentation tool develop port pin operate pin freely available thank prof dan host pin university colorado bistro team provide falcon suggest instruction schedule optimization mark develop peri implement part pin instrumentation reference one amber home page two fluent home page three home page four home page five ar j v b murphy serrano compiler dynamic compiler manage technology journal seven one six l efficient transparent comprehensive code manipulation thesis seven b r buck j code patch journal high performance compute fourteen four eight g burke fink grove hind v sarkar j serrano v c h j dynamic optimize compiler conference page june nine b w h dynamic instrumentation production proceed symposium operate design implementation ten cooper hall k methodology procedure clone computer nineteen two eleven j l spec measure performance new millennium computer seven twelve pin user manual thirteen architecture developer manual fourteen architecture developer manual thirteen fifteen extend memory technology developer fourteen guide twelve sixteen processor family developer manual seventeen kim j smith hardware support control transfer proceed annual code cache international symposium eighteen j e eel executable edit proceed conference program language design implementation page june nineteen p j w p nix c multiflow trace schedule compiler journal seven twelve twenty muth harish architecture generation optimization page proceed conference code j k de diota dynamic instrumentation optimization transformation compendium hold conjunction pact two n j program supervision proceed workshop framework verification h r r sun pinpoint representative portion large dynamic instrumentation proceed annual international symposium v sarkar linear scan register allocation program five sept g lee w wong h levy instrumentation optimization b b use etch proceed workshop page seventeen august h g w r h e g b automatically characterize large scale program behavior proceed international conference architectural support program operate h binary transformation distribute environment technical report research thirty atom system build program analysis tool proceed conference program language design implementation page r van b large system performance spec proceed workship experience implementation x z wang n gloy j b smith system support automatic profile optimization proceed symposium operate system k n b j l dynamic translation proceed conference code generation optimization page