stream efficient detail render university figure one image show volume data consist render dynamic sparse approach algorithm achieve interactive rat exceed memory capacity far tank efficient stream basically volume use resolution need produce final image besides gain memory speed render provide inherently abstract propose new approach efficiently render large volumetric data set system achieve interactive render performance several billion solution base adaptive data representation depend current view occlusion information couple efficient render algorithm one key element method guide data production stream directly base information extract render data structure exploit fact detail often concentrate interface free space cluster density show volumetric model might become valuable alternative render primitive spirit allow exploit temporal coherence also introduce process allow increase display rate better quality high quality filter enrich data set create additional detail variety procedural demonstrate approach several like exploration scan resolution mesh virtual resolution theoretically infinite resolution render current generation hardware respect limit memory budget one introduction volume data often use context scientific data visualization also part many special effect company digital domain rhythm n hue massively rely render complex copyright association compute machinery permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute commercial advantage copy bear notice full citation first page copyright work own must honor abstract credit permit copy otherwise republish post redistribute list require prior specific permission fee request one boston one fifteen find many recent movie lord ring day tomorrow pirate mummy three cloud smoke foam even extremely detail geometric data boat pirate represent render via volume render scene size resolution large often even fit computer memory addition storage render data also extremely costly even advantage richness representation regular structure make easy manipulate particular filter make good candidate address issue hard deal triangulate model one reason data often use represent interface resemble surface certain distance appear complex close view example foliage tree well approximate volumetric data observation hold complex surface general thus volumetric render also graceful way deal level detail problem paper show current hardware generation ready achieve massive volume render interactive rat benefit filter occlusion cull procedural data creation well integrate efficient engine enable us obtain visual quality previously reserve movie enable technique use special effect two major issue make detail render massive possible overcome memory propose relate update scheme usually costly render volume data require large amount memory thus limit scene extent resolution detail fact scene longer hold entirely memory imply need intelligent data stream memory point particularly crucial memory severe pro even able iteratively fill memory manner transfer frame standard memory size current already prevent performance second challenge actual render display data pure ray march lead alias costly due large amount need visit shade blend fortunately time part volume need full resolution invisible distant enough approximate without quality loss occlusion also cover part consequence omit happen even scene opaque entity transparent quickly accumulate thus opaque block view paper aim make alternative render primitive framework highly inspire engine tool use special effect lift feature know time memory consume even scope production interactive rat two previous work much work focus volume visualization much cover paper recent overview volume render refer reader also many approach focus overcome recover smooth signal also include normal reconstruction focus lie data management efficient render high resolution input also hide extent issue full use many benefit visual complexity allow fur vegetation detail realistic appearance arise use much effort spend accelerate volume render recently many approach publish rely volume slice whereas approach perform ray march fragment shader many efficient assume entire volume present graphics card memory thus highly limit possible detail level therefore context render remain mostly valuable representation distant model resolution keep low counteract usual memory cost recent rely ray march procedure opaque model particular interest allow early ray termination height field share concept also aim improve performance via sophisticate intelligent ray march mostly limit restrict type data figure two detail tend concentrate dense cluster empty space true though full volume always need sixteen graphics often suffice detail locate mostly layer interface empty fill space observation use render form specialize map relief bidirectional case volume data represent limit interface attach object surface space around case recent structure nonetheless storage render previous efficient volume layer remain small screen instead deal general general volumetric data set also often consist dense cluster free space compare figure two one benefit cluster data compaction fast traversal empty space avoidance occlude stop ray certain opacity level reach also want make use constant density acceleration compaction purpose although inspire work paper focus render achieve aim richness representation condition memory typically order magnitude smaller data detail much research focus topic massive volume render al analyze volume data compute structure base choose cut tree use leave data render al keep different resolution level memory choose block accord distance observer render goal combination render massive close data compress use manner empty space skip efficiently although relatively efficient approach involve much work achieve temporal continuity include occlusion test cull hide part volume volume block use many approach without filter block structure remain visible occur filter discuss two approach present one base lead difficult filter scheme one higher precision base tend overrefine part scene structure though whereas approach adapt resolution continuously make disappear temporal transition different subdivision level smooth structure share brick map dynamic consequence content lod visibility thus combine adaptive version structure regular memory block allow efficient filter relate work recently publish al take closer look solution next section approach develop parallel work al share work approach provide better quality performance offer new procedural content management thus push forward idea make render primitive better understand make paper self contain first give overview approach share al one let us start naive consideration volume small allow efficient render simply step data set store texture accumulate color way one benefit several hardware relate advantage like direct address trilinear interpolation coherent texture cache mechanism even enough memory two first algorithm would slow due many step need take large data set second whole fit memory one insight give point view entire volume need memory organize data spatial subdivision structure empty part let unsubdivided distant part replace lower level lead lower resolution different lod thus less memory addition give point view hide part need load see figure two al choose structure convenient represent traverse well adapt store regular data like refine reflect need precision scene tree node contain pointer brick indicate space brick small grid size usually approximate part original volume correspond node example brick root node would approximation entire data set data representation thus combine memory efficiency adapt structure small texture efficiently evaluate ray march group large texture brick pool store memory limit content need choose wisely update viewpoint change time algorithm make sure visible leaf nod pool enable appropriate render entire volume current viewpoint nod might miss case invalidate viewpoint move nod tree fuse collapse base need resolution visibility update trigger data brick pool miss brick pool certain reset upon usage node need subdivision new transfer algorithm use memory previously reserve thus unused concept refer last recently use keep track current data organization facilitate update structure mirror structure thus do host general computational change need transfer facilitate order also allow brick cache main memory important volume large hard disk access necessary three overview computer graphics section five explain basic render strategy ensure correctly produce image section also detail basic process involve traverse grid also address appear value define along ray integration along cone define eye extent compute value several ray increase computation time significantly way overcome issue use equivalently hierarchy build iteratively average neighbor due filter process read deliver integrate value small volume step size ray march choose accordingly distance observer possible obtain good approximation actual cone integral accelerate thus address large extent smooth result increase render performance increase memory consumption make tree update challenge discuss advance solution rely mechanism section six provide unify framework efficient eliminate much previous interaction easy implement finally section seven show several result amplify increase detail level original data enable higher render quality previously possible figure three leave spatial structure combine tree texture tile right traversal hybrid structure along ray illustrate four structure mention adaptive space subdivision key render large volumetric model algorithm make use similar node subdivide hence name case n two result standard use different n modify behavior memory efficiency low n deep tree traversal efficiency large n shallow tree easily possible adapt repartition input data scale allow node store brick pointer constant value store single value case almost homogenous empty core reduce memory enormously avoid ray march directly compute contribution store brick also interior nod tree enable us perform filter via new update introduce section six take account respect work describe previous section introduce several important section four present generalize data structure discuss condense representation reduce memory simplify implementation accelerate well update allow us exploit data structure often encounter implementation structure figure four summarize data structure approach might helpful follow discussion implementation structure single pointer use per node al need eight child seventeen tree also interior nod performance cost use instead minor still fit single texture five basic approach section discuss render update volume represent useful first consider simpler case standard render assume necessary data present allow reader familiarize data structure address dynamic update particular advance approach section six combine render algorithm visibility mechanism trigger update single unify method previous work rely separate step analyze adapt structure load next usually involve much interaction whereas execute render consist march data structure along view ray accumulate color opacity hierarchically ray need traverse reach leaf node homogenous region initialize ray use draw proxy geometry deliver correspond view ray fragment shader one could use quad near plane bound box volume data approximate geometry contain volume proxy initial position also use determine ray leave volume compute single activate alpha blend set maximum blend draw depth surface luminance one minus depth alpha channel alternatively tile two depth buffer one texture let geometry shader move second tile invert depth practice allow fair comparison previous work test perform use near plane initialize ray bound box stop one efficient method traverse tree along initial ray would recursive ie generalize tree nod algorithm rely stack implement dynamically index memory inefficient current due lack fast memory within shader instead use iterative descent tree root similarly algorithm particularly efficient highly benefit structure start origin ray locate descent stop reach node appropriate necessarily leaf node either represent constant region space contain brick whose resolution fine enough project one case constant node value simply integrate analytically along distance ray traverse node case brick standard apply leave current node new position serve origin next descent one important observation traversal need structure indicate correct do previously determine shader see later key feature minimize update descent fast point use figure four structure illustrate clarity well neighbor nod make possible keep nod texture refer node pool texture organize block nod group node one block make possible access child nod single pointer way coherence largely improve traversal texture cache modern help drastically also memory largely reduce even though structure exhibit neighbor adjacent nod show section efficient traversal remain possible node reserve data either store constant value homogenous volume pointer towards brick information reduce previous eight two bite value result sixteen time storage improvement may seem less important memory occupation much lower brick pool amount data read traversal tree critical render update structure achieve significantly less information transfer figure five node implementation bite node data follow see figure five thirty encode pointer child nod zero mean child one bite indicate whether node refine maximum whether original volume still contain data one bite store whether content constant value empty core describe brick accordingly represent either pointer brick leave thirty average value location homogenous leave paper also introduce filter base section without amount data per node could reduce leave need data thus child brick constant value store exclusive share thirty remain two leave enough room rest necessary node data hence volume data need highest resolution leave eighteen directly locate let x zero one three point local volume bound box c pointer root node offset child node contain x simply x n integer part multiplication x n fetch child c x n continue descent update x x n x n even though new descent need every time node leave mostly structure follow thus hardware texture cache well prepare perform use one big fragment shader traversal brick sample prove efficient make two step separate pass probably due local data storage texture cache high quality filter figure six method top show noise standard trace bottom render actually perform differently previously explain want perform better filter value hence adapt sample rate relative level ray march depend viewpoint mention traversal stop reach appropriate node idea behind twofold one hand allow increase render speed hand good approximation cone instead ray trace smooth transition different tree better fit actual cone size need access level fortunately correspond nod encounter tree descent see figure four one might think many level might necessary perform internal filter brick describe small extent space show small near plane offset three level enough three also minimum filter kernel entry point slightly next level might exceed cone leave brick proper blend three level must make available traversal collect traversal use small queue three implement shader register without use dynamic index store data leave use neighbor step volume would make appropriate filter difficult recover color opacity value accumulate transfer function phase function light use density gradient normal easily account tree update via interrupt resume far discuss render procedure case data present complex data might reside memory way achieve correct output image start ray trace process stop ray whenever data miss communicate initiate load algorithm resume last ray position consequence several pass perform complete output give frame treat active ray use standard technique ray trace block terminate relay feature prevent execution whenever stop ray need maintain status information ray preliminary output color accumulation miss node id current march position space fit information two multiple render target miss adapt data structure next render pass initiate proxy surface buffer use input texture technique ensure active fragment shader execute even though rudimentary algorithm already show nice load data directly traverse ray data lie outside frustum ever load even though explicitly test need track need ray indicate traversal precision need area screen nevertheless simple system describe far would know data become useless follow discuss complex system basic algorithm allow performance six advance algorithm discuss implementation spatial subdivision structure enable render large volumetric model also explain render perform present simple method update data tree first approach section interrupt ray trace data miss trigger update resume new data lead accurately render image cost much time second display mode discuss introduce approximation data need resolution miss higher level try none present available data coarse resort iterative method see use higher level often good choice show perceive less detail strong motion likely encounter miss data camera settle accurate render achieve within frame fix budget thus deliver relatively stable frame rate nonetheless information node usage still need communicate first hit node entire trajectory ray section discuss solution problem combine render visibility basic principle subdivide fuse nod manner node brick reset upon usage whenever new element add replace let us suppose moment access information ray conveniently update pool nod mirror data structure furthermore trigger load need data even know store brick pool maintain host memory necessary transfer via call lead unify management brick pool node pool two control cache question remain determine nod use need refinement coarsen data miss information derive evaluate node lod frustum containment nineteen tree traversal induce overhead visibility determine via occlusion query render image previous frame even interleave intelligently occlusion query result cost algorithm spatial screen temporal coherence successive frame introduce additional practice find three best choice hence store three four twelve nod follow strive establish volume data render primitive want avoid much interaction ultimately steer data load indicate data helpful previous frame interestingly information available ray trace terminate current volume traverse key insight motivate us combine render visibility update phase solution besides output color ray also output supplementary information data usage update need information collect ray frustum containment visibility lod selection naturally handle one unify way take two major need address describe detail follow section first especially presence transparency ray traverse large number nod output limit amount information per fragment even use store first node would lead acceptable result scheme second information need send back trigger update limit show perform compaction data exchange render feedback information render traverse tree stop reach node correspond need require data present traverse brick make sure keep pool collect current node index make sure node parent need also remain cache appropriate miss node terminal mean refine data original model simply add remember information indicate via one bite node figure five otherwise also add indicate need subdivision practice work best limit one request per ray single subdivision might already change opacity allow early ray termination next frame state arbitrarily size efficiently output current currently eight render target possible adapt repartition data necessary reserve first render target output color remain buffer keep node information refer texture provide room four encounter nod one per channel respective subdivision tag indicator make simply reset induce subdivision need currently miss interestingly need send collapse information render algorithm longer descend node index never put list thus mechanism reset thus replace data point establish lazy evaluation scheme simplify substantially previous need maintain tree actively use thirty node index one bite subdivision tag seven allow seven four output per ray generally insufficient complex ensure nod miss exploit two important neighbor ray visit mostly similar nod brick node always project onto several exploit spatial coherence group ray package image plane package size two two ray store first twelve traverse nod second twelve nod figure seven total node indices figure seven exploit spatial coherence use pattern attribute different node set addition temporal coherence use traversal render nod push fifo first frame stop push second frame window shift small set frame increase number retrievable nod less nod one notice use fifo ensure information output frame penalization due temporal coherence consequence gain reactivity compaction update information simplify ignore pattern assume twelve nod per ray suffice construct would possible read back memory result would enormous parse additionally costly ideally one instance node reference would enough naive way achieve consist sort node indices use stream reduction remove multiple sort expensive would sort many would afterwards delete fortunately saw coherence neighbor ray powerful property use compaction texture possible reduce set sufficiently make sort step unnecessary figure eight selection step n k keep right list compare local scope leave list compare follow pattern first pass derive selection mask bite output indicate element list underlie keep selection mask base local comparison use pattern like one show figure eight compare center list orange figure surround list entry list keep appear surround figure theoretically costly list long nod cross approximatively moment two neighbor ray allow us perform efficient approximate comparison list element test th th twenty figure nine result trabecular bone data augment noise bunny base distance field approximate fly neighbor list figure induce false remain conservative first step selection mask contain whose nonzero represent list keep rely reduce selection mask algorithm special case scan binary search algorithm highly optimize exploit locality texture process final step recover actual correspond node indices compact texture transfer rearrangement process original position lose twelve node per list avoid problem use remain twenty encode position ray location information able recover actual node indices reduction contain ray information allow creation compact node index texture read back practice usually contain nonzero thus possible make final compact texture one single texture allow us store indices four nod limit exceed request automatically postpone next frame seven result test perform graphics card image render see figure one nine example one explicit volume trabecular bone use scan volume trabecular bone analyze constant density example still fit memory copy volume eight time direction order simulate resolution data structure use n two sixteen algorithm achieve smooth activate without average possible also add scale noise increase richness noise add evaluate noise frame would expensive low penalty create use subsequent frame comparison indicate approximately fifty nevertheless base implementation example two procedural volume use one unique brick size naturally choose n three rely one unique resolution potentially infinite practice float point precision limit zoom maximum virtual resolution performance often reach ninety usually stay around sixty example three amplification mesh example use volume define interior mesh derive distance field mesh fly use surface vicinity aim high quality use twenty noise shade complex due complex produce volume information frame rate relatively low around twenty volume example four cumulus cloud method use encode cloud detail paper deal multiple scatter cloud even combination complex shade algorithm allow increase detail use n two five noise simulate enhance cumulus cloud virtual resolution memory usage node pool small four correspond use indices brick pool use give room usually computation time memory efficiency compute procedural noise show also create noise creation prove actually efficient evaluation transfer eight conclusion future work present method interactive render large detail work show performance high quality volume render possible algorithm avoid interaction compact data structure minimize memory usage side introduction smooth transition base allow temporal coherence hint possibility volume data could important future primitive currently animation big problem volume data future would like investigate possible another interest avenue would apply method hierarchical general mesh point render recent structure like tree would like thank support eric proof read anonymous helpful comment work partly support excellence cluster multimodal compute interaction reference l x realistic water workshop natural phenomena w x c tree computer graphics forum three proceed f n e c symposium interactive graphics game interactive multiple anisotropic scatter cloud r volume visualization vis thirteen three barge b l j v tetrad volume sketch particle render p h irradiance atlas global illumination complex production render p f render forest render june p f volumetric computer graphics forum k j c volume graphics k volume render use shade workshop graphics hardware e f far framework interactive render huge complex model commodity graphics graphics proceed e f j ray cast framework interactive render massive volumetric vis seven w advance high quality graphics volume render science hong w f large volume graphics fourth international workshop horn r j p interactive tree symposium interactive graphics game avalanche snowy sketch adaptive texture map conference graphics hardware j c cloud stealth model render sketch g make nebula cloud motion picture volumetric render sketch j kay l render fur three dimensional c symposium interactive graphics game h perfect spatial hash e b joy k interactive volume visualization proceed visualization vis f two f texture texture surface symposium interactive graphics j r j generic efficient data structure graphics one p fast volume render use factorization view transformation li w k empty space skip occlusion clip volume render proceed visualization vis p r k r proceed vis parison normal estimation scheme conference visualization nineteen f efficient realistic render proceed graphics interface f model animate render complex use volumetric visualization computer graphics four one bishop g relief texture map budge b l joy k map k e f three eighteen relax cone step relief map martin g volumetric reconstruction interactive render tree photograph proceed h advance central seminar computer graphics tong x j l wang x b synthesis bidirectional texture function arbitrary surface graphics three proceed j e employ complex data structure interactive visualization adaptive mesh refinement data international workshop volume graphics g c seidel point list generation histogram pyramid