projection query probabilistic business process milo milo abstract business process consist business undertake one pursuit business goal tool query analyze extremely valuable company particular give specification identify flow likely occur practice satisfy give query criteria crucial various personalize design paper study first time query evaluation query projection context analyze complexity problem different class distribution function flow likelihood provide efficient whenever possible furthermore show interest application analysis execution trace log recover miss information process behavior record log introduction one business process short collection logically relate combine flow achieve business goal simplify development common practice provide high level description operational flow use standard specification language five automatically generate specification since logic capture specification tool query analyze extremely valuable company two allow optimize identify potential reduce operational cost typical query engine give input specification execution pattern interest identify among potential execution flow sub flow structure specify pattern two three thirteen note however among possible flow typically interest particular give permission copy without fee part material grant provide copy make distribute direct commercial advantage copyright notice title publication date appear notice give copy permission copy otherwise republish post redistribute list require fee special publisher march saint russia copyright specification identify query answer flow likely occur practice crucial various use instance adjust design need certain user group personalize importance query evaluation enhance fact number answer qualify simple query may extensively large even infinite contain recursion two simple example consider travel agency analyzer wish examine execution flow may issue query ways may one reserve travel package contain flight hotel do particular company say may many ways book travel package assume instance obtain popular scenario one first search package contain flight eventually book flight without reserve hotel result may imply combine deal suggest unappealing specifically interest deal refuse present use improve web site previous paper fourteen suggest model rank execution flow base likelihood occurrence present efficient query evaluation algorithm selection query namely query give execution pattern specification retrieve full possible execution flow contain occurrence pattern many case however user may interest whole flow may long complex specific part relevant analysis deal hotel reservation issue payment request reject address need consider paper projection query retrieve interest full qualify flow provide efficient algorithm evaluation query important question rise consider projection query choice rank metric query result utilize notion flow likelihood define rank projection result maximal likelihood flow contain projection possible rank consider future work see although tight relationship semantics selection projection query search flow maximal new need develop provide efficient query evaluation projection query indeed show standard common use selection intermediate input projection yield case exponential blowup instead novel query evaluation algorithm construct direct compact representation avoid materialization intermediate full qualify flow algorithm first contribution paper interestingly work originally target static analysis specification turn choice rank metrics correspond query evaluation technique also valuable analysis process instance specification actual run process follow logic describe specification management allow trace instance record invoke execution trace record typically selective contain partial information perform six may due performance concern lack storage space confidentiality however give partial log often wish nevertheless understand actually happen word would like identify execution flow likely origin log typically focus specific part log particular interest seventeen four intuitively record may view query query result set relevant part flow likely occur practice show query evaluation adapt retrieve likely give sub trace first consider case name trace know advance difficult case information give challenge avoid consider possible set potential operation name whose number exponential size overcome prove small world theorem show polynomial number representative need test algorithm compute possible trace second contribution paper model use model flow likelihood borrow fourteen natural abstraction standard business process execution language five model nest dag consist nod link edge detail execution order dag shape allow describe parallel may either atomic compound latter case possible internal structure call also detail dags lead nest structure compound activity may different possible correspond different user variable value availability capture logical user variable value guard possible practice user state consequently truth value guard likely capture choice likelihood function describe probability implementation choice function use define second likelihood function time possible execution flow denote flow likelihood simplify presentation first assume independence implementation present set withdraw assumption study particular show computation still possible although become bound level dependency define formally paper allow query evaluation presence bound third contribution paper paper organization section two formally define model query language notion projection query section three present algorithm compute query answer assume independence technique set partial execution trace consider section four value introduce section five section six provide overview relate work conclude section seven two start present formal model query specification run example consider travel agency user search trip may choose search flight search combine deal flight flight inject parallel search view search result user may select either confirm selection reset restart search cancel leave without finalize reservation business logic travel agency describe schematically figure one model nest direct acyclic graph dag set dags intuitively correspond specific function service graph consist flow thereof activity represent pair nod first background stand activity activation point second completion point activation completion point utilize consider execution flow edge represent execution flow multiple edge go single node stand parallelism hence dag structure may either atomic like login activity compound like ravel f light latter case possible internal flow call implementation also detail depict bubble compound activity may different possible correspond different user variable value capture logical user variable value guard possible implementation ravel activity three possible definition specification triple finite set dags distinguish dag consist single activity pair call root implementation function map compound activity name set pair contain logical formula f call guard formula dag exactly one implementation choose occurrence compound activity correspond guard formula say satisfy assume two guard guard activity may satisfy concurrently example depict figure one set dags consist f one f two f three f four f one specification root implementation function depict bubble annotate guard execution flow execution flow actual run instance business process may abstractly view nest dag contain represent activation completion edge represent flow implementation among along record guard correspond choose compound activity nod example fig two depict two example execution flow travel agency process focus instance fig two user choose flight search follow choice flight confirm choice flow edge mark regular edge connect activation completion nod compound start end resp nod choose implementation mark dash fig two b depict different possible flow user choose search reserve flight hotel fi next nod consider next formally define notion execution flow give specification definition give specification g execution flow g consist root activity pair g execution flow g obtain g attach activity pair g label compound activity name edge attach implementation ga activity two new edge call edge start ga end ga annotate pair formula fa guard ga call g expansion g denote g g figure one business process f two f three f four guard test value variable value may either flight depend user choice exactly one implementation choose determine truth value guard determine turn user choice focus f two implementation f light activity set possible correspond choice ba stand air al aer last activity one option reset go back f one confirmation cancelation formally define assume existence three n nod activity name f guard distinguish two disjoint represent atomic compound resp also use two distinguish act denote resp activity activation completion first define auxiliary notion label dags use define definition dag n e n n finite set nod e set direct edge n n label function nod label node activity name graph require acyclic dag g obtain dag replace node n label label pair nod n n label resp act incoming edge n direct n outgo edge n outgo n single edge connect n n assume g single start node without incoming edge single end node without outgo edge denote start g end g resp next define notion define standard manner use predicate equality value g call full flow expand contain internal flow compound activity node p p hotel five six three one p hotel p choice ba al choice reset seven two one six four table one function example consider table one depict probability value different travel agency consequently function correspond guard accord function may compute instance compute multiplication value flight choice confirm five seven four fourteen b compute multiplication f light hotel choice ie seven six four query distinguish selection projection query former seek full execution flow contain give execution pattern latter focus interest user start define auxiliary execution pattern within execution flow utilize define syntax semantics selection projection query execution pattern tree offer exist query data nest dags namely pattern similar structure contain transitive edge may match execution flow path transitive nod search within indirect level correspond composite node nod pattern may label may match node definition execution pattern pair p e e whose nod label label may annotate formula distinguish set activity pair edge e call transitive edge resp example figure three depict simple execution pattern describe flow contain ba flight search result confirmation ignore rectangle surround pattern edge transitive edge doubly bound ravel nod transitive nod label next nod utilize intuitively transitive edge connect ravel may match sequence search reset transitive edge connect f light may match sequence search figure two execution flow partial flow otherwise set full define denote f low graph e say e partial full flow specification likelihood user variable value common thus execution flow vary likelihood occur practice define two likelihood function first name choice likelihood function associate value guard formula implementation choice value stand probability formula hold assume independence hold implementation make withdraw assumption later use function may define second likelihood function time possible execution flow namely recall execution flow correspond sequence implementation make execution joint likelihood guard thus stand flow likelihood formally definition give root function guard e define follow one e consist root activity e one two else e e e e e f f formula guard implementation add e form e note function consider imply independency likelihood formula hold constant regardless context flow truth value implementation take general may dependent instance choice hotel may dependent choice precede section five discuss result general context dependent definition projection query projection query q p p consist execution pattern p accompany p pattern form execution pattern call project part pattern e embed h p e result q e h denote q e h contain nod edge e nod edge p map h activity pair participate embed edge connect activation completion nod also include e result q e denote q e consist result possible q e ie q e h q e h finally result q denote q set possible result q apply namely q low q e easy prove q set note e q may originate several namely may several e f low st e q e score e maximum likelihood flow namely score e e e f low e q e function definition result projection query q specification denote top k q set q highest score value example reconsider pattern fig three fig two possible embed h map activation completion nod thus participate projection result along connect edge transitive edge map path contain edge login activity edge login f light transitive edge map implementation f light along edge edge connect projection result depict fig three b embed pattern fig two b similarly do projection result give fig three c evaluate projection query specification fig one projection depict fig three b maximal likelihood lead flow fig two likelihood fourteen thus projection score technical remark require definition two guard activity may satisfy concurrently consequently sum guard activity name one assumption comply intuitive concept specification necessary result indeed use tool relax without requirement figure three query answer transitivity ravel node allow match include indirect implementation correspond composite node nest level next formally define notion match execution pattern execution flow definition let p e execution pattern let e embed p e homomorphism nod edge p nod edge e st one nod activity pair p map activity pair e node label preserve node label may map nod activity name two edge transitive edge node node n p map edge path n e edge n belong direct internal trace transitive activity edge edge path n type flow otherwise must type n next define query consider two type query selection query simply consist apply specification select pattern may embed projection query hand allow focus specify part select flow formally definition selection query give execution pattern p e specification along function define result evaluate p denote p set execution flow e exist embed p within e top k q set k execution flow p highest value two projection query consist execution pattern along annotate output nod edge match part project appear query result distinct may likelihood set may unique choose one arbitrarily three query evaluation describe section evaluation algorithm projection query first recall algorithm evaluate selection query give fourteen show direct algorithm projection query fail achieve query evaluation finally describe alternative algorithm overcome evaluate selection query main tool efficient evaluation selection projection query give compact representation intermediate evaluation result via another specification thus start define specification capture set along definition along function correspond function capture possibly infinite set respect function one f low identical three rename function activity name two low e e give specification query q algorithm give fourteen find along capture q algorithm operate two step first algorithm find specification capture flow correspond query ie q second algorithm analyze obtain representation find representation likely flow thus capture q algorithm bear two important feature first execution time incur construction capture q polynomial size specification second explicit construction concrete flow flow q possible time polynomial output size ie size flow goal design evaluation algorithm projection query bear two feature detail algorithm may find fourteen important next show possible direct set projection query generally infeasible next present two possible projection query show may incur exponential data complexity use isomorphism equivalence graph first attempt explicit enumeration first simple approach evaluate projection query try use mention algorithm construct compact representation q four explicitly enumerate flow along value next obtain flow may compute correspond projection result rank base maximal flow lead note however naive algorithm may incur time exponential specification size well output size follow theorem hold theorem exist query q every n exist specification whose size linear n even size q exponential n size q bound constant proof consider specification activity single implementation follow implementation activity ai one consist two nod label implementation consist single atomic activity consider also query seek root activity whose indirect implementation consist two nod connect transitive edge query project root node easy observe q single possible size flow contain two instance four instance exponential n note contrast q consist single activity pair second attempt compute compact representation alternative approach adapt selection query evaluation algorithm follow idea generate compact representation result namely q retrieve unfortunately approach would also lead infeasible algorithm follow theorem hold theorem exist query q every n exist specification whose size linear n n whose size polynomial size capture q proof number n consider specification start node branch two different activity nod join edge go single node branch n time consider query q project path start end node specification n capture q possible path must appear direct implementation root activity distinct n number thus root activity n must bear least much direct consequence size n exponential size size latter linear n multiple flow lead projection result one may need generate flow k k next show alternative algorithm evaluate projection query efficient evaluation projection query show infeasible compute compact representation projection result retrieve however may still perform algorithm spirit second step stay intact however instead first step generate specification capture entire set result q first step refine evaluation algorithm generate specification capture subset q include particular rank say q formally definition give two query q number k say q top k q f low q rename function nod score projection f correspond flow theorem give specification projection query q p p may compute specification q time polynomial exponent determine query size proof present evaluation algorithm compute q throughout computation algorithm use embed function embed sub pattern invoke graph g pattern p embed return set graph em g p correspond single embed g em g p isomorphic name g activity label node encode identifier label original node g well nod transitive edge p map embed may implement use homomorphism nine algorithm detail intricate explain four step gradually consider complicate pattern flat pattern start consider simple execution pattern consist root activity whose implementation contain atomic activity nod compound activity nod implementation attach additionally pattern contain transitive nod edge algorithm begin embed pattern root r root r create new root r r use embed try embed implementation r direct implementation r consider implementation g r guard f st em g p let g em g p g implementation newly create r r guard formula denote f r r compute value assign f r r follow denote n set compound activity nod appear g n match g p contain implementation node root contrast recall score projection compute maximal likelihood flow lead likely flow contain implementation node n thus need compute partial induce implementation n n denote n compensate set f r r f n compute n employ algorithm describe section second step algorithm k one n root activity nest pattern next consider execution pattern nod root implementation may attach edge nod may bear case proceed embed match compound activity pattern bear implementation match implementation pattern implementation match node activity recursive call end either pattern contain nod case successful match find pattern contain nod embed find latter case mark match failure garbage collection step follow remove activity lead failure lead computation value compound nod g match consider computation thus need compensate compound nod match consequently set n contain nod pattern transitive nod query pattern include transitive nod may need embed indirect correspond nod consequently must consider possible split pattern appear transitive nod smaller split pattern p embed within direct implementation correspond compound node assign compound node generate node new activity name pi node original activity name pi assign subpattern intuitively pi guarantee embed pi indirect implementation construct embed pi implementation garbage collection step remove lead failure algorithm termination guarantee subpattern query match specification node match find generate activity name guarantee existence match need verify computation value refine account ing case upon match transitive node entire implementation graph node n omit node within keep intact thus compensation likelihood generalize newly generate formula guard implementation g multiply nod nod whose implementation generate g eliminate pattern transitive edge finally consider transitive edge edge match specification nod denote n start node edge end node remain consider transitive edge appear projection part need verify path exist transitive edge appear projection part projection result contain path edge match infeasible create implementation distinct projection ie distinct path number two nod specification may exponential specification size fortunately interest may appear also assume sequel transitive edge appear within implementation transitive node k five may choose coappear implementation thus share likelihood design dynamic program algorithm namely generate n first assign unique identifier specification node generate new set nod specification one k initialize table keep track th likely path along likelihood initialize empty path zero likelihood except entry assign likelihood one table full contain particular n explicitly generate fill table use auxiliary notion follow say child edge activation node compound activity start node implementation completion node compound activity implementation computation value table proceed follow compute th increase value compute topi path originate node l consider l specification child say j index path originate use rank path l previously compute compute j one path originate already compute obtain score score candidate path generate l case edge l edge score multiply k k match f f formula guard implementation root child maximal score along correspond choose topi path originate l obtain path serve separate implementation correspond compound activity follow lemma hold lemma partial specification generate algorithm capture k likely n complexity complexity algorithm polynomial size exponent determine query size q polynomial data complexity ensure polynomial data complexity embed well treatment transitive nod specification node match query subpattern transitive edge generate k rather corollary may compute specification capture top k q data complexity proof algorithm first apply obtain q flow capture result q possibly additional flow thus apply algorithm serve step two algorithm dynamic program algorithm similar detail may find fourteen thus omit note exponential dependency query size inevitable unless p n p follow theorem hold theorem give specification query q threshold respect query size decide whether exist projection q e score greater may prove reduction emptiness result set show twelve algorithm base pump lemma guarantee suffice guess small polynomial size flow project detail omit space interestingly problem remain even specification query graph simple almost form four employ selective trace study projection query tool analysis business process section consider another application result common practice trace process naive trace keep exact record occur along flow obtain trace thus equivalent case execution flow however typical trace naive first exact name sometimes record instance generic name say payment may use record set cash payment credit card payment second may omit trace altogether due lack storage space confidentiality lack interest give partial trace user may wish identify flow likely occur practice moreover focus part flow interest first describe model partial trace study identification likely flow give partial trace model partial trace execution trace well rename capture notion selective trace formally selective trace system f specification consist set f activity name guard omit rename function name name obtain trace call selective trace define recall definition thirteen six definition selective give spec selective trace system f satisfy condition set selective trace define denote trace consist graph e obtain delete activity pair label seven delete guard f replace label remain nod condition include root activity graph g graph g obtain g remove atomic activity pair name graph definition empty intuition behind condition practical point view reasonable assume result obtain loss information still bear shape flow consider example selective trace system hotel f flight six thirteen consider adaptation straightforward atomic activity pair delete edge incoming connect nod previously point compound incoming outgo edge connect nod implementation identity function trace impossible distinct flow contain search one contain search activity dictate search type omit indeed trace obtain two different flow fig two next define notion origin flow flow may occur give observe trace follow definition execution flow e possible origin execution trace selective trace system f denote e delete e activity name formula name f rename accord result give execution trace wish identify flow likely occur practice relevant part thereof consider generalize set input consist query seek relevant part likely occur trace conform query set indeed general observe trace may represent pattern projection part part interest next define selective trace say e e e e e isomorphic e definition give specification selective trace system f query q define q low e e e q e say e lead e score projection result e define maximal flow e lead top k q consist k q best score intuitively result set q contain e flow e rename rename e projection e q thus capture relevant part conform flow e rank maximal rank correspond flow e remainder section discuss computation q two different first assume knowledge ie know exactly delete rename consider intricate scenario information unknown know selective trace start show give q may efficiently capture q theorem give specification selective trace system query q obtain specification capture top k q may do polynomial time data complexity proof sketch revisit algorithm section three adapt first step selective set follow one upon match nod may match query node n specification node n label n rename label n two upon match edge may also match edge specification path give path include nod whose label deletion set trace system edge along path guard deletion adapt support newly create edge verify nod edge nest level along match path indeed conform requirement three composite node treat transitive correspond edge treat transitive item two conclude proof unknown selective trace previous discussion assume knowledge information lose trace process knowledge may generally absent instance access trace system sample trace obviously assume information trace system one infer anything flow shape thus assume trace system follow selective trace subset activity name delete another subset rename say origin origin selective trace system correspondingly define q follow definition give specification query q define q q score e e denote q k result highest score q follow theorem hold theorem give specification query q may generate specification top q polynomial time data complexity proof first give naive exponential algorithm explicitly enumerate possible trace optimize consider subset possible trace finally prove indeed sufficient consider subset naive algorithm give specification query q naive algorithm generate possible f contain name appear f contain guard appear map activity name activity name q algorithm find capture q possible theorem last algorithm construct specification whose root contain apply analysis find number trace test exponential size algorithm infeasible optimize version avoid explicit generation possible trace system generate subset first generate possible query nod name formula name ignore original map l first check l consistency verify two query nod whose original formula name identical map different label formula name algorithm generate selective trace system denote l deletion set al include activity name formula name except assign l query node formula name rename function l match activity name original activity name query node map l uniquely define due l consistency nod bear activity name consistent map l l add set trace denote size polynomial claim capture trace need check namely lemma give specification query q e exist st e top k q exist proof first direction immediate thus assume exist denote l node embed q assignment label query nod accord embed e q denote result apply l e construct embed e q map nod nod exactly e note node e map node q remove l edge map edge connect correspond nod transitive edge still exist path possibly contain one edge connect correspond edge remove unless remove number trace generate well evaluation complexity trace system polynomial specification size obtain polynomial data complexity algorithm conclude proof theorem five discussion assume full independency likelihood dictate execution flow practice independency rare user value tend correlate conclude withdraw assumption independency show plausible query evaluation feasible dependency define dependency first extend definition function consider give guard formula also represent history occur formula evaluation namely function e f e partial flow f formula guard activity name node next expand eight intuitively prediction next user choice variable value dependent history flow thus far instance offer combine deal expect observe typical stay show fourteen general function dependency even emptiness selection query undecidable however realistic case likelihood formula depend execution history bound manner one way define bind consider slide window allow dependency choice last however approach yield set class restrictive observe consider recursive choice precede follow recursive loop would still like allow dependency even number within loop exceed bind thus formula f bind number implementation previously make activity affect likelihood f next define class capture function follow definition give say memory exist finite bind n st guard formula f activity name ai pair e e agree choose activity name ai last n expansion step e f e f n zero memoryless continue run example assume choice hotel dependent last choice search type last choice memory bind case one contrast likelihood choose depend example exactly many time reset choose unbounded memory claim may extend set likelihood function though may incur exponential time specification size theorem give specification along function selective clarity presentation assume total order order assumption may relax fourteen ing system query q generate specification capture top k q top k q top q may do exponential time data complexity proof sketch use algorithm fourteen give specification function generate specification memoryless function capture f low activity name encode sufficient amount history require computation likelihood guard thus size may exponential size rename function map new name name present previous section may apply generate new capture q top k q top k q algorithm second rename function generate explain final rename function activity name obtain unless exponential time evaluation presence dependency may improve follow theorem hold proof omit space theorem give specification function query q threshold respect size decide whether exist projection q e score greater six relate work next give brief review relate work highlight result relative query language data model consider originally introduce two three extend probabilistic set fourteen work fourteen focus selection query assume naive trace ie execution trace accurately exactly represent flow occur practice contrast work first best knowledge study projection query partial trace probabilistic business process model partial trace use introduce set thirteen show realistic enough capture trace six probabilistic one twenty nineteen eight extend probabilistic set introduce distributional nod node subset randomly choose appear concrete document twenty show evaluation projection query probabilistic possible polynomial time data complexity result however imply algorithm set complex first model allow representation nest dag structure rather tree projection query entail another level complexity find match serve project relevant nod second infinite number flow may represent probabilistic serve schema due possible recursive call upon projection result set may infinite well pose challenge set evaluation projection query maximum aggregation function may do straightforward adaptation selection query evaluation thus study focus sum aggregation function contrast show probabilistic inherent adaptation support projection query even maximum aggregation sum aggregation function consider future work probabilistic eleven allow representation uncertain relational information extend relational algebra probabilistic set analyze complexity query evaluation set show find exact query result p hard eleven though query evaluation approximate result hardness however stem combination use sum aggregation function join absent context thus hold contrast different rise set representation dynamic nature flow possibly unbounded number recursive possibly dependent activity term possible semantics eleven number model infinite rather large yet finite variety probabilistic process exist literature chain eighteen probabilistic recursive state machine sixteen stochastic context free graph best knowledge projection query model study selection query analysis generally extend theoretical analysis ten regular consider strongly expressive monadic second order logic complexity bound obtain thus practically infeasible evaluation strongly expressive query p l undecidable general seven fragment work consider fifteen allow express stringlike contrast query language suggest reasonable expressibility feasibility twelve another advantage use query language study graphical intuitive nature similar view process use commercial specification three claim intuitive query temporal process two three seven conclusion study paper first time query evaluation projection query probabilistic show data complexity al query evaluation presence independency dictate flow study problem complexity presence dependency furthermore consider application result analysis execution trace recover information miss trace limit discussion paper aggregation function compute rank give projection maximal likelihood flow lead various aggregation function particular sum aggregation function consider future research eight reference one p query update probabilistic information two c milo query business process three c milo monitor business process query four w c mine improve composite web service recovery j web service five two five business process execution language web service six oracle process manager administrator guide configure view process log seven temporal probabilistic automata eight b incorporate probabilistic pod nine visual query system ten b monadic logic graph one eleven n efficient query evaluation probabilistic twelve milo query structural behavioral business process thirteen milo type inference type check query execution trace fourteen milo evaluate query business process fifteen k algorithmic verification recursive probabilistic state machine sixteen n l koller learn probabilistic relational model seventeen w c mine recovery event base log business process management eighteen j g j l snell finite chain springer nineteen b query efficiency probabilistic model twenty b match twig probabilistic z manna temporal logic reactive concurrent p r l chain stochastic stability f estimate maximum likelihood stochastic graph c n n efficient query evaluation probabilistic data axiomatization one p sen represent query correlate probabilistic