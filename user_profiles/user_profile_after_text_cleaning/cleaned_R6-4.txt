deterministic share memory mark computer science engineer university abstract current share memory multicore time execute multithreaded application even supply input produce different output frustrate limit ability properly test multithreaded code become major stumble block widespread adoption parallel program paper make case fully deterministic share memory behavior arbitrary multithreaded program system function input core idea make communication fully deterministic previous approach cop multithreaded program focus replay technique useful contrast directly useful offer repeatability default argue parallel program execute field well potential make test assure increase reliability deploy multithreaded propose range approach enforce determinism discuss implementation show determinism provide little performance cost use architecture future hardware approach utilize exist subject c zero general c one two multiple data stream general term performance design reliability introduction one develop multithreaded prove much difficult write code one major challenge current execute multithreaded code twelve give input thread interleave memory io differently execution permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee nine march copyright c multithreaded execution arise small execution environment process execute simultaneously operate system resource allocation state cache bus structure ultimate consequence change program behavior execution complicate development process significantly defective might execute correctly time subtle synchronization bug appear typically reproduce addition also make difficult test multithreaded program good coverage require wide range program input wide range possible interleave moreover program might behave differently time run input become hard assess test coverage reason fraction research test parallel program devote deal address problem replay multithreaded execution base previously generate log eight fourteen fifteen eighteen contrast paper make case fully deterministic share memory show hardware support arbitrary share memory parallel program execute little performance penalty addition obvious benefit deterministic ie repeatability argue parallel program always execute field potential make test assure allow meaningful collection crash information increase reliability multithreaded deploy field since execution field better resemble test moreover propose enable efficient deterministic execution also use directly manipulate thread interleave allow better test multithreaded program overall deterministic positively impact development deployment parallel program paper organize follow begin provide precise definition mean execute section two key insight definition multithreaded execution deterministic communication thread deterministic discuss give rise provide experimental data show one would expect current share memory indeed highly describe build efficient deterministic propose three basic section three one use serialization transform multithreaded execution execution two restrict access share data guarantee deterministic communication three use speculatively communicate thread roll back determinism violate moreover propose series reduce performance negligible amount discuss hardware contrast section four move describe experimental infrastructure section five compose simulator hardware implementation fully functional implementation use ten compiler infrastructure present performance characterization result section six hardware discuss system issue interaction operate system section seven finally discuss relate work section eight conclude section nine two background definition deterministic parallel execution define deterministic share memory system computer system one execute multiple thread communicate via share memory two produce program output give program input definition imply parallel program run system deterministic program direct way guarantee deterministic behavior preserve global interleave every execution parallel program however several interleave irrelevant ensure deterministic behavior important global interleave choose long always also two communicate order swap observable effect program behavior turn key deterministic execution communication thread must precisely every execution guarantee program always behave way give input guarantee deterministic communication require dynamic instance instruction consumer read data produce dynamic instance another instruction producer producer consumer need thread communication happen via share memory interestingly multiple global interleave lead communication call interleave figure one summary interleave yield program behavior guarantee deterministic behavior need carefully control behavior load store communication thread insight key efficient deterministic execution exist current generation hardware build behave execute program environment state change execution execution effect manifest time different thread execution cause final global interleave memory system different ultimately effect application change dynamic instance store instruction produce data dynamic instance load instruction point program execution behavior may diverge previous consequently program output may vary flow data st z st b st st w b st p q parallel execution st z st b st st w b st p q st z st b st b st w b st p q global interleave figure one parallel execution two multiple interleave b solid represent communicate hollow represent communicate source follow hardware source source several environment create process execute concurrently compete state memory page power save mode disk io buffer state global data structure os addition several operate system call legitimate behavior example read system call legitimately take variable amount time complete return variable amount data hardware source number vary program run program run among state cache predictor table bus priority short structure fact certain hardware bus change outcome execution purely due environmental factor choice priority base signal detect first outcome could vary differ temperature load collectively current generation hardware build behave next section measure behave quantify first show simple experiment illustrate simple change initial condition system lead different program simple toy example measure much exist execution real simple illustration behavior figure two depict simple program two thread synchronize barrier write different value share variable table inside figure also show frequency outcome run core two duo machine clear cache run thread set buffer zero enter barrier expect behavior vary significantly depend configuration run race one global variable void race zero void race one clear cache yes thread zero win figure two simple program data race two thread outcome race run measure real mention previously program execution occur particular dynamic instance load read data create different dynamic instance store measure degree start build set contain pair communicate dynamic dynamic store dynamic load occur execution call communication set c dynamic memory operation uniquely identify instruction address instance id thread execute assume two whose communicate set respectively symmetric difference communication set yield communicate pair present quantify execution difference finally define amount n one represent proportion communicate pair common two note number correctly account extra spend synchronization form communicate pair develop tool use pin thirteen collect communication set multithreaded program tool take single sample specify point execution cover whole application run tool twice number different point execution compute correspond point run figure three show result one instance number obtain keep counter number dynamic memory execute instruction pointer suite run core two duo machine plot show program behavior moreover reveal two interest first plot depict phase execution drop nearly zero create barrier synchronize thread make subsequent execution deterministic second never show fact fraction pair ie typically private data access program execution exploit design system actually deterministic n r e e n n ten nine eight seven six five four three two one zero n r e e n n ten nine eight seven six five four three two one zero zero one two three four five two three four five zero one time time figure three amount execution x axis position execution sample take axis n one compute sample execution three enforce deterministic share memory section describe build deterministic system focus key without discuss specific address section four begin basic naive approach refine simple technique progressively efficient basic idea see make deterministic depend upon ensure communication thread deterministic easiest way accomplish allow one processor time access memory deterministic order process think memory access token pass among call deterministic serialization parallel execution figure four b deterministic serialization guarantee communication deterministic preserve pair communicate memory way implement serialization processor obtain memory access token henceforth call deterministic token memory operation complete pass next processor deterministic order processor block whenever need access memory deterministic token wait token every memory operation likely expensive performance b c parallel execution deterministic serialize execution deterministic serialize execution figure four deterministic serialization memory dot memory dash synchronization dation compare original parallel execution figure four performance degradation stem overhead introduce wait pass deterministic token serialization remove benefit parallel execution synchronization overhead mitigate synchronize granularity figure four c allow processor execute finite deterministic number quantum pass token next processor system serialization granularity quanta call process divide execution quanta call quantum build way build quantum break execution fix instruction count call simple quantum build policy note interfere introduce synchronization offer memory access semantics traditional hence extra synchronization impose system reside synchronization two interact recover parallelism reduce impact serialization require enable parallel execution preserve execution behavior deterministic serialization propose two recover parallelism first technique exploit fact thread communicate time allow concurrent execution second technique use speculation allow parallel execution quanta different quanta determinism might violate leverage execution performance deterministic parallel execution improve leverage observation thread communicate time execution communicate execute parallel thread thread communication however must happen achieve fall back deterministic serialization thread communicate quantum break two part prefix execute parallel quanta suffix first point communication onwards execute serially execution serial suffix deterministic thread run serially order determine deterministic token transition parallel execution serial execution deterministic occur thread block thread block either first point communication communicate thread end current quantum thus thread block quanta though possibly end thread block deterministic point within quantum communication detect describe later communication occur thread write share piece data case system must guarantee thread observe write deterministic point execution figure five illustrate enforce two important case one read data hold private remote processor two write share data case one show figure five quantum two attempt read data hold private remote processor must first wait deterministic token thread block wait deterministic token example read execute quantum one finish execute necessary guarantee quantum two always get data since quantum one might still write complete execute case two show figure five b quantum one already hold deterministic token attempt write piece share data must also wait thread block wait deterministic token example store execute quantum two finish execute necessary guarantee observe change state share privately hold remote processor deterministic point execution note thread wait receive token reach end quantum start next quantum periodically allow thread wait thread block make progress memory operation n deterministic order deterministic token pass initially private st one block atomic quantum initially share st block parallel prefix one st two block two serial suffix b read another thread private data write share data figure execution five recover parallelism overlap detect write communication need global keep track share state memory position share table conceptual data structure contain share information memory position keep different line page figure six show share table use access freely proceed parallel thread access private data without hold deterministic token one also read share data without hold token two however order write share data read data regard private another thread thread need wait turn deterministic total order hold token thread block also wait token three guarantee share information keep consistent state transition deterministic thread write piece data become owner data four similarly thread read data yet read thread become owner data finally thread read data own another thread data become share five thread access address one own n two share n three wait token thread block read n proceed access four five set private own thread write set share n figure six deterministic serialization share memory communication summary let us thread run concurrently long communicate soon attempt communicate serialize communication leverage support transactional memory execute quanta atomically isolation deterministic total order equivalent deterministic serialization see consider quantum execute atomically isolation single instruction deterministic total order transactional memory five six leverage make quanta appear execute atomically isolation couple deterministic commit order make execution equivalent deterministic serialization recover parallelism use support encapsulate quantum inside transaction make appear execute atomically isolation addition need mechanism form quanta another enforce deterministic commit order figure seven illustrate speculation allow quantum run concurrently quanta system long overlap memory access would violate original deterministic serialization memory case conflict quantum later deterministic total order get squash two note deterministic total order quantum commit key component guarantee deterministic serialization memory call system memory operation atomic quantum deterministic token pass uncommitted value flow n deterministic order st b st one three st b st b one three st c st c st b squash two four st c st b two four pure b w uncommitted value flow figure seven recover parallelism execute quanta memory avoid unnecessary squash uncommitted data forward b deterministic commit order also allow isolation selectively relax improve performance allow uncommitted speculative data forward quanta potentially save large number squash communication allow quantum fetch speculative data another uncommitted quantum deterministic order illustrate figure seven b quantum two fetch uncommitted version quantum one note without support forward quantum two would squash guarantee correctness quantum provide data quanta squash subsequent quanta must also squash since might consume incorrect data call system leverage support forward another interest effect commit order memory rename employ avoid squash conflict example figure seven quanta three four execute concurrently store three need squash quantum four despite conflict exploit critical path basic quantum build policy produce quanta base count break quantum deterministic target number reach however base quantum build capture fact thread rate progress also capture fact multithreaded program critical path intuitively critical thread change thread communicate via synchronization data share describe exploit typical program behavior adapt size quanta lead efficient progress critical path execution devise three first heuristic call simply end quantum unlock operation perform figure eight show rationale thread release lock thread might spin wait lock deterministic token send forward early possible allow wait thread make progress addition pass token forward immediately thread start spin lock memory operation n deterministic order deterministic token pass atomic quantum lock l one unlock l lock l grab lock l one three unlock l lock l spin waste work two four grab lock l three two four b regular quantum break better quantum break figure eight example situation better quantum break lead better performance second heuristic rely information data share identify thread potentially complete work share data consequently end quantum time determine thread issue memory share time last thirty memory rationale thread work share data expect thread access data soon end quantum early pass deterministic token consumer thread potentially consume data quantum producer thread run longer effect performance also reduce amount work waste squash call quantum build heuristic addition explore combination refer quantum build strategy monitor synchronization share behavior determine end quantum whenever either two would decide implementation issue four see previous section implement system require mechanism break execution quanta guarantee proper tie deterministic serialization system could completely hardware completely even mix hardware one complexity versus performance implementation offer better performance require change hardware conversely implementation perform worse require special hardware section discuss relevant point implementation implementation quantum build quantum build policy implement count dynamic retire place quantum boundary desire quantum size reach require access information synchronization obtain compiler synchronization require monitor memory access determine whether share data do use share table section discuss later section finally exactly logical decision make regardless quantum build policy use depend upon consistency model underlie hardware thread must perform memory fence edge quantum communication occur implement hardware token pass deterministic order hardware support multiple allow multiple deterministic process time process token share table use keep track share state data memory hardware implementation share table leverage cache line state maintain cache coherence protocol line exclusive modify state consider private local processor figure six show freely read write owner thread without hold deterministic token apply read operation line share state conversely thread need acquire deterministic token write line share state moreover thread must deterministic point execution block state share table correspond line cache processor keep memory manage memory controller much like directory cache coherence note however require coherence per se state transfer cache miss service nevertheless simplify implementation even address state change share table happen three one speculative change state share table two coherence request change state cache line perform issuer hold ninety deterministic token three nod need know nod block wait deterministic token necessary implement step three figure six guarantee one speculative need change share table speculative guarantee two coherence request carry bite indicate whether issuer hold deterministic token service node process request service node request imply change cache line downgrade finally three guarantee broadcast block unblock alternatively share table use memory tag tag represent share information moreover evaluation section show track share information page granularity degrade performance excessively suggest implementation simpler implementation top standard support hardware implementation need mechanism enforce specific transaction commit order deterministic commit order quanta encapsulate inside allow transaction commit processor receive deterministic token single commit processor pass token next processor deterministic order require elaborate support allow speculative data flow uncommitted quanta deterministic order implement make coherence protocol aware data version quanta similarly use speculation three one interest aspect transaction overflow event make deterministic use quantum boundary make bound implementation perfectly suitable system make transaction overflow deterministic require make sure update speculative state cache line happen strictly function memory instruction retirement ie update speculative permit addition also require nonspeculative line displace overflow trigger ie state nonspeculative line affect overflow decision implementation system also performance versus complexity likely offer better performance require speculative execution conflict detection memory whereas perform little worse require speculation implementation system also implement use compiler binary rewrite infrastructure implementation detail largely similar hardware compiler build quanta sparsely insert code track dynamic instruction count quanta need uniform size long size deterministic do begin end function call tail end back edge insert code track quantum size target size reach call back system implement various support implement deterministic token queue lock compiler instrument every load store call back system system implement logic show figure six table keep memory also possible implement system use evaluate scheme paper five experimental setup evaluate hardware system use parsec two suit run completion include due infrastructure memory system issue lack compatibility note input size implementation experiment typically use simulation run due simulation time run native experiment machine dual eight core total clock memory run section describe evaluation environment implementation category assess performance different hardware simulator write use pin thirteen model include effect serialize quantum build memory conflict speculative execution squash buffer single outstanding transaction per thread transactional memory support note even execution behavior deterministic performance may deterministic therefore run simulator multiple time average result provide error bar show ninety confidence interval mean model simplify detail various system model detail reduce simulation time model assume include squash different reasonable assumption allow us compare performance different scheme use infrastructure note comparison parallel execution also run simulator evaluate performance impact system use compiler pass write ten main describe sec two note simulation actually serialize quanta execution functionally affect system execute program accurately model effect quanta serialization application behavior pass execute compiler object file link environment another complete optimization pass library main object code system provide custom thread management synchronization finally system allow user control maximum quantum size granularity share table configure basis quantum size vary share table experiment run real hardware take multiple run average run time provide error bar performance plot show ninety confidence interval mean focus paper hardware omit detail description evaluation implementation six evaluation first show hardware best case negligible overhead compare parallel execution sixteen thread aggressive reduce twenty average examine sensitivity hardware change quantum size conflict detection granularity quantum build strategy present subset average space reason finally show proposal demonstrate unduly limit performance believe represent good performance complexity fast enough useful depend application deployment purpose performance figure nine show compare parallel run four eight sixteen thread produce quanta one would expect exhibit slowdown nearly linear number thread degradation sublinear affect parallel behavior application execution overhead average sixteen thread case provide much better performance additional cost hardware complexity average overhead provide consistent performance improvement scheme scale number overhead scheme flat suggest system would ideal thus right hardware support performance deterministic execution competitive parallel execution sensitivity analysis figure ten show effect change maximum number include quantum use scheme conflict detection increase size quanta consistently degrade performance scheme quanta increase likelihood cost abort since work lose ability avoid conflict help increasingly quanta size get effect application dependent worse quanta since quantum hold deterministic token longer potentially exclude thread make progress however effect reverse relatively large per quantum allow thread make progress without hold deterministic token smaller quanta force thread wait deterministic token sooner lessen effect average however less affect quantum size n q n n zero zero zero one r e v p e e p forty twenty zero twenty forty sixty eighty two x c two x c two x two c two x c parsec c x splash figure ten performance two x c instruction quanta relative instruction quanta figure eleven compare conflict detection cache line page granularity increase conflict detection granularity decrease performance scheme suffer likely false conflict gap grow former avoid conflict forward value unaffected conflict detection granularity lead block also surprisingly improve performance make faster share large memory radix suggest mechanism improve performance average result show exploit exist virtual memory support implement could quite effective figure twelve show performance effect different quantum build quantum generally improve performance much produce small quanta heuristic break substantially three seven six two one zero seven three four three six six one one zero two three one three eight three six six eight one zero three three eight seven zero one one zero three one five two eight four three two five six four three six four three eight seven zero one two one three two three three four four three eight six nine one one eight four six six seven e z l r n e n r n c e x e l e l l r p c n r e e n n thirty twenty fifteen ten l r n r g r w r e v p e e p fifty zero fifty four eight sixteen four eight sixteen four eight sixteen four eight p sixteen eight four sixteen four four sixteen radix p eight eight sixteen eight sixteen four four four eight four four splash sixteen sixteen fluid sixteen sixteen eight sixteen four four sixteen eight four sixteen p parsec eight eight eight eight figure nine four eight sixteen thread p indicate conflict detection otherwise n c b q r e v p e e p eighty sixty forty twenty zero twenty forty n c b q r e v p e e p eighty sixty forty twenty zero twenty forty n c r c e e p n g l b fluid n c e h n p g e r e c n figure eleven performance conflict detection relative radix p splash parsec figure twelve performance quantum relative quanta progress along application critical path quanta figure thirteen effect different quantum pronounce general quantum take program synchronization account outperform perform better quantum build scheme less affect scheme recover parallelism work well parsec work synergistically quantum build often outperform characterization table one provide insight sensitivity result line conflict detection give average read size show buffer modest percentage quanta suffer conflict percentage conflict roughly correlate performance conflict equally expensive scheme show amount execution overlap quantum quanta parallel prefix percentage average quantum size metric highly correlate performance work exist begin quantum progress radix p parsec splash figure thirteen performance quantum build scheme relative quanta thread make need acquire deterministic token finally give average quantum size percentage quanta break cause heuristic quantum maximum quanta size average quantum size uniformly close omit result since average quantum size generally former outperform latter see smaller quanta always better important choose quantum well implementation quanta strategy quanta line q page q share overlap overlap line page set set seven nineteen thirteen fifty eight sixteen ten radix fluid splash nineteen fourteen five forty sixty q sync thirty one fifteen fifteen five one one q thirty ten q sync fifty twenty seven sixteen nineteen forty twelve e z l r n e n r b h p w n c e x e l e l l r p c n r e e n n eighty seventy sixty fifty forty thirty twenty fifteen ten two thread four thread eight thread parsec table one characterization result granularity use figure nine thirty nineteen radix splash figure fourteen relative execution performance figure fourteen show performance compare parallel see two class trend increase number thread increase much number thread latter class add thread substantially improve raw performance even former class add thread decrease raw performance compare correspond parallel slowdown sublinear number thread thus add thread still result improvement raw performance summary data show unduly limit performance multithreaded seven discussion evaluation various scheme lead several highest level conclusion deterministic execution environment achievable future little performance degradation simplistic geometric mean slowdown sixteen thread orchestrate communication slowdown reduce geometric mean often less fifteen use speculation able reduce overhead geometric mean often less ten addition forward overhead deterministic execution less fifteen often less eight finally provide deterministic execution performance cost suitable current generation hardware depend upon application deployment define deterministic share memory show build efficient hardware support demonstrate build current generation hardware discuss several additional point one performance complex energy two support three interaction operate system io four make deterministic execution portable deployment implementation evaluation show use speculation implementation pay term performance however speculation potentially waste energy require complex hardware system design since code io part operate system execute speculatively fortunately coexist system one easy way coexist switch deterministic boundary program edge quanta interestingly system design support multiple coexist simultaneously allow system use convenient approach depend code run use speculation user code avoid kernel code could also build hybrid fashion instead purely hardware implementation hybrid system example could leverage modest hardware support quantum build deterministic order flexibly low performance cost hybrid system could efficiently implement share table leverage modern cache coherence expose coherence state transition could enable simple high performance hybrid implementation near future support instrumentation order enable environment system need way allow user instrument code preserve interleave original execution accomplish must support mechanism allow compiler mark code insert instrumentation purpose code affect quantum build thus preserve original behavior deal os io many source today discuss section system hide allow many multithreaded program run besides hide system also hide os thread schedule use deterministic token provide deterministic thread schedule cause thread run order every execution nevertheless challenge source remain one challenge parallel program use operate system communicate thread system need make communication deterministic one way address problem execute os code discuss section alternatively layer operate system application utilize detect communication synchronization via kernel provide within application solution employ implementation another challenge many operate system call allow system call read may lead program execution run run specification permit variation two ways handle ignore variation outcome could also occur sequential code fix provide alternative deterministic read solution always return maximum amount data request final perhaps difficult challenge real world simply ultimately program interact remote might affect thread interleave may appear hope build deterministic system case multithreaded code synchronize opportunity deterministic point since thread know state system deterministic interaction external world consider part input much easier write deploy reliable likely encourage insert synchronization around io order make deterministic hence reliable support deployment deterministic use development deployment well believe field behave like use test reason twofold first higher confidence program work correctly deploy second program crash field deterministic execution provide meaningful way collect replay crash history data support deterministic execution across different physical machine place additional implementation quanta must build across mean effect use end quanta count full bound furthermore pass deterministic token across must suggest hardware provide core leave quanta build schedule control eight relate work one way obtain deterministic parallel program write use deterministic parallel program model like stream program twenty implicitly parallel jade seventeen fact need improve due shift multicore cause renew interest deterministic implicitly parallel program model however several model tend generality focus deal arbitrary share memory parallel program past work deal share memory focus primarily replay execution idea record log order happen parallel execution later replay execution base log several previously propose eight eleven eighteen record replay multithreaded execution approach typically suffer high type record synchronization enough reproduce outcome race several address devise record replay one sixteen hardware base approach actually record memory level memory efficiently allow accurate faster record replay research reduce log size performance impact deterministic replay strata fifteen exploit redundancy memory race log recent advance rerun seven fourteen aim reduce log size hardware complexity rerun hardware memory race record mechanism record execution without memory communication phenomenon leverage new strategy require little hardware state produce small race log execute block chunk commit order block record oppose instruction addition use commit order albeit chunk size log special case reduce memory order log make memory communication deterministic therefore completely eliminate memory communication log consequently need provide hardware record replay execution execution always long input since attempt control reduce log size minimum similar spirit work however still log require speculation whereas example need speculation finally chunk quantum similar concept chunk create blindly whereas propose create quanta intelligently better match application share synchronization use similar employ speculation four nine nineteen though employ almost opposite purpose order quantum commit speculative value forward optimization start deterministic sequential program speculatively execute parallel guarantee original sequential semantics program opposite start explicitly parallel program effectively serialize make deterministic use speculative execution efficiently recover parallelism preserve deterministic behavior summary record replay system provide fully deterministic share memory communication use offer repeatability default argue however deterministic execution useful deploy well nine conclusion paper make case fully deterministic share memory quantitatively show current show key requirement support deterministic execution deterministic communication via share memory fortunately requirement still leave room efficient describe range implementation hardware vary complexity performance cost show hardware implementation system negligible performance degradation also briefly describe system show performance impact quite tolerable benefit obvious suggest parallel program always run deterministic execution field potential increase reliability parallel code system field would behave similarly test allow meaningful collection crash information conclusion show perhaps contrary popular belief share memory system execute program little performance cost believe deterministic valuable goal besides yield several interest research question abstract away several write deploy parallel code thank anonymous invaluable comment also thank dan kim university feedback manuscript finally thank research helpful reference one bacon replay program workshop parallel distribute two c j singh k li parsec suite characterization architectural pact three n j e smith g speculative cache four l willey k data speculation support chip five l v wong b j b k prabhu h c k transactional memory coherence consistency six j e b moss transactional memory architectural support data structure seven hill rerun exploit lightweight memory race record eight j h deterministic replay multithreaded nine v j architecture speculative ten c v compilation framework lifelong program analysis transformation eleven parallel program instant replay twelve e lee problem thread computer thirteen c k r r muth h g v janapa k hazelwood pin build program analysis tool dynamic instrumentation fourteen p l j record replay execution efficiently fifteen c pereira b record share memory use strata sixteen g b continuously record program execution deterministic replay seventeen lam design implementation evaluation jade eighteen k de fully integrate practical system nineteen g e breach n twenty w language stream woo e j singh program characterization methodological r hill flight data recorder enable deterministic replay hill r regulate transitive reduction longer memory race record