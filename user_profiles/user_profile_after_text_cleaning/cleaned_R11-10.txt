type inference type check query execution trace milo university milo abstract paper study first time management type information important class data nest dags direct acyclic graph describe execution trace business process short specifically consider type inference type check query execution trace query consider select portion trace interest user type describe possible shape execution trace query formally define characterize three common class execution trace respective type inference type check study complexity two query vary expressive power present efficient type whenever possible analysis offer nearly complete picture trace class query feature lead undecidable one introduction schema type information prove extremely useful management data general particular knowledge even partial typical structure data allow intuitive query formulation optimize query process minimization run time twenty four paper study first time management type information important class data nest dags direct acyclic graph describe execution trace business process short consider type inference type check query execution trace query select portion trace interest user type consider describe possible shape execution trace query context study two follow type inference problem give query possible execution trace want infer type describe shape select query type check prob research partially support project science foundation permission make digital hard copy portion work personal classroom use grant without fee provide copy permission copy without fee part material grant provide make distribute profit commercial advantage copy make distribute direct commercial advantage copy bear notice full citation first page copyright notice title publication date appear copyright work own notice give copy permission large data endowment must honor base endowment copy otherwise republish post abstract credit permit copy otherwise republish redistribute list require fee special permission post redistribute list require prior specific publisher permission fee request permission republish eight august new one copyright endowment zero eight august new copyright endowment also give output type want verify shape select conform study two type query vary expressivity present result let us briefly consider practical origin influence particular graph type query study business process consist business undertake one pursuit particular goal operate distribute environment implement fairly complex facilitate design development deployment particular recent standard business process execution language five allow describe full operational logic execution flow specification describe process nest dag consist nod link edge detail execution order may either atomic compound latter case internal structure also detail dag lead nest structure compile executable code implement describe run application server execution trace instance specification actual run process follow logic describe specification management allow trace instance activity issue activation completion report compound activity correspond internal flow report activation completion execution trace abstractly view nest dag contain nod represent activation completion edge describe flow nest dags trace follow naturally nest specification trace may vary amount information record run general one distinguish three execution trace increase flexibility naive trace provide complete record trace record possibly partial information origin activity selective trace select subset record query type execution trace extremely valuable company analysis allow optimize business process reduce operational cost ultimately increase competitiveness next illustrate notion type intuitively explain merit purpose query optimization error detection type information ie knowledge possible structure query sub trace valuable query optimization three role analogous schema query optimization allow eliminate redundant simplify query evaluation example consider simple query search contain two b trace type might tell us trace contain optimize query evaluation check existence b possible similarly type tell us trace contain immediately infer query inconsistent sense output surely empty halt since trace repository typically large analysis often do two step repository first query select portion trace particular interest serve input finer analysis query mine derive critical business information type information readily available specification original trace use optimize query however available intermediary select query feed input query one main paper develop efficient derive type information thereby felicitate optimization stag query process another level analysis tool expect data particular type would like verify select query guarantee conform require type type check second problem study type inference type check well study graph find particular shape execution trace correspond type pose new challenge require development novel type instance type check general easier type inference find nest dags type check harder detail comparison type inference check see section six result mention model execution trace instance nest dag type consist specification model abstractly rewrite system accompany description sort trace naive selective employ query language consider select interest use execution pattern execution pattern adaptation tree offer exist query data first consider simple positive query without join show less detail thus less restrictive execution trace efficient type inference do time polynomial size input type exponent determine size query selective trace type may require time exponential size input type even small query trace type may possible trace type naive type check hand become difficult expressivity involve type extend decidable although expensive semi naive trace type undecidable selective trace type next consider powerful query include pattern join node path projection negation mention complexity result hold type inference longer possible query join path contrast type check show still possible class trace analysis offer nearly complete picture trace type query feature correspond complexity provide efficient type inference type check whenever possible identify difficulty result two main important practical first positive second negative one far type inference concern result signal class selective trace type ideal type system trace allow flexible description trace well efficient type inference thus believe firm basis study query optimization management two hand show static type check possible selective trace type even limit trace type available consequently believe check likely useful practice remark conclude remark regard choice query language data model already importance query recognize business process management initiative six yet unlike case data draft standard publish since data model query language consider introduce two three argue intuitive query temporal process base view process use commercial specification three state result term particular model naturally applicable fragment query share similar expressive power detail comparison relate data model query include temporal eighteen equational set nine find ten relate work section section six compare know result model result highlight relative contribution paper organize follow section two introduce simplify version model query language section three four formally define analyze type inference type check simplify set section five extend study model relate work consider section six conclude section seven two simplify presentation first consider basic data model query language enrich obtain model execution trace mention execution trace instance view nest dag contain represent activation completion edge represent causal assume existence two n nod activity name two distinguish act denote resp activity activation completion first define auxiliary notion label dags use define execution trace definition dag n e n n finite set nod e set direct edge n n label function label node activity name graph require acyclic dag g obtain dag replace node n label label pair nod n n label resp act incoming edge n direct n outgo edge n outgo n single edge connect n n assume g single start node without incoming edge single end node without outgo edge denote start g end g resp example illustrate let us consider dag figure two contain four search hotel flight print represent pair nod pair node lighter background denote activity activation completion definition set ex execution trace ex trace set graph satisfy follow one single activity g dag consist sin activity pair g ex two nest trace ex activity pair st resp single outgo incoming edge dag graph g consist two new edge start end ex new edge add item two call edge edge call flow edge sequel connect item two definition edge activity pair along edge call direct internal trace activity consist direct internal trace activity well direct internal trace internal call full internal trace example example depict figure one let us focus first detail possible travel agency activity trip reserve trip edge mark dash follow reveal internal trace correspond compound compound activity one edge originate activation node point start node another possibly nest dag g another outgo end node g point activity completion node example zoom trip reveal search perform correspond hotel flight reserve parallel hotel flight resp confirmation print zoom reservation reveal credit limit check namely figure one b another possible travel agency see user look luxury trip invoke luxury activity internal flow similar regular trip reservation except luxury flight reserve via another type credit check possibly higher credit limit check perform type define type use intuitive model rewrite abstraction standard five type consist specification accompany figure one execution trace description sort trace naive selective employ among activity name distinguish two disjoint represent atomic compound resp specification collection dags along map compound activity name definition specification triple finite set dags distinguish dag consist single activity pair call root function call implementation function map compound activity name set dags compound activity may map implementation function set dags represent alternative possible activity one choose run time actual implementation example continue travel agency example specification consist dags figure two compound trip luxury hotel flight root compound follow trip luxury hotel flight intuitive interpretation specification follow user start search trip may choose regular trip lead luxury trip lead turn lead search reserve luxury flight luxury describe consider three trace first call naive provide complete record internal flow compound give specification set possible naive consist obtain root activity attach compound activity one possible call expansion definition naive give specification dag g activity pair g label compound activity name internal trace say g g g obtain g attach pair implementation ga two new edge start ga end ga p say expansion p call full expansion expand set possible naive define specification denote n consist full root intuitively naive process contain full information regard process execution example two figure one b naive travel agency depict figure two contain full record compound atomic participate execution well flow edge connect general n may infinite case recursive activity naive detail execution flow fully case however partial information record example travel agency may wish disclose fact bill system invoke case luxury reservation different one invoke case regular reservation term rather label activity nod exact activity name would like label generic credit label capture follow definition definition give specification rename function activity name activity name set define denote consist e obtain naive e n replace label e example continue run example figure one c travel agency rename function st credit identity function two obtain resp naive figure one b see trace credit check issue familiar view tree define specialization case nod label give partial information origin node correspond activity type tree figure two business process one case even selective trace desire occurrence record instance completely confidential may want avoid include memory trace similarly standard input integrity check may simply non interest business may omit avoid overload log redundant information model type trace introduce notion selective definition selective give specification set activity name satisfy condition rename function activity name activity name set selective define denote selective consist e obtain naive delete activity pair label one replace label remain nod condition include root activity graph g graph g obtain g remove atomic activity pair name graph definition empty example instance travel agency also wish keep secret fact different type treat differently credit check need also record luxury activity omit altogether luxury credit hotel flight figure one e show selective obtain naive figure one b note graph node isomorphism also selective obtain naive figure one thus give selective trace way tell naive regular luxury trip reservation originate intuition behind condition definition practical point view reasonable assume graph obtain loss information still bear shape trace otherwise loss easily observable instance remove also search result graph two edge go trip point two different nod contradict definition condition assure happen proof omit technical implication constraint discuss sequel atomic activity pair delete edge incoming connect nod previously point compound incoming outgo edge connect nod implementation selective precisely l specification resemble l grammar contrast every semi naive contain root activity atomic shape specify direct implementation root activity hence bound length capture context free infinite selective one might consider set selective language graph perspective compare model common model graph appear literature common model name recursive state machine one naturally extend finite state machine bear entry exit state allow state call state invoke call simulate replace call state implementation graph obtain sequence call unfold original form single entry single exit unique start exit nod show selective capture set proposition set e set full un fold belong selective proof sketch inclusion follow condition direction show generate equivalent normal form like normal form string dags know capture graph one strict inclusion selective follow conclude proof proposition sum subsection comment analogy type various sort string selective trace type form context free language trace type restrict form parenthesis sixteen keep track activation analogous parenthesis naive trace type restrict bracket fourteen also keep track parenthesis origin analogy hold respect trace type shall see query consider query mention introduction query language use originally introduce two three query define use execution pattern generalize similarly way tree pattern generalize tree activity name either specify leave open use special symbol edge pattern either regular interpret edge transitive interpret similarly activity pair may regular transitive search direct internal trace transitively inside see navigation axis particular nest dags introduce special challenge type inference check definition execution pattern pair p e e whose nod label label distinguish set activity pair edge e call transitive edge resp figure three execution trace specification rename function set define possibly infinite set e n resp e e selective let naive resp selective denote class set obtain naive resp selective trace specification rename function set formally naive e st e n e st e selective e st e selective show strict inclusion relationship class capture possible set proposition naive selective proof inclusion follow naturally prove next strictness use highlight key various trace class useful sequel naive consider specification depict figure five ignore text next nod depict include trip root activity whose implementation sequence two compound label implementation resp contain single atomic activity consider rename function map single activity name hotel identity function remain activity name set trace e contain single e depict figure three e contain two implementation first second easy see however specification e single naive e n hotel must least two alternative one contain contain case n also contain three additional one hotel internal trace one one first second selective consider class implementation graph compound chain consider selective trace obtain delete compound keep name atomic root unchanged result consist root activity whose direct internal trace sequence atomic view sequence activity name chain word set word represent selective trace give language easy see selective define context free language context free grammar follow naturally specification conversely every context free language l define st word figure four query result evaluate query match give match represent embed definition let p e let e embed p e homomorphism nod edge p nod edge e st one nod activity pair p map activity pair e node label preserve however node label map nod activity name two edge transitive edge node node n p map edge path n e edge n belong direct internal trace transitive activity edge edge path n type flow otherwise must type n result define image p activity pair image edge connect activation completion nod also include p e result p apply e denote p e consist result possible p e finally give set e also use p e denote set possible output p apply e namely p e p e easy prove p e resp p e set example depict fig four transitively trip search credit activity nod resp edge denote transitive nod edge observe apart transitive nod edge look similar make formulation query rather intuitive let us evaluate query figure one e two embed possible yield result figure four b c first embed pattern transitive edge outgo incoming trip activity match path pass flight activity second embed match path traverse hotel activity important note query trip activity would yield empty result would search credit direct internal trace trip give appear hierarchy finally observe since embed multiple query nod may map nod edge three type inference type inference problem study define next three problem correspond three trace type follow figure five business process two give p set naive resp selective define rename function set would like find specification st n p n resp p selective p selective two first show type inference may possible naive trace type consider namely theorem exist specification p st specification n p n proof proof follow line similar first part proof proposition consider specification whose dags depict figure six ignore text near nod root implementation root activity trip contain two consecutive compound hotel hotel two possible one contain activity second contain activity n contain four internal trace first second hotel second first consider query p figure seven ignore text near nod require occurrence p n contain explain proof proposition specification single naive contrast greater expressive power trace type allow capture set enable type inference show next type inference possible trace type may costly theorem every p rename function exist p compute time exponential size p note since every naive trace type also type identity function theorem also imply type inference possible input represent naive trace output type capture representation proof sketch zero construct type inference algorithm intuitively intersection original pattern p next explain construct illustrate example let us first consider pattern contain transitive nod edge every two activity pair p equality use graph isomorphism node equality set define equality relation consider complexity algorithm let us see example demonstrate operation example consider p proof theorem pattern give fig seven figure six identity map next query activity pair represent construct algorithm depict figure five activity name form identifier query pattern activity node ignore label appear within nod implementation hotel implementation hotel rename function map note single shape depict figure three indeed answer query p apply semi naive trace next explain construct algorithm construction begin match query root specification root form new activity name rip implementation match implementation thus embed resp resp form new activity name hotel hotel main point algorithm unique activity name hotel label two pattern nod yield two distinct activity name consequently two name distinct comply different condition query impose structure indeed proceed embed implementation possible hotel exist two possible one contain contain latter embed implementation former exist embed yield node label similarly construct implementation hotel contain time complexity algorithm depend number possible consider exponential size p number possible dags note subpattern number possible nod polynomial size dags exponent determine size subpattern number possible transitive edge may exponential size dags transitive edge map number dag may large follow proposition show exponential blowup unavoidable even small query naive input trace proposition exist infinite set increase size p six nod st every st p n size proof class root activity whose implementation follow form start end implementation label flow start first split two b c merge another activity split b c forth contain k form p consist root activity pair whose internal trace contain start end activity pair label single transitive edge p n root activity internal trace one individual start end activity exponential number thus figure six business process three figure seven label either compound activity name use new activity name represent intersection pair rename function map note node resp pattern p may appear several new ni resp ni p compound implementation consist dags represent possible direct internal trace p possible direct nod result graph possible label record every activity pair p activity pair map give embed embed find mark failure may find use conventional homomorphism whose complexity discuss efficiency rather construct triplet name algorithm operate top manner start match pattern outer activity root build correspond activity compute appear final step perform garbage collection mark failure possible contain failure remove dags contain failure query pattern contain transitive edge also define new activity name every transitive edge p activity pattern embed transitive edge p connect two pattern nod map possible connect two correspond nod output graph node label appear path label triplet finally pattern p contain transitive algorithm become somewhat complex recall transitive allow navigate transitively inside compound query internal flow depth nest specifically part direct internal trace match direct implementation part may match level implementation account algorithm consider possible split internal trace pattern dags specification generate trace must contain path explicit implementation root hence size must see selective trace type flexible expressive semi naive trace type turn add expressivity output type also allow compact representation possible query result hence efficient type inference algorithm theorem every p rename function exist st selective p compute time polynomial size exponent determine p moreover add expressibility allow efficient algorithm even input type expressibility ie represent selective trace well theorem every p set rename function exist selective p selective compute time polynomial size exponent determine p note since every trace type also selective one proof theorem also prove theorem proof sketch improve type inference algorithm base follow observation consider treatment transitive edge previous type inference algorithm describe proof theorem algorithm embed p treat individually contribute one graph transitive edge mean nod match treat separately hence exponential blowup avoid use add expressive power selective trace view sequence activity name path word set word obtain two nod language l easy define pair nod regular grammar describe l use similar construction one present proof proposition show selective define along st word generate selective precisely l incorporate part aside type inference algorithm follow line similar trace result algorithm polynomial size exponent determine p first obvious reason able provide algorithm combine data query complexity need embed pattern dags entail check homomorphism know problem interestingly expose additional type hardness come nest shape use transitive navigate transitively inside compound query internal flow explain define decision problem p problem decide give pattern p set activity name rename function whether embed p trace exist ie whether p selective show follow proposition give p set rename function p size p even follow condition hold direct internal trace p dags nod besides end node single parent problem even naive trace type consider ie empty identity function note dags restrict shape enforce condition homomorphism solve use fifteen indeed hardness come need consider treat transitive pattern possible split see algorithm proof theorem proof omit reduction problem test formula satisfiable know well complete picture show proposition give p set rename function p combine complexity proof sketch algorithm base observation p selective empty exist least one e obtain root activity polynomial number expansion step st p e empty e selective obtain e remove apply rename function though space reason give proof correctness stem pump lemma analogous one exist context free string hold algorithm simple transitive compound activity pattern guess expansion sequence correspond activity system guess map query pattern obtain verify satisfy embed also imply test emptiness p p n four type check problem type check verify query result conform give type formally give target specification rename function set want check p n n resp p p selective selective observe class x trace type inclusion decidable ie one decide two x x ability perform type inference imply type check also possible see however sufficient condition case type check possible type inference first show selective trace type theorem give p source target rename function activity set problem test whether p selective selective undecidable proof proof reduction problem test containment context free string know undecidable give two context free l l construct proof proposition selective selective capture resp l l p consist root activity whose implementation contain two activity pair connect transitive edge apply selective retrieve word start end node root internal trace hence word l hence p selective selective p selective selective l l contrast type check decidable naive trace type prove start define auxiliary class trace type call deterministic suggest type check algorithm trace type finally show translate every rename function equivalent set deterministic note proof technique inspire nineteen consider inclusion parenthesis string however case complex proof must additionally account graph structure complex string structure well rename function define deterministic trace type use notion nod origin let specification rename function consider e n image rename e clearly least one isomorphism e e map activity pair label activity pair label node e map isomorphism node n e call n origin note general node may one possible origin b even specific pair trace e e may several different definition specification rename function set trace call deterministic every node n possible n activity name show follow theorem give p specification rename function target specification rename function st deterministic problem test p n n respectively p decidable solve proof note naive trace type view trace type identity function trace naturally deterministic suffice prove theorem trace type intuition behind proof follow saw every p derive st p prove theorem construct every deterministic empty empty note complement ie contain include also note fact suffice consider restrict portion include trace complement size direct internal trace bound size direct possible internal trace word bind size number k size graph hold trace complement isomorphic trace activity direct implementation choose graph thus size bound k rest proof dedicate show trace type close intersection deterministic trace type also restrict form complement may effectively compute start show closure intersection move closure restrict complement proposition every pair compute st n n n similarly every exist proof let us first consider naive trace let construct follow zero two require zero set activity name intersection activity name set activity name r r label root different clearly n n empty otherwise root label r construction proceed follow every compound activity name treat set intersection regular intersection set graph graph g appear intersection isomorphic node g graph appear activity name add finally perform cleanup repeatedly graph check graph g compound remove adjust accordingly remove g implementation set note may make b additional b trigger removal graph proof trace follow similar line two main one graph two test isomorphism modulo activity rename function two nod represent pair nod label pair origin activity name implementation activity compute intersection implementation implementation compute result isomorphism graph whose nod label pair original activity name label nod match isomorphism cleanup step remain consider restrict complement start define auxiliary notion define trace size direct internal trace compound activity bound k give specification rename function use denote set belong shall construct rename function st construction may use k proposition every specification activity rename function deterministic every k exist specification rename function st observe every specification deterministic identity function thus follow hold naive proof compound activity let new compound activity name use represent complement let act set activity name consist activity name complement rename function map ie construct follow set possible dags activity name act size bound k obtain root replace root activity name implementation function define follow compound complement subset consist one graph g g two graph one compound replace correspond complement show induction nest depth trace apply theorem infer type correspond query answer combine proposition proposition apply k size obtain algorithm type check target type deterministic show type check deterministic target type next show translate every rename function equivalent set deterministic theorem give rename function exist rename function deterministic proof sketch idea create equivalence class activity name set sub root trace type selective equivalence class may contain map activity name group equivalence class ensure determinism ensure new trace create require member equivalence class indeed implementation equivalent implementation equivalence class finally ensure trace lose consider maximal equivalence class hold detail follow shall use notation graph denote g graph obtain g apply activity name similarly g g set graph denote set obtain apply g g first group together map activity obtain set activity say subset represent single activity map activity map unique activity function guarantee activity appear two different furthermore subset represent single activity subset form activity map represent activity exploit notation denote activity name well subset activity name represent say set equivalence class respect graph g exist graph ga obtain g replace activity name b b b ga new implementation function define follow graph g label activity represent subset g maximal set set equivalence class respect g also respect specific keep fix g atomic activity g require represent maximal set atomic conclude show set stay intact deterministic define immediate corollary follow corollary give p specification rename function target specification rename function problem test p n n resp p decidable proof constructive give type check algorithm may extend algorithm check equality target trace type rather inclusion fairly straightforward manner trace type show problem size trace type proof work reduction problem test know naive trace type open whether algorithm polynomial size input output type exist already know proposition unless algorithm also polynomial size query exist five conclude consider useful query language enhance expressive power facilitate query real life join first extension consider obtain attach nod transitive edge introduce equality condition call join notion embed definition extend naturally account node require nod label equal map nod activity name transitive edge transitive edge equal attach require sequence node label map resp represent word inequality similarly define example query join depict figure eight two transitive edge annotate x join condition x intuitive mean query search contain two one c activity f activity activity f activity st sequence label two form word sequel refer annotate nod transitive edge node path result incorporate node type inference type check straightforward corollary still hold query join node query join path however type inference may longer possible even input naive trace type query test equality path may answer set belong selective illustrate follow theorem theorem also highlight difficulty introduce use transitive query theorem one exist p join path st rename conclude section briefly informally discuss two additional query language namely projection negation first describe consider effect result present previous section projection query projection user interest project match part nod edge mark project part stand case constraint project part must coappear part qualify trace negation query negation pattern nod edge mark negative stand query search trace contain positive portion pattern contain negative part coappear show result type check type inference extend negation projection corollary hold extend well space type inference check support remain outside scope paper six relate work next consider relate work highlight relative query language study use management system allow analyze monitor instance run time query execution trace two three task perform via uniform intuitive graphical query interface whose abstraction case trace analysis present complexity query evaluation study ten three latter work highlight value query optimization knowledge structure query sub trace motivate present work tight connection class type study correspond classical class string graph already mention analogy naive trace type bracket string fourteen trace type parenthesis nineteen selective trace type context free also close connection selective trace type context free graph sixteen nine define use context free graph extension context free string graph include graph nod represent derivation rule allow replace graph simple variant require graph single entry exit nod easy show selective equivalent set graph define however knowledge model area equivalent naive study term query work context free graph concern formal logic specifically first monadic second order logic expressive particular may capture query model nine show theory context free graph decidable however complexity suggest nine nonelementary size query choose restrict yet expressive enough need query language able obtain efficient practical type inference type check order use result first show set give rename function may express know case figure eight query function set selective p n two transitive type inference possible resp selective input output type even join path time complexity case exponential proof sketch first consider part one part two consider p depict figure eight whose dags depict figure eight b assume root activity single implementation graph e two possible consequently n contain internal trace two es follow c include arbitrary number nest e end g activity note p n include trace number nest e one follow c one follow identical easy show set may capture selective trace type require correlation activity distinct part pattern p example contain transitive root node hence transitive edge internal trace match zoom nest next show query transitive nod type inference still possible difference due fact query direct internal trace compound node query match direct internal trace correspond node thus number possible match finite may simply enumerate match select conform join criteria however transitive edge number possible match number dag might exponential hence exponential time complexity join make type inference type check still possible case theorem type check possible semi naive put output type even join path proof sketch first ignore join compute output type pattern without join next compute proof corollary type describe belong require target type conclude show trace type possible check exist result join empty answer type check problem positive exist trace type else type check would decidable whether hold subject ongoing research case even algorithm walk path exist complexity nonelementary size type specification whereas complexity algorithm exponential relate model study area verification mention selective trace type express one however query consider differ expressive power instance graph homomorphism express query language express temporal often use work moreover need verification different best knowledge particular trace type study note query process use formal representation study extensively typically use temporal see eleven twelve seven type check type inference well study functional program complexity derive interaction function type polymorphism point eight analysis valuable query well set complexity derive interaction nest type transitive query type inference type check also consider extensively context analogous query study selection query twenty use tree pattern select interest query twenty show type check perform time complexity equal lower type inference depend consider compare set bear obvious distinction nest dags instead flat tree type check may harder type inference another common class query transformation query input tree twenty show impossibility type inference type check general model work seventeen thirteen consider restrictive transformation model allow type check complexity range nonelementary interest future work examine adaptation correspond restrict transformation query another aspect study query language consider additional information often available name value data may interest formulate practical use data value allow type inference check seven conclusion study paper type inference type check query execution trace model nest dags formally define characterize three common class type naive selective consider respective type inference type check study complexity two query vary expressive power result two main important practical type inference signal class selective trace type ideal type system trace allow flexible description trace well efficient type inference thus believe firm basis study query optimization management hand type check show even limit trace type type check take impossible selective trace type consequently believe check query result likely useful practice eight reference one r k p reps analysis recursive state machine program four two c milo query business process three c milo monitor business process query four v g k projection five business process execution language web service six business process management initiative process query language seven j x fu analyze web service compute ten one eight j crash course query pod nine b monadic logic graph one ten milo query structural behavioral business process eleven l v verifier interactive web twelve l v verification communicate web service pod thirteen j h j b transformation invisible pod fourteen bracket j computer system one fifteen g c r efficient process query thirty two sixteen g graph control rewrite embed seventeen h exact type check polynomial time eighteen z manna temporal logic reactive concurrent nineteen r parenthesis j fourteen three twenty milo type inference query data pod milo v type check pod j c program press oracle process manager twenty quick start tutorial v inference view data pod f dayal business process cockpit introduction theory computation publish company