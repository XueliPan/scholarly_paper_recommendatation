understand transactional memory performance e porter university memory promise generalize transactional program data structure purport benefit easier program correctly lock perform well performance claim always bear application may violate assumption designer external system effect paper carefully study range factor adversely influence transactional memory performance order help assess suitability code transactional memory paper introduce formal model transactional memory well tool call predict conversion lock within stamp also use tool diagnose eliminate starvation pathology kernel improve performance modify paper also present first detail study performance transactional program stamp influence factor outside transactional memory system study include data interaction transactional program architecture memory allocator compiler many factor influence performance transactional program get good performance difficult commonly appreciate introduction transactional memory eleven fourteen promise paradigm simplify concurrent program relieve programmer worry deadlock make easier code correctly however program need correct efficient introduction application negative performance base several experience work transactional memory paper analyze range issue lead performance transactional focus help transition use lock transactional memory make implementation base implicit model application behavior instance design often trade faster commit abort result perform much worse lock many case application data structure reorganize improve transactional performance necessarily obvious upon inspection code thus important tool help diagnose correct performance help characterize tune performance transactional program paper develop validate synchronization characterization formal model transactional memory performance tool base model model start transactional parallel application sample set address read write critical section build model program execution predict performance application use model two key metrics data independence conflict density critical data independence measure likelihood thread access disjoint data conflict density measure many thread likely involve data conflict one occur parallel use lock key use model identify could benefit use invest engineer effort make conversion model approximate useful critical predict performance predict perform well focus time reorganize code critical serialize use work performance model help tune transactional performance require different tune code instance common program walk link list share counter inside critical region reduce transactional performance paper also present case study performance tune kernel version kernel convert use hardware transactional memory study demonstrate often nature tune transactional performance analysis help focus tune effort performance transactional also arise interaction system unrelated portion system instance compiler avoid branch deeply processor dramatically increase conflict rate critical region issue difficult application developer anticipate ultimately issue must resolve better integration implementation rest system stack tool help assess whether code need tune performance problem attributable system effect paper first present data system influence performance transactional program paper discuss effect various factor performance include input size architectural feature standard compiler paper contribute follow one new analytic model predict application per scale two experimental validation analytic model characterize performance stamp suite twenty average error rate three detail case study behavior include architectural effect memory allocator compiler four case study performance tune kernel improve performance modify eight relative unmodified paper describe need transactional memory performance prediction tune tool section paper present novel tool investigate potential transactional memory measure data independence conflict density critical protect lock section next paper validate model set stamp suite section paper present detail case study system effect transactional memory performance section v finally paper apply methodology tool tune performance kernel section section describe implementation detail tool section present relate work section conclude tune transactional performance difficult understand tune transactional performance require different tune concurrent code factor influence performance different tune performance program generally involve identify highly lock break smaller lock data avoid synchronization data structure update nineteen tune hand require reduction conflict memory concurrent write data although know avoid memory conflict process difficult many transactional memory also substantial complicate conversion lock instance use cache coherence either require address set transaction fit cache fall back mutual exclusion mechanism also difficulty isolate roll back effect system call inside transaction many transactional work around limit implementation practice issue make adoption complicate rote replacement lock atomic block give challenge adopt transactional memory predictive performance model help assess whether migration transactional memory worth investment also useful standard profile tool transactional give insight code likely become bottleneck performance convert system meet help assess whether problem lie within application transactional memory implementation show section v many part overall computer system affect performance transactional program transactional memory program community also benefit predictor performance develop standard transactional memory reason performance particular system transaction tune lock tune common optimization program cache attribute number data structure cache attribute save work need update introduce synchronization overhead lock since lock protect data structure already hold data structure update transactional memory however multiple thread update memory location serialize concurrent execution cache attribute particularly prone become bottleneck work waste transaction restart update make late critical section value read early work lose transaction restart increase split counter eliminate counter avoid conflict counter write introduce conflict read value must read provide correct sum counter thus work well update frequently read pointless otherwise link list commonly use generic container simple implement low memory overhead resize link list however pathologically bad transactional memory thread traverse exact pointer path inside critical region pointer update conflict critical walk list despite fact concurrent execution semantically safe b system effect instance transactional program influence program input size hardware architecture operate system sometimes memory allocator compiler subsystem affect performance interplay also responsiveness operate system lead load imbalance failure concurrently schedule transactional thread poor schedule traditional transaction metrics like restart rate improve despite worsen execution time similarly hardware system overflow cache take miss transaction restart fall back path effect often difficult predict code inspection despite seemingly straightforward appearance tune memory access pattern transactional program subtle nonintuitive even simple rule like split counter share thread counter pointless apply rote large complicate system need tool like identify tune best spend model model formalize intuition transactional performance primarily determine number conflict provide basis performance tune tool section explain behind model provide rigorous treatment model predict transactional performance base sample address set dynamic critical parallel execution approach assess likelihood dynamic instance critical conflict heart approach performance transactional memory program hinge number critical section execute concurrently transactional memory generally rely conflict safety condition implement abstract form lock thirty call set address read instance critical section read set set address write write set union read write set address set critical section b conflict b aw informally conflict say write set one critical region must disjoint address set guarantee safety conflict efficient compute use widely transactional memory group critical region data independent write set disjoint address set critical concurrently modify data data transactional memory system serialize execution critical section case transactional memory perform much worse conservative lock due overhead require detect resolve conflict conflict density measure long serial schedule result conflict likely assume conflict among n thread best case single thread might write datum read n one thread low density conflict produce short serialize execution schedule n one commit writer worst case thread write datum write n one thread yield high density conflict necessitate completely sequential schedule thread must run serially one next estimate data independence conflict density critical sample address set select term data conflict data dependence avoid confusion mean sample address set critical could potentially execute concurrently use transactional memory determine conflict process describe detail effectively implementation safety property system sample incorporate dynamic behavior application potential data conflict similar model develop al calculate dependence density application broadly categorize task within program low medium high concurrency dependence density essentially aggregation data independence conflict density experience show decomposition provide valuable insight performance close loop make concrete performance section provide performance tune section section provide additional comparison paper b data independence data independence provide profile likelihood set critical conflict data independence lock formally define mean number thread conflict n thread concurrently execute critical section protect lock data independence function number thread execute concurrently simple mean intuitively one expect probability conflict single thread schedule zero data independence one likelihood conflict increase number thread grow unless thread access completely disjoint data thus calculate data independence n begin sample critical n different thread compare address set sample address set sample determine thread involve conflict keep run mean number data independent thread n c conflict density key metric model density conflict set critical high conflict density prone conflict involve many thread form long serial schedule whereas low density conflict resolve quickly one think conflict form graph critical nod conflict edge density conflict number edge per node intuitively every transaction conflict every one expect execute sequentially mean lower performance transactional memory hand example one thread write memory location read thread complete writer complete result performance gain commonly experience practice scenario would star topology represent graph remove connect node cause become disconnect able proceed concurrently hence model phenomenon crucial accuracy predict performance calculate conflict density sample address set follow address set measure number conflict address set divide one sum term density formally express conflict x x conflict x evaluate one address set x conflict zero otherwise case conflict address set conflict density equal size conflict star topology case equal two predict transactional performance intuition behind approach predict transactional performance performance limit serial schedule must form ensure correctness model conflict density common case n thread concurrently execute set express n use parallel program track acquisition time lock length critical region lock acquire hold well unrelated cycle accord law overall obtain concurrent execution critical section constrain amount time spend section thus term apply cycle spend acquire hold lock leave unrelated cycle unaffected transaction behavior formally calculation become execution time hold one n e like model make certain simplify balance complexity accuracy al four provide analysis performance various hardware transactional memory design experience work implementation common deviation model perform substantially worse lock high contention attribute number factor include restart cost suboptimal policy bus contention ideally transaction restart resolve conflict retry execution soon winner conflict commit high restart cost high may period needle latency winner commit lose transaction resume lower transaction throughput worst case lead conflict new transaction end spectrum policy retry quickly increase contention cache line memory bus degrade fig one performance lock range conflict line illustrate model lose prediction precision correctly identify performance trend high contention due effect system performance goal model generality avoid include model contention vary widely across figure one show execution time simple eight critical write share variable probability probability range zero line cross lock line probability eighty ninety lead deviation accuracy model begin sixty probability dense conflict correctly identify give little performance improvement contention increase predict poorly give perform model might also underestimate performance application execute critical region also highly data independent excellent performance might experience lock contention thread use lock mutually exclude even critical region data independent case accurate prediction may realize drop cycle apply term hold cycle rather apply heuristic weight cycle leave issue future work use approximate prediction model validation section validate model implement module seventeen compare predict performance measure performance model validate model seven stamp version list input table experiment follow section perform model eight sixteen support fix zero five one fifteen two three zero ten twenty thirty forty fifty sixty seventy eighty ninety lock conflict execution time bay genome intruder vacation learn randomly generate network reconstruct gene sequence segment gene emulate network intrusion detection system packet capture reassembly phase implement cluster technique scalable synthetic compact two kernel one construct graph data structure use adjacency auxiliary array implement travel reservation system protect update local implement tree algorithm mesh refinement similar kulkarni al thirteen table description use section v stamp suite twenty include custom input reference compare default section v use one reasonable choice moderate implementation processor set associative private cache line access time one cycle cache also private line cache set associative cache access cost sixteen cycle keep coherent use snoop protocol coherence model implement module main memory single share one access time cycle two set associative entry one data experiment run version use hardware transactional memory model version transactional memory experiment main memory access latency perturb four get accurate performance multithreaded program multithreaded program sensitive schedule several randomly perturb run give accurate picture performance describe wood one present mean four simulate predict stamp apply model program stamp transactional memory suite twenty discuss section use labyrinth experiment due memory leak could resolve table show predict actual execution time parallel phase measure time mean four run standard within five mean except bay variable number standard bay eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen twenty fifty forty fifteen err zero nineteen sixteen forty three thirteen one thirteen thirteen eleven seventeen nineteen fifteen di zero one four thirteen zero zero one ninety genome intruder vacation table execution time second stamp second label project execution time second label accuracy error di data independence value conflict density eight bay data available time submission high execution time geometric mean error across track trend closely poor like intruder good like precision decrease become short particularly run three second less worst case predict scale trend offset factor data independence conflict density prove interest metrics widely vary value across stamp highly data independent intruder bay light conflict density conflict quite dense average nine densely conflict thread per transactional conflict figure two show project representative sample break portion attributable data independence portion attributable low conflict density percent attributable data independence fraction critical conflict rest attributable low conflict density projection figure two one end spectrum entirely due data independence like many transactional critical rarely conflict yield good substantial lock extreme nearly every critical section bay likely conflict least yet measure still substantial relatively thread involve conflict low conflict density key bay similarly high data independence intruder eight sixteen eight sixteen eight sixteen eight sixteen intruder eight sixteen eight sixteen eight sixteen eight sixteen ten err thirteen eleven two one zero zero zero zero fourteen five five ten err zero two two four two one zero zero zero zero zero one zero eight err twelve five four one zero zero zero zero zero five five zero err zero two two three one one zero zero zero zero zero one eight eight four conflict density zero zero one sensitivity data independence conflict density different sample rat ten table slide window reduce critical schedule concurrently due synchronization mechanism join fork without exhaustive schedule model sample address set reduce number address set record improve efficiency tool previous experiment use sample rate highest fidelity data table show data independence conflict density sample rate ten representative sample select omit space within eight exhaustive measurement ten sample rate result within fifteen exhaustive measurement insensitivity sample indicate practical v system influence transaction performance transactional application ought perform well problem may poor interaction full system transactional memory implementation section analyze system effect transactional performance program use seven stamp suite case study input size table compare stamp different input size detail simulation tend slow stamp fig two project select use versus lock decompose portion attributable data independence conflict density data independence moderate count increasingly rely nondense conflict performance improvement higher count show reasonable mix data independence nondense conflict expect case realistic experiment show model strike good balance accuracy complexity model less capture scale trend performance estimate help programmer understand transactional program performance b schedule model sample measure data independence conflict density check conflict critical likely schedule concurrently subsection describe sample critical detect conflict approach respect schedule original execution generalize significantly simplify model record address set critical within slide time window see certain number critical lock sample desire number critical measure data independence conflict density critical schedule together experiment slide window consist critical value select base experimentation different size select address set compare careful select one address set per process calculate data independence conflict density record address set discard limit number address set consider concurrently capture many likely execution schedule simple concurrency model implementation instance newly fork thread execute concurrently critical region occur creation bay genome intruder vacation big big big big big big big eight thirteen fourteen nine eleven seventy thirty sixteen thirty thirteen fourteen nineteen fifty ten fourteen table eleven twelve fifteen twelve fourteen seventy parallel phase selection stamp relative one standard simulator input big input distribute simulator input much smaller simulator input much smaller input program design table make clear simulator input small show accurate scale trend example performance genome simulator input scale input scale law two explain problem even though stamp measure performance parallel part code parallel section still include serial setup setup implicit example os must schedule thread execute parallel section short performance scale simulator input reflect scale realistic input also overhead synchronize barrier towards end grow higher processor count size effect know problem simulation continue impede accurate measurement note compensate brevity simulator input still accurately calculate gain performance author generally omit detail curve generate could verify particular methodology measure simulator input match scale trend input unless otherwise note stamp data paper use big input list table table show detail simulator input resize input important result table common transactional metrics like restart rate average generally poor indicator execution time instance execution time restart rate correlate count increase intruder bay simulator input inversely correlate vacation appreciate transactional memory community lack good performance serious problem must transactional program simple event counter statistics provide insufficient data base performance tune bay genome intruder eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen eight sixteen vacation miss five six eight zero zero zero three three three seven seven eight total miss eight sixteen number percent incur least one miss course execution table v simply reduce restart cycle might affect performance actual dynamics much complicate instance might important reduce latency critical path computation reduce restart occur critical path complexity tune transactional performance motivate us develop model table also show idle time high noticeably higher simulator input load imbalance significantly affect simulator input cause unrealistic amount idle time instance big input one idle time idle time simulate input stamp design minimize system time several still spend ten execution time operate system mostly memory management page fault handle b miss measure miss rat within table v miss common within fact almost every run genome vacation big input take least one miss miss rat simulator input generally lower input touch little data establish miss rate application simulator miss rate match big input three brief critical know miss common transactional program important hardware sun rock processor six report support tolerate miss transaction good fit design like sun rock low big bay genome intruder vacation total thirty fourteen ninety nine four two one one one one zero zero zero zero zero seven five four one one one ten seven five eight ten twelve zero zero zero zero zero one nine seventeen one one two one one two restart thirty zero zero zero zero one back zero one zero five zero zero zero table total sixteen sixteen eighteen thirteen thirteen sixteen sixteen seventeen nineteen twelve twelve eleven twelve thirteen nine fourteen fifteen eight ninety sixty three four two twelve nine ten zero zero zero zero one three six seven six zero one one two one zero twelve nine thirty sixty nine fifteen nineteen restart back thirteen ten thirteen zero zero eight six nine twenty execution time total select stamp use big simulate input break user system idle time restart rate restart mean cycle back miss rate none three critical make function call one critical region contain control flow loop unknown tolerate miss five reload would likely require load sequence run outside context current transaction avoid abort current transaction miss might challenge c memory allocation perform system call include memory allocation within transaction violate isolation memory mostly implement user level sometimes need make system call get memory os either might make system call problem well know several ways allow system call within include open nest transactional pause stamp allocate memory write special hook deal allocation transaction call memory allocator call os memory transaction restart many time leak memory hook compensate action transaction restart labyrinth miss paper pathologically leak complete experience pathological memory leak genome surprisingly memory allocation complete environment actually deadlock recent use block lock protect memory allocator data structure lock implement use system call seven block current thread lock release process release thread wait must trap kernel notify context hardware transaction transactional process acquire lock second block lock transaction hold lock restart hardware release lock variable notify kernel change block thread sleep indefinitely effectively application many standard system write still use lock condition synchronization transactional memory application potentially cause adverse effect discover deadlock behavior vacation often allocate memory within insert new node tree work around problem conservatively memory transaction might need begin transaction ad solution apply program especially presence compose standard library call standard system call within transaction likely require combination new standard os support solution like make single transaction nonspeculative three eight twelve compiler effect final challenge optimize transactional code compiler deeply machine figure three illustrate simple conditional statement programmer would expect reduce conflict access share variable yet code generate always read value memory always write back use condition determine whether update register write back compiler try avoid branch around threshold hold threshold hold threshold hold hold compare threshold conditionally load old value unconditionally store fig three simple code sequence annotate assembly produce simulate file system bottleneck activity squid inn stress instance n one file system simulate development run one instance per processor modify without compile phase parallel use exercise concurrency table lock nineteen size total conflict sample di j state lock two zero zero zero zero thirteen j list lock zero zero zero zero zero table distribution conflict address journal lock well key metrics range show number address involve percentage conflict sample take sixteen average size word di data independence conflict density probability involve asymmetric conflict load store make sense platform hardware transactional memory system however performance lose coherence conflict much lose branch critical section one tool identify data independence flag share variable contention result hint programmer code generate compiler inspect tune tool addition predict performance transactional memory system model provide clue critical section likely performance section demonstrate utility tune transactional performance use kernel case study tune feature provide number useful metrics transactional memory developer data independence conflict density give developer indication much parallelism expect code report distribution conflict address critical region allow developer identify contention also provide statistics size illustrate table help identify critical likely overflow cache finally provide traditional profile metrics frequently execute critical region critical one asymmetric conflict conflict transactional thread know asymmetric conflict introduce performance transactional resolve asymmetric conflict transaction must always restart thread roll back many access occur faster commit starve application performance cause asymmetric conflict difficult diagnose resolve simple profile indicate transaction program spend much time find unrelated code starve transaction asymmetric conflict even good intuition transactional performance tend scrutinize write yet variable read transaction frequently write outside transaction help indicate critical address prone asymmetric conflict implement track read write outside critical check conflict critical critical region report percentage address set conflict address set estimate probability asymmetric conflict next subsection use diagnose correct pathology b case study al report comparable performance lock kernel help performance lock already highly tune several spend relatively little time kernel primary exception show severely pathological behavior reproduce pathology use simple program counter profile indicate time spend code protect lock seven thirteen seven fourteen eighteen ten eight sixteen eight sixteen system time second unmodified optimize version eight sixteen lower better relative higher table better use provide additional insight problem sample critical run unmodified table show distribution conflict address journal lock critical tend word work set respectively relatively high conflict density indicate temporal locality data access within critical one address match initial experience audit journal code find immediately obvious datum cause high transaction restart red flag raise critical probability asymmetric conflict upon review find assertion code bite field set bite use always set enter critical convert moreover bite field use task journal interestingly modify inside transaction intuitive approach look conflict write inside transaction enough need tool help find sort bug large code base address problem convert bite transactional use optimistically fall back lock mutually exclude io acquisition arbitrate contention manager lock fairly critical region use separate bite word cache line depend conflict granularity able eliminate asymmetric conflict starve transaction c experimental result evaluate eight sixteen take describe section simply idle leave undisturbed need set parallel exercise concurrency within file system memory allocator use full suite six paper verify introduce performance sake space report two improve performance list fig four unmodified optimize version unmodified eight sixteen better table perform identically unmodified table present time spend kernel unmodified optimize version respectively kernel time present tune kernel expect improve portion execution time approach eliminate noise introduce load imbalance reproduce pathological behavior month simulate compare thirteen days average unmodified terminate list performance optimization allow complete also improve performance include journal lock affect execution time substantially performance remain flat count performance bottleneck shift journal critical kernel demonstrate introduce performance bite optimization also improve performance relative unmodified eight sixteen show figure four tune programmer intuition simple profile yield marginal ten improvement lead us fix pathology speed fifty case study indicate tune performance transactional memory tricky nonintuitive give critical region dominate execution time entirely different part application face challenge benefit tool help understand system quantitative rigor implementation detail section describe key implementation detail feature tool use performance tune complex kernel section prototype module simulator seventeen generate output implement machine simulator able measure code operate system nearly instrumentation perform use simulator performance transparent minimally affect execution behavior program test model modest enough could implement use binary instrumentation tool pin sixteen virtual machine monitor kernel instrumentation live machine track address set critical region code ignore read write lock lock would remove transactional version application similarly stack address generally private filter stack address avoid conflict due reuse stack address different activation frame need know dynamically allocate lock object contain lock free reallocate treat new lock current implementation information communicate lock many lock include spin lock ensure fairness susceptible load imbalance parallel program transactional memory sophisticate contention management account effect discard idle cycle end gross load imbalance practice one might use without cycle establish range performance prediction finally kernel protect concurrent attempt execute io actually conflict memory address run kernel detect io mark critical perform io annotation ensure critical incorrectly report nonconflicting relate work little publish performance tune transactional program however large body work tool use performance tune concurrent program nine tool similar use system track lock data access pattern different analysis collect information use identify possible data race condition rather data independence conflict density previous work introduce definition data independent critical section tool measure data independence critical paper substantially modify data independence metric practical measurement utility introduce new metric conflict density provide empirical evaluation application prediction tune al provide definition dependence density similar aggregation data independence conflict density focus program apply similar large data set provide coarse classification use result model predict report experience use result model tune measure program close loop generate validate performance model decompose data independence conflict density provide insight tune behavior irregular parallelism kernel ten present framework analytical performance model focus work assess performance impact certain design lazy versus eager conflict detection version management end make certain simplify general behavior length data equally likely conflict ie contention contrast model design help understand particular deviate designer instance many data create contention may tune improve performance several paper thirty discuss transaction conflict behavior context improve best knowledge none paper provide formal model transactional memory performance prior work close loop validate model measure performance memory performance important issue early ninety need tool like eighteen reason performance relate memory behavior parallel unavoidable need tool assist tune performance optimistically synchronize lev discuss necessity challenge tool transactional memory fifteen al introduce atomic block c forty paper distinguish address performance whereas work address correctness al introduce transactional memory instrumentation support performance profile work complementary model provide limit tie specific schedule conclusion paper introduce novel method tool reason performance transactional memory validate performance demonstrate usefulness guide performance tune kernel paper also present detail characterization whole system include architecture compiler affect performance transactional often way befuddle performance tune see one array profile tool must develop help application leverage transactional memory effectively x would like thank anonymous jeff napper helpful comment paper thank help develop tool also thank academic license program research support cise research infrastructure grant career award computer science study group reference one wood variability architectural multithreaded two g validity single processor approach achieve large scale compute three c j e lewis k martin make fast case common uncommon case simple unbounded transactional memory four j k e h l yen hill swift wood performance hardware transactional memory five c click six dice lev early experience commercial hardware transactional memory implementation seven h r russel fuss proceed fast lock symposium eight l v wong b j b k prabhu h c k page transactional memory coherence consistency computer society nine j harrow check multithreaded visual thread spin page ten g analytic framework performance model transactional memory eight eleven j e moss transactional memory architectural support data structure may twelve c e maximum benefit minimal thirteen kulkarni k b walter g k l p chew optimistic parallelism require fourteen j r r transactional memory morgan fifteen lev transactional memory transact sixteen c r r muth h g v j k hazelwood pin build program analysis tool dynamic instrumentation seventeen p j g j f b full system simulation platform computer eighteen analyze memory system bottleneck program nineteen p e exploit defer destruction analysis update operate system thesis health science university twenty c c j c k stamp transactional j j k e l yen hill b swift wood support nest transactional memory j e b moss nest approach reliable distribute compute thesis institute technology j k operate get faster fast hardware summer pant g limit early value communication improve performance transactional memory e g v b use accurate efficient simulation c n dissect transactional transact porter e concurrency warrant optimism optimistic e porter c j benn e operate system h c porter bhandari e transactional memory operate system thirty h e c j e increase concurrency micro c porter h bhandari e use manage transactional memory operate system c j hardware transactional memory perspective thesis university w n l advance contention management dynamic transactional memory referee conflict hardware transactional memory h j tack n swift safe io memory c r c model optimistic concurrency use quantitative dependence analysis l yen j k e h hill swift wood hardware transactional memory cache w efficient detection data race condition via adaptive track c l extend hardware transactional memory support wait action transact forty f program use atomic block transactional memory