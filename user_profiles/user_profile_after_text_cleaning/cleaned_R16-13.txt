code coverage test use hardware performance monitor support janapa department electrical computer engineer university colorado boulder abstract code coverage analysis process find code exercise particular set test input important component development verification traditional implement code coverage analysis tool base program instrumentation typically incur high overhead due insertion execution instrumentation code many sample attempt lower overhead leverage exist hardware performance monitor support program counter sample incur lower level overhead provide complete coverage information paper extend approach two ways first utilize sample branch support modern second compiler analysis perform branch extend amount code coverage information derive sample paper show although generally use guide performance improvement substantial promise leverage information code verification combination sample branch compiler analysis use attain upwards eighty actual code coverage subject engineer test general term verification code coverage test hardware performance monitor permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee five copyright one introduction design increasingly complex process involve issue compatibility conformance functionality performance moreover size rapidly grow thus potential multiply fifteen essential step development process aggressive test one critical characteristic evaluate test process determine amount code execute individual test set test code coverage observation specific code point execute evaluation common metric test twelve eighteen traditional method perform code coverage analysis four nine use program instrumentation instrumentation process insert probe target application track execute program track program assurance correct operation instrumentation generate precise code coverage information disadvantage collection overhead fifty seventeen nevertheless generation test timely fashion important aspect development result shorter development time another class code coverage system utilize exist hardware performance monitor support sample program counter address sample use determine partial code coverage three fourteen although decrease overhead considerably able gather fraction information full instrumentation allow paper examine potential use support modern code coverage analysis modern processor support eight ten sixteen provide sample branch set correlate branch represent path program execution branch naturally provide information single program point furthermore information like branch integrate compiler infrastructure inherent value information dramatically extend use standard analysis example map information compiler control flow graph representation program dominator analysis two guarantee execution additional code block experimental system evaluate use thirteen compiler initial result indicate although figure one partial path creation path extension base dominator analysis figure two dominator b post dominator tree figure one partial path block block add dominator analysis show code coverage provide promise alternative program instrumentation two code coverage section present code coverage analysis framework framework consist two main phase collection phase sample gather analysis phase phase compiler framework branch information program structure loop call know within program representation compiler analysis extend inherent amount information provide increase code coverage result branch execution information experiment paper utilize branch trace buffer register support ten act circular buffer able store instruction target address last four branch execute collectively set branch define branch vector also allow set filter sample branch sample take branch apply instruction range framework configure sample take branch effort collect information per sample since branch automatically track within program branch vector consist take branch indicate information likewise since compiler tend emphasize take improve code locality aggressively optimize likely execute branch periodically sample correspond branch vector store table keep track encounter branch set encounter branch use phase analysis compiler support code coverage first component compiler analysis associate branch partial representation program partial path set basic block know execute give branch vector figure one show example entire process particular branch vector program number branch figure one show four take branch indicate single branch vector sample partial path creation four branch map onto original create partial path show dark shade block partial path six basic block determine branch vector follow section discuss dominator analysis utilize systematically infer block guarantee execute dominator analysis number compiler rely dominator analysis one determine guarantee execution block two commonly analyze dominator dominance basic block dominate basic block v every path entry basic block v contain basic block basic block basic block v every path v exit contain basic block tree information summarize dominance example dominator tree node dominate nod underneath dominator tree figure one show figure two figure two b example apply dominator analysis partial path e g j l n guarantee basic block b p must also execute case execution ten basic block could guarantee collection analysis single branch vector vector four path branch block dominator tree b post dominator path dominator cover eight thirty table one number per actual code coverage number well number actually cover code size vary greatly set range number percentage cover also range greatly eight coverage coverage figure four present code coverage normalize total instruction count show table one would mean code coverage cover actually execute four sample show clock cycle code coverage divide three main single branch branch w dominator analysis single first basic block branch vector use mark cover use simulate single map basic block branch branch map partial basic block path mark cover branch w dominator analysis dominator analysis perform partial mark additional basic block figure four show single leave much desire term code coverage even low sample period cycle highest code coverage percentage barely fifty perform particularly bad around code coverage percentage decrease sample period increase sample branch map back partial substantial increase percentage cover code discover use code coverage sample period coverage percentage increase average fourteen improvement due use branch around thirty dominator analysis significantly extend amount code coverage information show figure four lower sample consistently provide additional code coverage percentage exception improve less ten sample figure three overhead collection branch various sample three experimental evaluation methodology experiment paper perform use set spec compile thirteen research compiler kernel compile base configuration include classical run use data collection tool develop use interface library five seven tool configure collect branch vector sample regular randomize branch vector sample feed module perform code coverage analysis result compare code coverage tool develop pin six result analysis sample overhead main cause contribute overhead incur collect branch first interrupt occur every sample period copy register kernel buffer sample period increase cause overhead increase interrupt happen frequently afterwards data must periodically read kernel buffer process store figure three show effect sample period collection branch sample period vary clock cycle percent overhead average overhead across experimental clearly exist overhead amount information gather use smaller sample period increase number sample therefore quality information provide code coverage analysis however sample period decrease overhead increase coverage explore code coverage data important understand size evaluate well instruction table one show size percent overhead sample period clock cycle figure four code coverage across different sample show effect one use single basic block per sample two use branch create partial three extend partial path information use dominator analysis figure five instruction execution distribution across address range actual b entropy analysis figure five show probability distribution graph code execution determine complete coverage coverage b although sample coverage may miss program behavior instruction execution appear similar however detail analysis assess overall ability code coverage data accurately characterize actual coverage relative entropy divergence eleven define distance two probability distribution function let two discrete probability function relative entropy p respect q define figure six present relative entropy number actual code coverage three sample rat examine result indicate average divergence actual five number relative use quantify deviation complete code coverage figure six entropy divergence coverage result instance divergence sample rat increase indicate sample direct role coverage accuracy divergence smaller code execution footprint effect sample rate result indicate code coverage test deploy variable sample rat maximize code coverage test overhead aggregate multiple run one opportunity improve quality coverage approach aggregate data multiple execution run simply matter collect monitor tool output multiple run apply analysis module figure seven show example aggregate twenty separate run regular sample period clock cycle two general trend show figure seven first significantly improve code coverage percentage ten actually improve twenty case aggregation multiple run seem code code w dom analysis actual distribution b estimate distribution figure seven code coverage percentage aggregate multiple run use regular sample period use b randomize sample period promise see substantial stay fairly level additional run one issue face periodic sample sample possible miss important section code periodically execute time sample randomize sample may use order account sample figure seven b show twenty aggregate run use randomize sample behavior significantly alter however see substantial case random sample able uncover section code regular sample discover four conclusion initial rationale result use system code coverage present overall code coverage show promise since low overhead less three obtain upwards eighty code coverage average fifty several increase code coverage information illustrate use branch compiler analysis random sample use multiple application run considerable amount future work investigate compiler test specifically examine effect code optimization code coverage explore use multiple application create full coverage result study library within approach five reference one aho r j tool aw press two f control flow analysis proceed compiler optimization page three j al continuous profile cycle go symposium operate page four test technology five interface specification technical report laboratory six c l al pin build program analysis tool dynamic instrumentation conference program language design implementation june seven development company project eight user manual nine ten corporation two processor reference manual development optimization may eleven al discrete proceed annual symposium theory compute page press twelve w kim efficient use code coverage development three proceed conference advance study collaborative research page press thirteen compiler fourteen system profiler fifteen n shi j scale regression test large proceed symposium engineer page press sixteen b sprunt four feature micro four page seventeen j k efficient instrumentation code coverage test proceed symposium test analysis eighteen h p v hall j h r may unit test coverage adequacy compute survey four regular aggregate b randomize aggregate