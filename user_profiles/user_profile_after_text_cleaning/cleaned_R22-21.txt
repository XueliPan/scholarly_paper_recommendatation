empirical evaluation high level embed institute compute architecture division university abstract efficient implementation critical many embed application program write c largely focus code generation schedule grow maturity provide diminish return paper evaluate another approach namely high level source source high level apply three instrument average best transformation give factor improvement across certain case find preliminary result justify investigation use high level embed one introduction digital signal process media process performance critical embed demand performance lead development application program hand cod assembly recently cost develop embed system become dominate algorithm development move towards use high level program particular c compute program c much less time consume assembler come price less efficient implementation compare approach nine bridge gap application development time one hand performance much interest compiler technology compiler responsible automatically tune program three fourteen twenty nineteen five work primarily focus efficient code generation schedule low level permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee case one copyright however code generation lesser extent schedule platform specific fact relatively mature diminish rate return increasingly sophisticate approach twenty instance develop particular core optimal majority case thus wish continue increase performance worth consider alternative approach one approach examine high level inherently portable show give performance improvement general purpose twelve yet little work impact embed perhaps due historical approach embed one major difficulty use high level prefer application language c well suit program transformation extensive usage pointer arithmetic thirteen sixteen prevent application well develop array base analysis however previous work eight develop technique transform pointer base program equivalent array base form open opportunity application extensive high level limit work evaluation embed performance six memory space execution time loop unroll investigate ten impact tile power consumption evaluate although power consumption memory size also important issue embed focus work rather focus improve execution time assume fix amount embed memory evaluate impact several high level suite three different embed show select appropriate transformation average improve execution time factor justify investigation high level within embed paper follow section two provide motivate example illustrate application effect high level section three describe three embed investigate follow section four description analysis result section five discuss incorporation high level compiler section six conclude paper zero n zero n zero b zero b one one zero one c zero c one figure three scalar replacement figure one original array traversal zero n c b b c b b figure two conversion explicit array access two example excessive use within program one possible reason prevent adoption high level within exist instance consider example figure one kernel loop n complex although pointer increment access may help compiler address address generation unit thirteen severe impediment program analysis transformation although general array access pointer analysis without intractable fifteen easier find suitable array data dependence problem keep result algorithm applicable program eight develop technique translate restrict class program array base form apply technique figure one code show figure two easier read show three fourteen thirteen program form translate back pointer base program without adversely affect form may apply apply figure three show example loop application seventeen redundant load store elimination via scalar replacement seven give twenty improvement execution time ti three experimental framework paper focus execution time behaviour suite three distinct respect high level briefly describe salient point consider figure four functional block diagram see figure four two float point process pes two internal memory external memory internal memory two block give word code space program memory respectively sequential mode one two pes active mode second always perform first one different data basically vector processor vector size two order mode pes must simultaneously access different data bank ie program data memory via two independent bus switch require special involve overhead see figure five float point processor eighteen cycle issue five order exploit instruction level parallelism data instruction cache respectively speed data transfer sixty program structure select small kernel find typical make extensive use pointer arithmetic investigate select base suite loop array base extensively study area scientific computation select four loop unroll select increase size loop body allow instruction level parallelism expose use transformation show aid native compiler eight tile pad allow cache allow exploitation parallelism finally scalar replacement reduce number access memory automatic tool use develop previous work eight apply manually application transformation level result code use input c release compiler version instrument compiler version performance data collect execute program three four result since interest signal process emphasis focus execution time give fix memory size code size power consumption important beyond scope paper evaluation section examine effect transformation isolation behaviour show figure eleven often help native compiler perform accurate dependence test often benefit transformation see fig nine consistently perform worse variable usually beneficial impact main benefit however enable discuss unroll increase machine variable impact performance loop unroll pointer base n real update program deteriorate performance see fig nine small program benefit total unroll unroll little beneficial effect usually array base program slow loop unroll generally improve performance best array form program best unroll factor consider performance vary respect unroll factor see figure eight unroll increase code size limit amount instruction memory figure five functional block diagram tween processor core external ram achieve highest performance important compiler schedule many possible instruction use cache efficiently figure six functional block diagram instrument contrast two see figure six processor like ti processor two data contain four functional register file sixteen register memory structure block program memory two block data memory access parallel external memory connect via external memory interface select suite eleven contain iterative loop loop loop unroll five six four three four three five six figure seven assembly code generate n real update loop unroll order explain impact unroll low level code generation performance figure seven juxtapose assembly cod generate n real update loop unroll respectively loop body loop inspection perform computation c b show loop body take six also execute arithmetic operation parallel memory operation unroll version however complex code size grow factor although compiler able identify sequential traversal array therefore generate loop fix number use mode memory access also generate unnecessary code increment loop induction variable two repeat load change store index register additionally waste cycle result performance unroll loop far worse loop example show loop unroll even small unroll factor always beneficial especially applicable two functional applicable generally give good performance except two case overhead change mode greater work available see fig nine necessary transformation even though decrease performance applicable four show figure ten aid dependence analysis figure n real update influence eight unroll factor allow loop data overall generally beneficial costly array pad use reduce data cache conflict suitable improve execution time case applicable see loop tile increase cache also improve cod ti although contain data cache effect match work set local memory see fig ten scalar replacement fig eleven generally improve performance ninety pad tile figure ten due pad tile scalar figure eleven due scalar replacement applicable variable two summary result show impact performance however impact always beneficial vary depend machine furthermore consider next section look combine impact performance evaluation figure twelve result select set program architecture maximum achieve set apply show highlight best performance justify fact embed programmer feedback direct compiler system would try several different select best one discuss section five compute product two matrices original program several different analyse apply program subsequent result transform program processor also two memory bank use parallel whereas original program make poor usage available achieve still higher expect four due usage memory bank additional performance gain due improve code generation presence array base code benefit version program loop unroll pad apply successful depend array representation memory access whereas pad require knowledge data layout cache design processor transformation apply already increase performance combination observe loop unroll increase flexibility instruction fill five issue slot since new loop body choose reduce number memory access whereas pad reduce number cache conflict situation similar ti although best performance achieve loop unroll together execution speed double architecture base matrix multiplication algorithm implementation first last iteration inner loop peel originally intend hint compiler create efficient code available avoid otherwise necessary accumulator clear operation loop transformation prevent exploitation parallelism since require alignment array data loop violate take benefit parallel loop unless back regular form however loop unroll apply yield situation different parallelism exploit instruction level rather loop level achieve pad unroll also ti benefit implementation unroll possible example show certain code transformation positive effect one class whereas inhibit successful usage available however result code analyse exist easily transform back loop fusion original form parallelism may exploit program compute matrix product three three matrix three one vector simple loop total loop unroll small loop speed execution factor however interest observation since number odd number cleanup code must generate apply array element artificial void iteration introduce number cycle reduce cleanup overhead avoid achieve total loop unroll either pointer array base version program although loop unroll general increase code size well justify case loop iteration range well loop body small total loop unroll array base code also account possible performance gain architecture smaller fir program implementation finite response filter contain single loop loop amendable loop reversal loop split turn allow one result loop although single loop array unroll pointer array pointer array pointer array dot eighty eighty fir eighty ninety forty real eighty figure nine due unroll architecture ti array array scalar pad one unroll nine array unroll three array pad one unroll five scalar array unroll three array unroll total array unroll total array part array unroll eight array unroll fifteen array scalar array scalar unroll array scalar unroll pointer fir convolution n real update original original array unroll ten array array unroll three n complex update array part array scalar unroll two array scalar dot product original array unroll total n section array scalar array unroll five array part array unroll eleven array unroll seven average maximum figure twelve summary suite unroll eight unroll nine original ten original twenty achieve since loop contain memory access non align array element loop must execute sequentially order overcome restriction possible beyond standard compiler analysis order find upper bind available library function fir filter use reference library function four time fast original program fast loop loop unroll loop give best result unroll result set account achieve smaller ti processor two dimensional finite response filter theory could compiler overly restrictive use loop directive sequential execution mode apply program obtain possible total unroll three small inner loop example loop tile increase locality also improve performance whereas influence array pad negligible version program achieve best performance convert representation allow application array analysis loop unroll program convert back form give overall although rather small example show major advantage possibility apply program analyse could apply program addition possible go back code appear improve overall performance convolution routine perform convolution operation basically small loop two memory access mac operation loop easily execution time reduce original time loop unroll best result similar achieve unroll increase size loop body provide ti compiler increase flexibility instruction schedule reduce number n real update real contain small loop perform n compute statement cab real number loop easily achieve benefit unroll help compiler prove independence different memory access whereas loop unroll increase number loop body therefore give instruction choose try fill five issue slot maximum achievable however maximum rather small due loop unroll code n complex update implement n type c b complex number full fail due overly restrictive compiler still possible take advantage two functional loop split one result loop could achieve prove useful support together loop unroll obtain set without unroll also achieve dot product dot implement computation dot product two two simple loop offer apply unroll three compare original program perform best applicable overhead involve switch sequential mode back benefit obtain parallel process also loop unroll beneficial increase execution time contrast loop unroll either pointer array base program result architecture clearly benefit number loop body instruction schedule ti compiler handle loop well unroll code original program decrease unroll n section implement infinite impulse response filter n section apply program due data dependence loop body however sequential version improve speed factor unroll give best performance experiment less successful due technical program available simulation environment however initial result show small chance achieve kernel least mean square filter program contain two loop benefit loop reversal applicable compiler accept first loop loop overall achieve also architecture benefit loop unroll respectively possible five discussion paper show select appropriate transformation combination lead good performance ever select right transformation much difficult task much work investigate use static analysis determine best transformation eleven approach highly attractive context general purpose compute analysis typically small fraction compilation time transformation selection base static analysis fast unfortunately frequently inaccurate approach approach prove promise actual data use improve selection recently investigate use iterative compilation different select evaluate eventual best perform one select twelve approach much longer compilation time major issue embed use approach compiler automatically find best show figure eleven subject ongoing research six conclusion paper demonstrate usefulness apply high level select appropriate transformation give average across three investigate program consider relatively straightforward future work investigate scope high level potentially greater give empirical evidence justify use high level next step build compiler strategy exploit future work investigate static iterative approach selection consider integration high level low level code selection schedule seven reference one randy compile c parallelization expansion proceed conference program design implementation june two hardware reference three de code generation digital signal dissertation university department electrical engineer june four bacon graham sharp compiler compute compute survey vol issue four five r p synthesis code generation signal process circuit digital signal process vol nine compiler strategy trade code size performance embed tech report seven e r practical data flow framework array reference analysis use proceed conference program design implementation six new eight b compiler transformation explicit array access proceed nine r bier j p evaluation interaction conference signal pacific grove ca ten n j h kim experimental evaluation energy behavior iteration space tile high performance compute zero august eleven j improve cache locality combination loop data vol two twelve combine selection tile size unroll factor use iterative compilation pact parallel compiler technology press thirteen c paulin p address calculation compilation exploration instruction set architecture design conference las fourteen rainer novel code education research conference fifteen l lam effectiveness data dependence analysis international journal parallel program one sixteen digital signal process web site seventeen integrate loop data global pact parallel compiler technology press eighteen nineteen sair w study loop unroll proceed workshop signal process sip twenty van j jess j conflict model instruction schedule code generation core processor v c h methodology proceed signal process technology six f z c e instrument digital signal