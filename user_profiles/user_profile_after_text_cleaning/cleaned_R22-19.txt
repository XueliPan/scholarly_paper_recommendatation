combine program recovery locality analysis c program embed institute compute architecture school university abstract suitable paper develop complete approach space digital signal combine pointer conversion technique new modulo elimination transformation follow combine address resolution approach map array reference without introduce furthermore possess cache structure present transform program exploit remote data locality local memory approach apply suit give average four processor one introduction provide cost effective solution embed require high performance although sophisticate target single seventeen successful reason simple task complex require combination number overcome particular encounter compile namely program idiom use challenge space architecture write c make extensive use pointer arithmetic alone prevent attempt use modulo address prevent standard data dependence analysis also failure paper outline two program recovery translate restrict pointer arithmetic modulo address form memory model globally similar reduce hardware cost support space eliminate need hardware consistency place pressure compiler either generate code mean ensure correct execution paper describe map address resolution technique allow remote data access without need achieve develop mechanism similar use generate space code whilst allow exploit architecture cache structure compiler rely cache exploit temporal reuse remote data large cache line size exploit spatial locality instead space machine rely effective use direct memory access transfer paper describe space specific locality improve upon approach achieve determine location data transform program exploit locality transfer remote data also exploit increase typically available data guarantee location specific require program correctness case machine nine nineteen allow safe incremental approach improve program performance paper develop new combine previous work manner allow first time efficient map standard write c multiple address space embed paper follow section two provide motivate example follow four section notation program recovery data proceed international conference parallel compilation pact three array recovery two remove three original code one b c zero b zero zero pa c zero j zero j j one zero j zero j j two e j f g j eight b c zero b zero pa c zero j zero j j b c j one zero zero three zero seven h j four two e f g h two b c zero j zero j j one b c j zero zero three zero one zero three two e f g h figure one example show program recovery locality section seven provide overall algorithm evaluation approach follow brief review extensive relate work conclude remark two illustrate main point paper two present allow certain separation concern example one demonstrate program recovery use aid later stag example two demonstrate program contain remote access transform ensure correctness wherever possible exploit space memory model example one code figure one box one typical c program write use pointer traversal well know idiom circular buffer access use modulo nonlinear defeat data dependence prevent program recovery scheme first replace array reference base loop modulo access remove apply suitable transformation give new code box two figure one remove pointer arithmetic repeat give code box three new form suitable although new code contain linear array easily code hoist strength reduction standard native example two consider first array recover loop nest box three figure one assume four single address space would simply partition iteration space across four access remote data multiple address space machine however processor location partition data need explicitly available scheme achieve data twenty array form two dimensional array whose inner index correspond four box one figure two show program partition data apply suitable automatically generate loop recovery twenty transformation assume z loop array partition zero zero seven write processor zero one zero seven write processor one similarly array b c space machine need generate separate program processor ie explicitly enumerate processor id loop z example partition code processor zero specify z show figure two box two multiple address space machine require remote data distinct name local thus rename follow zero zero seven become zero seven one zero seven become zero seven processor zero declare variable reside processor declare extern see second third line box three figure two access local remote data local pointer array set processor use original name array pointer array pointer array point assume private copy proceed international conference parallel compilation pact three partition expose id z one one program per processor two four eight b four eight c four eight define z zero z zero z three z zero seven zero three zero seven z b z c four eight b four eight c four eight zero seven zero three zero seven z b z c isolate local remote four introduce load loop five define z zero local c remote zero seven zero zero seven temp c zero seven zero seven zero zero zero seven c zero seven temp local zero seven z z zero seven zero seven z z zero seven zero seven local c remote zero seven three zero seven temp c three zero seven zero seven c three zero seven temp address resolution three define z zero eight local extern eight eight eight four zero seven zero three zero seven z b z c remote access six zero get temp c zero eight zero seven zero zero seven temp zero seven z z zero seven three get temp c zero eight zero seven three zero seven temp figure two example show data transformation address resolution scheme locality apply first loop box three figure one show four distribute array four see box three figure two use original name mean exactly array access form use array box two achieve use property multidimensional array c define contain array program provide code array reference require pointer native compiler know eventual location data must schedule fit external interconnect network bus greater result available straight forward identify local reference replace indirect pointer array access local array name examine value partition indices see equal local processor id z data reference sometimes local sometimes remote isolate index split program section replace local reference local name show box four figure two reference pointer array c occur first last loop reference local transform local name remote access expensive therefore group access remote data via transfer effective method reduce overhead scheme remote data proceed international conference parallel compilation pact three transfer local temporary storage area achieve insert load loop remote reference show box five figure two transfer perform way exploit temporal spatial locality map potentially distinct multidimensional array reference occur throughout program single dimension temporary area reuse show figure two box six three notation describe partition map approach briefly describe notation use loop represent column vector j loop range describe system define polyhedron iteration space b array indices represent describe array index space give ai assume reference array write integer matrix vector thus figure one box three array declaration represent one one zero ie index range zero loop bound represent similar manner subscript simply one zero zero discuss program structure introduce notion computation set q b computation set consist loop bound b either enclose loop nest one two four program recovery section outline two program recovery tech aid later array recovery array recovery consist two main stag first stage determine whether program form amenable conversion consist number check second stage gather information array pointer usage replace pointer reference explicit array access remove pointer arithmetic completely detail see seven pointer arithmetic pointer assignment arithmetic restrict analysis may array element whose subscript affine expression enclose whose base type scalar simple pointer arithmetic assignment also allow prohibit scheme assignment pointer may side effect relation array difficult identify fortunately rarely find program information pointer update capture system solve efficient algorithm seven pointer conversion index array access construct information see loop one figure one box two separate pass pointer access arithmetic replace remove show loop one box three figure one modulo removal modulo address frequently occur idiom program transform program equivalent linear form one exist use transformation framework twenty manipulate extend linear include restrict attention simple modulo form j one reference contain modulo expression complex reference highly unlikely may address extend approach include skew let l least common multiple figure one box one loop two eight four access g h hence l eight apply loop transformation base l loop nest l eight one zero zero zero eight eight apply j new iteration space b j b zero zero one b zero zero one case one zero zero zero eight one three four five proceed international conference parallel compilation pact three apply second loop nest box one figure one new iteration space indices use matrix one zero zero one zero one zero zero zero zero zero one zero zero one zero one zero zero zero zero three seven six give new array indices example figure two p four map transformation define p p nine ten eleven thirteen partition indices sequential indices leave alone example one zero apply index space new index space array bound twelve transform array bound equation one one zero zero one zero one zero one zero zero three seven ie four eight new array also find general without loop introduce array access example figure two would four b four c j four however framework twenty always generate suitable recovery loop transformation case transformation apply enclose loop j j update access matrices array ut one one zero zero one fourteen z result code show figure two box one expose processor id reference without expensive subscript address resolution innermost indices correspond local p single address space give unique name order impact code generation pointer array size p introduce point start address p rename figure two box three show insert array remain array similar detail address resolution see eight loop nest show loop nest two figure one box two new array access find us give new access show second loop box two figure one process repeat modulo remain one modulo expression array h subscript remain second loop box two remove apply transformation give code box three figure one five data parallelism section briefly describe approach scheme partition attempt partition data along align dimension array may evaluate parallel communication sophisticate approach available four beyond scope paper partition base alignment three fifteen try row equal subscript matrix align row determine index partition along construct partition matrix p define pi zero otherwise row identity matrix also construct sequential matrix contain indices partition p example figure two one index partition along therefore p one zero seven eight map partition indices map p approach base twenty explicitly expose processor id critical later stag achieve data proceed international conference parallel compilation pact three six locality analysis straightforward code generate previous section however introduce overhead exploit locality exploit local access greater via external bus hence local node compiler make conservative address location general determine whether array reference entirely local throughout program however partition scheme explicitly incorporate processor id array reference simply check see equal processor id z simple syntactic transformation give array access pointer array name x syntactic concatenation operator x x n j n fifteen apply example figure two box three code box four access statically determine local native compiler locality remote access repeat reference remote data item incur multiple remote access approach determine likely remote transfer data local temporary remote data transfer code transform exploit temporal spatial locality use underlie engine index split first separate local remote reference split iteration space data either local remote processor id explicit framework need array section analysis perform remote reference original loop partition n separate loop nest use index set split q b zero sixteen n one number dimension partition case box three figure two partition one dimension hence n three follow zero z one seventeen z z one three eighteen nineteen give program box four figure two remote data buffer size remote access take place must sufficient storage let storage available remote access simply check remote data fit ie twenty condition meet currently abandon load loop load loop introduce refer exploit locality remote access temporary remote reference introduce follow loop distribution transformation form q single loop nest q distribute k loop nest k one load loop example figure two box five one remote array hence k two transform load loop exploit locality temporal locality load loop correspond invariant access null space access matrix ie n always exist transformation find reduce form transform iteration space invariant innermost remove elimination loop load loop box five figure two invariant remove show box six stride order allow large amount remote data access one go rather separate access per array element must access order achieve simple loop transformation example box five figure two identity transformation access load loop already order distinct remote reference may declare vary dimension yet data storage area set aside access fix therefore temporary array must throughout program reference update accordingly proceed international conference parallel compilation pact three one perform program recovery two parallel determine data partition b partition transform data code c perform address translation apply locality figure three overall algorithm figure five exploitable parallelism seven empirical result overall algorithm show figure three currently multiply loop trip count number check certain threshold continue beyond step two algorithm thirteen compiler evaluate effectiveness scheme two different set sixteen program execute board cluster four share external bus external program compile twenty compiler version full time cycle accurate parallelism detection figure four show set program initially compiler fail program make extensive use pointer arithmetic array show second column however apply array recovery column three program become column four fact program array conversion contain data dependence permit program set recover due complexity fifth column figure four show whether program profitably program comprise small data set size select focus code generation use scale version wherever appropriate figure four exploitable parallelism lut case l transform array access temp temp box five figure two eight one convert form format transfer require start address remote data local memory location store plus amount data store achieve effectively inner loop remove loop body place within call start address remote element give lower bind innermost loop size equal range thus transform remote array access follow um zero um min temporary array access similarly update remove elimination finally replace assignment statement generic transfer call get size give final code box six figure two proceed international conference parallel compilation pact three figure six total small loop dot product perform better execute sequentially due overhead associate parallel execution filter stage two algorithm far concern many program available original form well form wherever possible take program start point impact modulo removal see figure five four program fir convert form scheme modulo removal direct impact ability successfully program three four program could application transformation modulo removal due data although program recovery use largely facilitate performance impact sequential performance well first two set bar figure six seven show original sequential time program recovery three eight benefit transformation whereas single kernel fir experience performance degradation program recovery array recovery enable better data dependence analysis allow schedule case fir small number slight overhead enumerate recovery pointer program give equivalent array form array disproportional effect performance figure seven show impact modulo removal performance since computation modulo comparatively expensive operation removal positively influence performance three program wherever applicable partition address resolution third column set bar figure six seven show effect blindly use space approach without data distribution space machine surprisingly performance universally poor fourth column figure show performance apply data partition map address resolution although program experience sequential version convolution overall performance still disappoint closer inspection generate assembly cod appear compiler distinguish local remote data conservatively assume data remote generate slow access double word instead quad word local data increase memory access latency account produce schedule addition remote memory occur effectively engine final figure six seven show performance locality apply partition code access local proceed international conference parallel compilation pact three figure seven total data make explicit compiler identify local data able generate efficient schedule addition remote memory access group engine case linear achieve program bar one fir number small occur precisely case program recovery give sequential improvement pointer base code overall vary nineteen fir average four overall less dramatic program complex include full greater communication overhead program show average histogram fail give due lack sufficient data parallelism inherent program conversely fir mult large compress filter give due improve sequential performance program loop shorter appear native loop unroll algorithm perform better reduce trip count eight relate work extremely large body work compile good overview find ten compile machine largely focus program language nineteen main challenge insert correctly efficient call program nineteen nine without require complex bookkeeping although compile distribute share memory must incorporate data distribution data locality six one face problem multiple address space benefit extensive work automatic data partition four alignment three fifteen potentially remove need machine reduce memory coherence traffic case work approach examine improve communication performance introduce private copy share data must keep consistent use complex linear memory array access contrast keep copy share data instead use access mean global name data analysis develop nearest communication general communication partition scheme expose processor id eliminate need array section analysis handle general global communication area c eleven work though target space machine modulo recovery c program consider two large highly framework base present solve modulo access however introduce floor div ceiling function effect part program consider proceed international conference parallel compilation pact three large body work develop loop data improve memory access thirteen five one data transformation data tile use improve spatial locality representation allow easy integration loop data far concern twelve interest overall framework describe mechanism detail might take place provide eighteen impact different consider however automatic approach provide fourteen semiautomatic method enable exploration different present however integrate data partition strategy available single address space assume example cod nine conclusion space embed prove challenge compiler due complexity memory model idiomatic program style paper develop integrate approach give average four apply seventeen find suggest cost effective solution high performance embed exploit automatically future work consider form parallelism find integrate reference one lam data computation two f de man transformation nest loop modulo index affine parallel process letter four three three v k p solve alignment use linear algebra four b k automatic data layout use one integer program pact five carr compiler improve data locality six r r cox de n data distribution support distribute share memory seven b array recovery two two eight b address resolution multicore multiple address space appear nine e h unify framework optimize communication program ten r k v compilation parallel parallel compute thirteen eleven hall murphy e lam maximize performance compiler computer twelve j b singh environment design conference thirteen j improve cache locality combination loop data two fourteen h exploit fine parallelism embed program pact fifteen k j g data optimization allocation array reduce communication machine eight two sixteen lee suite seventeen k schedule one eighteen combine parallelization increase adaptability efficiency ninth workshop hunt nineteen j v b broom r fowler g k q advance optimization rice compiler experience one twenty integrate loop data global pact g el parallelization scalable pact communication v c h methodology proceed signal process technology proceed international conference parallel compilation pact three