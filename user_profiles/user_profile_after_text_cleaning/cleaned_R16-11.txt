use redundancy exploit multiple core transient fault tolerance janapa electrical computer engineer colorado boulder computer science colorado boulder elect computer science university abstract transient fault emerge critical concern reliability architectural trend point towards multithreaded multicore design substantial interest adapt parallel hardware transient fault tolerance paper propose multicore alternative transient fault tolerance use redundancy create set redundant process per application process systematically compare process guarantee correct execution redundancy process level allow operate system freely schedule process across available hardware approach transient fault tolerance shift focus ensure correct hardware execution ensure correct execution result ignore many benign fault propagate affect program correctness real prototype run present evaluate fault coverage performance machine provide improve performance exist transient fault tolerance overhead fault detection set optimize one introduction transient fault also know soft emerge critical concern reliability computer four transient fault occur event cosmic particle strike power supply noise device couple cause deposit removal enough charge invert state transistor invert value may propagate error program execution current trend process technology indicate future error rate single transistor remain relatively constant thirteen eighteen number available per chip continue grow exponentially error rate entire chip expect increase dramatically trend indicate ensure correct operation must employ reliability transient fault historically design concern specific compute server machine key system reliability dependability availability memory easily protect code parity protect complex logic within present challenge custom hardware design add additional logic add redundancy cover upwards latch two approach include specialize machine custom hardware redundancy sixteen however directly adopt compute domain compare compute drive different often conflict set factor factor include application specific result transient error difference life death compute faulty execution often less severe instance audio decode playback fault result mere may even notice thus focus reliability shift provide bulletproof system improve reliability meet user failure rat design time cost compute market low cost quick time market paramount design verification new redundant hardware costly may feasible market addition inclusion redundant design may negatively impact design product cycle environment system susceptibility transient fault often unplanned appear design fabrication process example national laboratory document surprisingly high incidence due transient fault deployment q likewise environmental condition system altitude temperature age higher fault rat forty case reliability must augment design development phase without addition new hardware pressure drive compute hardware reliability attractive solution improve reliability face transient fault provide level reliability comparable hardware significantly lower cost zero hardware design cost flexible deployment exist transient fault tolerant approach use compiler insert redundant check computation control flow suffer first execution insert decrease performance slowdown second compiler approach require recompilation inconvenient recompile source code legacy program often unavailable paper present redundancy reliability technique leverage multiple processor core transient fault tolerance create set redundant process per original application process compare output ensure correct execution scale architectural trend towards large machine leverage available hardware parallelism improve performance without additional redundant hardware structure system compute provide alternate method leverage hardware transient fault tolerance addition easily deploy without recompilation underlie operate system paper make follow imply paradigm transient fault tolerance view system layer must execute correctly contrast typical paradigm view system collection hardware must protect differentiate view use commonly accept sphere influence concept demonstrate benefit approach particular show register propagate show many result benign fault many detect fault propagate use approach able ignore many benign fault present transient fault tolerance technique leverage multiple core transient fault tolerance describe real prototype system design evaluate fault coverage performance overall prototype run set suite overhead system rest paper organize follow section two provide background transient fault tolerance section three describe section four show initial result dynamic prototype section five discuss relate work section six conclude paper two background general fault effect system execution follow benign fault transient fault propagate affect correctness application consider benign fault benign fault occur number reason include fault idle functional unit fault instruction ie instruction data mask silent data corruption undetected fault propagate corrupt system output worst case scenario system appear execute correctly silently produce incorrect output detect unrecoverable error due fault detect without possibility recovery consider due split two true due occur fault would propagate incorrect execution detect false due occur benign fault detect fault transient fault system without transient fault tolerance result benign fault true due error detect core dump system detection attempt detect true however system may inadvertently convert benign fault false unnecessarily halt execution finally system detection recovery detect recover fault without form due case fault would false may unwarranted recovery mechanism three approach fault detection sphere replication commonly accept concept describe technique logical domain redundancy specify boundary fault detection containment data enter replicate execution within redundant fault affect correctness detect benign fault safely ignore system detection able reduce incidence false system detection recovery need invoke recovery mechanism fault affect correctness figure one b show example place around user space application use act exactly except act instead hardware input replicate execution within redundant data leave compare operate level model cater technique limit visibility hardware able view fault scope determine effect execution thus approach ignore potential approach redundancy redundancy technique use model transient fault detection show figure one b place around user address space provide redundancy process level replicate application library code global data heap stack file table everything outside namely os must protect mean data enter via system call interface must replicate output data must compare verify correctness provide redundancy process level natural basic abstraction os os view hardware thread core logical processor schedule process available logical leverage os schedule redundant process take advantage hardware massive multicore horizon tremendous amount hardware parallelism available future machine compute throughput primary concern provide way utilize extra hardware transient fault tolerance high level overview show figure two three redundant process minimum number process necessary transient fault detection recovery intercept begin application execution replicate original process create redundant process one process logically label master process label slave process system call system call emulation unit invoke emulation unit perform input replica figure one transient fault detection model form leave output data compare ensure correctness execution outside cover particular transient fault must protect mean fault contain within detect data leave previous work fault tolerance use model view system collection hardware must protect transient fault model place around specific hardware input replicate execution redundant output compare model appropriate awkward apply approach naturally operate different level full visibility hardware nevertheless previous approach attempt imitate example swift place around processor show figure one without ability control duplication hardware swift duplicate instruction level load perform twice input replication computation perform twice replicate input output comparison accomplish check data store instruction prior execute store instruction particular approach work possible emulate processor redundancy redundant however would impossible emulate example alone implement around hardware cache fault detection paradigm system view layer must execute correctly model use place around layer instead hardware key insight fault detection although fault occur hardware level fault matter fault affect correctness change output comparison model shift focus ensure correct hardware execution ensure correct execution result system b figure two overview three redundant process emulate system call output comparison data exit redundant process must compare correctness proceed output data match transient fault detect recovery routine invoke write buffer pass outside must compare also data pass system call parameter consider output event leave must also check verify program correctness emulation unit responsible input replication output comparison system call emulation data transfer input replication output comparison accomplish share memory segment redundant process begin call emulation unit type system call compare ensure redundant process common system call fault assume cause error control flow call errant system call depend upon system call system call emulation unit perform different task system call modify system state file rename link must execute case system call actually call process master process original state redundant process emulate operation example emulate system call open new file master process create open new file redundant process simply open file without create transient fault detection transient fault detect one three ways one output mismatch transient fault propagate incorrect output detect output comparison within emulation unit point data exit two watchdog two watchdog timer time first case fault cause error control flow call errant system call faulty process entrance emulation unit begin wait process process enter emulation unit error detect system call mismatch mismatch data process continue execution occur second case transient fault cause process indefinitely infinite loop case next system call process except process enter emulation unit eventually watchdog output comparison recovery emulation unit also ensure follow maintain order operate correctly execution must transparent system environment redundant process interact system original process execute system call alter system state execute master process actually execute system call slave process emulate system call execution among redundant process must deterministic system call return data request system time must emulate ensure redundant process use data computation redundant process must identical address space data file table time transient fault could render one redundant process useless identical process process logically label master process give invocation emulation unit occasion transient fault program suspend watchdog alarm employ emulation unit detect fault upon entrance system call emulation unit timer begin redundant process enter emulation unit amount time watchdog alarm time signal error execution input replication model dictate data enter must replicate ensure data redundant within case data pass process via system call read file receive master process replicate among slave process also return value system call consider input value copy use across redundant process drawback watchdog alarm period exist application make progress experience unload system twelve second sufficient value user specify increase load system load system spurious affect application correctness unnecessary call recovery unit three program failure finally transient fault may program failure due illegal operation segmentation violation bus error illegal instruction signal set catch correspond signal error flag next time emulation unit call immediately begin recovery process transient fault recovery transient fault recovery typically fit two broad repair fault mask repair involve periodic execution state fault detect execution roll back previous fault mask involve use multiple copy execution vote correct output support type fault recovery repair functionality already exist need use two process detection defer recovery repair mechanism otherwise fault mask accomplish use least three process majority vote fault mask use follow scheme use recovery use assumption three redundant process one output mismatch output data mismatch occur remain process compare ensure correctness output data majority process agree upon value output data assume correct process incorrect data immediately kill replace duplicate correct process use fork system call two watchdog mention section two case watchdog first case faulty process call emulation unit process continue execute one process emulation unit process emulation unit kill recovery occur next system call second case faulty process process except one emulation unit process kill replace duplicate correct process three program failure case program failure incorrect process already dead emulation unit simply replace miss process duplicate one remain process assume single event upset fault model single transient fault occur time however support simultaneous fault simply scale number redundant process majority vote logic vulnerability fault execution code may unrecoverable error also fault cause erroneous branch code could result undefined behavior finally mean protect operate system fault operate system execution may failure first third vulnerability may mitigate compile operate system code fault tolerance fault tolerance vulnerability usually associate fault checker mechanism although completely reliable partial redundancy twelve may sufficient improve reliability enough meet user vendor reliability share memory interrupt hinge upon deterministic behavior among redundant process however share memory interrupt multithreaded introduce potential share memory could support change page trap upon access share memory similar approach use detect code within dynamic code nine interrupt present difficult challenge clear execution point synchronize redundant process hardware support propose previously hardware counter support eight multithreaded require program model ensure memory order replica without support limit execute challenge still open research fault tolerance plan explore support issue four experimental result paper present evaluate prototype build use pin dynamic binary instrumentation system twenty tool use pin dynamically create redundant process use dynamic code patch system program intercept system call compile prototype evaluate run set fault coverage evaluate use fault injection campaign similar one thousand run execute per maintain manageable run time test input use fault analysis run instruction execution count profile application use randomly choose specific invocation instruction fault select instruction random bite select source destination register inject simulate transient error pin tool instrumentation use change random bite specify dynamic execution count instruction utility include within harness use determine correctness program output fault propagation performance evaluation study use reference input performance measure run prototype two three redundant process without fault injection system specifically system four cache memory run red hat enterprise release four fault injection result fault injection study perform illustrate effectiveness well benefit use model fault detection figure three show result fault injection campaign leave bar cluster show fault injection right bar show detect fault possible correct benign fault affect pro gram correctness incorrect program execute completely return correct return code output incorrect abort due program return invalid return code fail due program terminate segmentation violation mismatch occur run case mismatch detect output comparison occur run case signal handler detect program termination watchdog alarm ignore occur infrequently five time able successfully eliminate fail abort incorrect general output comparison detect incorrect abort case turn error detect mismatch case similarly detect fail case turn case occasionally small fraction fail case detect mismatch indicate case able detect mismatch output data failure occur approach effective detect fault base effect execution fault affect correctness generally detect thereby avoid false contrast swift currently advance approach detect roughly seventy correct fault however correct case fault injection remain correct detection model would suggest mainly occur particular show many original correct case fault injection become detect mismatch case inject fault cause output data different data regular run however output difference occur print float point number log file allow certain tolerance float point consider difference within acceptable bound compare raw output detect fault data match issue less effectiveness model relate definition application correctness fault propagation figure four show number execute fault injection detection run show stack bar show breakdown execute fault detect leftmost bar label show mismatch run show figure three middle bar show breakdown run leave bar show detect fault include mismatch general mismatch run tend detect much later point fault injection fault propagation instruction count nearly hand run higher probability detect early across detect run wide variety amount fault propagation range low amount fault propagation even distribution run among various model delay detection fault error certain via program failure incorrect data exit however delay detection also mean fault may remain latent execution unbounded period time future work remain characterize fault propagation well explore bound time fault remain undetected figure three result fault injection campaign leave bar cluster show fault injection right bar show breakdown detect fault figure four distribution number execute injection detection fault normalize run detect via output mismatch program failure combine performance result performance evaluate use two redundant process fault detection three process support recovery figure five show performance compile compiler flag performance normalize native execution time provide transient fault tolerance program average overhead overhead overhead program incur overhead overhead overhead due fact multiple redundant process system program place higher demand result higher overhead optimize stress system higher cache miss rate therefore higher overhead number redundant process increase increase burden place upon system memory controller bus well cache coherency implementation similarly emulation call process increase synchronization semaphore usage share memory may decrease performance certain point system saturate performance severely impact case observe run overhead system resource saturation point explain detail next subsection overhead breakdown performance overhead consist contention overhead emulation overhead show stack bar figure five contention overhead overhead simultaneously run redundant process share memory system bus contention overhead measure run application multiple time independently compare overhead execution single run roughly simulate run redundant process without synchronization emulation rest overhead consider emulation overhead emulation overhead due synchronization system call emulation fault detection incur fault injection detection execute fault injection run figure five overhead run set optimize run include compile b c figure six overhead cache miss rate set contention overhead significantly higher emulation overhead relatively high cache miss rat lead high contention overhead increase memory bus utilization hand substantially utilize emulation unit result high overhead contention overhead contention overhead mainly stem share memory multiple redundant process study effect contention overhead construct program generate memory request periodically miss cache figure six show effect cache miss rate contention overhead run cache miss rate substantial affect contention overhead less ten cache miss per second figure seven overhead system call rate overhead ten point overhead increase greatly fifty overhead forty cache miss per second result indicate total overhead use highly impact cache memory behavior protect transient fault low overhead may suffer high emulation overhead emulation overhead mainly consist synchronization overhead overhead transfer compare data share memory examine aspect emulation overhead two synthetic program design run first program call time system call rate time one simpler system call support use measure emulation overhead barrier within emulation unit second test program call write system call ten time second write user cache cache emulation unit unit call per pi bite check explore follow propagation fault attempt detect fault affect program behavior model accomplish task scale approach similar body fault tolerant work explore use fault tolerance six eight seven body work target hard fault hardware power assume execution thirty processor stop event failure transient fault assumption hold far know provide first performance evaluation overhead breakdown use redundant process multiple core number previous approach program replication program three use three different application tolerate use time redundant technique execute application multiple time use majority vote one virtual duplex combine program ten nineteen tandem nonstop cyclone sixteen custom system design use process transaction process chameleon seventeen infrastructure design distribute use various armor process similar process implement adaptive fault tolerance diehard five propose use machine tolerate memory shadow profile use process program instrumentation six conclusion paper motivate necessity transient fault tolerance propose redundancy attractive alternative emerge multicore provide redundancy process level leverage os freely schedule process available hardware addition deploy without application operate system underlie hardware real prototype support present evaluate fault coverage performance fault injection experiment prove fault detection model effectively detect fault safely ignore benign fault experimental result show run optimize set machine provide fault detection overhead performance improve upon exist transient fault take step towards enable fault tolerant comparable hardware figure eight overhead data specify number per system call write system call force emulation unit transfer compare write data share memory figure seven show effect synchronization overhead synchronization overhead minimal emulation unit call per second less five overhead use two three redundant process afterward emulation overhead increase quickly overall result indicate technique might best deploy specific application without system call functionality figure eight illustrate effect write data emulation overhead experiment evaluate amount data system call must compare redundant process write data similar system call synchronization achieve low overhead cutoff point case experimental machine evaluate overhead minimal write data rate stay less per second increase substantially point five relate work similar version hardware transient fault tolerance eleven however aim provide functionality wang propose compiler infrastructure redundant achieve nineteen overhead addition special hardware communication queue attain similar overhead rely fact multiple exist addition require source code operate executable fourteen fifteen explore placement within scheme explicitly check control flow execution approach provide different model transient fault tolerance use equivalent commonly accept model data write write per seven author would like thank anonymous rest architecture research group insightful comment helpful discussion work fund corporation reference one j j p j experimental evaluation execution application two h al fifth generation proceed conference design three approach engineer eleven twelve four r c soft commercial semiconductor technology overview scale trend reliability physics tutorial note reliability page eleven five e berger b g diehard probabilistic mem ory safety unsafe six borg w w f w fault tolerance computer seven one seven c system international transparent conference compute eight c f b schneider fault tolerance nine maintain consistency bound capacity code cache proceed international symposium code generation optimization march ten k b hardware fault diagnosis diverse proceed conference diagnostics eleven al recovery chip twelve n opportunistic transient fault detection thirteen al impact scale error rat logic process technology digest technical paper fourteen hiller executable detect data embed control fifteen hiller al placement detection data sixteen r w horst al multiple instruction issue non stop cyclone processor seventeen z r k k chameleon infrastructure adaptive fault tolerance parallel distribute ten six eighteen al scale trend cosmic ray induce soft static latch beyond eighteen circuit digest technical paper nineteen dynamic double virtual duplex approach proceed work conference dependable compute critical twenty al pin build program anal tool dynamic instrumentation e al predict number fatal soft national laboratory q device reliability five three v j r v peri shadow profile hide instrumentation cost parallelism proceed al detail design evaluation redundant p r p harry p somersault technical report white paper alto n oh al check reliability march n oh al error detection duplicate reliability march k z metrics strategic placement proceed international symposium pacific rim dependable compute r k k transient fault via simultaneous g reis al swift implement fault tolerance thirty r f b schneider approach design compute compute one three august j p p k experimental evaluation two concurrent error detection scheme proceed j al de sign micro k z purser e improve performance fault tolerance n k cheng pro fault recovery use simultaneous c wang h kim v redundant transient fault detection proceed n wang al come fork road take pact c weaver al reduce soft error rate j h al sift design analysis computer aircraft control proceed ten redundant primary flight computer proceed conference volume one page forty j al experiment soft fail computer electronics journal research development forty one