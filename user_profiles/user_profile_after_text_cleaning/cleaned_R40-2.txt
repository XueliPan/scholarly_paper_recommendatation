make nest parallel practical use lightweight hardware support computer laboratory university abstract transactional memory simplify parallel program support parallel task execute atomic isolate way achieve best possible performance must support nest parallelism available support popular program model recent paper propose support nest parallelism hardware however propose design still impractical either introduce excessive require complex hardware structure paper present nest extend hybrid base hardware provide practical support nest parallel design hardware filter provide continuous conflict detection effectively eliminate excessive nest contrast full approach simplify hardware nest parallel cache use hardware filter also describe subtle correctness liven issue exist quantify performance use stamp use concurrent data structure first demonstrate overhead small average use parallelism second show incremental performance overhead reasonable available parallelism use nest level also demonstrate nest parallel run significantly faster nest finally show nest parallelism use improve overall performance transactional subject program concurrent program parallel program processor parallel permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten june japan copyright general term design performance transactional memory nest parallelism parallel program one introduction transactional memory eleven propose promise solution simplify parallel program simply declare parallel task appear execute atomic isolate way manage concurrency control among concurrent large number propose base hardware nine thirteen eight ten seventeen hybrid six seven sixteen date assume sequential execution code within however parallel often include nest parallelism various form include nest parallel loop call parallel recursive function call nineteen achieve best possible performance increase number core critical fully exploit parallelism available level several popular program model use already incorporate nest parallelism one eighteen extend efficiently support case nest parallelism recent paper investigate semantics concurrent nest propose prototype fifteen compatible exist multicore chip already suffer excessive even parallelism six make problem worse support nest parallelism solely may introduce additional performance due use complicate data structure two four use algorithm whose time complexity proportional nest depth three example show performance evaluation transactional version tree run nest sequential version nest parallel remain impractical unless performance issue successfully address recent paper investigate support nest parallelism twenty however support nest parallelism solely hardware may drastically increase hardware complexity require intrusive cache instance apart additional transactional tag design propose twenty require cache capable maintain multiple block tag different version provide logic merge speculative data ways give current trend hardware company reluctant introduce complicate hardware implement transactional functionality even parallelism approach unlikely adopt address problem propose nest transactional memory provide practical support nest parallel use hardware filter extend hybrid six implement conflict detection data since hardware filter provide continuous conflict detection effectively reduce excessive nest contrast full approach simplify hardware nest cache result make nest parallel practical term performance implementation cost specific work propose hybrid system support nest parallel low provide eager data conflict detection granularity across nest parallel describe subtle correctness liven issue problem exist also propose address quantify performance across multiple use first demonstrate overhead small use parallelism specifically hybrid average run stamp second show incremental overhead nest reasonable also show nest run significantly faster nest finally demonstrate improve performance transactional use nest parallelism rest paper organize follow section two review semantics concurrent nest section three present section four discuss subtle correctness liven issue section five quantify performance section six review relate work section seven conclude paper two background semantics concurrent nest discuss concurrent nest three refer two fourteen additional transaction assign transaction id tid positive integer concurrent tid root transaction tid zero represent state system whose parent root transaction follow semantics fourteen assume transaction perform transactional concurrently live finally family transaction define union transactional semantics memory object l l define set active l l define similarly access l follow two case conflict read l conflict exist zero zero l zero six zero field tid act bite set description tid bite vector encode family correspond transaction belong family tid transaction conflict read signature write signature set pending abort set active set bite outgo memory request set table one state information store denote transaction map write l conflict exist zero zero l l zero six zero commit transaction transaction read merge parent otherwise ie value write become visible transaction abort change make discard previous state restore fourteen use three proxy support concurrent nest open research issue formally check correctness liven guarantee nest use investigate performance hybrid nest provide brief description refer three additional information three extend eager variant eight support concurrent nest use global version clock establish memory word associate lock simultaneously encode version owner information transactional extend implement conflict detection data since transactional functionality solely implement introduce substantial nest one critical performance bottleneck repeat validation memory object must repeatedly validate across different nest level three since performance overhead increase linearly nest depth limit improve performance two three furthermore complicate impact performance even quantify section hybrid start point use hybrid follow design use hardware conservatively track read transaction hardware provide fast conflict detection granularity snoop coherence message data implement use choose eager avoid lazy higher nest since update buffer write buffer lazy nest must examine parent write buffer handle read follow speculative write access expensive must synchronize change parent write buffer sibling transaction commit message description content merge read signature destination packet merge write signature destination packet set bite destination correspond bite set packet reset bite destination correspond bite set packet table two message use instruction description reset state signature active insert address register signature active signature active look coherence message configure signature active conflict request type register send exclusive load request address register network send request destination tid register network tid value active register get value active register bite active entry associate tid register send request destination tid register network increase nest level allocate one set active decrease release current active set one active table three message also assume coherence message include additional field tid encode transactional information transaction generate message filter consist fix number transactional block summarize state information map correspond processor number filter limit number map processor without need nest depth overflow currently rely switch back nest three four fifteen subsume ie serialize flatten nest avoid increase hardware complexity leave hardware depth future work table one summarize state information store discuss field use describe later table two summarize message message use commit remotely merge parent sag use nest remotely update ancestor note every message intercept filter thus need modify cache message table three summarize use manipulate filter use manipulate tid active outgo memory request associate tid use update transactional hierarchy information use switch nest transaction execute core parent run provide detail describe algorithm section figure two illustrate receive coherence message receive message match destination tid figure two perform request operation receive request figure two b request request address contain write signature request transaction figure one overall architecture require memory hold speculative value three design overview hybrid support parallelism therefore support concurrent nest hardware must extend provide conflict detection retain multiple transactional per processor core must extend implement data handle liven issue nest section present design implement nest parallel manner keep hardware complexity low also provide qualitative performance analysis hardware figure one show overall architecture processor hardware filter filter connect interconnection network snoop coherence message request access negative request assume underlie coherence protocol provide mechanism filter may handle propagate incoming message associate cache depend cache filter request b request figure three example execution simple program transaction tid log transaction parent lock bool doom bool active abort figure four transaction maintain implement use list provide eager pointer parent transaction access parent necessary transaction maintain synchronize concurrent access additional field doom active abort discuss later one two present al summarize key function make barrier check whether doom ancestor return failure initiate recursive abort provide forward progress otherwise start transaction initialize note bite set ensure conflict memory access transaction correctly handle barrier insert address read signature attempt read correspond memory object load request successful read barrier return memory value otherwise processor interrupt program control transfer abort handler initiate abort barrier insert address write signature send exclusive load request address interconnection network use instruction table three request fail filter interrupt processor abort transaction otherwise transaction insert current memory value update memory object barrier first reset bite active handle deadlock issue discuss section doom transaction hierarchy transaction could also check doom three possible scheme check doom always periodic never always periodic scheme introduce overhead increase linearly nest depth never periodic scheme admit execution scenario nest transaction keep run temporarily even ancestor already doom performance evaluation section five perform experiment design implement never scheme c request figure two belong family note request bite message reset discuss section otherwise transfer request associate cache receive request figure two c request satisfy condition request address contain read signature write signature follow two case consider first request family propagate request associate cache without abort transaction otherwise set bite eventually abort transaction disable read signature prevent repeat abort reset bite avoid deadlock section figure three illustrate example execution simple program run child transaction run step zero two perform transactional memory access x step three send exclusive load request prior update since request family filter zero simply propagate request associate cache without abort hand since request family conflict filter one interrupt abort exclusive load request successful therefore acquire exclusive ownership cache line hold proceed execution figure four present transaction data structure summarize transactional transaction track perform hit hit hit family three x interconnection st st one program one procedure self two p three p six nil p false four five six true p return return failure self seven procedure self eight nine ten eleven false twelve true thirteen fourteen fifteen sixteen return success seventeen procedure self eighteen nineteen twenty memory return procedure self data memory memory data return procedure self thirty period period one x self x false true else self algorithm one algorithm abort otherwise transaction finish commit simply reset nest transaction merge read signature parent send message nest transaction detect potential conflict receive parent message receive parent transaction disable read signature parent detect subsequent conflict behalf transaction transaction merge write signature send message parent merge transaction must acquire parent avoid data race reduce execution time critical section merge link instead copy finally transaction finish commit reset transactional barrier restore speculatively write memory value reset transactional include write signature perform contention management exponential transaction restart restore interrupt handler call processor interrupt due conflict handle liven issue discuss section abort transaction periodically doom set doom variable transaction currently inactive ie live set doom variable defer actual abort become active otherwise transaction initiate abort self self self false self self self else one procedure self two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen zero nineteen return twenty procedure self memory one thirty false algorithm two algorithm barrier one read one write commit w one one one r one w one one table four symbolic comparison time complexity eager eager r w denote size size nest depth respectively qualitative performance analysis table four present symbolic comparison time complexity nest note discuss perform eager assume maintain data structure use fast ancestor relationship check time complexity read barrier one two time complexity write barrier high transaction validate update memory object contrast still one complexity commit barrier one commit simply reset complexity check doom w complexity commit transaction validate release lock slightly higher complexity check doom apart time complexity three performance issue first nest ex assume check doom read write assume initially run zero begin one st two three four five six seven eight nine abort run begin x cache miss end start begin x cache hit end observe figure five problem due unexpected cache hit temporal locality access nest transaction commit merge parent hence temporal locality lose new nest transaction start core second large number child commit time contention parent may degrade performance finally extra code send message network nest commit check doom may introduce additional quantify performance impact section five four nest section discuss subtle correctness liven issue encounter develop dirty read problem key assumption guarantee correctness transactional memory access conflict cause cache miss filter snoop conflict request correctly resolve presence nest parallel however assumption may hold thread carelessly schedule figure five illustrate dirty read problem may occur assumption hold step one attempt write x cache acquire exclusive ownership line hold x correspond line cache invalidate step three attempt read x access cause cache miss due prior invalidation since belong family request therefore cache line hold x cache share state commit another thread schedule execute step seven attempt read x access conflict due unexpected cache hit step eight successfully commit even read value speculatively write incorrect solution root problem unexpected cache hit occur transaction figure five run processor nest transaction run ancestor quiesce yet address problem without require complex hardware rely approach number available system less number thread application thread pin thread figure six scenario avoid eventual rollback outer transaction atomic fork work mem access potentially tid set tid figure seven scenario cause carelessly enforce strong isolation dedicate number large enough thread attempt schedule thread processor transaction whose family quiesce run processor thread map thread processor thread start transaction may defer execution family transaction quiesce invalidate private cache prevent unexpected cache hit leave exhaustive exploration approach future work problem nest transaction detect conflict abort restart instead abort avoid unnecessary performance penalty however potentially figure six illustrate example nest abort restart none make forward progress memory object still crosswise lock solution address problem nest transaction periodically doom execute line thirty algorithm one specifically detect conflict record tid conflict transaction use transaction periodically doom every ancestor ancestor conflict transaction instance figure six abort doom parent ancestor however doom ancestor carelessly doom cause self transaction make forward progress abort even without conflict transaction deadlock problem line provide strong isolation transaction isolate memory access twelve however carelessly enforce strong isolation various deadlock issue due inexact nature figure seven eight illustrate potential deadlock figure seven memory access performance evaluation section five assume number available less number thread st st run zero begin one two three four access x five progress run begin x access progress figure eight deadlock scenario cause carelessly enforce strong isolation feature cache network cache main memory filter description core line private associative one cycle latency bus split protocol arbitration latency six cycle line share associative ten cycle latency cycle latency eight outstanding transfer four per filter per signature register hash function report six table five simulate system tid set potentially generate false positive write signature reactivate finish create cycle dependency graph thus self deadlock occur note deadlock occur even hybrid figure eight illustrate another deadlock scenario abort access memory x crosswise manner attempt restore memory object potentially deadlock memory access due false write solution address problem enforce follow two rule first default every memory request associate tid zero root transaction since definition root transaction belong family every transaction filter respond request tid zero strong isolation desire explicitly enable associate memory access nonzero tid use instruction table three second every memory request commit abort transaction reset bite filter memory request even hit write five evaluation methodology use simulator multicore table five summarize main architectural processor model assume ten except access memory generate message interconnection network however time detail memory hierarchy model include contention queue performance evaluation aim answer follow three question performance overhead use parallelism performance overhead available parallelism one two four eight sixteen g fifty forty eighteen zero k nine five ten fifteen thirteen l one two nineteen twenty thirteen v five eight ten sixteen three eight four three four eleven thirteen eighteen eighteen table six normalize performance difference relative stamp g k l v indicate genome intruder labyrinth vacation respectively rightmost column bottommost row present average value exploit nest level exploit nest parallelism improve transactional application performance use seven eight stamp five except bay behavior may make difficult compare result across different use two base concurrent hash table tree use use multiple tree provide additional detail later section overhead parallelism table six show performance use stamp use summarize normalize performance difference define n p show table six average across thread count small include extra code performance impact infrequently execute compare understand exact show execution time figure nine nine b execution time application normalize one one figure nine sixteen thread figure nine b execution time break busy useful cache miss start overhead read write abort time spend abort commit overhead work imbalance one thread figure nine relatively high small use account significant portion execution time intruder five overhead due extra code fully amortize small contrast use labyrinth vacation performance difference become small observe similar performance trend sixteen thread figure nine b except several spend portion time abort overhead nest quantify incremental overhead available parallelism use nest level use two perform concurrent hash table bucket tree perform insert read perform insert read transaction one thread b sixteen thread figure nine execution time stamp f indicate b hybrid figure ten execution time various nest level perform eight four four flat use push available parallelism enclose code big outer transaction implement repeatedly add outer note flat nest different transactional semantics ie perform atomically compare investigate nest figure ten eleven provide execution time normalize sequential version figure ten eleven present result figure ten b eleven b show result apart segment bar contain additional segment time spend acquire parent time spend commit aim answer follow three incremental performance overhead nest parallel much faster nest run nest par much computational require amortize overhead nest figure ten b eleven b show continue scale sixteen thread sixteen thread faster sequential version sixteen thread limit conflict among nest figure ten b eleven b also reveal three performance issue first overhead write barrier become expensive run nest due cache miss cause access since nest transaction merge parent temporal locality lose access however since write relatively infrequent compare read performance impact second performance degrade due contention parent large number nest simultaneously attempt commit nest rarely conflict even sixteen thread time flat time flat time concurrent thread time concurrent thread b hybrid figure eleven execution time various nest level figure ten b therefore many child simultaneously commit contention contrast conflict among nest relatively frequent sixteen thread figure eleven b thus performance impact contention small finally extra code may introduce additional however since amortize use reasonably large performance impact critical figure ten ten b also figure eleven eleven b demonstrate significantly outperform execute nest example sixteen thread run faster performance improvement achieve address two critical performance issue first eliminate repeat validation since repeatedly validate memory object across different nest level suffer excessive linearly increase nest depth hand since hardware filter continuously provide conflict detection suffer performance pathology second performance read barrier almost unaffected run nest whereas performance read barrier drastically degrade mainly due cache miss access since commit merge parent exploit temporal locality access contrast since replace hardware suffer performance pathology investigate much computational require amortize nest end compare performance nest flat version vary size computational within figure twelve present normalize performance difference sixteen thread little work high extra nest amortize contrast even little work nest per figure twelve performance sensitivity size form comparably flat version introduce reasonable nest furthermore nest depth increase require even amortize hand performance nest almost unaffected nest depth require extra nest improve performance use nest parallelism operate data structure consist multiple tree perform two type data structure look read insert insert tree insert often modify tree global manner cause many abort ratio insert operation atomically access tree data structure within transaction access tree execute computational whose size also exploit parallelism two ways one flat parallelism outer level ie two nest time concurrent thread time concurrent thread flat size low contention small b low contention medium c low contention large medium contention small e medium contention medium f medium contention large g high contention small h high contention medium high contention large figure thirteen parallelism level ie percentage insert high flat version limit due frequent conflict among perform experiment vary two degree contention size computational low medium high contention case one five ten insert small medium large case computational iterate loop respectively addition perform access eight tree atomically figure thirteen demonstrate flat version significantly outperform nest version low contention small performance difference result sufficient parallelism ie low contention effectively exploit flat version unamortized ie small nest version nest contrast nest version greatly outperform flat version high contention large nest version effectively exploit parallelism available level sufficiently amortize use large hand flat version mainly limit due frequent conflict among six relate work moss propose reference model concurrent nest fourteen base propose model recent paper investigate nest parallelism fifteen compatible exist multicore chip approach may introduce excessive due use complicate data structure two four use algorithm whose time complexity proportional nest depth three limit practicality work differ aim eliminate substantial nest use hardware acceleration propose support nest parallelism within twenty insightful propose design drastically increase hardware complexity intrusively modify hardware cache implement conflict detection data contrast simplify hardware transactional functionality cache use hardware filter seventy concurrent concurrent concurrent concurrent concurrent concurrent concurrent concurrent concurrent thread seven conclusion paper present hybrid provide practical support nest parallel use hardware filter effectively eliminate excessive nest use lightweight hardware support simplify hardware nest parallel hardware cache performance evaluation show incur small overhead parallelism use also demonstrate nest perform comparably run significantly faster nest finally show nest parallelism improve performance transactional would like thank anonymous feedback also want thank sun make code available support scholarship graduate fellowship work support award number pervasive parallelism lab research center eight reference one application program interface specification version thirty may two k j j nest parallelism transactional memory eight proceed symposium practice parallel program page new york three w n c k implement evaluate nest parallel transactional memory symposium parallelism june four j p r leverage parallel nest transactional memory ten proceed symposium practice parallel program page new york five c j c k stamp transactional eight proceed international symposium characterization six c j n j c k effective hybrid transactional memory system strong isolation guarantee proceed annual international symposium computer architecture june seven p lev v hybrid transactional memory proceed international conference architectural support program operate eight dice n transactional lock disc six proceed international symposium distribute compute march nine l v wong b j b k prabhu h c k transactional memory coherence consistency proceed international symposium computer architecture page june ten k language support lightweight three proceed annual conference program page press eleven j e b moss transactional memory architectural support data structure proceed international symposium computer architecture page twelve j r transactional memory morgan synthesis series thirteen k e j j hill wood transactional memory international conference computer architecture fourteen j e b moss nest transactional memory model preliminary architecture sketch workshop synchronization concurrency university fifteen h e e road sibling fourth workshop transactional compute transact nine sixteen b q architectural support transactional memory micro six proceed international symposium seventeen b ar r l c b high performance transactional memory system multicore six proceed symposium practice parallel program new york march press eighteen group institute technology laboratory computer science reference manual nineteen k performance evaluation nest parallelism zero scalable page twenty n intelligent speculation thesis university h ar x r design implementation nest parallelism transactional memory