international workshop embed fast data assignment dual memory bank university school institute compute architecture abstract due stream nature memory critical digital signal process accommodate digital signal typically equip dual memory bank enable simultaneous access two data partition appropriately fully compiler integrate approach data partition memory bank assignment however find little acceptance partly due inflexibility inability cope certain manual data due io paper present different flexible approach namely dual memory assignment code generation target c language extension widely support industrial c additionally present novel partition algorithm base soft colour efficient scalable currently know best integer linear program algorithm whilst achieve competitive code quality evaluate scheme achieve thirteen one introduction digital signal domain specific embed digital signal process demand high performance low power low cost lead development many nonstandard feature expose programmer recent trend towards complex signal process program particular c become viable alternative predominant assembly cod days however come price efficiency compare approach six c compiler technology play key role enable program many newly develop approach code generation four specific code twelve instruction schedule seventeen transition research product development production situation however different compile target one distinctive feature dual memory bank design enable simultaneous fetch two operation require careful partition map data unfold full potential dual memory bank concept find active interest academic community work seem find way production instead specific language iso c language two embed c nine shift responsibility data partition map programmer widely embrace industry believe partly due fact fully compiler integrate approach memory bank assignment ignore require control map certain example use io buffer tie specific bank additionally would frequently like specify partial map achieve certain effect particular code leave rest compiler knowledge none previously publish memory bank assignment scheme allow level interaction follow different approach namely explicit memory bank assignment transformation operate iso c input language generate output next inherent portability advantage approach ease manual ie coerce specific bank accomplish hand approach like one present paper need address difficulty cope unpredictable later code generation stag may interact bank assignment international workshop embed v l f f l f l f l g n n p e x p e c e f l p f l c e f f c e n v r b l e e c l r n e sum zero zero f zero sum n p c e f f c e n p zero sum e r r e x p e c e zero f zero c e f f c e n n p e r r sum one g n c e f f c e n one c e f f c e n n p one two e r r figure one function four memory bank result different execution time paper model possible extend variable interference graph introduce fifteen edge effectively introduce uncertainty model also help balance memory bank previous approach thirteen seven aim generate partition show optimal solution accord standard interference graph model necessarily result program practice exhaustively enumerate legal memory bank set demonstrate room optimal b different equally optimal standard model may result greatly different actual performance finally replace expensive integer linear program base algorithm thirteen efficient scalable stochastic soft colour algorithm compiler efficiency improve demonstrate achievable code quality highly competitive eleven motivation efficient memory bank performance impact difficult determine instance consider example figure one show function eight one function five allocate two different bank local stack allocate outside scope explicit memory bank assignment right side figure one four possible legal show first case illustrate figure one data place x memory bank default case many explicit memory bank assignment specify clearly advantage dual memory bank take assignment result execution time cycle platform best possible assignment show figure one b input gain place x memory output expect coefficient memory simultaneous access input coefficient array enable consequently assignment reduce execution time cycle interestingly equivalent assignment scheme show figure one c simply swap assignment two memory bank perform well fact invert scheme derive best assignment result execution time cycle slowdown worst possible assignment scheme show figure one still input coefficient place different bank enable parallel load scheme take cycle execute slowdown example demonstrate difficult find best memory bank assignment approach analyse code generation effect occur later compile chain must operate model generic enough cover paper propose refine variable interference graph construction together fast scalable soft colour algorithm capable handle complex allow partial require rest paper structure follow section two discuss large body relate work relevant background material explain section three memory bank assignment scheme introduce section four two different colour describe section five six present result section seven finally conclude section eight international workshop embed two relate work early attempt solve dual memory bank assignment problem undertake al fifteen produce solution perform greedy partition use depth interference priority heuristic problem formulate interference graph two nod interfere represent potentially parallel access basic block intuitive representation problem use many since al use genetic algorithm provide solution dual memory bank assignment eight use constraint satisfaction problem model hard able exceed memory capacity soft want interfere memory genetic algorithm use find optimal result term model due technical however method evaluate randomly generate synthetic another approach ko use synchronous data flow simple conflict graph accompany program three propose traditional colour algorithm integer linear program base algorithm low complexity greedy heuristic use variable size priority metric though evaluate exist demonstrate work hard describe integer linear program solution thirteen prior ko ten describe work level compiler technique run compiler generate object code let us consider spill code ignore access reach memory assignment problem model interference graph two interfere basic block dependence interference weight accord number potentially parallel memory access recently al describe accurate integer linear program model memory assignment seven model describe considerably complicate one previously present thirteen provide evaluate use different base however two use sufficiently similar comparison meaningful simpler integer linear program achieve four seventeen complex model achieve seven finally describe technique sixteen operate previously describe perform memory assignment thus allow colour method use figure two example processor architecture memory data path mac unit three within compiler problem model independence graph weight take account execution frequency close two access code several different base formulation evaluate subset suite two three background dual memory bank typical digital signal process convolution filter dot product various matrix make intensive use mac ie compute product two number add product accumulator digital signal design efficiently support digital signal process among prominent architectural feature support mac instruction set dual memory bank enable simultaneous fetch two provide data appropriately partition across two memory bank effectively double memory ensure efficient figure two show generic architecture dual memory bank x two bank access via x address may support specific address embed c two later extension embed c nine three set language iso c program language allow application describe international workshop embed key feature enable efficient source code compilation include support fix point data type circular array particular divide multiple memory space use address identify specific memory space variable example variable declaration like x define integer array size locate x memory similar way address qualifier concept apply two address provide specify pointer data point store example follow pointer declaration x p describe pointer p store memory point integer data locate x memory unqualified default rule apply place data x memory common constraint assign memory bank global may place specific memory bank case target architecture compiler unable split stack across memory bank stack allocate must place first memory bank note specify use address actual memory segmentation leave implementation commonly use address example x four methodology memory bank assignment scheme comprise follow stag one group form stage group must allocate memory bank due pointer form two interference graph construction graph represent potential simultaneous access construct stage three colour interference graph finally nod interference graph colour two colour represent two memory bank benefit simultaneous memory access three stag stage one critical correctness whereas acceptable stag two three ie inaccurate interference graph colour still result correct code however may may perform group form group form first stage memory bank assignment scheme base pointer analysis single group arise set one group must allocate bank ensure type correctness memory result memory bank assignment figure three illustrate concept figure three pointer p may point c however c store memory bank x respectively eventually cause conflict p memory bank p store bank p point must statically specify thus p must point locate single bank legal assignment would place c bank result previous group group show figure three b two p q example p may point x z various point execution program similarly q assume point x group ensure x z always store bank due p also x due q transitivity x z place memory bank note p q store different memory bank target must group locate single memory bank algorithm one group form v require ensure variable group form singleton group contain one v two three end four l pointer p v five l six select p l six seven merge group p eight end algorithm one work list algorithm group assume set ing present pointer available prior pointer analysis program algorithm operate set v group initially algorithm place variable singleton group merge group pointer p set v set calculate group correspond merge process repeat pointer visit algorithm efficiently implement main cost usually arise require pointer analysis phase different actual multiple call sit single set formal function handle analogously international workshop embed incompatible pointer b pointer induce variable group figure three incompatible pointer pointer induce group expression dependence tree b expression interference graph c colour interference graph alternate colour figure four map potential interference model able effectively assign group memory bank necessary build interference graph represent memory access program do statically take dependence graph expression mark pair memory variable access dependence potentially interfere see figure four represent case load store could schedule parallel potential give weight equal estimate number time expression execute estimate determine calculate loop iteration count use value exact count statically determine assume branch take fifty probability estimate call count function also calculate way calculate many time call site execute variable interference graph reduce group interference graph use previous approximate information sufficient determine group important optionally extend model able handle must assign fix memory bank automatic must place stack programmer already assign specific memory bank extend model single additional node per fix group group automatic name node automatic node possible assign nod memory bank always place fix one possible interfere thus may possible accurately determine group five colour single solution reference integer linear program colour approach approximately equivalent model thirteen implement model construct interference graph g e g set group vertices graph e weight g xi one place bank zero otherwise xi one ensure group place exactly one memory bank place neither xi would equal one international workshop embed g one xi zero otherwise two xi two xi ensure set one group place different memory bank first two ensure one different bank zero otherwise next two set one different bank zero otherwise combine ensure always set correctly linear program solver follow objective function obey value set value xi latter solver may set attempt objective function thus effectively assign memory bank attempt available parallelism e x x j zero zero interference weight associate edge e calculate describe section edge e weight zero use equation linear program solver find set g place high interference different memory bank mean possible perform critical memory parallel set necessarily truly optimal though optimal solution term interference graph model base model describe paper thirteen model use interference graph build compiler run reasonably accurate model potential parallelism program however technique build interference model base program entire target compiler still run program assign memory bank thus technique section seven ensure still valid colour model multiple build interference graph also mean problem less constrain mean may many optimal model example node completely disconnect interference graph score linear solver whichever memory bank group assign integer linear program generally work first reduce much program linear problem solve quickly use technique solve remain multiple optimal may find stage possible keep search even optimal solution find however process reduce integer problem one many alternate optimal may lose technique find memory bank assignment model technique always find single optimal solution problem reduce problem well reduction crucial part process skip would make trivial intractable use alternative method find multiple optimal alternative approach find set nod may invert node variable group variable group set connect least one node set equation one every node connect node set belong set equation two g st e e one two set define take optimal solution program memory assignment every node within set may flip simultaneously give new solution still optimal term model exception set contain node fix specific memory bank automatic node belong set group invertible take number set g may invert least different possible optimal memory g example consider interference graph figure four b would split two set b c e assume edge equal weight figure four c contain one possible optimal set memory potential parallelism access e block due assign memory bank graph inevitable three additional optimal find invert group assume none nod fix specific memory first additional assignment find flip assignment second flip b c e third flip figure four show assignment flip set international workshop embed simple example also allow us see set optimal find invert set necessarily full set optimal figure four b six optimal ways colour b e c always opposite b mean six optimal ways colour b c e combine two ways colour twelve different optimal instead four find invert set however aim find every possible optimal solution program representative set evaluation approximation sufficient fact even take colour would many many instead take one specifically colour find invert set colour find invert set individually six soft colour previously describe assignment solution find optimal solution problem exponential small simple solver generally able reduce integer problem linear problem part solve polynomial time however complex interference graph reduction less effective mean small change interference graph change reducibility result large increase time take solve model exponential solve time make assignment solution undesirable many case solution find good colour quickly predictable solve time would seem advantageous single solution graph colour well establish within primarily register allocation however graph colour term memory bank assignment slightly different graph colour register allocation register allocation colour do hard constraint two interfere register must place register memory bank assignment operate soft constraint would prefer two interfere place memory bank therefore conventional graph colour approach unlikely adequate instead make use algorithm design distribute environment colour frequently operate soft distribute stochastic five current colour c opt current locally optimal colour result step five nod allow central controller make decision step three every node already optimal colour algorithm terminate colour algorithm two soft colour variable group g require interference graph ensure memory assignment one g two three four rand zero one g still local optimum determine c opt inform central controller whether c opt probability p c opt five six seven eight end end longer change node still optimal colour may change would nod change colour next iteration loop continue execute also worth note step six may already equal c opt step four calculate use equation xi define section refer current node algorithm e e x x cost min essentially calculate weight value many memory bank x pick colour value ie one conflict although method conflict different metric try potential parallelism actually equivalent change interference graph addition use different algorithm also make change interference graph g e soft colour set vertices g stay make set weight e specifically make graph fully weakly connect connect every unconnected pair nod g edge low weight weight set low enough always lower weight relate actual detect interference low weight mean extra nod never change colour decision two interfere nod provide balance metric unconnected nod figure four b roughly equally distribute x international workshop embed multiple stochastic soft colour algorithm possible get range colour repeat execution technique every set return local optimum seven experimental evaluation platform implement c compiler use compiler framework eighteen c program convert intermediate format annotate information use span tool fourteen use information form group describe section output group place memory c may use assign group specific memory bank accord generate group memory bank map soft implement make use solve one library implement native binary default presolve colour do system two memory experiment run operate clock program compile use compiler evaluate technique use suite eleven colour run static pipeline lack cache result deterministic hardware result initially evaluate effectiveness colour provide exhaustive result exhaustive result obtain run every possible colour except different colour try represent total colour figure five show achieve various different equivalent colour describe section best worst bar figure correspond highest relative performance iso c set equivalent find per see see range result eight one spectral see performance colour another observation except able find optimal solution average range due compare best exhaustive result compare soft colour technique result show figure five b range soft colour result show see despite guarantee solve colour model soft colour well find almost exactly range result however range still quite wide attempt constrain add additional automatic node describe section effect show figure five c automatic node shorten range soft colour way colour mostly good result eliminate go average soft colour mostly bad result eliminate go average also automatic node allow soft colour always find truly optimal solution fir find better spectral final thing consider long take execute two colour figure five show time take soft remain total colour time second time report time take perform alias analysis execute colour algorithm alias analysis take notable amount time seven second time time take perform colour many automatic possible make global declare function artificial change always result code however allow result obtain interference graph without get program run target architecture roughly double quadruple number nod interference graph interference graph due expose exponential although code soft colour take roughly time code soft time faster notably soft take second take one half second figure five e show affect add additional automatic node interference graph time take colour little change soft colour dramatic effect code colour minute second possibly mean single extra node allow part integer problem reduce linear problem demonstrate fragility colour fifty international workshop embed comparison range true optimum b comparison range range soft colour c figure five b additional automatic node time take perform memory assignment e figure five additional automatic node figure five various result soft colour spectral spectral spectral second second international workshop embed computer architecture news one march nine program c support embed technical report ten ko data synthesis proceed international workshop embed page eleven c g lee suite twelve r novel code optimization proceed education research conference thirteen r variable dual memory bank proceed international conference acoustics speech signal process volume two page may fourteen r pointer analysis multithreaded proceed program language design page may fifteen r p chow c g lee exploit dual bank digital signal international conference architectural support program operate page sixteen v efficient variable allocation dual memory proceed international bank workshop embed page seventeen j van j jess conflict model instruction schedule code generation core proceed design conference eighteen r p r c p j w k w hall lam j l infrastructure research parallelize optimize notice twelve eight summary future work present method perform dual memory bank assignment use c compiler demonstrate assignment technique perform well colour return shorter range result lower predictable execution time evaluate technique suite achieve average colour apply problem mature exhaustive result show however range equivalent optimal result find effect add automatic node interference graph range find time take find suggest develop interference model likely provide result intend investigate apply machine learn area technique may easily introduce exist due operate shorter range return result predictable colour time compare make technique less risky include previous also result demonstrate close true optimum mean able well automatically combine make seem likely technique would effective industrial scenario reference one solve package two ace extension tech report ace associate compiler three h van w w bank embed c extension c four r p synthesis code generation signal process circuit digital signal process nine five l experimental assessment stochastic decentralize soft sparse graph proceed international symposium stochastic page six r j bier p evaluation interaction proceed conference signal seven g integer linear program memory assignment domain proceed workshop memory performance issue page eight g approach assignment data multiple