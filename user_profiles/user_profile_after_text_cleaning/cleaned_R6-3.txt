page forty deterministic multicore frustrate complicate test multithreaded code impede parallel program widespread adoption author propose fully deterministic enhance offer repeatability default also improve quality test deployment production code show determinism provide little performance cost future hardware develop multithreaded soft ware prove much difficult write code one major challenge current multicore execute multithreaded code give input thread interleave memory io differently execution multithreaded execution arise small execution example process execute simultaneously operate system resource allocation state cache bus structure complicate development process significantly defective might execute correctly time subtle synchronization bug typically reproduce program behave differently time run input assess test coverage difficult reason much research test parallel program devote deal although make significant address mostly focus replay multithreaded execution base previously generate see relate work deal multithreaded information contrast make case fully deterministic show hardware support execute arbitrary parallel program scant performance penalty discussion determinism benefit see determinism benefit multithreaded development article describe architecture determinism work lead several project example recently publish work pure approach mark university forty publish computer society c page relate work deal multithreaded past work deal focus primarily replay execution idea record log order occur parallel execution later replay execution basis log typically suffer high overhead type example synchronization insufficient reproduce race record replay address issue enable record efficiently allow faster accurate record replay research reduce deterministic replay log size performance impact exploit redundancy memory race log recent advance aim reduce log size hardware complexity rerun hardware memory race record mechanism record execution without memory communication phenomenon leverage require little hardware state produce small race log execute block similar quanta need record commit order block additionally use commit order albeit block size log special case reduce memory order log contrast make memory communication deterministic construction eliminate need log similarly concurrently develop work provide deterministic execution leverage application freedom provide determinism efficiently purely via deterministic synchronization library contrast use hardware support provide determinism arbitrary program include data race work explore enforce determinism execution level provide generality require architecture body relate work propose different move new deterministic continue run commodity hardware three k de fully integrate practical system computer vol seventeen two four bacon replay program workshop par distribute press five g b con record program execution deterministic replay l computer five press six r hill flight data recorder enable deterministic replay l computer architecture three press seven c pereira b record share memory use strata l ar support program operate six press eight hill r regulate transitive reduction longer memory race record l architectural support program operate six press nine hill rerun exploit light weight memory race record l architecture eight press ten p l j record ing replay execution efficiently l computer architecture eight press eleven j efficient deterministic l architectural support program ing nine press twelve w language stream l compiler construction springer thirteen lam design implementation reference one h deterministic replay evaluation jade program lan multithreaded parallel distribute tool press vol twenty three fourteen al type effect system deter two parallel parallel program instant replay object orient program vol four nine define deterministic parallel execution define system computer produce program output give program input system execute multiple thread via share memory definition imply parallel program run system deterministic program page top pick determinism benefit multithreaded development deterministic execution could potentially improve entire multithreaded development process see figure development environment determinism allow repeatable turn enable reversible multithreaded program determinism also act powerful lever thread analysis tool race verify execution give input continue hold future input determinism simplify test eliminate need stress test program run repeatedly input expose different thread interleave instead thread interleave control fashion modify input however reward accrue parallel program always execute field deploy determinism potential make test valuable execution field better resemble test allow easier reproduction bug field back environment ultimately determinism enable deployment reliable parallel test need stress test test input behave identically production test result reproducible reverse possible effective thread analysis tool deploy robust production code production bug reproduce figure benefit determinism throughout development cycle multithreaded direct way guarantee deterministic behavior preserve global interleave every execution parallel program however interleave several irrelevant ensure deterministic behavior important particular global interleave choose long always also two communicate system swap execution order observable effect program behavior key deterministic execution communication thread precisely every execution guarantee deterministic communication dynamic instance load consumer must read data produce dynamic instance another store producer producer consumer need thread communication happen via share memory interestingly multiple global interleave lead communication interleave interleave yield program behavior guarantee deterministic behavior must carefully control behavior load store communication thread insight key efficient deterministic execution enforce deterministic execution section describe build deterministic system focus key begin basic approach refine micro b c figure one deterministic serialization memory parallel execution deterministic serialize execution b deterministic serialize execution c overlap execution dot memory dash synchronization page simple technique progressively efficient discuss specific later basic idea note make deterministic depend ensure communication thread deterministic easiest way accomplish take parallel execution see figure allow one processor time access memory call deterministic serialization parallel execution see figure way implement serialization processor obtain deterministic token perform memory operation memory operation complete pass token next processor processor block whenever need access memory token wait token every memory operation significant performance degradation two reason first processor must wait pass deterministic token second serialization remove performance benefit parallel execution mitigate synchronization overhead token pass synchronize granularity let processor execute finite deterministic number quantum pass token next processor figure call system process divide execution quanta call quantum build way build quantum break execution fix instruction count example notably interfere synchronization example introduce offer memory access semantics traditional extra synchronization system impose reside synchronization two interact recover parallelism reduce serialization impact require enable parallel execution preserve determinism propose two recover parallelism execution figure first technique leverage cache coherence protocol identify communication occur second technique use speculation allow parallel execution quanta different quanta determinism might violate cache leverage coherence protocol improve deterministic parallel execution performance serialize thread communicate divide quantum two part prefix execute parallel quanta suffix first point communication onward execute serially serial suffix execution deterministic thread run serially order establish deterministic token transition parallel execution serial execution deterministic occur thread thread block either first point communication communicate thread end current quantum thus thread block quanta though possibly end thread block deterministic point within page top pick memory operation deterministic token pass n deterministic order atomic quantum load st store initially private po initially share st block block st parallel prefix one st two block two serial suffix b one figure two recover parallelism overlap execution remote processor read another thread private data remote processor write share data b quantum communication detect describe later communication occur thread write share piece data case system must guarantee thread observe write deterministic point execution figure two illustrate enforce two important case read data hold private remote processor write share data figure show first case quantum two attempt read data remote processor hold private must first wait deterministic token thread block wait deterministic token example read execute quantum one finish execute guarantee quantum two always get data quantum one might still write location finish execute figure show second case quantum one already hold deterministic token attempt write piece share data must also wait thread block wait deterministic token example store execute quantum two finish execute necessary guarantee observe change location state share privately hold remote processor deterministic point execution thread reach end quantum wait receive token start next quantum periodically allow thread wait thread block make progress leverage support transactional memory execute quanta atomically isolation deterministic total order equivalent deterministic serialization see consider quantum execute atomically isolation single instruction deterministic total order leverage transactional make quanta appear execute atomically isolation couple deterministic commit order make execution functionally equivalent deterministic serialization recover parallelism additionally need form quanta enforce deterministic commit order figure show speculation let us quantum run concurrently quanta system long micro page memory operation deterministic token pass deterministic order atomic quantum uncommitted value flow st store n load st b st one three st c st c st b squash two four st b st b one three b st c st b two four figure three recover parallelism execute quanta memory avoid unnecessary squash uncommitted data forward b overlap memory access would violate original deterministic serialization memory case conflict quantum get squash later deterministic total order see quantum two figure notably deterministic total order quantum commit key component guarantee deterministic behavior call system store concurrently another interest effect commit order let us us use memory rename avoid squash conflict example figure quanta three four execute quantum three need squash quantum four despite conflict deterministic commit order also let us us selectively relax isolation improve performance forward uncommitted speculative data could save large number squash communication avoid spurious squash let quantum fetch speculative data another uncommitted quantum deterministic order show figure quantum two fetch uncommitted version quantum one recall without forward support quantum two would squash quanta let guarantee correctness quantum provide data quanta squash subsequent quanta must also squash might directly indirectly consume incorrect data call system leverage support transactional memory forward build quanta intelligently devise several modify simplistic quantum build algorithm higher performance example end quantum unlock operation occur rationale thread release lock thread might wait lock deterministic token send forward early possible let wait thread progress discuss base pattern full conference implement share table data structure keep track share state data memory hardware implementation share table leverage cache line state maintain cache coherence protocol local processor consider line exclusive modify state private owner thread freely read write without hold deterministic token page top pick execution apply read operation line share state conversely thread must acquire deterministic token write line share moreover thread must deterministic point block memory controller keep manage state share table correspond line cache like directory cache coherence however require coherence per se system service cache miss state transfer nevertheless simplify implementation even require top standard transactional memory support small amount machinery enforce deterministic transaction commit order allow transaction commit processor receive deterministic token additionally require elaborate transactional memory support allow speculative data flow uncommitted quanta deterministic order accomplish make coherence protocol aware data version quanta much like use speculation one interest aspect make transaction overflow event deterministic use quantum boundary make bound transactional memory implementation perfectly suitable system make transaction overflow deterministic require update speculative state cache line happen strictly function memory instruction retirement update speculative permit addition require nonspeculative line displace overflow trigger state nonspeculative line affect overflow decision experimental setup assess performance different hardware simulator write use model include effect serialize execution quantum build memory conflict speculative execution fully serialize quanta squash buffer single outstanding transaction per processor execution affect system execute program accurately model quanta serialization effect application behavior reduce simulation time model assume different include squash reasonable assumption let us us compare performance different scheme use infrastructure even execution behavior deterministic performance might deterministic therefore run simulator multiple time average result provide error bar show ninety percent confidence interval mean comparison parallel execution also run simulator use suit run completion exclude due infrastructure lack compatibility evaluation figure four show compare parallel run sixteen thread quantum build strategy produce quanta leverage synchronization share information might expect exhibit slowdown nearly linear number thread degradation sublinear affect parallel portion application execution percent overhead average sixteen thread case example see figure four provide much better performance additional hardware complexity cost average overhead percent provide consistent performance improvement overhead scheme flat suggest system would ideal thus micro page e z l r n e n r n c e x e l e l l r p c n r e e n n thirty twenty fifteen ten p p radix p splash fluid parsec figure four sixteen thread p indicate conflict detection otherwise conflict detection right hardware support deterministic execution performance compete parallel execution instrumentation purpose code affect quantum build thus preserve original behavior beyond correctness performance present must also consider architecture implementation evaluation show use speculation pay term performance however speculation potentially waste energy require complex hardware system design code io part operate system execute speculatively fortunately coexist system one easy way coexist switch deterministic boundary program edge quantum support instrumentation enable environment system need way allow user instrument code preserve original execution interleave accomplish must support mechanism let us compiler mark code insert deal operate system io system hide source today allow many multithreaded program run slight exist operate system handle remain source example parallel program use operate system communicate thread must either execute operate system code detect communication synchronization via kernel provide within application use latter approach another fixable source operate system allow unnecessarily example return value read system call might vary run run even file read change solution read always return maximum amount data request ultimately however real world simply program interact remote affect thread page top pick interleave might seem imply hope build deterministic system true multithreaded code synchronize opportunity deterministic point forward thread know state system deterministic interaction external world consider part input much easier write deploy reliable multithreaded support deployment deterministic use development deployment well field behave like use test reason twofold first confident program work correctly deploy second program crash field deterministic execution provide meaningful way collect replay crash history data support deterministic execution across different physical machine place additional implementation quanta must build across mean effect count full bound use end quanta furthermore pass deterministic token across must suggest hardware provide core leave quanta build schedule control p contrary popular belief system execute program little performance cost believe deterministic valuable goal besides yield several interest research question abstract away several write micro deploy parallel code thank dan kim university feedback article finally thank research helpful group involve project nick hunt gribble dan reference one bacon hardware assist replay pro workshop parallel distribute press two p l j record replay execution efficiently l computer architecture eight press three c pereira b record share memory use strata l program support operate six press four k de fully integrate practical system computer vol seventeen two five r hill flight data recorder enable deterministic replay l computer architecture three press six al compiler system deterministic thread execution present l architectural support program operate seven l al transactional memory coherence consistency l computer architecture four press eight moss transactional memory architectural support data structure l computer architecture press nine j al deterministic share memory l micro page architectural support program operate nine press university member mark associate professor computer science engineer department university currently leave commercialize many behind research interest include parallel compute communication network silicon manufacture computer science university direct question comment computer science engineer box wa ten al speculative cache l high performance computer architecture press eleven al pin build program analysis tool dynamic mentation program language design implementation press twelve woo al program characterization methodological con l architecture press thirteen c al parsec suite characterization architectural l parallel compilation press research interest candidate computer science engineer department university include model intersection architecture program computer science engineer university member candidate computer science engineer department university research interest include hardware support dynamic analysis concurrent program focus increase reliability computer science engineer university member assistant professor computer science engineer department university research interest include computer architecture program operate improve reliability cofounder company form around technology computer science