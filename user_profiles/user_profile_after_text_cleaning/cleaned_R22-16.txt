probabilistic embed program institute compute architecture university unite kingdom mob member abstract efficient implementation critical many embed c embed largely focus code generation instruction schedule grow maturity provide diminish return paper evaluate another approach namely probabilistic search good transformation sequence within large space novel approach combine two selection one base explore space focus search good technique apply suite two digital signal embed processor derive popular processor architecture average approach give factor time improvement across equivalent average reduction execution time outperform exist approach certain case seven find individual subject embed optimization optimization global optimization probability statistics probabilistic general term performance experimentation optimization iterative compilation adaptive compilation optimization digital signal process introduction one high performance short time market two major factor embed design want end product deliver best performance give cost want solution deliver quickly possible past digital signal process media process rely assembler program deliver performance however cost develop embed system become permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee five copyright c june dominate algorithm development use program mean reduce time market commonplace program c however lead less efficient compare approach therefore large amount research interest improve performance embed sixteen work largely focus improve architecture specific compiler phase code generation register allocation schedule however investment ever sophisticate produce diminish return eight give embed system typically run one program lifetime afford much longer compilation time order several compute particular feedback direct iterative approach multiple compiler try best select area recent interest four eighteen however still give relatively small effectively restrict try different paper consider entirely distinct approach namely use embed approach definition highly portable one processor another entirely complementary fact show allow put less effort compiler reduce time market product give higher performance see section approach deliver good performance extremely difficult predict best transformation depend underlie processor architecture native compiler small change program new release native compiler next generation processor impact transformation selection typically high level static simplify model three guide transformation selection show five nine however space highly nonlinear completely static approach doom failure paper propose new approach transformation namely probabilistic essentially use stochastic select direct execution time feedback trade space coverage search know good use approach achieve remarkable performance average across three machine demonstrate approach automatically port new processor extract high level performance unachievable traditional additional native compiler effort paper follow section two provide motivate example demonstrate need search high level section three describe transformation space con original implementation b implementation c implementation void float input float output float expect float coefficient float gain float sum error adapt old adapt sum zero zero sum input coefficient output zero sum error expect zero sum gain zero coefficient input error coefficient coefficient input error see figure two specific code loop loop totally unroll array reference dismantle loop totally unroll array reference dismantle new introduce lower loop pseudo code linear array traversal loop totally unroll pseudo code linear array traversal figure one original implementation b c follow section four overview search use follow section five empirical evaluation approach section six survey relate work follow conclude remark section seven two motivation example portable yet highly effective way improve performance enable native compiler produce efficient code derive efficient program transformation sequence however complex task basic program interaction transformation native compiler underlie target architecture easily analyse exploit three furthermore frequently apply series program program base expert knowledge experience specific processor compiler however new generation processor even release new compiler version knowledge become outdated furthermore new frequently immature challenge program developer aim high performance data input coefficient sum zero float data data data one one sum sum one eight figure two first loop example one processor example consider program excerpt figure one function part fifteen compute single point adaptive finite impulse response fir filter apply set input sample first two loop iterate input coefficient perform repeat mac second loop update filter coefficient next run filter function figure one b main due implementation list routine change semantically outperform routine figure one factor processor transform version program loop flatten array reference dismantle explicit base address plus offset however different produce best perform implementation see figure one c twelve achieve convert first loop loop flatten second array reference convert almost code produce best result first loop example one form show figure two short example demonstrate difficult predict best transformation new platform interleave transformation profile execution stag actively search good transformation sequence portable however must able search potentially huge transformation space order find successful sequence particular program particular architecture paper propose probabilistic search algorithm able examine small fraction space still find performance three space transform rewrite program source level impact performance illustrate consider describe figure five supply four distinct firstly available either array pointer form addition may also available form although four independent source version readily derive pointer seventeen eight twenty figure four show average execution time version across processor transformation analysis thirteen control nineteen data computation loop five four lower ten layout access nine lower two part simplify four seven two lower eleven prop mem seven three type three lower one number parentheses denote number correspond transformation category figure three transformation clean array version give best average performance prefer pointer base version paper order compare effect native compiler system performance consider two marginally prefer array base code pointer base case notable exception program perform poorly set data conclude affect performance depend processor program possibly underlie compiler due variation performance four different paper respect best perform original code example case normally array base original code usually pointer version select best overall transformation normally consist select sequence smaller apply part program give certain may different may consider select best transformation effectively problem space possible remainder section describe transformation consider novel mechanism encode binary allow exist use paper consider high level applicable c program available within extend eleven base framework convenience show figure three thirteen effect analysis phase mark enable later actually modify source three broad group aim modify program modify actual computation perform focus data subdivide actual layout access broad refine show figure three contain lower translate complex structure smaller one ie unpack structure aim either loop general change data access include value propagation modify memory reference data type conversion finally computation base one example loop unroll unroll factor figure four relative slowdown different cod style per processor data performance array code include partial evaluation redundancy elimination code simplification mean definitive transformation taxonomy provide overview available encode one main select best transformation sequence many position dependent ie apply part program unlike global specify location transformation furthermore may lead two firstly space increase size secondly become asymmetric description mean search space uniform manner overcome devise simple method make treatment location specific indistinguishable decision global constant propagation achieve simply enumerate possible example consider case loop unroll three loop may unroll eight time possible loop unroll consider begin determine total number need base program size parameter space select number loop may change time due say fusion program description fir fir one four one one eight one eight one mult ten ten mult four four compress edge detect histogram fast transform finite impulse response fir filter infinite impulse response filter lattice filter adaptive fir filter matrix multiplication speech speech image compression use discrete cosine transform edge detection use convolution image enhancement use histogram figure five number select change dynamically case focus search describe therefore need track individual transformation contribution success number change time four search small set impossible perform exhaustive search possible transformation sequence give short length practical search algorithm must therefore find good rather optimal solution acceptable time figure six overview iterative compilation framework give c code enter system translate intermediate representation operate finish transformation process translate back c code compile executable particular machine native c compiler make use aggressive set implement transformation use compiler eleven provide us c code generator rich number already implement algorithm central iterative transformation framework algorithm host engine figure six huge size space complexity make necessary find balance space exploration focus search consider size space approximately find good point whilst keep number sample point thus number program run within reasonable limit employ probabilistic although random base search space lead performance improvement nine definition unable direct search optimal point transformation subsequence find consistently perform well poorly indeed effect would like use guide search however natural tension avoid bias search need technique combine unbiased sample transformation space feedback focus attention good order overcome dilemma space exploration focus search combine two simple yet powerful represent two two compete within final merge stage best two individual choose facilitate broad space coverage choose simple random search space exploration algorithm focus search represent machine learn algorithm base modify incremental learn one approach consider two extreme case continuum learn rate one inspire technique zero random search particular competitive learn network activation output compute weight adjust accord rule give follow two one one x j two learn rate zero lead constant weight adjust search hand learn rate one enforce strong adjustment individual weight change input two follow two paragraph discuss detail space exploration random search assign constant uniform probability distribution set next transformation solely base value generate number generator case equally divide assign probability across enumerate example transformation one probability select fifty loop unroll assign probability two formally learn rate zero random search information carry across algorithm equation two follow zero transformation length transformation sequence upper limit determine random process random search algorithm use effectiveness direct search focus search stochastic search technique aim integrate genetic competitive learn increase probability option select whenever positive instance use option encounter stochastic algorithm associate selection probability unlike space explore random search algorithm change time distribution need uniform ie zero fact choose one fast convergence encounter performance enhance original algorithm consider binary encode generate population base probability vector modify purpose start uniform probability distribution individual sample point ie transformation sequence choose evaluate execute correspond program selection figure six overview iterative framework five experimental evaluation section present analyse empirical result gain tool result find run search algorithm correspond two search evaluate adaptive scheme three different represent different embed compute domain among three embed digital signal processor processor embed processor derive popular processor architecture native use development environment eighty gnu highest use native execution time measure use hardware cycle counter methodology transformation highly portable port within eight distinct embed processor however time write experimental data additional yet available choose fifteen nineteen suite evaluate technique set contain well compose complex data structure detail show figure five many program available four cod style explicit array reference plain exclude study due incompatibility differ acceptable c native particular much term c accept also focus bite manipulation cause due figure seven due transformation aggressive native compiler tie individual update base success ie execution time sequence whole contribute better performance reward result performance thus future sample point likely include previously successful frequently search intensively standard allow random mutation within probability vector discard wish incur overhead finally generate population base probability vector one candidate depend success update probability vector accordingly high learn rate lack mutation single candidate per generation mean strongly focus search base feedback result figure eight due transformation aggressive native compiler figure nine program average across aggressive native compiler conflict issue fix recently however data yet available result state section four respect best perform original program give true evaluation approach thus best original execution time four possible program select comparison use highest level select native compiler platform base evaluation figure seven ten eleven eight show performance achieve approach across benefit iterative search average give overall average overall figure demonstrate importance word use platform independent approach able reduce execution time average outperform approach examine result see figure seven closely see much variation surprisingly matrix multiplication improve almost factor seven completely flatten code well know routine one would think compiler would well iterative scheme perform less well small data size fir unlike also unable improve performance problem share different picture emerge consider processor see figure ten less variable direct contrast large performance gain achieve small data size program good result also find compression edge detection like little performance gain performance gain achieve compiler surprise result give mature compiler therefore prove difficult improve upon like perform well large matrix multiplication small poorly however perform well small like share similar performance gain edge detection compare two detail see section average like uneven distribution result large achieve almost five perform poorly unlike perform poorly compress orientate evaluation examine average performance improvement across show figure nine see three fail achieve average benefit loop unroll however due native instruction take full advantage enlarge loop body suffer cod style introduce frequent conditional branch innermost loop similarly limit transformation potential many conditional branch tiny basic block surprisingly four six case iterative search able speed program greater extent small rather large data size many noticeable effect deal large amount data computation examine output code seem several case iterative search completely unroll flatten certain section code turn loop large basic block act enabler compiler reason large matrix multiplication use two one platform give insight effect performance expect overall compiler outperform approximately time faster average however apply top see improvement average outperform mean automatic approach use simple outperform handcraft base many person work furthermore allow put less effort compiler reduce time market product give higher performance diagram also show apply give relative alone also figure ten due transformation aggressive native compiler figure eleven due transformation aggressive native compiler figure twelve comparison two result performance transformation show approach also port scale improve complementary approach vendor overall loop identify beneficial class framework category figure three follow value propagation partial evaluation remain class small derive metrics across focus search phase algorithm find best sequence time average effective transformation sequence length example compress best sequence hoist loop function parameter pass flatten main loop remain time best transformation sequence find random phase absolute length average result look surprise first compiler research suggest sequence beneficial obviously contrast break large expression tree b value propagation c hoist loop loop e loop unroll f mark constant g dismantle array h eliminate copy enumerate likelihood transformation select figure thirteen probability transformation successful across program focus search result however randomly select sequence one eighty average around forty expect furthermore examination see many include impact code junk transformation frequently contain repeat effect particular program hence effective sequence length much shorter mean long sequence may beneficial sufficient future work consider short effective sequence less ten length interest note focus search find best time achieve average performance gain random space exploration find best solution less often achieve average case justify choice use two approach search space transformation sequence experimental data confirm hard establish generally successful sequence order vary drastically general rule large increase performance appear come one two either loop unroll large combination five however appear little correlation length transformation sequence performance achieve distribution examine probability distribution useful across program eight peak label ah figure thirteen first glance seem much commonality across loop unroll e far successful transformation although well know improve performance surprise successful native apply unroll mean heuristic employ native compiler fact poor propagate know value b loop hoist c also useful surprise native compiler perform less obviously break expression tree effectively handle code generator prove useful finally change array pointer traversal g useful machine separate address generation eliminate copy h reduce memory focus whose profile similar see also among figure fourteen show transformation order overall effectiveness three point b c see mark usefulness data layout transformation rearrange order location data enable user efficient address transformation important pair seem sensitive memory layout change control flow simplification b eliminate redundant conditional branch loop might introduce previous pass unlike dynamic branch predictor unnecessary branch expensive array reference dismantle make address computation array reference explicit importance attribute compiler relative immaturity efficiency although evaluate time acceptable embed context cost multiple run fact average majority performance improvement occur within less run future work exploit program structure guide transformation selection improve include consideration learn rat different zero one six relate work program transformation one major difficulty use prefer application language embed c well suit extensive usage pointer arithmetic seventeen prevent application well develop analyse previous work eight however show many memory reference eliminate convert explicit array reference amendable advance analyse two use highest level available native compiler data layout transformation b control flow simplification c dismantle array reference reorder effective leftmost first fourteen show figure fourteen highlight overall effectiveness limit work evaluation embed performance two code size execution time loop unroll investigate twelve impact tile power consumption evaluate impact several kernel evaluate four different embed eight program transformation iterative adaptive compilation recent development lead number past early work field two thirteen investigate iterative search good loop unroll tile nine random search strategy numerical evaluate seven propose neural network base search however without give empirical result partially approach select sequence vista fourteen combine user guide performance information genetic algorithm select local global sequence adapt adaptive compilation system flexible new require compiler writer specify apply dynamically code however usually suitable embed context author eighteen ten four explore ways search program command line enable disable specific various approach eighteen four make use fractional factorial design experiment plan recently range search find attention among compiler particular work cooper al six al relevant context paper six probably similar work main focus evaluate effectiveness various search compiler phase order within native compiler algorithm compiler space exploration machine present similar approach different apply code segment main work however level kind number consider approach execution time estimation approach deal much space sixteen six fifteen also consider additional dimension introduce transformation outperform technique use highly portable code data transformation already employ successfully early development stag native compiler continue deliver performance benefit compiler mature contrast six estimate actual execution time count base abstract machine employ real embed hardware measure cycle accurate execution time alleviate inevitable difficulty show predict estimate possible performance impact highly often idiosyncratic embed contrast rely compiler writer supply predictive configuration prune handle large search space leave decision employ search algorithm seven conclusion paper describe probabilistic algorithm find good transformation sequence typical embed program write c demonstrate highly portable provide much scope performance technique two compete search provide good balance space exploration focus search already identify good integrate global local unify framework efficiently operate huge space span eighty empirical evaluation base three real embed suite successfully demonstrate approach able outperform exist approach give average across future work investigate integration machine learn base program feature algorithm reference one incremental learn method integrate genetic search base function optimization competitive learn source technical report mellon university pa two f e iterative compilation nonlinear space proceed workshop profile feedback direct compilation conjunction pact three c w f execution time estimation c program proceed international workshop cod one four k chow selection characterization compiler proceed workshop dynamic optimization five k cooper l adaptive optimize century proceed symposium computer science institute six k cooper reeve l waterman explore structure space compilation sequence use randomize search proceed symposium fe seven h approach application source code eight b array recovery embed compute two two may nine g p evaluate iterative proceed parallel two college park ten holler automatic recommendation compiler proceed workshop dynamic optimization eleven hall l b murphy e lam maximize performance compiler computer twelve twelve n j h kim experimental evaluation energy behavior iteration space tile proceed international workshop parallel compute zero page thirteen combine selection tile size unroll factor use iterative compilation proceed international conference parallel compilation pact zero page fourteen p kulkarni w h moon k cho j bailey park k find effective optimization phase sequence proceed conference tool embed three page june fifteen c lee suite sixteen k wang code optimization embed proceed design conference seventeen c p paulin address calculation compilation exploration proceed design conference page las eighteen hag statistical selection compiler proceed nineteen p chow c lee comparison traditional architecture compile international workshop compiler architecture support embed case twenty b j wang loop optimization code generation proceed international conference acoustic speech signal process volume four page phoenix di august compiler exploration journal parallelism volume seven r adaptive program adapt notice seven v j c h proceed methodology international conference signal process technology page