international web conference efficient common extraction multiple sort list twelve twelve two twelve three four information university china data engineer knowledge engineer ministry education china compute state university university set list list sort ascend order value objective paper figure common appear list efficiently problem sometimes know common extraction sort list solve problem one common approach scan list sequentially parallel one list exhaust however observe overlap across list high sequential access approach significantly improve paper propose two solve problem take idea skip many list possible result large number among save hence efficiency improve conduct extensive analysis propose one real two synthetic different data report find paper introduction give set sort list list sort ascend order value objective figure common appear sort list efficiently problem sometimes know common extraction sort list common extraction sort list classical problem computer science wide range many different discipline one two three four five six seven join use sort index assume n x x yn index x want compute x x yn notice item index index x sort figure common appear index join operation information retrieval assume exist collection document query objective extract set document contain word query order figure document efficiently always create set invert list first invert list represent document contain specific word usually contain set document id sort ascend order base invert list two five eight twelve fifty eighty three six nine twelve eighty result eighty five twenty fig one example obtain require document figure common id invert list represent word query example one suppose exist four order list show figure one accord algorithm describe one order obtain common list start first list two three eighty five current equal know current item one common otherwise select item minimum value move next item repeat selection move list exhaust finally common item describe example one list need access finish scan list moreover among list require order obtain minimum value step actually figure one observe maximum value first list eighty third list clearly list value less eighty belong common result move first list value greater equal eighty instead scan list one one strategy apply selection result performance great improve large number skip among list save sum make follow propose two extract common set sort list skip obvious common improve table symbol definition l l li li li j set sort list l number list l sort list one l number li item position j list li one j li algorithm one l input l set list output r common l initialize array size l one l one true performance skip many list possible conduct extensive experimental evaluation propose one real two synthetic synthetic generate different data experimental result demonstrate efficiency propose problem definition let l set list use l denote number list li denote list l one l give list li use li j denote item position j list li li denote number li item integer string data structure provide total order relationship derive reference table show set use throughout paper definition one sort list give list li li say sort list n one n li li li n ease presentation assume list mention paper sort list formalize definition one duplication list deal list beyond scope paper give set list objective extract common appear list propose work section first give basic algorithm one solve problem present two propose exist work one example assume exist four list show figure one begin select first four list l two three eighty five since two item minimum value discard two list look next item five current item list three minimum value result discard three list move next item six list minimum value five similarly discard five move next eight twenty respectively step choose minimum value move next time reach come across common item insert result dispense move one two l one one l li return r one else min min one l li l li min li return r one repeat select minimum value move next point reach since minimum value move next item however exhaust know belong result two description detail describe algorithm one first initialize array store position current line thirteen value current equal line five insert item result set line six list advance next item line notice list exhaust safe return result line eight value current equal identify minimum value line eleven list current value equal minimum value advance next line whole process continue list exhaust line order compare propose later figure two show number number scan use example one algorithm terminate iteration number scan b propose work one algorithm iteration choose minimum value move next need scan list sequentially clearly list exhaust scan list access one one continuously skip moreover identify minimum key require among list iteration also time consume process order improve one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen two iteration one five iteration two eight iteration four twelve iteration six fifty iteration eight eighty iteration eleven iteration thirteen iteration fourteen three iteration one six iteration three nine iteration five twelve iteration seven eighty iteration eight iteration thirteen iteration fourteen iteration seventeen eighty iteration one iteration thirteen iteration fourteen iteration fifteen iteration sixteen iteration eighteen five iteration one twenty iteration four iteration nine iteration ten iteration twelve iteration fourteen iteration seventeen fig two number scan example one use algorithm terminate iteration nineteen scan two iteration one five eight twelve fifty eighty iteration two iteration three iteration four three iteration one six nine twelve eighty iteration two iteration three iteration four eighty iteration one iteration three iteration four five iteration one twenty iteration two iteration four fig three number scan example one use algorithm terminate iteration five fourteen scan performance develop algorithm base follow observation observation one give iteration let minimum value maximum value current list respectively item value greater equal strictly smaller common item one motivate example let us consider set list figure one first iteration move first list two three eighty five figure item maximum value eighty list accord observation one value less eighty common second iteration immediately move item eighty position six item eighty position five item position five result ideally skip ten whole process continue one list exhaust figure three show general idea algorithm ideally total number five total number need scan fourteen much two description detail describe algorithm two main difference show line eleven fifteen value current equal calculate maximum value among current list line eleven list li value current item equal issue binary search current position end list li identify first item li value greater equal line value li less stop algorithm immediately return line fifteen whole process continue one list exhaust line three discussion compare offer major advantage list value less skip iteration obvious overlap among list low one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen algorithm two l input l set list output r common l initialize array size l one l one true one two l one one l li return r one else one l li l li li li one return r however list similar use binary search derive much order tackle issue slightly modify binary search base observation case item try search list li actually near current position thus try shrink search range begin li modify binary search conduct follow first check item position li value item less search li finish otherwise check item position two value item greater check item position one otherwise check item position four generally j one step verify value item position less issue binary search begin one one performance improve search range shrink binary search c propose work two next part develop another enhance version call solve common extraction problem describe iteration select item maximum value iteration skip list value less notice change throughout iteration ie loop line twelve fifteen algorithm two always iteration contrast refine continuously even iteration effective efficient distribution value among list sparse one motivate example let us take example show figure four use list figure one formally present algorithm start select first item two list set two access list accord observation one value less two skip thus select first item three update three similarly move first item eighty update eighty access list move item item position update hence first four skip continue whole process one list exhaust eventually need access eight totally four involve two description detail algorithm describe algorithm three first set value first item set counter store many current list value line one three manner similar algorithm two give list li issue binary search obtain item li minimum value among whose value greater equal line five item li value less algorithm terminate result r return immediately line six otherwise value current item li greater update reset counter immediately line seven nine otherwise increase counter one line thirteen denote many number value equal counter equal number list line fourteen imply current list value therefore union result r reset necessary line eleven seventeen whole process continue one list exhaust line four eighteen three discussion take different precedence select list affect performance take figure four example take first item eighty access first two three algorithm three l input l set list output r common l initialize array size l one one one counter one two true li li one return li li counter one else counter counter one counter l r li return one li counter one l one one one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen skip two access select first thus several take precedence select list adopt selection token ring method describe previous part always take next list refine reach last list first list take next list random selection randomly select list next list refine selection size list select list minimum length begin current position end list selection statistical information select next list accord statistical information list update access paper apply strategy one algorithm study regard future work experimental evaluation experiment setup experiment conduct dual core memory operate system program implement c list load memory run compile use use follow commonly use real data set two synthetic data set cover wide range application computer science bibliography article take record include two iteration one five eight twelve fifty eighty iteration two iteration three three iteration one six nine twelve eighty iteration two eighty iteration one iteration two five twenty iteration one fig four number scan example one use algorithm terminate iteration three scan list two eight scan list min mean one two three four five six seven eight nine ten eighteen seventy one four fourteen twenty fourteen seven five four three two one four three two one zero b different mean variance c mean different variance zero zero zero fig five distribution different data set fifty e l n p c one fifty e l n p c fifty fifty offset mean offset variance different mean variance b mean different variance fig six computational time different data author name title paper preconstruct invert index author name randomly select ten invert list figure common extraction statistic information invert list show figure five normal distribution variance different mean generate set list list follow normal distribution first list set mean zero variance list set variance mean equal previous list plus offset control overlap list value offset example data set show figure five b normal distribution mean different variance generate set list list follow normal distribution first list set mean zero variance list set mean variance equal previous list plus offset control overlap list value offset example data set show figure five c b effect data distribution investigate performance identify common extraction problem two synthetic data set li l plot result figure six initialize mean zero variance set offset two data set figure six observe perform best follow specific run fifteen time faster run time faster compare reach item position list number skip compare scan list one one continuously list exhaust skip obvious common value offset increase mean overlap across list become smaller three run much faster reason efficiency improve list finish scan time overlap decrease notice size list fifty ten n r p c f r e b n e l n p c n r p c f r e b n e h n r p c f r e b n e l n p c n r p c f r e b n e h fifty two fifty fifty offset mean offset variance different mean variance b mean different variance fig seven number comparison different data two four six eight ten four six eight ten number list number list b mean different variance fig eight computational time effect number list two four six eight ten two four six eight ten number list number list b different mean variance fig nine number effect number list overlap decrease ability skip become much powerful order illustrate advantage skip strategy bring count number algorithm show figure seven observe basically matter distribution trend computational time accordance trend number demonstrate computational time dependent number c effect number list study performance identify common extraction problem real data set synthetic data set two l li l plot result figure eight synthetic data set initialize mean zero variance offset still perform follow number list increase computational time increase best linearly gap become reason need access new add list although new list add number old list skip since may refine new add list new list skip well also count number algorithm show figure nine observe trend computational time accordance number effect size list measure performance identify common extraction problem synthetic data set one l four li l li plot result figure ten synthetic data set one initialize mean zero variance offset figure observe perform best follow e l n p c sixty forty twenty one n r p c f r e b n e h two four size list three five computational time one two three four five size list b number fig ten effect size list increase size list computational time increase linearly however size list increase gap keep find show size list increase power skip keep nearly data distribution also count number algorithm show figure ten b observe trend computational time accordance number well v relate work common extraction problem widely apply community also many computer science community common extraction problem study one eight nine ten one propose algorithm perform join operation two order list also extend apply multiple order list describe algorithm propose base propose algorithm efficient skip technique eight ten nine focus problem efficiently figure appear give number list rather list different common extraction problem also study eleven twelve thirteen eleven twelve study construct specialize processor speed calculation common instruction level thirteen describe specialize computer system capable perform common extraction take information retrieval application scenario hardware architecture derive improvement performance different previous work focus efficiency common extraction problem decrease number many possible conclusion paper study problem identify set common appear sort list efficiently exist work handle problem need scan list one list exhaust scan paper propose two try solve problem take idea skip many list possible base skip strategy large number among list save efficiency improve conduct set comprehensive experiment real two synthetic result demonstrate propose approach effective efficient especially overlap across list high research partially support national natural science foundation china grant graduate research fund project university china grant reference one h j j system implementation two h c bell manage compress index document image second edition morgan three c p sextuple index semantic web data management vol one one four j x e lin madden e j p e n b five l j depth vol one one six j madden integrate compression execution conference seven h v j patel n join primitive efficient query structural pattern match eight l li efficient merge filter approximate string search nine c li b wang x yang improve performance approximate query string use ten efficient set join similarity predicate eleven l architecture efficient combine linearly order list forum vol ten four twelve l list merge processor invert file information retrieval university thirteen w invert file processor information retrieval vol