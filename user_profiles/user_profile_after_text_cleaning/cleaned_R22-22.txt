compiler transformation explicit array access institute compute architecture division university abstract efficient implementation critical embed however current write c make extensive use pointer arithmetic make compiler analysis difficult paper present method conversion restrict class memory access typically find cod array access explicit index function c program pointer access array data independent pointer arithmetic structure loop convert semantically equivalent explicit array access technique apply several two different initial result show technique give average reduction execution time one introduction embed account vast majority ship due exponential demand commodity range typically responsible run digital signal process performance critical demand performance lead development hand cod assembly recently cost develop embed system become dominate algorithm development move towards use high level program particular c compute program c much less time consume assembler come price less efficient implementation due inability current compiler technology match balance requirement absolute performance program development time move tune c program source level although one time tune program may perform well contemporary compiler technology program tune frequently make matter worse current generation particular make extensive use pointer arithmetic see twelve furthermore nine actively encourage use pointer base code mistake belief compiler generate better code precisely analogous development early scientific cod convolute code create cope current become dusty deck make much challenge example original array traversal zero b zero c zero k zero k z k zero zero x b f zero f f paper concern change pointer base program typically find array base form amenable current compiler analysis sense reverse engineer dusty desk next section provide motivate example use typical program technique may transform efficient form follow section three description basic algorithm within simple loop nest section four describe general algorithm follow section five evaluation technique set suite across two section six describe relate work area follow section seven conclude remark two motivation pointer access array data frequently occur typical program many address generation five early unable generate efficient code especially program contain explicit array reference therefore use access pointer arithmetic within program order give hint early compiler use address available instance consider example kernel loop pointer increment access encourage compiler address however analysis need code generation formulation problematic rely explicit array index cope pointer reference order maintain semantic correctness use conservative ie many possible array access example conversion explicit array access k zero k z k zero x c b f zero f f c b c b apply presence obviously limit maximal performance produce code highly desirable overcome drawback without adversely affect although general array access pointer analysis without intractable seven easier find suitable array data dependence problem keep result algorithm applicable program furthermore array base analysis mature pointer base analysis within program contain array rather likely efficiently implement paper develop technique collect information code order regenerate original access explicit index suitable analyse furthermore translation show affect performance two five example show loop explicit array index semantically equivalent previous loop example easier read understand human reader amendable compiler array data flow analyse three data flow information collect analyse use redundant loop thirteen step towards regain representation analyse exist formal application transformation array access shape particular multidimensional array ten example show example loop application cleanup conversion array b c longer linear array transform matrices representation enable aggressive compiler data layout ten later phase compiler easily array automatic generation efficient memory access three algorithm pointer cleanup conversion use two stag process first stage information array pointer pointer well loop collect second step use information order example loop pointer cleanup conversion k zero k z k zero x c k zero b k zero f zero f f c k b k c k b k replace pointer access correspond explicit array access remove pointer arithmetic completely general array dependence analysis pointer analysis intractable simplify problem introduce certain analysis might possible also efficient pointer conversion apply result index function array access affine function function must dependent apart induction enclose loop pointer constant ensure easily order facilitate pointer cleanup conversion guarantee termination correctness overall affine requirement break follow one structure loop two pointer apart maybe repeat array start element three data dependent pointer arithmetic four function call might change five equal number pointer branch conditional structure loop loop iteration range go lower bind zero constant upper bind n step one structure loop property pointer apart start element array traverse permit particular dynamic memory allocation handle potentially unbounded complexity dynamic data structure contrary array may do repeatedly even dependence induction variable ie within loop construct example show program fragment whereas statically repeatedly within loop construct dependence outer iteration variable example legal pointer assignment five zero n j zero j j example illegal pointer show block memory dynamically allocate assign whereas might dependent input data b w evaluate compile time assignment illegal pointer statically determine example illegal pointer b dynamic memory allocation b data dependent illegal unknown data dependent pointer arithmetic change pointer ie value point way dependent data process might change one program execution know advance data process future program run compiler know compile time final value eventually although powerful available eleven problem pointer alias analysis kind program construct consider pointer cleanup conversion algorithm therefore permit general pointer evaluate statically handle similar way data dependent pointer arithmetic function call might change involve conversion function take actual pass function content change hence must ensure function call type occur within program fragment convert example receive pointer array thus content array change example data dependent independent pointer arithmetic four data independent data independent x f dependent f dependent x pointer contrary change pointer example function call change pointer array zero finally number pointer must equal branch conditional compiler determine compile time branch actually take information total number pointer leave condition statement available unequal number pointer extremely rare typically find code first example legal treat equally branch second different therefore construct handle note however overlap array access single array via several different perfectly acceptable conversion require information perform transformation memory access representation kind construct often prevent standard program analysis interfere conversion algorithm overall algorithm data acquisition first stage algorithm traverse control flow graph function collect information pointer give initial reference array element keep track subsequent change note change pointer value object point trace loop encounter simple pointer change within loop body multiply effect one case could handle powerful pointer analysis six use static determination pointer example pointer different branch legal else else two illegal cause repeat execution loop body therefore information loop bound induction compulsory follow reconstruction array index function program analysis step abstract program interpretation create summary information node traverse main objective second phase replace pointer access array explicit array access affine index function map array extract information gather pointer first phase array index function outside loop constant whereas inside loop dependent loop induction correspond loop order determine index function information pointer change base pointer arithmetic collect first stage use finally array reference replace semantically equivalent explicit access whereas serve purpose modify delete pointer conversion algorithm apply whole function handle one multidimensional array general loop nest structure loop several consecutive loop code therefore restrict handle single loop loop body contain conditional control flow present algorithm suitable handle function simple loop array conditional branch interest simplicity presentation algorithm cover enhance feature like loop nest algorithm one keep list nod visit list nod obtain traverse control flow graph supply parameter algorithm preorder long nod list next one take process depend type statement different action start pointer result update map whereas loop handle separate procedure pointer arithmetic statically evaluate array reference replace equivalent explicit array reference map contain pointer correspond array also initial offset pointer within array local offset keep track pointer loop body procedure handle loop part algorithm one similar basic algorithm loop handle procedure proceed preorder traversal nod algorithm one pointer cleanup conversion g procedure cleanup g map l g l empty head l l pointer assignment statement pointer array map map map pointer array end map map pointer array else contain pointer reference look pointer array offset map contain array access replace access array initial else contain pointer arithmetic map map pointer array offset calculate new offset map map pointer array new end else loop map end end loop body two pass nod make first pass count total offset within one loop iteration traverse array second pass actual replacement phase final stage adjust pointer map situation end loop algorithm pass every simple node every node enclose loop construct twice hence algorithm use time n n number nod exact time depend number size loop handle loop possible store nod pointer access replacement rather spend second pass however algorithm still run linear time space complexity linearly dependent number different use access array every pointer separate entry map data structure array pass function legal pointer assignment find pointer use traverse array formal parameter function process use name array four loop nest perfect loop nest structure loop different simple loop way effect pointer loop body procedure statement map map count pointer loop body update map l l empty head l l contain array arithmetic update increment pointer array offset increment end end replace pointer accord map l l empty contain pointer reference look pointer array offset increment map look pointer local offset pointer local offset six end contain array access index increment offset local offset replace access array index else contain pointer arithmetic update local offset map end end end adjust situation end loop pointer map update offset map end multiply iteration range immediately enclose loop construct range outer loop therefore outer loop consider convert perfect loop nest handle perfect loop nest require extra pass loop sufficient detect perfect loop nest descent inner loop body keep track outer loop actual loop body reach conversion perform usual incorporate additional outer loop loop range part index function hence asymptotical complexity algorithm affect general loop nest similarly handle slightly extend version basic algorithm track loop pointer dependent upon introductory example illustrate general loop nest conversion table absolute time n section level pen array pointer array pointer eleven eleven eight nine nine eight eight eight best p e e p fifteen eleven zero five level fig one performance comparison n complex update four experiment pointer cleanup conversion algorithm implement prototype integrate experimental octave compiler application transformation level result code use input c version performance data collect execute program simulator real machine order quantify benefit apply pointer cleanup conversion program execution time program suite determine program explicit array access respect vary level calculate application developer typically want best performance determine level give best execution time pointer array cod separately due complex interaction compiler architecture highest level necessarily give best performance thus ratio best version best explicit array access version also present table show example absolute performance figure n section use state minimal execution time achieve highest available level thus reasonable give additional measure compare best explicit array base example execution time achieve version explicit array access base version hence best figure one six measure three level best p e e p fourteen twelve eleven eight six four two zero level fig two performance comparison performance combination usually benefit use explicit array access rather array access simple apply level zero program explicit array access significantly faster program difference n complex update higher level become smaller although original program take less time transform many case still performance gain expect pointer cleanup conversion program tend superior level si situation change level best case best case special interest since compare best performance program explicit array access base program best explicit array base program perform usually better least good best program one case dot product decrease performance could observe figure one result n complex update show rather complex program show achieve among test reach maximum level still compare best program contain series memory access successfully analyse explicit array base version easily amendable simple pointer analyse although large common evaluate program show clearly potential benefit pointer cleanup conversion figure two compare architecture one achieve typical set test program increase fourteen performance observe best explicit array base program version enable performance benefit transform form program even higher best p e e p fifteen eleven five zero level fig three performance comparison figure three four represent result respectively achieve level explicit array access base actually level highest level transform program perform better good original although small speed observable show use explicit array access penalty array still provide representation better suitable array data dependence analysis general pointer cleanup conversion substantial benefit achieve without need higher level transform program still perform better least good program evaluate program complex original program often perform good transform program higher level show figure one complex program conversion provide substantial advantage processor architecture additionally support instruction set make quite different however many signal process run processor commonly find therefore processor include evaluation level fig four performance comparison combination compiler produce result differ significantly performance program pointer conversion quite poor without level increase transform program often outperform original maximum transform program usually achieve level respectively fir p e e p fifteen eleven five zero p e e p fifteen eleven five zero best best level fig five performance comparison fir figure five result fir chart initially pointer transformation negative effect performance program observe higher level maximum achieve level compare two best still reach result represent figure six performance transform version inferior level increase performance increase six case best p e e p fifteen eleven five zero level fig six performance comparison general achievable architecture large yet clear whether consequence architectural influence different however increase performance observe processor particular higher level five relate work allan one use framework base c intermediate language induction variable substitution array access together pointer arithmetic loop regard induction convert directly dependent loop induction variable approach regenerate index supply equivalent pointer main objective produce loop suitable therefore method treat loop individually rather context whole function approach base heuristic mostly work efficiently although backtrack possible hence worst case solution inefficient information supply treatment loop nest multidimensional array case study reference architecture family eight mention briefly technique regenerate array index array traversal detail include give complementary conversion ie explicit array access access simultaneous generation optimal code study five two six conclusion contribution paper introduce new technique transform c code array access explicit array access support exist array data flow analyse approach implement integrate experimental octave compiler test suite result show reduction execution time generation efficient address generation code improve since modern able analyse array access generate code memory access rely use source level believe use explicit array access key automatic future work focus distribute computation data different make best use parallelism reference one randy compile c parallelization expansion proceed conference program design implementation june two de code generation digital signal university department electrical engineer june three e r practical data flow framework array reference analysis use proceed conference program design implementation six new four w c program language second prentice hall new jersey five rainer novel code cation research conference six j pointer analysis c thesis department computer rice university seven l lam effectiveness data analysis international journal parallel program one eight advance compiler design implementation morgan san nine digital signal process web site ten integrate loop data global pact parallel compiler technology press eleven efficient pointer analysis c program thesis university computer laboratory twelve v c h methodology proceed signal process technology thirteen h parallel vector press