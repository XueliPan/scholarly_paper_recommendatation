use manage hardware transactional memory operate system j e porter e bhandari department computer university bhandari abstract variant first operate system use hardware transactional memory synchronization primitive first manage paper describe measure discuss two detail lock integration os mix lock require new primitive transactional allow lock protect data maintain advantage synchronization allow system attempt execution critical automatically roll back use lock region perform io integrate eliminate priority inversion series similar performance expose concurrency many concurrent thread critical region subject processor parallel architecture operate process management program concurrent program general term design performance transactional memory operate optimistic concurrency synchronization one introduction chip currently norm major processor plan scale number core chip come possibly nod program challenge transactional memory gain attention technique reduce parallel program complexity maintain performance permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee seven copyright lock code achieve scalable operate system performance lock current synchronization thousand core come program code maintenance cost transactional memory help operate system maintain high performance reduce cod complexity transactional memory program model make concurrent program easier programmer delimit code access share data system execute atomically isolation buffer result individual restart execution isolation violate result schedule atomic programmer benefit several ways program state reason atomic execution large section code simplify performance optimistic execution come additional effort system enforce atomicity programmer burden reason partial lift well moreover suffer many challenge associate parallel program susceptibility deadlock lack hardware transactional memory provide efficient hardware implementation transactional memory appropriate use os general purpose operate benefit simplify program hardware transactional memory simply replace eliminate lock several reason propose design prohibit certain perform io large legacy system practical convert every instance lock use partial conversion require coexistence lock finally optimistic primitive perform well critical interfere conservative like lock usually perform better highly critical section introduce transactional primitive allow lock work together protect data maintain advantage current transactional memory require every execution critical section protect either lock transaction allow critical region sometimes protect lock sometimes transaction also current transactional memory design allow different critical access data structure protect transaction conventional lock enable novel way manage io within system dynamically automatically choose lock thread execute critical region transaction hardware detect thread attempt io operation write io port hardware prevent io request issue transfer control implementation ensure thread critical region exclusively block transactional thread finally provide convenient convert code use enable solution problem priority inversion due lock demonstrate necessary transactional memory hardware nearly eliminate priority policy inversion moreover os improve schedule help manage high contention leverage thread transaction history calculate thread dynamic priority conflict thread paper make follow one novel mechanism transactional synchronization critical region transactional call transactional thread favor greater parallelism enable two novel mechanism handle io within allow transaction perform io automatically restart execution acquire conventional lock three mechanism nearly eliminate priority inversion os schedule use information increase system throughput four convert operate system use hardware transactional memory synchronization primitive paper provide primer section two motivate os describe model explain basic issue add os code section three section four explain use tolerate io section five discuss user kernel transactional program model section six discuss modification nearly eliminate priority inversion use information increase system throughput section seven contain discuss relate work section eight conclude section nine two transactional memory primer section provide background hardware transactional mem ory operate along multithreaded make heavy use different synchronize access memory traditional include semaphore hardware transactional memory useful replacement poll synchronization sequence lock eliminate lock coherence cache miss generate simply specify code execute atomically isolation system provide globally consistent order revert state change do transaction transaction commit thread attempt conflict memory access execute transaction concurrently benefit performance modular thread execute transaction call module start another transaction second transaction nest inside first pattern transaction nest free deadlock different nest semantics explore literature flat nest flat nest data nest flatten one big transaction add support show table one specific implementation illustrate general start end transaction start transaction cause hardware buffer memory read write transaction end successfully commit update atomically make visible rest system transactional conflict occur one transaction intersect union another transaction read write set define set address read write transaction conflict compromise isolation transaction one transaction may proceed safety property call conflict efficient method transactional system provide provable isolation fifteen logic determine two conflict may proceed call contention manager due performance level contention management usually happen hardware complicate rare case handle lose thread conflict discard buffer change restart execution approach contention management may complicate asymmetric conflict conflict memory operation conflict transactional one complex conflict operation cause conflict involve two write location read many order make program easy modern primitive conflict asymmetric conflict definition instruction begin transaction instruction commit transaction instruction restart transaction instruction get current transaction identifier zero currently active transaction instruction save transaction state suspend current transaction use receive interrupt instruction restore previously save transaction state continue transaction use interrupt return value variable equal argument enter variable transaction transaction exist return true otherwise return false compare swap instruction subject thread contention manager policy one transactional thread write address read write another transactional thread thread read write address write read write transactional thread contention multiple thread attempt acquire resource access particular data structure encode information current transaction recent restart return include reason transaction status word table one hardware transactional memory design place limit size data contain transaction deal overflow hardware state call many recent literature include use direct hardware support os data structure nine ten backup transactional memory system unknown prevalent large even rare belief architecture community need support order provide good program model three os section motivate need within os describe hardware model call section discuss basic strategy challenge convert synchronization use f os benefit synchronization make os program maintenance difficult one comprehensive study bug eight bug involve synchronization another study thirteen find four confirm eight unconfirmed deadlock bug kernel complexity synchronization evident source file fifty line comment top file describe lock order use file comment describe lock use call depth four function file moreover lock modular component must know lock take another component order avoid deadlock lock many know disadvantage priority inversion convoy lack failure scale problem size complexity twenty transactional memory modular lock ease code maintenance reduce likelihood bug also provide performance allow multiple noninterfering thread concurrently execute critical section concurrency thus guide many model look like standard share memory chip use mechanism provide transactional memory design similar publish previously architectural interface list table one call kernel thread start transaction transactional thread thread execute transaction thread conflict detection eager first memory access cause conflict also cause one restart use eager version management newly write memory value store place old value copy undo log manage processor facilitate interrupt handle support multiple active single thread control thread stop current transaction use restore use see table one ability save restore lifo order allow interrupt use interrupt handler execute suspend current run transaction leave handler free use transaction status word use communicate information current thread transactional state four transaction status word return result status word indicate whether first execution transaction transaction restart transaction restart status word indicate reason p n l c k l l l c k f f e l c l r n e x f l c l r n e x c c h e p c l l c l r n e x zero p n n l c k l l l c k f b j p c c h e p f l g n e g f l e p n l c k l l l c k l l l b p l l l b f r e e p n n l c k l l l c k x b e g n f f e l c l r n e x f l c l r n e x c c h e p c l l c l r n e x zero b j p c c h e p f l g n e g f l e x b e g n l l l b p l l l b f r e e figure one simplify example lock function transactional equivalent restart restart due conflict manual restart instruction thread execute may also set cod communicate detail information reason restart transaction resume support flat nest short average cycle benefit small section four provide functionality handle io provide form suspend transactional context seven use os many large concurrent program require great programmer effort make lock protect minimum possible data figure one show example list lock kernel memory allocator drop work do acquire list lock would correct code hold call function lock release increase concurrency many kernel thread call concurrently one big feature transition series series reduce use big kernel lock single large lock create serial bottleneck series figure one show conversion code use hardware memory use example lock protect disjoint relate data prevent different thread execute two critical section concurrently allow concurrency concurrency lead performance keep critical section short important scalable performance benefit kernel response latency transactional need short critical achieve performance single thread lock critical section every thread must wait minimize critical section size paramount use lock contrast allow thread critical section depend memory access safely execute need make short critical easier reason maintain require less engineer effort similar performance code figure one make clear one straightforward ways introduce kernel convert lock acquire release transaction start end hold short instruction sequence rarely hold process sleep though happen process take page fault lock hold static instance kernel result convert also convert atomic like lock compare exchange instruction guarantee single operation atomically commit safely subsume indeed currently implement use mechanism similar use sequence lock form transaction current kernel loop read counter start loop perform read data structure need read counter end loop counter value match read loop exit lock increment counter start update data end fail read odd counter value mean writer update concurrent read convert restart conflict eliminate instruction overhead retry loop enable parallel execution though usually optimize mostly single several challenge prevent rote conversion operate system like use include semantic abuse lock function obscure control flow issue discuss detail section four transactional lock order ensure isolation must able roll back effect transaction lose conflict however roll back processor state content physical memory difficult perform part transaction example effect io roll back execute io part transaction break atomicity isolation transactional design guarantee know output commit problem twelve critical section protect lock restart may freely perform io order allow conventional lock operate system propose synchronization afford seamless integration call transactional allow different single critical section synchronize either lock freedom enable concurrency possible enforce safety lock necessary lock may use io protection data structure read hardware page table access particular data structure performance might suffer excessive restart also provide simple upgrade path let kernel use place exist synchronization necessary kernel allow user program model remain simple need directly access io block transactional critical region transactional one transactional thread enter time conflict lock variable good way perform io critical region revert outer transaction use mutual exclusion critical region lock thread always get exclusive access kick transactional thread critical region though transactional thread critical region lock thread defer contention manager decide transactional thread critical region critical region transactional multiple transactional thread critical region thread require mutual exclusion transaction restart revert table two summary happen various lock type call transactional thread direct user access common os design decision allow os safely multiplex among user program sophisticate user program want lock coexist use require use within use conventional within possible maintain mutual exclusion however approach lose concurrency lack fairness thread hold lock transactional thread spin lock release transactional thread acquire traditional lock write lock variable add lock transaction another thread either transactional try enter critical section must read lock variable conflict one thread must restart read thread transactional contention manager choose one thread restart read thread asymmetric conflict must decide favor thread transactional thread restart progress transactional tread unfairly throttle thread conventional prevent multiple transactional thread execute critical region concurrently even safe transactional thread acquire restart therefore perform io allow single critical region safely protect either lock transaction thread perform io inside protect critical section without concern undo restart many transactional thread simultaneously enter critical section protect share data improve performance simple return cod allow choice lock make dynamically simplify programmer reason transactional transactional lock primitive allow critical section protect transaction mutually exclusive lock require hardware support beyond simple model ensure set allow transactional code correctly use critical section maintain fairness high concurrency multiple transactional thread may enter single critical section without conflict lock variable thread exclude transactional thread enter critical section transactional thread poll without restart transaction especially important acquire nest thread do transactional work attempt acquire thread acquire use instruction arbitrate transactional contention manager contention manager implement many favor transactional thread thread acquire use two function function take lock address argument table two summarize semantics function well traditional function replacement safe almost lock do kernel page table lock lock whose ownership pass thread protect run queue optimistically attempt protect critical section use code path within critical section protect require mutual exclusion transaction restart acquire lock exclusively unlike pure transactional program critical protect necessarily execute isolation code path within critical section may force revert lock allow thread see intermediate update execution progress critical region control always require mutual exclusion always perform io optimize access data structure may execute transactionally use allow different critical synchronize mix assure maximum concurrency maintain safety table three show simplify state transition diagram transition three conceptual state free exclusive transactional implement identical data layout conventional occupy single sign thread lock order exclude thread enter critical section transactional thread make sure lock unlock enter critical section also make sure lock variable read set thread acquire lock write lock variable cause conflict restart transactional thread critical region remove critical region use transaction status word pass information transaction restart begin transaction use status word determine whether critical section may protect transaction revert mutual exclusion figure two show start transaction wait thread transaction start v c x p c l c k x b e g n use mutual exclusion require f close nest f g e x x r e r e l e r e r n c x e x c l v e l c k spin wait lock free one w h l e x e l c k one zero b l e n e r r p spin v c x e x c l v e l c k thread f x g e x x r e r w h l e one spin spin wait lock free w h l e l c k one b l e n e r r p acquire lock set zero contention manager arbitrate lock f x c l c k one zero b r e k e n b l e n e r r p v c x e n l c k f x g e x e l e l c k one e n b l e n e r r p figure two function acquire either mutual exclusion current choose lock disable interrupt disable interrupt show simply remove interrupt manipulation line code return status word check determine whether transaction restart mutual exclusion require critical section enter exclusively use mutual exclusion require thread wait unlock indicate zero thread critical section number transactional thread enter unlock critical section concurrently transaction hardware ensure isolation code poll lock use avoid add lock variable read set lock remain lock simple load would add variable read set matter state lock put lock lock read set transaction ensure transaction restart lock unlock restart harm performance especially nest call note instruction reduce power consumption lock poll pause instruction would reduce power consume poll loop code show interrupt disable return code figure two disable interrupt correspond function programmer choose function disable disable interrupt currently choose function disable disable event state ree thread proceed restart thread wait thread proceed thread wait thread pro invalid thread pro thread ree wait thread release one restart transaction thread wait wait thread ree wait exclusive thread release one exclusive thread wait atomic thread release atomic io transaction invalid table three simplify conceptual state transition table acquire thread cell format take state separate vertical bar initial state ree interrupt disable interrupt case show general simply eliminate interrupt manipulation code obtain simpler case use protect critical section use true mutual exclusion figure two first use detect active transaction active transaction transaction must also make exclusive code issue status code transfer control outermost transaction start indicate exclusion require active transaction thread enter critical section lock traditional test test set ensure one thread may enter critical section code spin wait lock value become one indicate lock free interrupt disable thread attempt grab lock instruction thread successful return lock hold interrupt disable unsuccessful interrupt retry mimic current way spin lock interrupt enable instruction let us contention manager set policy lock favor transactional thread mutually exclusive thread high priority thread many lock favor differ careful programmer control favor improve performance thread try obtain lock contention manager decide thread wait current refuse give lock writer current do manufacturer decide compare swap participate contention management order avoid add new instruction one key feature fairness transactional thread require primitive subject contention manager policy active transaction port memory access cancel operation affect hardware current transaction status set inform caller mutual exclusion require transaction restart well simple start without check return code transaction start call function might require exclusion initial check return code infinite loop possible kernel call know critical region never require hope efficient enough obviate need naked five user kernel transactional program model one guide design provide simple program model user program important program model operate system believe operate system need benefit transactional memory kernel program environment always terrain sacrifice generality benefit order successfully integrate lock fight battle lock order kernel mean fight user level additional benefit kernel use transactional hardware without overflow transactional hardware limit restart exclusive lock mode allow os virtualize without recursive problem though yet section discuss various make regard program model first discuss effort require modify use talk system call conclude frank discussion handle io convert combine basic information current transactional provide simple solution perform io within transaction operate system may initiate either port io detect io initiate processor case port io processor easily detect use io memory map io must already indicate processor mark page table recent processor may assume access memory represent io detect io convert use synchronization twice first time process consist use information highly content lock replace lock biggest hurdle process critical perform io protect simple process identify lock convert test difficult ultimately convert thirty dynamic call lock function use require effort five course nearly year line kernel source add modify file first conversion lock discover several use abuse lock amenable one example run queue lock lock one process context release context switch different process context another example one lock protect page table page table read hardware affect processor state roll back clear deal write page table transaction lock convert use second conversion use transaction use lock conversion require two effort single developer time spend work proper hardware support transparently replace call require addition single line source file difficult lock kernel like run queue lock convert use require line seven file io system call issue io transaction system call transaction often conflate current literature conflation harm program model system call make within user transaction isolate several forbid os start transaction call transaction believe operate system parallel program extremely complicate synchronization able benefit transactional memory system call even change state visible process actually change state io create write file file system change kernel data structure necessarily write anything disk buffer memory effect system call initiate user transaction io system call file perform synchronous disk write transactional interface file system require interface already present task io system call reduce make sure enough system available sequence system call complete update memory achieve os might need free system create free memory write back data disk cache unrelated current transaction order free kernel current transaction perform io outside transactional context enough information must leak transaction let kernel learn type amount must make available kernel free enough perform sequence system call use memory kill user process transaction important hardware limit like cache size support transaction whose update available memory io system call kernel provide full transactional program model even critical may modify device state result user able retain simpler transactional program model kernel able provide feature necessary complete transactional program model rollback strong isolation system call current conventional wisdom design transactional rollback system call handle user level strong isolation need system call four nineteen however sequence common system call impossible roll back user level necessarily maintain isolation transactional thread even among transactional thread degree necessary successful program model difficulty achieve strong isolation area future work allow critical section protect lock bring concurrency code previously would incompatible critical occasionally perform io however also reintroduce intend solve like enforce mutual exclusion thread poor lock discipline lead deadlock problem would normally solve unfortunate deadlock also possibility advance transaction model allow open nest unlikely require mutual exclusion use single global lock use single global lock simplify program without compromise performance critical region would mostly completely use addition could deadlock use combination would deadlock use problem arise nature flat nest thread may transactional enter leave another transactional critical section one protect flat nest even thread leave critical section data read write nest transaction remain part outer transaction data set suppose thread begin transaction transaction enter leave critical section protect thus start complete nest transaction thread begin another processor acquire lock attempt lock certain contention management always win conflict lock must wait complete transaction even though already leave associate critical section attempt enter critical section protect lock must wait wait progress make critical section example protect lock deadlock would occur would release lock soon leave associate critical section thus would hold one lock simultaneously require convolute execution traditional deadlock might easier avoid static check tool transactional memory suppose make programmer life easier allow lock appear make programmer life difficult however convert little effort resultant code easier maintain hold longer code without compromise performance rarely hold exclusive merge use smaller number lock simplify maintenance experience convince us data structure greatly simplify transactional memory however synchronization primitive powerful make parallel program easy six schedule section first describe allow os communicate schedule hardware conflict manger hardware subvert os schedule policy discuss modify decrease amount work waste transactional conflict priority policy inversion lock invert os schedule priority result thread wait thread like deal priority inversion priority inheritance wherein wait thread temporarily donate priority thread hold lock recent implement priority inheritance well priority inheritance complicate technique shorten length priority inversion eliminate moreover require conversion block conversion provide upper bind latency face priority inversion slow response time overall eliminate problem contention manager system nearly eradicate priority inversion contention manager invoke one transaction intersect union read another transaction contention manager resolve conflict favor thread higher os schedule priority experience priority inversion however one fact escape many hardware though simple hardware contention management invert os schedule priority focus simple hardware contention management guarantee free deadlock transaction win policy deadlock refresh transactional transaction eventually become system succeed process higher os priority start transaction process lower priority start one conflict policy allow lower priority process continue violation occur higher priority process force restart lock invert schedule priority schedule policy well support soft process like allow thread synchronize thread synchronization policy inversion thread wait thread policy inversion serious priority inversion process regular process higher priority os treat differently process exist always schedule process priority inversion many contention management bring policy inversion lock domain contention manager respect os schedule policy largely eliminate policy inversion contention management use os priority eliminate priority policy inversion provide interface os communicate schedule priority policy hardware contention manager suggest abstract implement novel contention management policy call policy hybrid three contention management first prefer action schedule value os give small number schedule priority value tie conflict priority rare next employ policy show give good performance low hardware complexity transaction size equal employ encode process dynamic schedule priority schedule policy single integer call conflict priority communicate hardware write register process schedule process register write os user code change value instance schedule policy might encode upper conflict priority schedule priority lower value sufficient record priority value process upon detect conflict contention manager favor transaction whose conflict priority value policy free deadlock conflict priority compute instruction execute os never change conflict priority lifetime transaction equal default default set size equal hence conflict priority size age induce total order make policy free deadlock transaction conflict priority change active transaction process reschedule different dynamic priority value conflict priority dynamic schedule priority differ priority inversion still possible case rare fact actually occur experiment priority also occur due asymmetric conflict case memory operation thread conflict data transaction thread always decide conflict favor operation simply ing memory operation result unbounded latency memory operation lose timer interrupt well sensitive state thread lower process priority transactional one priority inversion occur way prevent inversion contention manager involve problem occur use strong isolation five since strong isolation require consistent policy respect asymmetric conflict thread always win always lose fortunately conflict rare properly synchronize program rarely access data transactional context schedule presence hardware system provide opportunity operate system take advantage process transaction state mitigate effect high contention make schedule assign dynamic priority current transaction state relevant current process work invest active transaction system may wish reschedule process sooner reduce likelihood contention work lose restart process restart repeatedly may make sense make schedule make future contention less likely account impact transaction state system throughput make better schedule improve overall performance order ensure schedule work provide os query hardware communicate transaction state os support modify take information account make schedule useful information include existence currently active number recent restart cycle spend back size transaction read write set use transaction status word determine status current transaction none active stall overflow hardware counter one per provide saturate count number restart maintain hardware last transaction begin implement contention policy register hold current transaction size another hold cumulative number cycle current transaction back restart register write transactional hardware potentially reset os read use information dynamically adjust priority process likely repeat restart detail default follow use describe previous section maintain transactional profile track restart cycle average profile attribute high restart high cycle maintain use exponentially move average general profile attribute reset every examination transaction profile fundamental build block use enable dynamic priority dynamic priority base state use routine call calculate dynamic priority process whenever process transfer active expire array indicate use quantum process active transaction reward priority boost otherwise process high restart rat tendency conflict penalize large reward attempt thread waste work due restart quickly possible timer interrupt call function current thread transaction profile indicate high probability significant work waste current quantum due restart conflict thread caveat suitable replacement candidate thread must available run instead suitable replacement must within five priority level preserve guarantee must also likely waste work due conflict multiple criteria use predict thread may profitably average cycle current process exceed cost context switch threshold determine average measure context switch time predict thread profitable similarly process high restart rate average implementation previous timer interval process candidate reschedule seven evaluation section present detail experiment show performance generally good sixteen though uncover one performance pathology core kernel spend less twelve time synchronize opportunity improve performance synchronization limit scale use add kernel section remove primary reason eschew engineer effort add incompatibility io priority inversion common occurrence kernel ability nearly eliminate encourage result transactional program ability use transaction state information little ability affect performance study find effort best direct avoid transactional performance experimental setup base implement hardware module thirty machine simulator architecture four model assume one instruction per cycle allow constant one reasonable choice moderate implementation level one cache sixteen cache line cache hit cache miss penalty data cache contain transactional data second level cache four associative cache line cycle miss penalty main memory cache coherence maintain snoop protocol main memory single share configuration typical reasonably approximate disk device model data transfer fix access latency model time network interface card support data transfer link fix latency run script user interaction use conflict detection exponential conflict contention management policy use simulation allow make os hardware schedule contention management fee back simulation change thread order application provide realistic model multithreaded tend variable performance sense small change thread schedule introduce noticeable jitter execution time compensate variability perturb cache miss time order sample space reasonable thread interleave use statistical approach wood two produce confidence perturb run use describe table five characterize term user system io wait idle time figure three large exercise kernel realistic fix amount work usually thread scale amount work processor count execute occur kernel since kernel use experiment measure behavior kernel exercise run zero latency disk performance disk latency highly dependent block layout remove disk delay al characterization idle user system n c e twelve ten eight six four two zero p c six one x n l p c two three x n l p c six one x n l p c two three x n l p c six one x n l p c two three x n l p c six one x n l p c two three x n l p c six one x n l p c two three x n l p c six one x n l p c two three x n l find figure three user system io wait idle time sixteen characterize use unmodified slab allocator cache zone page frame allocator architecture memory file object noncontiguous memory kernel memory allocator extensive use lock lock protect directory entry cache access file use place implementation protect private share nonlinear within address space physical memory zone active inactive list synchronize include lock sequence lock protect variable lock protect list contain process list process memory protect access list open file protect doubly link list physically noncontiguous memory table four kernel alter use instead lock subsystem name correspond directly index six low analysis focus portion independent file system layout mention section perform two first conversion call subsystem kernel do hand show table four second call kernel convert nearly use sequence lock convert use convert synchronization performance measure time waste due synchronization percentage kernel execution time synchronization time waste spin lock time simulate file system bottleneck activity squid inn stress instance n one run disk delay find configure run several parallel instance configure script large package one processor run instance find command different directory search file kernel text string find directory contain file file system simulate development forty run one instance per processor modify without compile phase run make j two compile source file total line code source tree parallel locally develop stress synchronization directory entry cache parallel rename across multiple file table five use evaluate synchronization characterization abort spin g n z n r h c n n e p e l e n r e k f e g n e c r e p sixteen fourteen twelve ten eight six four two zero p c six one x n l p c six one x n l x p c two three x n l p c six one x n l p c two three x n l x p c six one x n l x p c two three x n l x p c six one x n l p c six one x n l x p c two three x n l p c two three x n l x p c six one x n l p c six one x n l x p c two three x n l p c six one x n l p c two three x n l x p c six one x n l x p c two three x n l p c six one x n l p c six one x n l x p c two three x n l p c two three x n l x find figure four time lose due restart acquire spin lock sixteen experiment first bar represent second represent subsystem kernel time break acquire restart whereas synchronization time acquire waste spin lock also restart figure four show spend execution time synchronize sixteen configuration waste average less time synchronize waste one time save attributable remove cache miss lock variable measure time spend spin bias result favor data show number increase time waste synchronize also increase generally reduce time waste synchronization double time lose loss performance due primarily ninety restart continue fail since substantial creation deletion small file single directory result contention file system code result pathological restart behavior function link count directory manipulate list directory entry appear effectively starve use restart technique handle high contention may insufficient complex transaction system may need queue consistently complete remain ten performance loss attributable large overflow transactional memory state cache incur cost conflict detection version management overflow data many virtualize grow large hardware data indicate importance scheme however issue could address use protect critical region create transaction difficulty complete hardware module measure number time acquire number cycle spend acquire number time process spin acquire lock test test set lock count inner test outer test set loop separately table six present detail lock behavior show reduce lock contention eliminate call lock eliminate call lock test loop fifty test set loop reduce number test set important use coherence hardware reduce system throughput lower lock contention convert heavily lock use allow multiple transactional thread critical region concurrently another interest trend sixteen number lock acquire increase substantially amount spin increase three indicate amount time spend synchronization tolerable synchronization overhead impediment large system concurrency order measure degree concurrency provide compare lock transactional thread upon enter critical section record number transactional thread critical section figure five show histogram maximum concurrency critical section use many kernel critical single thread execute indicate even highly tune critical benefit execute parallel critical region thread sequence lock read kernel tick counter frequently execute function critical region guard sequence lock may also contain many concurrent thread however necessary reason type access protect data single primitive add concurrency critical many optimize low lock contention get convert lock average concurrency critical low amount time spend critical small compare total kernel execution time average transaction size grow reflect ability achieve high concurrency critical section average maximum concurrency increase find nine sixteen sixteen sixteen sixteen sixteen sixteen twenty six fourteen forty fifty thirty eighteen table six performance unmodified subsystem kernel represent number time test test set lock acquire test represent number time processor spin cache lock value test set represent outer loop lock code perform cache coherent lock decrement percent reduction example sixteen perform lock outer loop acquisition perform result reduction data available maximum concurrency across critical section processor n c e l c r c eighteen ten eight three eight six two four one one one one two one one two one one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty thirty maximum concurrency figure five distribution maximum concurrency across critical section find performance use one main advantage traditional low overhead lock unlock acquire uncontended lock body function execute three include two memory reference acquire already lock nine execute addition time spend wait unlock usually require one instruction acquire involve complicate logic normal introduce overhead number execute call begin transaction uncontended critical section require nine memory reference use enter uncontended critical section thread require eight memory reference case reference except one stack optimize access stack reference contribute minimal additional latency n c e l c r c io transactional critical section six one two two one one one zero ten thirty twenty eighty restart io seventy sixty fifty forty ninety figure six distribution across critical section percentage require restart io measure find sixteen practice performance near traditional average across introduction result kernel time sixteen respectively contrast subsystem conversion use sixteen subsystem kernel twenty slowdown average exclude whose discuss section become nine garner twenty case change performance within confidence interval measurement justify increase complexity must exist critical kernel require exclusion along code figure six show often io perform critical protect restrict critical contain io along least one code path several critical perform io along small percentage dynamic code may benefit majority however perform io nearly time critical optimize replace even case enable additional concurrency lock share critical always perform io critical never perform io coarse lock protect ide subsystem sometimes use protect device access sometimes use protect simple data structure critical contain io may execute concurrently even share data critical always require mutual exclusion table seven show amount time waste restart io current implementation io operation number transaction restart equal nest depth io operation execute however average nest depth execute io show table low io nest three level perform lot io hence lose time io restart time waste restart io mostly time spend idle io restart happen right suspend last runnable process process block io nearly identical contention management use os priority figure seven show frequently transactional priority inversion occur case priority inversion mean default contention management policy favor process lower os schedule priority result time io origin origin nest waste three three three find sixteen sixteen sixteen sixteen table seven usage nest average nest depth io execute waste total time waste due restart io percentage kernel execution time show percentage originate system call interrupt respectively data give subsystem kernel tamp similar show percentage transactional conflict result priority inversion average across kernel test priority inversion tend decrease number trend strict show increase higher processor count unmodified modify respectively number distribution transactional conflict chaotic change number change conflict behavior policy inversion thread favor conflict thread much find occur rat one two respectively conflict management policy eliminate priority inversion policy inversion entirely cost performance one frequency naive contention management violate os schedule priority argue strongly mechanism let us os participate contention management communicate hint hardware schedule goal schedule take advantage availability transaction state information hardware increase performance primarily make schedule attempt decrease lose work due restart figure seven percentage transaction restart decide favor transaction start processor lower process priority result transactional priority inversion result show sixteen pipeline consist multiple thread four number work set eight phase memory reference make thread mostly distinct phase thread work phase contention high unlikely one thread time make progress execution generally overlap safely thread different phase figure nine show normalize execution time able improve performance eight six four eight respectively benefit sixteen close confidence total number restart total restart cycle waste reduce respectively average show transaction aware schedule potentially help manage contention relate negative performance impact low contention eight relate work transactional memory root optimistic synchronization optimistic concurrency control moss give one design hardware transactional memory goodman explore speculative transactional execution critical section spark renewal interest fall back lock violation isolation detect dynamically similar though general primitive technique first execute transactional context fall back lock io detect current work focus architectural provide transactional memory three nine eighteen support seven fourteen transactional resource four ten several transaction involve os four nine ten level os involvement vary none actually allow os use synchronization paper go beyond architecture address issue arise use os discuss os support operate make heavy use nonblocking include synthesis cache kernel sixteen nonblocking eliminate deadlock minimize interference schedule synchronization require specialization code data structure unlike use io io fall three basic camp give isolation escape hatch delay io transaction commit seventeen nineteen guarantee thread perform io commit serious many allow transactional escape hatch know open nest transaction open nest transaction read partial result current transaction change make include io isolate major drawback open nest enclose transaction restart effect transaction must undo code provide programmer programmer effort write maintain compensate code severely compromise utility efficient hardware open nest introduce correctness condition restrict transactional program model condition subtle easy violate common program figure eight restart cycle percentage total execution time sixteen percentage restart cycle give theoretical upper bind performance benefit achievable schedule policy attempt minimize restart waste normalize execution time p c four p c eight p c six one figure nine relative execution time pipeline four eight sixteen figure eight show cycle spend restart percentage total execution time use unmodified kernel opportunity improve performance eliminate restart limit average savvy schedule eliminate waste restart cycle overall performance gain sixteen would one average across statistically margin give confidence able achieve simulation environment execution time within fifteen provide neither consistent benefit consistent detriment performance policy attempt thread contention indicate restart profile thread result ability policy positive effect rely heavily presence contention availability thread similar priority able make progress schedule place thread schedule policy reduce restart may minimal impact contention low average impact contention high react contention ameliorate extreme condition ways possible traditional lock test hypothesis develop call simulate multithreaded application significantly longer high contention critical delay io possible code perform io depend result device register read might return status word os must interpret order finish transaction guarantee transaction commit severely limit flexibility highly result serial bottleneck deadlock thread conflict guarantee thread force retry stall guarantee thread commit work likely lead lose timer interrupt deadlock kernel schedule al seven demonstrate wherein thread listen conflict behalf yield thread technique require dedicate core thread wasteful os scale bind size transaction set amass explore os allow modify task state raise invoke provide mechanism thread involve transactional conflict attempt thread involve multiple restart mechanism entirely control os put directly mercy hardware process schedule receive early attention operate invigorate arrival operate six implement sophisticate different class variety schedule class bilge al one explore hardware support priority inheritance use approach use hardware support priority inheritance provide upper bind priority inversion work take advantage transactional hardware avoid priority inversion occur patch support priority inheritance help mitigate effect priority inversion work also address priority inversion patch implementation convert change primitive block primitive rely react inherit priority contrast policy allow contention manager nearly eliminate priority inversion without require primitive block involve transactional memory transactional memory use hardware support usually work language level much recent work efficient fourteen work relevant use interface hybrid system try run small hardware effectively hardware eleven os heavy memory share include share stack memory must handle architectural feature interrupt challenge literature contain rich set contention manager fifty also contain work lock lock acquire much faster transaction start scheme virtual machine start guard critical section lock convert transaction contention high case opposite lightly efficient lock nine conclusion paper first description operate system use synchronization primitive present innovative schedule lock demonstrate provide comparable performance lock simplify code coexist synchronization modern os primitive enable solution problem io ease conversion lock significantly introduction synchronization primitive os reduce time waste synchronize average occur traditional lock high contention critical section sufficiently large overhead become aware schedule eliminate priority inversion investigate enable better management high contention ways possible traditional lock however unable impact performance normal contention profile ten extend thank prince jeff napper careful read draft shepherd hank levy valuable feedback research support cise research infrastructure grant career award j award student travel scholarship support sun present paper conference eleven reference one b e v j h thane p hardware support priority inheritance two wood variability architectural multithreaded three c k b c lie unbounded transactional memory four c j e c lewis k martin make fast case common uncommon case simple unbounded transactional memory five c e c lewis k martin atomicity fourth annual workshop duplicate debunk six understand kernel media edition seven b h j c c k transactional program language eight j yang b study operate nine w g j v g b unbounded transactional memory ten j c h b c k transactional memory press eleven p lev v hybrid transactional memory twelve e wang survey thirteen k effective static detection race condition fourteen ar al compiler support efficient transactional memory j j k e l yen hill b swift wood support nest transactional memory e moss nest transactional memory model preliminary architecture sketch fifteen j gray transaction process morgan edition j e b moss n h graham abstraction recovery management fifteen two sixteen synergy j e b moss l nest transactional nonblocking synchronization operate system structure memory model architecture sketch science computer program volume seventeen l v wong b j forty j k operate get faster b prabhu h c k transactional memory coherence consistency june eighteen l v wong b j b k prabhu h c k transactional memory coherence consistency nineteen atomic block program three twenty memory synchronization j e moss transactional memory architectural support data structure may e porter c j h e e solve difficult without difficult hardware transact workshop corporation architecture developer developer hybrid transactional memory h kung j optimistic concurrency control six two june l concurrent read write b w schedule philosophy eleven five j r r transactional memory morgan fast hardware summer c experiment kernel four gazette r j goodman speculative lock elision enable highly concurrent multithreaded execution micro r j goodman transactional execution program r k lai transactional memory h c porter bhandari e evaluate transactional memory h c e kernel challenge transactional memory workshop transactional memory june v hart internals patch symposium internals server press edition architectural support transactional memory micro page fifty w n l advance contention management dynamic transactional memory h j concurrency revolution queue three seven tucker process control schedule issue c j p b ar q thirty p j e al full system simulation platform computer h c pu os kernel operate system review two j b c h c k architectural semantics practical transactional memory l transparently reconcile lock synchronization l yen j k e h hill swift wood hardware transactional memory cache r j internals prentice hall c l extend hardware transactional memory support wait action transact workshop edition corporation transactional k e j j hill wood transactional memory