transactional application program interface chi martin computer laboratory university abstract transactional memory simplify parallel program support atomic isolate execution task date program require use make difficult achieve scalable performance code easy develop maintain program become practical important integrate familiar parallel program paper present application program interface parallel program extend widely use parallel program set compiler express nonblocking synchronization speculative parallelization base memory also present portable implementation produce code hardware hybrid implementation build upon support compiler include c program language evaluate performance feature show deliver performance lock program simplicity lock compare transactional program remove burden manual access share enable easy change schedule contention management overall provide practical efficient program environment within familiar scope one introduction transactional memory sixteen emerge promise technology address difficulty parallel program multicore chip simply declare certain code section execute atomic isolate respect code concurrency control multiple execute parallel responsibility system several propose base hardware eleven hybrid eighteen six achieve widespread use must integrate practical familiar program date program primarily base include special function define transaction manipulate share data control system approach sufficient initial experimentation small program inadequate large project nonexpert code difficult comprehend maintain port scale since programmer must manually annotate access share data library also complicate static analysis reduce effectiveness compiler two paper present application program interface parallel program extend popular one compiler necessary express nonblocking synchronization speculative parallelization use memory provide simple interface express transactional parallelism identify role key provide schedule contention management hint code efficiently map variety hardware hybrid also tune optimize compiler dynamically schedule system specific work define set support nonblocking synchronization speculative parallelization use transactional memory apart integrate memory construct parallel loop section address issue nest conditional synchronization schedule contention management international conference architecture compilation pact describe implementation c program language environment base support compiler produce executable code hardware hybrid implementation easy port system provide basic interface transactional functionality evaluate performance feature parallel program use variety program show code simple compact scale well rest paper organize follow section two review section three introduce section four describe first implementation section five six present quantitative evaluation section seven review relate work section eight conclude paper two overview widely use parallel program one specification include set compiler library environment follow parallel execution model master thread begin program execution sequentially master thread encounter parallel construct create set worker thread execute code inside parallel construct construct encounter work divide among concurrent execute end construct every thread team resume execution code parallel construct next opportunity implicit barrier end parallel construct master thread execute user code beyond point memory model share memory relax consistency three thread perform load store access share memory parallel directive support two type within correspond structure block share private variable reference within block original variable name exist outside parallel construct access share thread access original variable private thread private copy original variable provide five class parallel synchronization data environment library parallel directive start parallel construct describe parallel work iterative loop parallel section code pattern follow simple example parallel loop parallel n b twenty synchronization construct critical barrier allow thread access data environment describe share attribute reference parallel finally specify set use synchronization schedule detail specification several available one three language syntax construct design extension support nonblocking synchronization speculative parallelization use transactional hence inherit execution model memory semantics program legitimate program code parallel sequential behave exactly describe specification discuss interaction new feature certain feature section transactional model transactional model base three key implicit support implicit programmer simply define transaction within parallel block without additional access share data memory execute implicitly transactional state order guarantee atomicity isolation implicit minimize burden require compiler hardware support order implement transactional bookkeeping compiler insert necessary hardware perform bookkeeping background transaction execute regular load store two even hardware support compiler highly profitable another advantage implicit simplify reuse programmer reuse function implicit without reconsider necessary transactional bookkeeping new context strong isolation program memory atomic isolate respect access also exist consistent order commit access whole system property know strong isolation necessary correct international conference architecture compilation pact predictable transactional code nineteen hardware hybrid six guarantee strong isolation compiler must insert additional read write outside order implement strong isolation require underlie system support bound execution time memory footprint nest depth system guarantee correct execution even exceed schedule quantum exceed capacity hardware cache physical memory include large number nest level expect majority four ten six naturally expect even infrequent handle correctly transparent manner challenge use hardware cache physical address transactional bookkeeping exclude performance agnostic exact method use support four nine eight basic construct follow basic par program transaction introduce specify transaction construct strongly isolate syntax transaction clause clause follow order clause one nest order use specify sequential commit order transaction different thread useful speculative parallelization sequential code specify generate unordered yet unordered useful nonblocking synchronization parallel code execution underlie system detect conflict access share order guarantee atomicity isolation conflict system abort base order scheme contention management policy discuss nest clause along advance feature section note definition transactional loop construct specify loop execute parallel atomic syntax clause clause reuse construct private reduction identify private reduction respectively certain extend add specify transactional associate loop body order clause specify commit sequential order imply loop sequential semantics speculative loop parallelization order specify generate unordered imply unordered loop potential construct specify loop construct three schedule clause first parameter specify loop schedule across worker thread see discussion section second parameter identify number chunk size assign thread every schedule decision chunk size schedule overhead load balance across thread third parameter specify many loop execute per transaction worker thread transaction size specify iteration execute separate transaction transaction size overhead transaction higher probability conflict follow code example use perform parallel histogram update case statically schedule across thread chunk size unordered six per transaction void histogram bin schedule bin user also define use transaction construct within loop body construct approach allow write tune code smaller loop body may reduce pressure underlie system hand require better understand within loop body slightly cod effort transactional section support parallel section parallel task use construct syntax clause clause one two international conference architecture compilation pact compare section use additional order clause specify sequential transaction order section imply structure block prove parallel independent express parallel task potential similar loop case transactional section also specify use transaction construct within section follow simple example speculative parallelization use construct order advance construct basic construct discuss sufficient express parallelism wide range nevertheless also introduce advance construct support recently propose program construct require advance feature underlie system alternative execution construct support alternative execution abort fifteen two syntax transaction one two transaction block one successfully commit entire operation complete block two never execute transaction block one abort reason code associate construct execute atomic transaction program cascade arbitrary number construct alternative execution conditional synchronization support conditional synchronization atomic use retry routine retry indicate transaction block due certain condition fifteen system decide whether transaction immediately correspond thread suspend transaction use watch routine notify system monitor set address block transaction one update seven follow simple example conditional synchronization within transaction transaction empty else queue compare atomic block condition fourteen two conditional synchronization retry allow complex block condition occur anywhere within transaction moreover approach place additional specification block condition example programmer use array indices specify condition finally retry fifteen note retry call transaction also use transaction abort control transfer immediately alternative execution path nest nest clause specify nest behavior nest specify use default abort due without cause parent abort memory update become visible thread outermost transaction commit open clause allow program start transaction abort independently parent make update visible immediately upon commit regardless happen parent transaction may require finalize compensate action execute outermost transaction commit abort respectively thirteen expect many use directly helpful address performance issue implementation additional program construct transaction handler construct specify invoke transaction commit abort follow semantics present handler syntax transaction clause clause one handler clause two clause one follow commit abort violation violation refer rollback trigger dependency abort invoke transaction handler construct associate transaction construct code provide example abort handler use compensate transaction international conference architecture compilation pact routine transaction get description abort retry watch set get return true execute within transaction return current transaction abort current transaction retry current transaction add address seven set contention management scheme return current contention management scheme table one extra transaction transaction nest open end transaction handler abort end parent transaction system also extend system support transactional execution table one summarize additional library available loop schedule construct provide four schedule across worker thread static dynamic guide static schedule statically distribute work thread dynamic schedule assign chunk thread upon request guide schedule similar dynamic schedule chunk size decrease exponentially avoid work imbalance schedule make decision dependent environment variable one reuse add additional task group loop group dynamic guide manner system use feedback minimize overhead small without run overhead higher probability conflict contention management provide two present table one control contention management scheme underlie system twelve get routine return type currently use contention management scheme set routine allow user change contention management scheme whole system use interface adapt contention management improve performance robustness provide fairness guarantee twelve exact set depend available example current implementation support simple back scheme require parameter specify maximum number retry abort transaction get priority commit mature correspond contention management integrate open issue discussion certain subtle issue initial specification take conservative approach several case however expect practical experience transactional research advance compiler support provide sophisticate future synchronization allow use synchronization construct within critical atomic barrier synchronization construct block semantics lead strong isolation use within also disallow use within synchronization construct deadlock retry use general separate transactional code block synchronization help reason correctness code point block semantics atomic critical also primary reason introduce nonblocking transaction construct reuse atomic critical program could lead incorrect result exist program io system call require call within parallel similarly require call within challenge transactional permanent side effect io system call currently propose specification implementation responsible specify library call safely use within well commit abort semantics ongoing research integrate io system call use buffer serialization nest parallelism moment allow user code spawn extra worker thread within transaction relax conflict detection recent paper propose exclude certain conflict detection race exclude motivation reduce bookkeeping overhead unnecessary conflict moment include multiple reason first without strong understand algorithm use easily lead incorrect unpredictable program behavior second directive international conference architecture compilation pact code current implementation base full compiler specifically extend gnu environment implementation consist four main parser intermediate representation code generator library extend four follow manner support parser extend identify validate generate correspond report generic intermediate extend represent feature interface describe table two similar code generator perform code include correspond expansion call library static single assignment code generation stage implementation generate code hardware hybrid figure one summarize code generation process user code write c modify target different system guide compiler produce code right system compiler target single interface see table two may use subset interface target specific system example hardware require use read write compiler implement conventional common elimination specific system two finally code link library system library provide implementation interface successfully use implementation three hardware system similar system eleven hybrid system six implementation target system support assume interface support virtually hence implementation target use currently introduce compiler two note compare relate work optimization somewhat reduce target unmanaged c c instead manage language like c interface table two present interface target compiler interface describe basic functionality hardware hybrid h specify function require hardware figure one overview first implementation base syntax static quite limit respect describe array indices pointer finally private share already provide mechanism identify participate conflict detection concurrent nevertheless future examine inclusion early release thirty compilation issue must guarantee function call within transaction instrument bookkeeping function partial compilation use compiler may able statically identify function case programmer must use function directive identify function may call within transaction compiler responsible clone function order introduce instrumentation code necessary steer control proper clone point time compiler freely reorder code within guarantee update perform make visible rest system atomically transaction commit four first implementation early stage work implement use translation framework twenty translation allow us quickly develop portable prototype two important first limit degree compiler apply code hybrid eliminate redundant register impact performance full compiler framework exist compilation pass implement two translation framework type scope limit second translation complicate code development tool like must do level translate output instead user compiler system specific binary international conference architecture compilation pact interface void void void void bool validate void abort void type void type void void data void data bool description make start transaction commit transaction make start transaction commit transaction validate current transaction abort current transaction register handler transaction type commit violation abort function pointer handler invoke handler set contention management policy contention management type return contention management current policy get transaction monolithic transactional read barrier monolithic transactional write barrier insert address transaction conflict detection decompose read eager insert transaction create undo log entry lazy insert allocate entry return address lazy search address find read value otherwise return value regular memory location use certain compile time word write transaction check address conflict h table two interface target compiler code generation respectively hybrid require function function may implement differently across eager lazy eleven version management sufficient control execution memory give implementation interface compiler generate correct code system first set function table two provide thread begin commit abort common across type also require register invoke abort commit conflict second set function provide read write necessary transactional bookkeeping hybrid support monolithic decompose monolithic enough correct execution decompose reveal compiler optimization two system system current implementation extend system small set library table one system support dynamic schedule transactional loop also provide basic support contention management use simple policy conditional synchronization currently implement immediate retry support suspend thread conditional synchronization currently progress also plan integrate system profile tool order feature cache network cache main memory description core line private associative one cycle latency bus split protocol line share associative twelve cycle latency cycle latency eight outstanding transfer per signature register table three simulate multicore system improve schedule efficiency five experimental methodology environment use simulator model multicore coherence support hardware hybrid table three summarize simulate architecture except load store ten however detail memory hierarchy time include contention queue model hardware system cache enhance support lazy version management optimistic conflict detection hybrid system use hardware accelerate conflict detection six data perform apart hardware need also use sun system eleven run top conventional multicore system without hardware international conference architecture compilation pact piler output system run real machine however run code simulate system facilitate three hardware hybrid use four one evaluation six seventeen implement mesh generation graphics render genome application perform gene sequence data mine algorithm cluster object k partition base attribute vacation similar implement travel reservation system power histogram multiple thread concurrently update array histogram bin computational work vacation use two input lead different frequency conflict concurrent develop code use execute concurrent task operate various share data structure graph tree parallel cod level easy programmer understand manually manage within data structure code parallel code close sequential algorithm result behavior account comparison develop additional application code directly use interface available system library develop another transactional version code similar parallelization due syntax version tend cumbersome develop provide expose level lock implement simply replace transaction lock release lock implement use lock granularity possible order maximize concurrency code quite difficult tune port programmer responsible concurrency management example vacation show simplicity program figure two present vacation programmer simply use transaction construct specify client request run parallel atomic need prove request independent use lock manage infrequent code achieve good performance underlie system implement optimistic concurrency conflict client request void transaction begin transaction switch action case case end transaction void main parallel figure two vacation application file extra c line genome vacation sixteen zero zero eight three three zero zero zero eleven zero eight zero eighteen zero zero eight zero zero two zero zero zero zero eight zero four ten ten six zero two one seven twenty ten zero zero zero eight zero eleven zero eleven two zero zero zero zero eight table four number extra line c code need parallelize application use lock interface hardware particularly common use lock require similar program effort scale due serialization better achieve use lock expense user must manage lock tree traverse update potentially manner avoid six evaluation quantify program effort difficult task require extensive user study nevertheless table four show number extra line c code need parallelize application use lock interface construct one indication cod complexity interface present two set result hardware programmer must define transaction programmer must also introduce table four report result international conference architecture compilation pact figure three application lock lock interface lock code essentially identical code hardware system compare code require significantly program effort user must manually orchestrate access share state apart identify example code require optimistic parallelization place burden user detect handle conflict concurrent cavity use lock seventeen apart extra code programmer must make sure deadlock contention manage reasonable manner code programmer simply identify memory concurrency management responsibility system include conflict detection contention management dynamic schedule also advantage directly use interface use interface require manual instrumentation optimization load store access within transaction obvious case vacation instrumentation code lead code size increase tricky handle programmer introduce redundant impact performance two programmer miss barrier program behavior incorrect unpredictable depend input environment eliminate automatically introduce optimize share compilation find approach advantageous even target hardware system need case code transformation often require distribute loop implement dynamic schedule genome code also difficult change make change chunk size transaction size case code require simple parallelism memory relatively easy understand maintain reuse without require expert program performance comparison figure three present four code application scale number two sixteen higher better relative sequential version application two assume hardware support provide figure four present execution time sixteen normalize sequential execution time bar break time execute useful time cache miss idle synchronization time transaction commit time time spend abort violation code compare favorably code expect code scale due serialization lock code exhibit excellent scale three vacation penal international conference architecture compilation pact figure four normalize execution time sixteen figure six normalize execution time histogram sixteen use various contention management dynamic schedule use histogram histogram bin update vary amount computational work imbalance figure five present sixteen static version use static clause statically schedule loop interleave fashion chunk size one dynamic use dynamic clause dynamically schedule loop chunk size one simplicity set transaction size equal chunk size dynamically schedule scale significantly better statically schedule one eliminate work imbalance dynamic due eliminate schedule overhead smaller chunk size frequently access global work queue allow imbalance frequent transaction abort chunk size note change schedule policy chunk size transaction size simple require global code change case use contention management also use histogram showcase usefulness contention management figure six present normalize execution time sixteen various contention management leftmost bar represent execution time without contention management soon transaction abort immediate retry remain bar represent execution time simple contention management policy transaction abort use linear transaction abort time request execute high priority transaction win conflict concurrent reduce amount waste work multiple thread operate data priority mechanism provide fairness across thread long starve figure five histogram sixteen static dynamic schedule c represent chunk size overhead acquire release lock search update tree structure code scale well across program code marginally faster code due overhead abort optimistic concurrency fail hand code marginally genome significantly vacation faster code avoid overhead lock management figure three four also capture performance code code since utilize hardware support perform similarly system scale use simpler syntax lead performance issue genome code faster due better schedule contention management use approach similar difficult introduce tune code system dynamic schedule demonstrate usefulness execution execution international conference architecture compilation pact seven relate work parallel program topic long history research development paper relate approach one recently research program transactional memory similar parallel wang al propose c program language optimize c compiler support proposal differ work build top instead focus issue propose integrate system include feature along language construct express manage parallelism dynamic schedule al propose program environment use order support speculative parallelization support order unordered recognize nonblocking synchronization important speculation also lack full program construct advance feature help develop optimize transactional parallel work al propose extend support proposal define transaction construct similar one include implementation base translation addition transaction construct define construct feature conditional synchronization nest transactional contention management moreover implement use approach nevertheless reasonable merge two unify set program several investigate support manage fifteen two seven use similar construct program exploit dynamic code generation type safety feature infrastructure target unmanaged c c focus synergy program transactional nonblocking synchronization speculative parallelization eight paper present parallel program extend familiar environment support nonblocking synchronization speculative parallelization use memory also present first implementation base compiler system produce code hardware hybrid include system figure seven histogram code run hardware hybrid due conflict smaller five figure six show reduction execution time use contention management also demonstrate importance tune contention management policy low value priority mechanism use frequently cause performance loss due serialization hardware system use transaction use priority mechanism transaction commit even conflict detect high performance loss long repeat multiple time cause imbalance system overall contention management important robust performance allow provide hint order guide system address contention challenge code generation result thus far execution code hardware system however compiler produce code hybrid well figure seven present achieve code histogram three available us expect hardware system eliminate overhead transactional bookkeeping hybrid system address system provide two performance improvement detail comparison three implementation approach beyond scope paper see six detail figure seven demonstrate code map variety proper compiler environment provide scalable portable way build efficient parallel program international conference architecture compilation pact dynamic schedule contention management feature evaluate performance environment show deliver good performance simple portable code overall provide practical efficient program environment within familiar scope currently improve compiler system introduce improve schedule conditional synchronization add contention management scheme also investigate language feature nest parallelism relax transactional semantics cognitive finally intend environment order encourage application development experimentation transactional memory would like thank anonymous feedback various stag work also want thank sun make code available work support career award number grant number contract support graduate fellowship scholarship reference one application program interface specification version may two ar b lewis al compiler support efficient transactional memory proceed program language design implementation june three v k share memory consistency els tutorial computer twelve four c k al unbounded transactional memory proceed computer architecture five j k e al performance hardware transactional memory proceed computer architecture page new york press six c al effective hybrid transactional memory system strong isolation guarantee proceed computer architecture june seven b al transactional proceed pro program language language design implementation june eight w al unbounded transactional memory proceed architectural support program operate nine j c al transactional memory proceed architectural support program operate ten j h al common case transactional behavior multithreaded program proceed computer architecture eleven dice al transactional lock proceed distribute compute sept twelve r al robust contention management transactional memory workshop synchronization concurrency thirteen atomic block workshop concurrency synchronization program fourteen k language support lightweight proceed action program fifteen al memory proceed practice parallel program sixteen j e b moss transactional memory architectural proceed support data structure computer architecture may seventeen kulkarni k al optimistic parallelism require proceed program lan design implementation june eighteen al hybrid transactional memory proceed practice parallel program new york march nineteen j r transactional memory morgan synthesis series twenty lee al extensible compiler infrastructure transformation proceed workshop parallel compute j al characterization proceed parallel compilation sept j al architectural semantics practical transactional memory proceed computer architecture june r al transactional memory proceed workshop june k e j al transactional proceed high memory performance computer architecture automatic parallelization proceed summit june b ar al high performance transactional memory system multicore proceed practice parallel program march b ar al architectural support proceed ware transactional memory micro w n l advance contention management dynamic transactional memory proceed distribute compute v al enforce isolation order proceed program language design implementation march thirty c early release friend foe workshop transactional memory c l al implicit parallelism order proceed practice parallel program march c wang wy al code generation optimization transactional memory construct unmanaged language proceed code generation optimization march international conference architecture compilation pact