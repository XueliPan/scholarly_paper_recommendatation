necromancer enhance system throughput animate dead core amin advance computer architecture laboratory university michigan ann arbor mi shoe abstract aggressive technology scale regime lead host reliability challenge last several unlike cache efficiently protect use conventional scheme general core area less homogeneous structure make tolerate defect much challenge problem due lack effective disable nonfunctional core common practice industry enhance manufacture yield result reduction system throughput although faulty core trust correctly execute program observe work defect start valid architectural state execution trace defective core actually coarsely resemble light insight propose robust heterogeneous core couple execution scheme necromancer exploit functionally dead core improve system throughput supply hint regard program behavior partition core conventional system multiple group group share lightweight core substantially accelerate use execution hint potentially dead core prevent undead core wander far correct path execution dynamically architectural state lightweight core system average approach enable couple core achieve performance fully function core defect tolerance throughput enhancement come modest area power respectively subject performance reliability reliability test general term design reliability performance manufacture defect heterogeneous core couple execution abstraction permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten june copyright one introduction rapid growth silicon process last decade substantially improve semiconductor integration level however aggressive technology scale lead host reliability challenge manufacture defect parametric ten nine affect correct program execution one computer system four traditionally hardware reliability concern tandem nonstop apply redundancy triple modular redundancy acceptable nevertheless hardware reliability already become major issue compute usage reliability acceptable one main challenge semiconductor industry manufacture defect direct impact yield process generation next become susceptible manufacture defect due higher sensitivity random attach wafer surface lithography issue exposure tool optimization clean technology resist process optimization eighteen thus order maintain acceptable level manufacture yield substantial investment require traditionally modern declare functional part design operate correctly tolerate however since manufacture defect significant yield loss semiconductor company recently start manufacture part hedge defect instance improve yield cell engine sometimes seven eight process activate base latest report nineteen current near future technology one manufacture defect per five die expect fortunately large fraction die area devote memory structure particular cache protect use exist redundancy three disable one appropriate protection place cache process core become major source defect vulnerability die consequently try tackle part process core due inherent irregularity general core area handle defect part challenge common solution core disable two however industry currently dominate chip modest number core core two afford lose core due manufacture defect extreme solution spectrum lie redundancy twelve break structure isolate replace maintain core functionality unfortunately since majority core logic fault coverage approach limit less ten processor work propose necromancer tackle manufacture defect current near future technology nod enhance overall system throughput mitigate performance loss cause defect part core accomplish first relax correct execution constraint faulty core undead core since trust faithfully execute program next leverage high level execution information hint undead core accelerate execution animator core animator core additional core introduce older generation core less instruction set architecture main rationale behind approach fact defect instance execution flow program undead core coarsely resemble program execution animator core start architectural state ie program counter architectural register memory moreover animator core hint treat performance influence execution correctness rely intrinsically robust hint effective hint disable ensure animator core mislead unprofitable hint dynamic state also employ update undead core valid architectural state whenever stray far correct execution path increase design efficiency share small animator core among multiple core scheme unique sense keep undead core execution path ultimately enable animator core achieve performance close performance live core addition noticeably increase design complexity core easily apply current near future enhance overall system throughput two utility undead core motivate design demonstrate rationale behind end provide evidence support follow two one although aggressive core area trust perform normal operation still provide useful execution hint case two exploit hint undead core animator core typically achieve significantly higher performance effect program prior work study effect upset transient fault program execution use show transient fault often mask easier categorize temporal effect program behavior hand effect program execution hard study since result complicate intertwine behavior example multiple data finally mask effect moreover persistent effect go away result dramatically corrupt program execution order illustrate negative impact program execution study average number commit mask l f r h e c e j n f e g n e c r e p eighty sixty forty twenty zero figure one distribution inject manifest architectural state mismatch across different term number commit serve architectural state mismatch result injection experiment across depict figure one detail monte engine statistical fault injection infrastructure target system suite find section experiment golden execution compare architectural state faulty execution every cycle soon mismatch detect stop simulation report number commit point instance look inject architectural state mismatch happen less commit since uniformly stress different core show higher vulnerability figure show forty inject immediate architectural state mismatch thus faulty core trust provide correct functionality even short program execution relax correctness discuss program execution dead core trust try determine quality program execution dead core relax absolute correctness word interest know expect level correctness dead core practically execute large chunk program base inject figure two depict many commit dead core get considerably correct execution path order practical system dead core able execute program reasonable time execution become ineffectual define similarity index si measure similarity commit dead core golden execution program si calculate every whenever become less threshold stop simulation record number commit instance similarity index thirty value mean instruction window thirty hit exactly instruction cache line golden execution program execution dead core figure two show number commit three different si instance consider si threshold ninety average twelve render program execution dead core ineffectual least get commit hence even si threshold ninety case dead core successfully commit least execution differ ten mask l f r h e c e j n f e g n e c r e p ninety eighty seventy sixty fifty forty thirty twenty ten zero nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three nine six three average figure two number commit inject result violation similarity index threshold purpose inject consider three different similarity index ninety sixty thirty acceleration since execution behavior dead core coarsely match intact program execution long time take advantage program execution dead core accelerate execution program another core do extract useful information execution program dead core send information hint core animator core run program allow undead core run without require absolutely correct functionality undead core responsible provide helpful hint animator core symbiotic relation two core enable animator core achieve significantly higher performance hint lose effectiveness architectural state two core since architectural state two core system take cycle case happen least commit overhead associate small purpose evaluation since want single system base availability data power area use alpha twenty core hand animator core select simpler core like alpha alpha save add extra core system order evaluate efficacy hint figure three show performance boost alpha core use perfect hint perfect branch prediction cache miss also consider version potential option animator core see employ perfect hint outperform case thus demonstrate possibility achieve performance close performance live core system nevertheless achieve goal quite challenge due presence defect different source imperfection hint communication issue three traditional couple animation system prior work show two core couple together achieve higher performance since overall performance couple core system bound core two core traditionally identical tain acceptable level performance however order accelerate program execution one couple core must progress program stream faster order three propose sixteen core run ahead leader core receive execution hint checker leader core operate different cut frequency safety margin leader core continuously compare architectural state exclude two core mismatch happen frequency leader adjust state match enforce finally interval roll back speculative parallelization need two different program scheme leader core run shorter version program base removal ineffectual checker core run unmodified program finally two pass six execution forty allow leader core return invalid value proceed although scheme widely vary implementation scheme detail share common leader core try get ahead send hint accelerate checker core execution two core connect fifo hardware queue transfer hint retire along checker core take advantage program execution leader core three ways first checker core receive instruction data stream second program execution leader core branch get resolve third program execution leader core automatically initiate cache checker core straightforward extension animate dead core seem plausible however encounter major try fit dead core execution model briefly describe two main challenge leave propose subsequent section one main source presence defect dead core due presence defect undead core might less number cause similarity program two core instance many case undead core take wrong direction statement get back right execution path afterwards thereby prevent original performance performance four v e e z l r n c p seven six five four three two one zero four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e five v e six v e four v e four v e four v e four v e four v e four v e four v e four v e four v e four v e four v e four v e four v e four v e average figure three different alpha normalize case provide perfect hint simpler core core achieve performance comparable achieve perfect data instruction stream animator core necessitate employ generic hint resilient local moreover number time visit use synchronize two core mechanism require help animator core identify proper time pull hint communication queue give variation usefulness hint order enhance efficiency animator core hint disable leverage instance last k branch prediction hint particular useful branch prediction particular handle animator core branch predictor global undead core get completely correct execution path hint become useless need bring back valid execution point purpose architectural state animator core copy undead core although exact state match register file use prior work sixteen applicable animate dead core since architectural state mismatch occur frequently therefore need monitor effectiveness hint large time period decide whether undead core animator core moreover cheap relatively infrequent avoid noticeable impact overall performance animator core one possible approach maintain correct memory state suggest refetch access last interval cache leader core sixteen however since might happen often dead core need approach require substantial book keep four architecture main objective mitigate system throughput loss due manufacture defect purpose leverage robust flexible heterogeneous core couple execution technique discuss rest section give group core introduce animator core older generation share among core defect tolerance purpose section describe architectural detail couple pair dead animator core design system core discuss next section section two show faulty core undead core trust run even short part program however relax exact architectural state match look global execution pattern undead core execute moderate portion program require execute program undead core provide hint accelerate animator core without require multiple program word undead core use external engine animator core add system believe valuable solution improve system throughput current near future without notably influence design complexity system description figure four illustrate heterogeneous couple core design discuss section two purpose evaluation use core animator core design unidirectional undead core animator core exception hint disable signal thus single queue use send hint cache fingerprint animator core hint gather unit attach tag queue entry indicate type queue get full undead core want insert new entry stall preserve correct memory state allow dirty line undead core data cache write back share cache result dirty data undead core simply drop whenever require replacement exception han e r c e n e h cache fingerprint hint gather queue l e h fet dis mem signal hint disable information hint distribution hint disable fe de di ex h e n r c r e memory hierarchy share cache figure four architecture show figure modify add underlie core highlight draw scale two port busy one port busy free port busy port free port e l c c n c e x e r g r p f e g n e c r e p ninety eighty seventy sixty fifty forty thirty twenty ten zero ninety eighty seventy sixty fifty forty thirty twenty ten zero e l c c n c e x e r g r p f e g n e c r e p port activity animator core cache b port activity animator core cache figure five port activity breakdown local cache animator core show percentage cycle cache port either busy free animator core data cache two port instruction cache single port also disable undead core since animator core maintain precise state discuss section two animator core perfect hint potential surpass average performance live core nonetheless performance undead core bottleneck system since many case figure three performance core worse performance animator core perfect hint b undead core need branch predictor local cache therefore allow undead core proceed data cache miss without wait several hundred cycle need receive data back main memory simply return zero since miss common also value prediction would beneficial large impact performance undead core potentially shorten period give ability eliminate stall miss also semiperfect hint undead core potentially achieve even higher performance live core nevertheless provide even semiperfect hint challenge due defect undead core queue size limit performance undead core queue delay natural program behavior use heterogeneous core couple program execution prune core significantly smaller area compare core rely undead core multiple program furthermore approach transparent operate system os also require register file perform exact state match two core instead employ fuzzy hint disable approach base continuous monitor hint effectiveness initiate appropriate hint disable also help enhance performance save communication power program phase undead core get ahead animator core apart undead core might occasionally get correct execution path take wrong direction statement return correct path afterwards order make hint robust two core also execute leverage number commit hint synchronization attach number every queue entry age tag moreover introduce release window concept make hint robust presence particular hint type release window help animator core determine right time utilize hint instance assume data cache release window already commit animator core hint age tag pull queue apply hint gather distribution program execution undead core automatically share cache without require communication two core however hint ie data cache instruction cache branch prediction hint need send queue animator core hint gather unit undead core responsible gather hint cache fingerprint attach age type tag finally insert queue side hint distribution unit receive compare age tag local number commit plus correspond release window size every cycle hint gather unit look commit data instruction cache hint fact commit address commit load store consider hint respectively animator core side hint distribution unit treat incoming hint information local cache animator core figure five depict utilization two port single port give cache access see port busy less five cycle therefore leverage original cache port apply hint however since hint potentially help program execution priority access always give normal operation animator core hand port busy fifty cycle three free instruction fetch queue full moreover since operation critical sustainable performance add extra port cache animator core order provide branch prediction hint hint gather unit look branch predictor update every time undead core get update hint send queue animator core side default simple bimodal predictor firstly add extra bimodal predictor keep track incoming branch prediction hint furthermore employ hierarchical tournament predictor decide give whether original take design space exploration size structure determine section mention introduce release window size get hint need however due number execute undead core even release window guarantee perfect time hint scenario subset tournament predictor give ad branch prediction release window size ten commit code sum zero zero j zero j two j sum sum j alpha assembly code one one one sum zero two two two zero three three three j zero four zero five load one zero five sum sum j three one three j five one five pointer proceed three two six j two two one two two seven six seven chronologically sort branch prediction hint send undead core age tag take take take take take take take take take nine fifteen entry different time animator core number commit take take nine fifteen take take take take take take take perfect branch prediction non take take take take take take take figure six code example perform poorly switch original animator core require code simply calculate summation store format note branch prediction release window size normally set branch prediction accuracy entire execution get maximize see hint receive animator core improper time result low branch prediction accuracy vantage original animator core avoid performance penalty mind figure six show simple example achieve branch prediction accuracy mainly due existence tight inner loop number loop body less release window size low trip count switch original enhance overall branch prediction accuracy code region another aspect dual core execution potential hint speculative execution speculative path turn correct path path eventually commit correspond hint send animator core hand wrong path although send hint potentially accelerate execution speculative animator core acceleration decrease efficiency hint correct instance animator core execute wrong path faster bring useless data local cause data nonspeculative drop therefore clear send hint speculative merely hurt performance system reduce communication order reduce queue size communication traffic need limit beneficial hint consequently hint gather unit use two content several discard hint recently send eliminate redundant hint also minimize resource contention animator core side purpose two keep track last n number cam commit address undead core addition send less number hint queue size reduce send less per hint save number do several ways send block relate address hint ignore hint speculative branch prediction hint send lower use update branch history table give design multiple communication queue undead core stall least one queue full want insert new entry queue queue full stall remain thus use single aggregate queue guarantee higher utilization reduce area overhead number stall interconnection wire hand since single queue use multiple might need send receive queue cycle solve group together several hint age tag send single packet queue require small buffer hint distribution unit handle case hint nonidentical release size hint disable hint disable longer beneficial animator core might happen several reason first program execution undead core get correct execution path due destructive impact defect second certain phase program performance animator core might close ideal case attenuate value hint lastly certain part program due intertwine behavior system animator core might able get ahead undead core hint disable help four ways avoid occupy animator core hint buy performance benefit queue fill less often mean less number stall undead core disable hint gather distribution save power en side serve indicator undead core stray far correct path execution ie hint frequently disable require hint disable unit responsible realize type hint get disable order disable cache hint cache fingerprint unit generate cache access information base commit last disable time interval last commit fingerprint send queue compare animator core cache access pattern base threshold value similarity access pattern animator core decide whether cache hint disable happen addition hint get disable hint remain disable time period call period precisely cache fingerprint unit retain two table keep track nonspeculative access last disable time interval figure seven illustrate example cache disable consider hint correspond table several eight example entry commit animator core absolute difference absolute value eighty sixty forty twenty zero cache disable table undead core eighty sixty forty twenty zero eighty sixty forty twenty zero bar threshold value disable cache hint resolve branch result n n n n branch predictor n n n n n original branch predictor animator core n n n instantaneous score cumulative score one one zero one one zero one one one two zero two zero zero zero zero disable time interval cumulative score two threshold value cache disable table disable cache hint disable branch prediction hint b disable branch prediction hint figure seven two cache branch prediction hint disable value plot correspond eight cache disable table ted whenever address match rank order entry therefore cache disable table maintain distribution address access last interval end interval table content send queue animator core clear next interval give similar cache access distribution animator core side evaluate similarity two undead core animator core calculate k si k example less threshold signal send undead core stop gather particular hint period disable branch prediction hint solely do animator core apart original animator core subset also employ global disable branch prediction hint purpose continuously monitor performance performance compare original worse threshold last disable time interval disable branch prediction hint figure seven b depict branch prediction hint disable use scheme single counter every branch original either correctly predict action take nonetheless branch correctly predict original score counter one similarly original correctly predict score counter finally end disable time interval score counter two example less certain threshold branch prediction hint disable period perform infrequent add hint disable unit since undead core might get correct execution path mechanism require take back valid architectural state order use two core animator core architectural register value get copy undead core accord modern processor process copy register value core take order cycle moreover undead core squash rename table reset content also invalidate memory state happen undead core get correct execution path longer provide useful hint animator core policy every n commit n constant number like however show section dynamic policy achieve higher overall system take advantage hint disable information identify happen aggressive policy every time hint get disable however policy result many short time clearly reduce efficiency scheme another potential policy point time least two hint get disable later section compare potential design far describe heterogeneous couple core execution approach architectural detail discuss figure eight illustrate design system four cluster model sun rock processor cluster contain four core share single animator core show order maintain design employ cluster design build block although single animator core might share among core introduce long interconnection wire travel one corner die another one r e c l three r e c l cache bank data switch cache bank cache bank cache bank cache bank core l l c c e e r r two two l l c c e e e r r four four hint gather hint gather animator core hint gather hint gather figure eight design large system sixteen core model sun rock processor four core per cluster detail core couple find figure four therefore give low area overhead discuss section propose build block preserve design hand since many die order avoid disable animator core core leverage accelerate operation live core one possibility use animator core exploit speculative parallelism spawn extra thread move animator core execute method call original thread execute code follow method return leverage return value predictor base observation dependency infrequent however evaluation latter beyond scope work heterogeneous system problem slightly difficult due inherent diversity core therefore share animator core multiple core might possible since core different computational potential solution partition system group core group contain core similar performance therefore group share animator core different alternative partition core group group several large core small core original set heterogeneous core group smaller core capability operate conventional core animator core defect one core group dual purpose core suitable fit many heterogeneous come bunch simpler core cell processor design since animator core share among multiple core reasonable shift animator core side avoid replicate module core instance similarity match structure hint disable locate animator core side furthermore since undead core run significantly ahead animator core program stream communication queue also closer animator core reduce time overhead access queue check age tag finally disable hint longer beneficial allow undead core avoid gather send hint save side five evaluation section describe experiment perform quantify potential enhance system throughput experimental methodology order model heterogeneous couple core execution heavily modify validate cycle accurate simulator base five run two different simulator implement undead animator core use inter process communication model information flow two core hint cache fingerprint mention choose animator core respectively configuration two couple core memory system summarize table one simulate suite alpha early study effect manufacture defect system develop monte fault injection engine iteration monte simulation structure select random single fault inject time simulator table two summarize fault use experiment since every transistor table one target system configuration parameter animator core core width two per cycle six per cycle reorder buffer queue issue queue sixteen instruction fetch queue eight branch predictor tournament bimodal tournament bimodal branch target buffer size branch history table return address stack data cache cache cache main memory three cycle latency two port two cycle latency two port five cycle latency four port five cycle latency one port unify fifteen cycle latency cycle access latency probability defective distribute across structure proportion area therefore fault injection experiment inject artificially structure area fault inject one one course individual experiment result point time single fault undead core give operational frequency scale technology node would result frequency frequency pessimistic value animator core clearly achieve even better overall performance animator core allow operate higher frequency nevertheless since amount work per pipeline stage remain relatively consistent across alpha give supply voltage level technology node peak operational frequency different core essentially dynamic power consumption core evaluate use thirteen leakage power evaluate area core exclude io pad interconnection wire unit cache control logic derive order derive area animator core table two fault injection correspond pipeline stag along area breakdown pipeline stage area breakdown fault location fetch decode rename dispatch program counter branch target buffer instruction fetch queue input latch rename alias table integer register file float point register file reorder buffer integer integer multiplier integer divider float point float point multiplier float point divider queue zero four sixteen effect release window size data cache miss rate animator core b effect branch history table size overall branch prediction accuracy animator core two four eight sixteen hint two hint four hint eight hint sixteen one nine eight seven six five four three two one zero e c c n r n n h e h c c f n average c effect cam size use reduce number hint generate undead core data cache miss rate animator core line show number data cache hint send animator core per cycle normalize case without cam zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine zero five zero seven zero eight zero nine nine nine average number commit animator core branch prediction hint disable different branch prediction hint disable ie fifty seventy eighty ninety e r e h c c forty thirty twenty fifteen ten five zero e r e h c c fifty forty thirty twenty fifteen ten five zero l f r h e c e j n f e g n e c r e p ninety eighty seventy sixty fifty forty thirty twenty ten zero fifteen three two one zero five e r c r n e h r n e c n r f r e p c r c c n c e r p h c n r b ninety eighty e r c r n e h r n e c n r f r e p fifteen five two one zero e effect different overall couple core normalize performance animator core f effect communication queue size overall couple core normalize performance animator core figure nine design space exploration system describe table one start publicly available area breakdown resize every structure base size number port furthermore cacti use evaluate delay area power cache memory structure add design branch prediction table evaluate generator module provide artisan memory compiler moreover standard industrial tech library use evaluate remain miscellaneous logic shift register finally area interconnection wire couple core estimate use methodology intermediate wire pitch take road map nineteen experimental result section evaluate different design ing occasional feedback effectiveness hint program execution finally figure nine e f show impact different communication queue size achievable respectively two plot normalize performance animator core consider four policy consist one static three dynamic police static policy occur periodically commit dynamic number disable hint determine whether require since aggressively exploit hint rarely disable policy invoke first disable hint achieve better finally sensitivity communication queue size present figure nine f although seem queue always better extremely large queue enable undead core get far ahead animator core pollute cache unprofitable value remain identify similar fashion release window size four commit branch prediction release window size four commit hint cam size two branch prediction hint disable threshold seventy similarity hint disable threshold seventy similarity hint disable threshold eighty similarity hint disable table size hint disable table size give parameter value average achieve animator core simulation set queue delay fifteen cycle cache however since couple core design highly minimal sensitivity queue delay instance even set delay cycle affect final less one performance impact different order highlight impact fault location achievable system figure ten depict performance breakdown result fault describe table two result row plot normalize average achieve couple core particular do eliminate come inherent suitability core couple see harmful consist integer instruction fetch queue another interest observation like reaction defect significantly differ conclude two main point plot first average fault drastically impact gain second give fault location different show various susceptibility thus heterogeneity across run system help achieve higher suitable assign couple core summary benefit figure eleven demonstrate amount achieve couple core different number core see achieve higher overall number core increase system average couple core achieve performance live core essentially provide appearance core animator core achieve different base defect type location run system assume full utilization mean always one job per core hence heterogeneity across run system figure ten animator core different across highlight impact row result normalize average achieve couple core particular design space achievable presence defect performance impact different area power finally throughput enhancement design space exploration fix architectural involve design since variety hardware policy due space present subset exploration interest exploration initially assign nominal value select proper value parameter use update value reminder experiment figure nine depict design space exploration prune set figure nine release window size vary zero commit monitor data cache miss rate animator core see optimal window size ie sixteen commit maximize efficiency give number commit undead core miss rate even optimize reduce figure nine b illustrate effect reduce branch history table size branch prediction accuracy animator core save area limit size cause less five reduction achievable branch prediction accuracy size hint cam sword impact miss rate communication traffic show figure nine c increase cam size reduce communication traffic queue size however aggravate efficiency hint reason send hint increase likelihood data present local animator core need nevertheless use cam two reduce number transmit hint thirty affect miss rate less five next figure nine illustrate effect vary threshold disable branch prediction hint inject record number commit branch prediction hint disable result process depict five different threshold value ie fifty seventy eighty ninety high similarity branch prediction hint mostly disable even instruction commit animator core consequently select seventy similarity hint disable occur frequently still e r c r n e h r n e c n r f r e p fifteen two one zero five animator core necromancer couple core live core necromancer specific structure undead core interconnection wire queue necromancer specific structure animator core animator core net overhead e h r e v f e g n e c r e p eighteen sixteen fourteen twelve ten eight six four two zero one core two core four core eight core sixteen core performance animator core couple core live core normalize average performance animator core due higher heterogeneity across system core achieve higher overall b breakdown area power different number core see impose animator core typically major component get amortize number core grow figure eleven summary benefit scheme different number core area power area power area power area power area power opportunity exploit evaluation do conduct monte simulation iteration select one core allow replication select figure eleven b show breakdown area power scheme assume single core system assume share per core see area overhead gradually shrink number core grow since cost animator core amortize among core nevertheless since simply replicate build block construct four core area overhead remain term power overhead two point note first base target defect rate four core animator core remain disable contribute power consumption next result show less eight core undead core remain ahead animator core need stall queue get full stall time undead core consume dynamic power account net overhead animator core figure eleven b finally discuss base expect defect rate current near future average one defect per five manufacture die expect case defect one original core apply scheme hand animator core communication queue specific like hint gather unit faulty simply disable animator core rest system continue normal operation six relate work manufacture defect different part get corrupt prior work defect tolerance mostly focus cache since less homogeneity part core make defect tolerance challenge issue typically server design reliability design constraint tandem nonstop seven fifteen seven replication employ eight isolation two high availability chip architecture partition core multiple fault allow independent redundant however dual triple modular redundant incur term area power generally acceptable compute easy solution disable faulty core avoid yield loss clearly cause reduction system throughput sale price two simple core disable approach take sun maintain acceptable level manufacture yield core cannibalization seventeen suggest break core pipeline stag allow one core borrow stag core interconnection network introduction interconnection network processor pipeline present performance power consumption design complexity challenge redundancy maintenance use bulletproof fourteen spar array structure eleven vein al propose method disable nonfunctional execution faulty small array structure register file rescue mainly technique map faulty pipeline spar thirty however show scheme limit applicability due small amount redundancy exist modern processor architectural core salvage architectural use thread migration core guarantee correct execution avoid incorrect execution instruction assess whether fault location might exercise correspond thus without use extra redundancy applicable defect ten core area diva four propose dynamic verification complex employ checker pipeline rerun instruction stream ensure correct program execution give fact diva defect tolerant scheme show four catastrophic core processor failure result slowdown detour completely approach leverage binary translation handle defect execution register file apart limit defect type handle binary translation layer typically apply core seven conclusion since manufacture defect directly impact yield maintain acceptable level manufacture yield defect need address properly part core less structure homogeneous thus tolerate defect general core area remain challenge problem work present necromancer architectural scheme enhance system throughput exploit dead core although dead core trust perform program two n p n p j e smith z purser k e study defect execution flow start valid architectural state coarsely match intact program behavior long time period hence necromancer rely correct program execution dead core instead expect undead core generate effective execution hint accelerate animator core order increase necromancer efficacy use provide intrinsically robust hint effective hint disable dynamic state system average approach enable couple core achieve performance live core defect tolerance throughput enhancement come modest area power respectively believe valuable solution tolerate manufacture defect improve throughput current near future eight thank anonymous referee valuable comment research support national science foundation grant arm limit nine reference one j j p chaparro x vera low cache highly predictable performance annual international symposium page appear isolation build high availability commodity multicore annual international symposium computer architecture page three armor cache high defect density annual international symposium four diva reliable substrate deep submicron design annual international symposium page five e infrastructure computer system model two six r e n j w j patel n w w beat stall annual international symposium page seven w l commercial fault tolerance tale two dependable secure compute one one eight b p r j j nonstop advance architecture international conference dependable network page june nine k scale tutorial presentation ten design reliable unreliable challenge transistor variability degradation micro six eleven f bower p g j tolerate hard fault array structure international conference dependable network page twelve f bower j mechanism diagnosis hard fault annual international symposium page thirteen brook v framework power analysis annual international symposium computer architecture page june fourteen k plaza j b v bulletproof switch architecture international symposium computer architecture page fifteen w r r carter p g defect tolerance custom computer symposium custom compute machine page sixteen b j improve performance core international conference parallel compilation page seventeen j fabric construct resilient multicore annual international symposium page eighteen status future lithography sub device lithography workshop nineteen international technology twenty r e alpha micro nineteen two j kim n k b j c hoe error tolerant cache use error cod annual international symposium r k n p p heterogeneous multicore potential processor power reduction annual international symposium page r n chip annual international symposium page li p r k v accurate fault model study hardware fault international symposium computer architecture page comprehensive error detection simple core micro one n r n p optimize wire large cache cacti sixty micro page architectural core salvage multicore processor tolerance annual international symposium computer architecture page appear june annual international symposium page b f j core cannibalization architecture improve lifetime chip performance multicore processor presence hard fault international conference parallel compilation thirty e n rescue defect tolerance annual international symposium computer architecture page e g b automatically characterize large scale program behavior tenth international conference architectural support program operate page new york p c exploit redundancy defect tolerance international conference computer design page l parallel enterprise server fault tolerance historical perspective journal research development six e sperling turn heat please j v p bose j exploit structural duplication lifetime reliability enhancement annual international symposium computer architecture page june n j wang j patel come fork road take international conference parallel compilation page n j wang j j patel characterize effect transient fault processor pipeline international conference dependable network page june c h r z trade cache capacity reliability enable low voltage operation annual international symposium computer architecture c f w highly cache architecture embed computer architecture news two forty h execution build highly scalable instruction window international conference parallel compilation page c g speculative parallelization annual international symposium page