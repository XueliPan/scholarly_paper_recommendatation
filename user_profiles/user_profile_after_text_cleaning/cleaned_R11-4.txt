optimal query evaluation weight business process milo university university yam university abstract business process short consist set achieve business goal combine flow among maybe infinitely many possible execution flow often interest identify flow important accord weight metric paper study follow problem give specification weight function execution flow query number k identify k flow highest weight among satisfy query provide first time provably optimal algorithm identify weight flow give use efficient query evaluation one introduction business process short consist set combine flow achieve business goal typically design via use standard specification language three compile executable code logic capture specification tool query analyze possible execution flow short specification extremely valuable company six single typically induce large possibly infinite recursive set possible among often interest subset relevant analysis subset describe via query since number query answer qualify may extensively large even infinite important identify important notion importance capture weight metric depend analysis goal paper consider problem find give specification weight metric number k research partially support ministry science grant science foundation binational science foundation faculty development award grant permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee article volume present international conference large data base proceed endowment vol three one copyright endowment weight specification provide first time provably optimal algorithm identify weight give algorithm utilize efficient query evaluation intuition kind analysis one may interest correspond query weight metrics let us consider simple example assume give shop mall virtual shop various customer mall may interest buy player overall price suppose among possible contain purchase two query one weight achieve user first subscribe customer club result may suggest subscription beneficial even entail registration fee alternatively suppose user interest minimal ship time another weight case prefer flow may purchase store another example owner may inter identify weight lead purchase query answer may use instance target relevant personalize several weight function interest may combine form single weight metric formally study query evaluation first propose generic model weight weigh assume choice take bear weight denote eight choice weight throughout aggregate obtain weight denote f w eight flow weight example eight may price product choose give point likelihood user click give store link first case summation may use aggregation may use multiplication follow common practice eleven require aggregation monotonic progress flow capture practical total price shop cart subset exceed price full cart even presence discount deal important note eight give choice may vary different point may depend course flow far previous instance price give product may reduce user previously subscribe customer club buy two vendor likelihood click certain store link may depend store previously visit thus eight model function whose input include choice also information history thus far derive equivalence relation capture much eight give choice affect precede provide algorithm whose complexity polynomial count class size specification linear size output study set follow common practice eleven employ instance reflect well give algorithm perform compare possible class show f w eight function dictate set general monotone f w eight function show algorithm optimal even instance optimal however consider class monotone function arise frequently practice show still optimal algorithm exist function show instance algorithm finally show restrict class strongly monotone algorithm fact optimal conclude experimental study algorithm performance experiment show realistic include condition guarantee meet algorithm outperform bind well previously propose order magnitude novelty first difficulty infinite search space individual finite single may infinite number possible analogous grammar define infinite set word due possibly recursive nature moreover even size single may exponential specification size indeed standard five search may fail halt context moreover become prohibitively inefficient even previous work seven attempt overcome show work performance solution propose seven unsatisfactory several realistic contrast novel algorithm present provably optimal outperform algorithm seven ninety see section five furthermore algorithm seven tailor probabilistic thus limit applicability compare novel algorithm generically applicable weight metric paper organization section two present model weight section three present algorithm section four discuss section five describe experiment section six conclude relate work space proof defer appendix two start recall standard basic model six extend support weight run example use shop mall introduction specification encode set order may occur specification model set dags dag unique start node incoming edge unique end node outgo edge nod label activity name direct edge impose order link via direct path assume occur parallel dags link implementation idea activity one dag realize via another dag call activity compound differentiate atomic compound may multiple possible choice implementation control condition refer guard formula assume domain activity name domain f predicate calculus definition specification triple finite set dags distinguish dag consist single activity call root implementation function map compound activity name set pair consist implementation dag guard formula f example figure one show example root precisely one activity name latter implementation dag describe group comprise user login injection advertisement choice particular store user exit possibly pay direct edge specify order may occur user login first store choose particular order injection advertisement choice store mean occur parallel within observe login compound login activity two possible guard respective idea exactly one formula satisfy user either choose login visa credit card thus login implement either respectively similar observation make several possible exactly one choose depend guard formula satisfy note specification recursive may call note satisfaction guard determine external factor user environment assume exactly one guard formula satisfy determine implementation give compound activity occurrence observe satisfaction guard change occur several time instance user may choose buy product first time go product second time model nest dag represent execution model occurrence activity two nod first stand activity activation second completion point two nod connect edge edge dag represent order among implementation emphasize nest nature figure one business process specification figure two example execution flow implementation compound activity appear activation completion nod course structure dag must adhere structure correspond specification ie occur order implementation must conform function definition give specification e execution flow base e consist activation completion nod root activity connect single edge expansion step e e e attach pair activity e implementation ea two new edge call implementation edge start ea end ea annotate pair formula fa guard ea require pair implementation attach already e whereas ancestor compound e one attach implementation ea activity node replace correspond pair activation completion nod connect edge call e expansion e denote e e example example shop mall give figure two order edge implementation edge draw regular resp dash describe sequence occur execution user visa credit card choose shop store choose look player select one continue shop store look select one also last part omit figure finally exit pay use e e denote e obtain e sequence activity pair e unexpanded source implementation edge imply use expand e say partial unexpanded full otherwise denote set full flow specification f low graph e say e partial full flow specification simplify presentation impose total order among unexpanded give partial flow assume expansion follow order order achieve topological sort dag thus partial correspond unique sequence expansion step base assumption make solely presentation result extend general context multiple expansion order possible see appendix b weight assume order domain w weight use three function one eight describe weight implementation choice give precede two aggregate eight value three f w eight use eight compute flow weight function give specification eight partial function assign weight w w pair e f e f guard compound activity node e next expand intuitively value eight e f weight implementation guard f give e flow precede example reconsider fig two eight function assign implementation choice additional cost incur customer case w set positive number eight choice brand give precede flow indicate product purchase shop user identify visa card holder may visa discount price eight choice give product precede flow already include purchase product may reflect twenty discount second product eight like store product type may zero incur additional cost user aggregation function weight along aggregate use aggregation function w w w first input intuitively aggregate weight compute far second new eight aggregate previous value instance compute purchase cost w zero compute likelihood w zero one consider aggregation function associative commutative continuous monotone either increase decrease formal definition see appendix c observe aggregation function cost likelihood resp satisfy function finally f w eight obtain aggregate make flow define e consist root f w eight e otherwise e e e f w eight e f w eight e eight e f f formula guard implementation add e form e example assume individually cost resp sell together twenty discount ie eight first choice resp eight next choice seventy compute minus cost already incur first product use aggregation along flow sum yield total deal price observe monotonically increase decrease f w eight sense weight increase resp decrease execution advance generally f w eight increase overall price purchase interest full flow overall price f w eight decrease likelihood interest likely since present apply symmetrically case consider monotonically decrease function give specification monotonically decrease f w eight function number k study problem identify weight f low one refer problem one may consider query select interest case retrieve match query common practice case see seven two employ algorithm first step intersect query q obtain new whose flow exactly flow also match q second step perform analysis efficient algorithm first step suggest six thus focus second step ie completeness recall appendix six formal definition query detail two step algorithm three optimal algorithm devise algorithm one encounter two main first recall may recursive case number consider may infinite second even without recursion size single may exponential size single graph may appear implementation multiple compound flow conventional algorithm five may traverse entire search space worst case thus fail halt recursive observe consider follow simple example example consider follow specification root activity two possible first guard formula f one consist single atomic activity second guard f two consist recursive invocation eight every two e e eight e f one st eight e f one five eight e f two eight e f two zero use algorithm keep consider recursive time obtain decrease weight nevertheless higher zero never terminate note example may equal weight imply may several valid problem case pick one arbitrarily eight value guard zero may also design complicate weight function positive weight algorithm terminate moreover inefficient incur specification size even due size materialize provide example appendix e overcome use follow two observation one first observe distinct nod n n may fact equivalent sense every may originate n may also originate n f w eight example nod label equivalent another example consider weight function stand product price deal propose every two nod n n stand purchase product p equivalent deal price p may depend flow precede n n term purchase specify combine deal p n n equivalent equivalence thus relation two pair formally define relation introduce auxiliary notion isomorphic give e activity n e e root n consist nod edge appear path activation completion nod n isomorphism two sub flow e e onto match nod edge e e respect node label guard edge relation definition give two pair e n e n say e n e n equivalent one n n label activity name two e e st e e e e root n n denote en e n isomorphic f w eight en f w eight e n denote set equivalence class give specification assume sequel know finite explain generate observation two observe existence equivalence class combination f w eight facilitate computation lemma every equivalence class compound activity node n follow hold one exist best rank originate n contain occurrence node n two j one exist j th rank flow originate n occurrence node n root n one top j one flow let us illustrate two example reconsider example recall try retrieve root alike algorithm encounter recursive invocation examine possible latter thus result infinite loop follow lemma redundant compute one may avoid consider flow contain recursive call note regardless flow precede equivalent flow may contain recursive invocation need consider potential expansion occurrence already compute flow algorithm follow define table f able compactly maintain sub flow equivalence class row correspond equivalence class range one k entry contain pointer correspond turn every implementation compound activity node give explicitly rather pointer another entry f able guarantee size flow representation bound table size avoid blowup size follow every represent via single pointer entry f able discuss explicit construction flow algorithm operate two step first call compute compact representation within f able call use table explicitly enumerate compact representation next explain operation two procedure maintain two priority queue f partial order f w eight step f contain flow still need examine upon termination contain flow initially empty f contain single partial contain root step pop highest weight flow e f e full partial flow algorithm invoke ull handle algorithm input e v e f e v n insert e v f able e e f eight e f insert e f e choose e v n v e insert e v v one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty end end else end else end end e ie e st e e along weight algorithm first retrieve node v e line one look equivalence class f able line two entry find mean encounter yet equivalent node computation thus create new row f able equivalence class line four row fill later correspond full flow find obtain e line five expansion compute f w eight value insert f queue process follow line otherwise appropriate row already exist table consider partial appear row yet consider expand e line twelve exist although table entry exist mean e previously reach expand node v appear e well follow observation two may compute next best without expand e thus put e hold line fourteen release upon find full flow originate v see unused exist take highest rank attach v make v point flow line compute weight obtain line nineteen add f line twenty depict algorithm two first give full e insert line one already contain k flow terminate otherwise every node appear e along precede line define equivalence class use entry f able root node insert table entry appear already line last put hold due node participate e return frontier line algorithm input e insert e k output end else node n e n e precede n n e root n f w eight f root f able n n n f n n n end e n insert e f one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen e v top e expand e point v e v f w eight e insert e f v end end end algorithm one depict algorithm one give partial flow e consider possible e e end assume existence function allow retrieve give partial flow algorithm two explicit enumeration f low terminate flow compactly represent via f able compound within graph appear possibly represent low follow materialize pointer chase terminate follow observation two theorem strongly monotone f w eight function may prove follow theorem optimal within theorem give eight number k finite time complexity algorithm polynomial k generate recall observe dictate fragment partial flow precede give choice fact affect eight fragment term memory instance eight stand product price memory give product choice p include choice shop previous purchase suggest combine deal p thus practice may derive product price propose deal consequently complexity polynomial exponent depend require memory size use similar construction seven may show necessity exponential dependency memory size unless p n p problem become undecidable memory size unbounded see appendix practice memory size navigation typically bound small four seventeen four next consider start define measure analyze weight function different measure introduce class compare cost metric use comparison compete define class deterministic correct operate input additional information algorithm may retrieve multiple call may obtain eight expansion choice apply compute f w eight use information obtainable manner cost metric consider number call dominant computational factor indicate number distinct sub flow examine cost algorithm execute input instance denote cost thus define number call make instance follow eleven use two within class optimal algorithm input instance cost cost exist c c instance cost c cost c result show next instance algorithm influence f w eight function strongly monotone say f w eight strongly monotone every two distinct partial full flow e e f w eight e f w eight e particular imply weight strictly decrease flow advance prove follow proof sketch proof work contradiction base follow lemma prove appendix lemma give input let worst solution upon termination whenever e pop f f w eight e f w eight algorithm expand input less nod exist flow e node v e st expand v expand node equivalent v expand single node equivalence class denote f w eight f w eight e lemma consider w st f w eight e w w exist continuous design input similar new implementation v activity eight w wrong act never see v thus miss better weight monotone realistic set incur change f w eight instance shop mall example choice store product type induce zero add cost consequently flow may share f w eight value still number flow share specific f w eight value typically bound model define constant c notion monotone f w eight definition constant c f w eight function monotone specification every weight w e f low f w eight e w c follow theorem hold theorem every constant c every specification along monotone f w eight function instance optimal within proof similar theorem give appendix note optimal algorithm possible follow theorem algorithm within optimal monotone f w eight function proof sketch proof assume existence optimal algorithm define algorithm different order expansion equally weight construct input order choose yield less find flow full detail give appendix weakly monotone finally consider common practice case weakly monotone f w eight function may perform unbounded number consecutive incur change weight unfortunately case algorithm instance optimal show case instance optimal algorithm exist theorem algorithm within class instance optimal weakly monotone f w eight function five experimental study present experimental study algorithm base synthetic data study evaluate performance algorithm practice relative bound imply analysis examine case guarantee well case note gradually fill f able halt discover flow implement variant term fill terminate compare performance similar algorithm seven also compute flow root every activity comparison thus provide comparison seven demonstrate performance gain achieve new algorithm implement algorithm c run experiment duo processor ram run two series experiment first use synthetic data study algorithm performance second use real data context yahoo shop evaluate performance real life set experiment synthetic data generate synthetic input vary number different affect complexity problem range parameter value choose base upon survey structure typical web thirteen seventeen examine favor value higher end spectrum follow describe choose value range size vary total number note thirteen state typical number give demonstrate study whose size ten time typical application history bind consider eight function bound range zero ten previous study seventeen behavior web conclude typical history bind four equivalence class recall number together size history bind determine number equivalence class thus also size f able value yield different equivalence class strength vary percentage equal neutral value aggregation function percentage determine monotone f w eight function turn extent condition guarantee hold see section four study effect strength algorithm performance vary standard deviation distribution eight value consider uniform normal high standard deviation imply greater strength number result vary k range one additional structure ie number implementation graph number possible activity try parameter value five time greater serve case yahoo shop vary number implementation activity range two number implementation give fix number equivalence class note effect structure algorithm performance consequently show result fix number namely fifty possible implementation number implementation dictate overall size number possible implementation representative sample experimental result present figure four examine execution time second increase number equivalence class scale time axis graph logarithmic since experiment show shape graph history bind affect performance give fix number equivalence class show one representative sample history bind five number k request result consider vary k value figure show performance eight value range one different include uniform normal average value five vary standard deviation two one zero latter correspond eight value always fill f able thus sensitive eight distribution show one curve compare generally show improvement positively correlate variance distribution eight value variance imply variance f w eight exploit greedy nature quickly separate result rest shall see variance indeed common extreme unrealistic case eight value identical ie standard deviation zero performance become early stop condition hold flow table must fully fill thus show curve figure four b examine execution time grow number k request result number equivalence class history bind five see run time increase moderately k grow steadily show significantly better performance exhibit similar behavior describe increase less visible graph due logarithmic time scale figure four c examine effect strength weight function execution time fix k number equivalence class history bind five resp vary percentage neutral weight nonneutral weight uniformly distribute leftmost end neutral weight guarantee optimal rightmost unlikely case weight neutral exhibit execution time flow table must fully fill see performance significantly superior even condition necessarily hold particular realistic less ninety weight neutral improve experiment real data second set experiment perform use part yahoo shop computer store twenty use real data detail price information include deal obtain site web interface offer yahoo obtain specification consist average implementation per compound activity history bind four yield equivalence class variance eight value cost compound activity product type high average ram price standard deviation consider increasingly large part specification correspond outcome evaluate decreasingly selective query evaluation process depict bottom section two fig four depict result fifteen representative involve increase count equivalence lead factor performance algorithm extreme right equivalence class participate computation observe outperform factor demonstrate good performance note also example case alike algorithm halt specification contain mutual recursion due back button facilitate press back button incur cost recursive choice zero weight lead case similar depict example contrast optimal algorithm halt show extremely good performance six conclusion relate work consider paper query evaluation context weight analyze different class weight function complexity query evaluation give first time provably optimal algorithm identify show algorithm outperform previous work seven order magnitude algorithm seven use eight evaluation projection query probabilistic replace faster optimal algorithm give present work yield acceleration observe evaluation projection query query study extensively relational data twelve notably eleven present algorithm query aggregate individual score give join context one may think eight equivalent individual score f w eight aggregation eight value along give specific one size give flow thus number aggregate score unbounded two particular function unique three number rank infinite note infinite set also appear stream data analysis sixteen work aggregate bound size slide window whereas study aggregation flow unbounded size rank likelihood also study probabilistic eighteen probabilistic one fifteen extend relational resp probabilistic set example eighteen fifteen study query evaluation probabilistic resp contrast relational data model flow allow representation infinite number retrieve work probabilistic process fourteen ten four either suffer low expressivity incur infeasibility query evaluation analysis process context verification rather analysis discuss nine finally note complementary line work nineteen optimization process allow construct repository execution flow occur past consequently derive weight function use within model complementary analysis possible future extend powerful model query feature include join projection negation weight function preserve low complexity challenge future research seven reference one p query update probabilistic information two active three business process execution language web service four b monadic logic graph one five r j pearl generalize search three six milo type inference type check query execution trace seven milo evaluate query business process short paper eight milo projection query probabilistic business process nine l v verification communicate web service pod ten k algorithmic verification recursive probabilistic state machine eleven r optimal aggregation four twelve f g survey query process relational forty four thirteen estimate cost fourteen j j snell finite chain springer fifteen b match twig probabilistic sixteen n data stream query process tutorial seventeen p l j e world wide web empirical world wide web two twelve eighteen p sen represent query correlate probabilistic nineteen k dayal design reduce cost consult nine twenty yahoo shop appendix additional proof proof lemma one let e flow root n e contain node n do otherwise consider e e implementation n ie e appear activation completion nod n since n n equivalent may e also implementation n furthermore weight appear along e stay e root n intact due equivalence n n e e thus f w eight e f w eight e due thus e also flow root e additional nod n still appear e may repeat process omit two part two theorem assume induction hold th rank flow root n every j part one base case induction specifically mean exist set top flow root n node n root j flow e j th rank flow originate n bear node n root n one top j one flow may replace root n rank flow without decrease weight e proof theorem number f able k flow node v consider course algorithm execution either already appear f able case request v appear table may happen k time compute flow root v cost computation case search table assume index allow one time get last worst rank entry give row otherwise may additional factor k one computation consider direct v total k two consider v already appear f able need point implementation v already compute one next consider number time scenario may occur start consider computation flow consider equivalence class e say encounter node n e do compute flow root n encounter another point search tree another node n e course algorithm execution follow observation two section four suspend computation flow n computation flow n do put n hold line fourteen algorithm number compute flow n bound size specification n e e number equivalence class argument hold computation th highest weight flow one k lead total bound two k case total complexity thus polynomial k may show undecidable general may infinite state text follow proof proof reduction halt problem give machine idea encode use specification state represent activity name model transition state well change tape head location history flow utilize allow read tape formally give machine set state q initial state q accept state q tape alphabet transition function delta generate specification whose set compound activity name q additionally contain atomic activity implementation set compound activity correspond state contain implementation activity name possibly transition accord transition intuitively one transition legitimate accord current symbol head zero otherwise eight function allow determine value accord entire precede flow flow determine uniquely tape state head location accept state single implementation consist atomic activity eight one use multiplication aggregation seek full flow eight higher zero may show require memory size may solve state text follow proof use reduction set cover simplicity consider monotonically increase f w eight function computation function w positive number proof work symmetrically monotonically decrease f w eight simply take negative instead positive use give instance set cover namely set x set bind b construct follow activity name root compound atomic si one bear two j one si two consist single node whose activity first guard formula si choose second si choose last implementation si guard si do consist eight si choose si choose zero si do depend last b one set si si choose within set b cover x otherwise eight three use addition exist flow f w eight smaller two exist set cover size smaller b proof theorem give full proof theorem sketch appear paper body follow use denote f w eight proof theorem start show invariant satisfy algorithm flow e lemma give input let worst solution appear upon termination whenever e pop f line four algorithm f w eight e f w eight proof denote f w eight also flow e denote f w eight e definition strong exist unique flow weight flow already appear frontier e pop clearly appear yet f f must contain least prefix e ie flow e st e since e pop e strong also thus next use lemma prove theorem assume sample instance algorithm cost less ie call smaller number time since algorithm produce correct solution input must hold output weight last worst weight result easy show equivalence class e algorithm call node v e assume algorithm invoke less thus exist least one equivalence class e algorithm expand node v e algorithm expand v node equivalent say v e e specific flow e consider algorithm lemma guarantee thus exist least one partial flow f expansion nod consider algorithm consider algorithm define w w continuous exist w construct another input instance follow function nod expand well eight function aggregation function node v function return single implementation e consist single atomic activity correspond eight w subsequent compound e exist design give e history w correspond flow weight higher add algorithm thus commit mistake contradict assumption correct algorithm thus must hold algorithm optimal input give arbitrary input follow algorithm optimal proof theorem proof work contradiction let c bind number consecutive flow e lead flow e f w eight e f w eight e assume better algorithm factor greater c let define proof theorem note every flow e consider f w eight e c flow e f w eight e c flow flow e consider f w eight e consequently exist least one flow e insert frontier f w eight e f consider proof proceed similarly proof theorem proof theorem contradiction let us assume existence optimal algorithm give number n construct specification follow compound atomic root activity construct gradually time obtain intermediate execute change accord prior execution two possible one contain second contain continue construct specification accord behavior choose expand resp resp implementation single activity single implementation consist five n ai single implementation consist single implementation consist use multiplication eight function assign one every guard formula apart guard implementation weight five induce f w eight monotone execute expand n one nod expand three nod first four either rest n four nod contrast different algorithm choose different order expansion instance expand n two nod go still always correct proof theorem give algorithm construct follow root compound atomic use multiplication eight function assign one every guard formula clearly weakly monotone construct gradually time obtain intermediate execute change accord prior execution root activity r two first consist second first set execute partial examine activity expand first since choice depend thus change follow choose expand first set two consist respectively implementation still consist next three next expansion choose activity set two consist respectively consist repeat process obtain n compound allow implementation consist well denote obtain clearly execute expand n nod activity ai choose n lead contain compound contrast claim exist optimal algorithm execute expand log n observe true show two low lemma exist flow f low f w eight one f w eight flow f low obtain log n proof assume contradiction every flow f low consist log n since every compound activity two contain distinct activity name obtain n n distinct contradiction way construct c aggregation function provide exact definition impose aggregation function describe intuitively section two one associative commutative namely x z w x z x z x x two continuous x z w x x z exist w w x x w x z three neutral value denote namely x w x x x four monotonically increase decrease w namely either x w x x x query lemma exist correct algorithm execute find flow expand exactly activity nod appear quote formal query match appear also six consider query evaluation proof first note eight value within identical thus every order expansion comply specification exist correct algorithm correct every input execute follow expansion order specifically correct algorithm expand exactly participate corollary two evaluate expand log n nod expand n nod thus better factor log n n may choose wish give constant c may choose n log n c c thus better factor instance optimal n n conclude proof theorem b multiple expansion sequence assume see text follow example simplicity presentation existence total order expansion next withdraw assumption explain need eight function previously define eight e f e formula f define eight e n f n node e f guard formula implementation n eight e n f weight f give n choose expansion e f w eight define f w eight e e e f w eight e eight e n f n node e expand form e f guard formula correspond expansion n give partial flow e algorithm examine node e rather single node e definition say dag e abstract flow exist st e f low execution pattern pair p e e abstract whose nod label label may annotate guard distinguish set activity pair edge e call transitive example example query give fig three edge nod transitive edge query look user choose brand possibly perform correspond transitive edge choose also brand activity transitive indicate implementation may appear nest depth transitive require brand choice appear direct implementation give specification query p select e f low contain occurrence p intuitively nod edge match nod edge respect activity name order implementation edge formally definition let p e execution pattern let e embed p e homomorphism nod edge p nod edge e st one nod activity pair p map activity pair e node label preserve node label may map node activity name two edge transitive edge node node n p map edge path n e edge n belong direct internal flow transitive activity edge edge path n type flow otherwise must type n result extend multiple expansion sequence e belong query result exist embed p e say e satisfy p correspond exactly satisfy assignment every variable whose correspond compound activity implementation false true graph assign false true indeed assignment every compound activity exactly one true false graph implementation e satisfy every clause node appear e truth value assign variable correspond compound activity thus satisfy clause conversely let satisfy assignment obtain choose implementation compound activity true graph assign true correspond variable false graph assign false indeed f low since assignment satisfy q every node clause appear least due fact assignment satisfy thus clause least one variable whose truth value cause clause true e example behavior alike algorithm suggest section three algorithm base idea note two first recursive second possibly behavior even example show first pitfall next provide example second pitfall example let n integer consider follow specification whose activity name root compound b atomic use integer weight addition aggregate weight root activity bear two possible first name guard formula f one single activity node label second name guard formula f two two label bear single implementation two label ie ai bear single implementation two label one n one single implementation bear single atomic activity node eight value dictate choice implementation independent precede flow eight value f one n two eight value one look alike algorithm would generate size obtain subsequent implementation contain ai identify flow fact obtain choose implementation root contrast algorithm present section three compute top root activity use f able see algorithm description avoid exponential blowup figure three example query query evaluation name problem find give specification weight function flow p number k flow satisfy p follow theorem hold theorem may solve time poly nomial k exponent depend p linear output size proof combine two follow one first algorithm query evaluation algorithm six give specification p construct specification include match p intuitively intersection p obtain consider possible split query match dags two second algorithm algorithm construct complexity first algorithm six maximal size result second step show polynomial size input k linear output size show exponential dependency size query inevitable define decision problem test give weight specification query q k zero threshold whether flow weight higher follow theorem hold theorem q proof prove use reduction follow give conjunctive normal form formula f generate specification query q follow idea create compound activity associate variable formula activity two different xi rue former contain xi satisfy latter contain xi satisfy query require formula f appear formally prove reduction valid give follow lemma lemma exist f low satisfy query q formula f satisfiable proof let e f low satisfy q e obtain choose subset compound rue choose implementation another subset choose