probabilistic chain query university university milo university milo abstract study highly expressive query probabilistic generalize computation step rule fire define two possible semantics query namely inflationary semantics result computation step add current query induce random walk instance study complexity exact approximate query evaluation semantics subject management management logical design mathematics compute probability statistics general term theory one introduction probabilistic recently start attract considerable interest number query relational algebra study probabilistic six eight three four fifteen sixteen seventeen twelve far virtually work expressive beyond original proposal use probabilistic context information retrieval eleven highly expressive query iteration construct enable interest new probabilistic query language research iterate probabilistic change state use declaratively specify query chain random walk stochastic process ten open permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee pod ten june copyright entirely new application data management research many chain chain monte nineteen fourteen statistical physics five theory play increasingly important role theoretical computer science far base chain develop none application allow program use easy use declarative declarative define chain walk efficiently execute query would allow improve research productivity use chain solve computational task like relational management greatly improve productivity context business information declarative query chain would also allow program higher level abstraction may yield interest among combination sophisticate main paper establish useful probabilistic query base highly expressive literature study expressiveness complexity specifically study probabilistic query probabilistic extension inflationary semantics show classical random walk graph probabilistic analysis inference may express query core complexity result summarize table one table order increase expressive power language expressively subsume table one show exact evaluation approximation quality guarantee relative size probability value compute relative approximation infeasible absolute approximation ie approximation constant factor efficiently feasible inflationary query depict result relate correspond decision namely give value p approximate correct probability value give approximate relate either relative absolute approximation accord correspond problem show hardness result apply even language linear without probabilistic rule inflationary probabilistic rule probabilistic rule exact computation p hard p hard p hard two relative approximation absolute approximation input size mix time table one overview complexity result data complexity restrict query apply also discuss probabilistic omit table whose expressive power subsume specifically show hardness result hold already probabilistic paper organize follow section two recall probabilistic well complexity use measure quality query evaluation section three formally define query inflationary flavor query evaluation inflationary query study section four five respectively conclude overview relate work section six two section provide common use remainder paper first recall common computational complexity approximation use analyze give background probabilistic last recall important chain complexity complexity part paper address exact computation essentially count problem complexity analysis thus make use count complexity specifically p set count associate decision formally count problem p machine whose number accept instance problem equal result count problem p hard every problem p reduce polynomial time consider probabilistic recall context eighteen probabilistic polynomial time class decision solvable probabilistic machine polynomial time error probability instance zero five note choice range may arbitrary algorithm error probability bound may transform one error probability bound execute multiple time take majority vote answer bind seven guarantee number require logarithmic one analyze complexity query evaluation one may consider data complexity combine complexity data complexity complexity evaluate query function size combine complexity function query size focus data complexity even restrict query study show combine complexity p hard thus whenever refer complexity query evaluation mean data complexity use two approximation common literature namely absolute relative approximation algorithm count problem c take input instance c parameter denote c correct answer output execute say absolute approximation c every input instance relative approximation c one c one every randomize absolute approximation algorithm input additional parameter satisfy p r c every input instance p r stand probability analogously randomize relative approximation algorithm satisfy p r c one c one correspond decision ask whether give value p absolute relative approximation correct answer c give provide sequel data complexity result mean correspond decision problem size probabilistic use definition sixteen probabilistic follow schema use relational schema probabilistic schema relation name finite set possible one k p one one k p n positive rational weight p st p one give two previously introduce els allow generation probabilistic namely probabilistic thirteen relational algebra enrich sixteen construct probabilistic probabilistic finite variable define follow definition thirteen relation associate condition condition combination involve finite domain v probabilistic random probabilistic pair joint probability distribution random occur set possible probabilistic set possible random probability world probability valuation world set whose condition true probabilistic define way succinct mean represent finite probabilistic one may fix without loss generality random probabilistic independent thus joint distribution give individual random variable assign random variable x possible value x x probability x x joint distribution obtain product individual random let p column name schema relation r vector p single column contain numerical value greater zero operation p r sixteen sample one maximal repair key distinct value appear r denote set key value sample exactly one probability distribution give normalize column p one probability choose application p construct generate set possible sample single key value probability possible world product choose within group group assume independent example consider simple relation r depict table two relation correspond possibly incorrect fact regard basketball player team currently play third column represent level belief fact ie player play team consider relation level belief construct accumulate various belief value possibly derive popular support fact ie number think fact correct player column constitute primary key note still multiple share value attribute thus key repair mean single thus team player choose three apply layer belief r choice perform determine relative belief option probability seventeen la choose probability choose similarly player one choose accord relative belief value assume functional dependency schema r p p alternatively assume semantics first replace group b b violate functional dependency single b pi team player la belief seventeen three eight seven table two basketball table eight seven possible world consist single fact key value probability multiplication probability value choose appear exemplify use section three standard notion relational algebra enrich construct application generate set possible relational algebra apply possible world independently result evaluate enrich query q relation r probabilistic denote q r q r thus set correspond possible world associate probability value note operator natural probabilistic generalization witness operator see one expressive power discuss sixteen finite probabilistic construct certain consist single possible world probability one use query language specifically construct define may simply view probabilistic generate possible may simulate polynomial number construct consider connection construct sequel ease presentation use follow optionally omit column parameter p write r case choose group uniformly random r p p one standard relational product rename also use p r p r choice single r regardless key value probability set accord relative value p respect sum p value r r choose single r uniformly chain next provide short chain reader refer ten detail chain chain finite state machine transition annotate sum probability outgo transition state one probability transition depend previous state process random walk start arbitrary state point randomly choose accord transition transition originate current state continue target state chain irreducible random walk start state eventually reach state j probability greater zero period state chain number k return state must occur k step namely k n p r zero xi state step walk k one state say aperiodic state say positively recurrent start probability eventually get back finite number step one positively recurrent state positively recurrent ergodic aperiodic positively recurrent stationary transition matrix p define give p probability transition state state j stationary distribution distribution state space p distribution uniquely exist irreducible positively recurrent chain monte chain monte fourteen nineteen sample probability distribution construct ergodic whose stationary distribution correspond perform random walk use distribution nod observe random point walk estimate underlie stationary distribution sample correctly chain must first mix mean probability walk state independent initial state walk approximately stationary probability state ergodic guarantee occur walk long enough mix time ergodic thus define number step take forget initial state namely give p r st state st state random walk step ergodic exist every value three language section formally define query provide use language start consider standard relational generalize sample extension base operation define query base interpretation extend discussion probabilistic definition probabilistic interpretation relational schema q query relational algebra extend operation result schema query schema give relational interpretation define probabilistic q whose ak p st ai one k possible result world p multiplication probability value associate ai next introduce probabilistic one definition query give schema pair q e q probabilistic interpretation schema call transition kernel e relational query call query event assume query form r check whether give relation current state conceptually query evaluate input relational initial state follow program state input forever state q state query language semantics follow note q state general probabilistic ie set possible loop body apply every possible world possibly generate new possible intuitively application correspond random walk state start input state walk state state dictate probability among possible q query result probability query event true arbitrary point time infinite random walk ie probability arbitrarily many step current state satisfy r formally world sequence sequence state initial state si possible world q associate probability pi denote length probability denote p r k pi probability give state arbitrary point time infinite random walk instance define p r lim k k p r one k k follow ten limit exist finite last query result sum p r state satisfy r note q along initial define chain state ergodic query result also probability r accord stationary distribution example random walk graph show express random walk consider scenario input consist two input unary relation c consist single stand start node walk ternary relation e j p reflect graph edge annotate j p e edge probability weight p node node j graph p probability perform transition node j give node define random walk interpretation q p c e c j e e unchanged recall stand natural join projection rename iteration current c query select use next node j j e j new c e remain constant query event v c e define ergodic chain ask probability v accord stationary distribution see variant let v denote set nod graph e view chain state v obtain query e namely union project e project j consider isolate nod modify first equation interpretation q c p j p c e p one p v p compute node v usual dampen factor ie probability abandon current walk jump uniformly arbitrary node graph probabilistic query evaluation define case input standard relational case useful consider probabilistic input give collection probabilistic mention view macro correspond algebraic expression use construct observe possible see sixteen particular semantics appear transition kernel probabilistic make iteration see section five inflationary query inflationary query define counterpart query one intuitively inflationary query assignment new state cumulative rather destructive query result add current instead replace case formally inflationary query define follow fragment definition q e call inflationary query relational possible world b q b define inflationary query transition define new state union old state result query old state example graph consider input example e j p ternary relation stand edge relation c unary relation initially consist single stand start node walk express query ask probability node v eventually reach random walk start give start node walk nod store c use additional auxiliary relation cold initially empty inflationary language q define follow probabilistic interpretation cold c c c j p c cold e e e unchanged query event v c note value cold relation use second line cold value write first line previous version due semantics query evaluation point fire rule parallel namely side evaluate old state actual update take place subtlety arise inflationary query careful reuse multiple time generate new illustrate next example reconsider example assume e b five c five b c five however replace update rule c c c j p c e forever try add node c one node reachable via single edge suppose c c either add b c already c add nothing successor may forever choose c successor probability world go zero continue iterate eventually b r thus b c one example demonstrate general property restrict reuse generation new appear result query without appear query result probability one example also demonstrate computation reach finite number step probability path approach zero evaluate inflationary query probabilistic explain see bottom section fact may simulate via rule contain consequently appear inflationary query semantics different case query probabilistic take place begin query evaluation rather repeatedly make semantics inflationary semantics rule fire new rule side since implement application grind new valuation occur query evaluation probabilistic probabilistic rule probabilistic syntactically extend one construct use follow notation construct rule head key underline head optionally postfixed p p variable bind weight column omit weight uniform like algebra operator example consider relation schema r b c e rule h x z p r x z p w correspond relational algebra extend recall standard rule compile expression relational algebra compute rule head one query give probabilistic query define probabilistic program q query event e may use translation addition operation translate construct translate q e equivalent query define inflationary semantics easy observe every step possible rule body use application every probabilistic program equivalent conventional program without may appear output appear probability one see example thus define inflationary semantics probabilistic query follow repeat forever parallel rule r r x p b x z r body r old state r r r r r repair key x p x p r recall term relation stand derive relation relation input relation computation apply initial contain data empty rule b stand body r two auxiliary r r initially empty body rule empty single valuation body empty valuation rule thus fire first iteration probabilistic query must reach possible computation path since many possible active domain initial state rule head underline essentially add classical rule would add also note similarly inflationary semantics probabilistic query evaluate may first simulate rule rule fire since body rule correspond grind thus new throughout iteration semantics use random make iteration hard show follow proposition proposition every probabilistic program equivalent inflationary query next express query example probabilistic example graph revisit query compute graph nod start node v see example express probabilistic simply c v x c x e x c x consider evaluation query initial e v w five v five first add v c empty valuation body first rule use yet exist two new x v w x v one choose probability five choice let w world bear probability five x v w respectively x v choose x v respectively x v w longer new valuation valid valuation previous iteration well third rule must fire lead addition w c world note use essential enforce application nod appear currently c model probabilistic choice next nod would write c c x e x probabilistic choice body make instead would use classical next consider complicate example namely computation marginal give network example network example construct joint distribution number random define network use probabilistic simplicity assume upper bind k node network ie number parent random variable input consist two input specify network relation schema specify random variable name exactly parent relation schema p specify conditional probability table parent x call ie x x x p x name random variable x zero one value random x p zero one x x p single predicate v n v specify complete valuation random variable n possible world probabilistic program consist k one rule program define follow program q zero k k v p p v v marginal x x compute probability event q rule q v x x v add program x x remainder paper consider inflationary also study restrict one follow ways without apply probabilistic linear rule body contain one atom four complexity inflationary next discuss complexity query evaluation respect inflationary semantics easy show follow twenty exact query evaluation ie ask whether probability give query event exactly p p hard thus turn first consider relative approximation unfortunately show approximation infeasible well follow theorem hold theorem unless p n p p n p exist deterministic randomize relative approximation scheme query evaluation inflationary semantics hold even one problem restrict evaluation linear program two either apply base two query without repair key apply probabilistic proof prove theorem case condition one two hold proof case one two hold follow discuss use reduction give formula f consist set construct program q follow consist follow c c l l r c initialize follow l probabilistic stand v negation associate predicate associate xi zero associate xi one variable v p r xi zero p r xi one five xi independent relation contain one one relation c contain c clause literal appear r r c r c c c c c l l do r next show existence relative approximation deterministic randomize evaluate q do imply algorithm decide whether f satisfy assignment start follow lemma lemma denote p query result q do n f satisfiable p one ber f otherwise p zero proof consider probabilistic choice choice must correspond consistent assignment variable exactly one hold assume f satisfy assignment thus probabilistic choice exist c value l c l l hold thus rule r fire consequently r r appear well neither do hold probabilistic thus p zero conversely assume f least one satisfy assignment exist choice correspond assignment choice bear probability one choice step evaluate q r hold observe note first step r hold assume one th step r hold hold well c l l literal l satisfy note assignment satisfy thus l must exist thus th step r hold consequently n th step r hold thus do hold next step happen choice correspond satisfy assignment satisfy assignment choose probability one thus obtain p one next use lemma prove theorem note proof rather straightforward follow lower bind repeat completeness first assume existence deterministic query evaluation algorithm relative error simply apply conclude f satisfiable algorithm output nonzero second part theorem assume randomize query evaluation algorithm run n time independently decide f unsatisfiable majority return zero next show construction yield algorithm say invocation succeed return zero formula f indeed satisfiable return number zero f indeed satisfiable exist invocation succeed probability least one fail probability define xi binary random variable represent success failure th invocation let x next bind probability x n two since independent x bear binomial distribution e x n one lower bind p x k e x x two two one n x two x one two x x obtain p x n set k n one n two one denote fraction positive one five bind translate x two two achieve error bind simply set n n one two two ie two en one two one two n one two one two prove theorem case condition one two specify theorem hold next show theorem also hold case one two hold case change construction replace similar table v l p whose five five use choose single proceed however may show randomize absolute may achieve theorem randomize absolute approximation data complexity inflationary language even apply probabilistic proof sketch employ sample algorithm every give approximate query result probability least follow sample do randomly choose single value independent variable accord probability consecutively apply query rule make probabilistic application construct appear within rule ie sample possible repair accord probability dictate current status operation reach end sample check satisfaction declare probability p average number sample sample do data complexity sequence entail number step evaluation linear time overhead incur random value independent bind number sample require approximation use bind denote x random variable whose value indicate query satisfaction dissatisfaction output p algorithm average sample x denote p correct probability x query probability additive bind give p r p p two number sample choose st two one ie four two sample sufficient overall complexity thus polynomial size logarithmic one two complete picture may exactly evaluate inflationary query recall exact evaluation even simple query probabilistic twenty consequently query even without recursion p hard sixteen proposition exact evaluation inflationary query construct even probabilistic proof sketch consider follow algorithm compute probability give probabilistic query construct iterate possible input probabilistic specify probabilistic iterate possible need iterate independent random easy possible world iteratively evaluate query iteration program may choose one exponentially many state however due independence choice across key rule iterate use polynomial amount memory thus make full traversal tree possible tree exponentially many nod depth bound number consist polynomial active domain input store path computation tree root ie many result probability initially zero traverse tree whenever reach leaf test query event true add probability weight result probability five complexity language next consider evaluation query show previous section inflationary query exact computation p hard respect data complexity unless p n p relative approximation also impossible follow true query inflationary query special case absolute approximation show approximation feasible inflationary semantics unfortunately may show case query follow theorem hold theorem unless p n p p n p deterministic randomize absolute approximation query hold even one problem restrict evaluation program two either apply base two query without repair key apply probabilistic proof sketch similarly proof theorem use reduction time use expressive power query show even absolute approximation impossible prove theorem case condition one two hold proof case one two hold follow exactly manner explain theorem similarly show proof deterministic case proof randomize case follow theorem recall first semantics repeatedly sample iteration give formula f consist set construct program follow consist follow c c l l r c x initialize follow proof theorem l probabilistic stand v negation associate predicate associate xi zero associate xi one variable v p r xi zero p r xi one five xi independent bear one c c l bear c clause literal appear program consider follow program q r l l r l r l r l c l do r do x do x employ approximation algorithm estimate probability q do absolute error five output f satisfiable result greater five correctness construction follow next lemma lemma denote p result evaluate q do hold p one f satisfiable p zero otherwise proof sketch probabilistic choice set l r l correspond randomly choose assignment note variable x single literal x x choose randomly follow relate set without ie include variable negation assignment say set consistent set correspond subset correspond use follow auxiliary proposition prove induction proposition iteration evaluate q l r l correspond assignment consistent satisfy exist none exist r l hold l follow proposition nth iteration l r l satisfy assignment consistent initial ie f n two th iteration do hold last rule program guarantee point do remain forever set possible correspond possible consistent follow satisfy assignment exist generate step k evaluation additional n two explain do hold thus k do hold hence p r do one f satisfiable conversely satisfy assignment p r do zero complete proof lemma thus existence absolute approximation algorithm five provide f satisfiable algorithm return p five imply p n p p n p however may show transition kernel query exact evaluation query possible proposition let q q e let input chain instance define q irreducible positively recurrent exact evaluation q proof sketch many possible active domain input thus exponentially many state chain define q thus compute stochastic matrix define transition relation chain evaluate q state state compute representation result q state probabilistic feasible polynomial time per state extract reachable state probability weight representation yield matrix chain next run elimination matrix compute principal feasible cubic time size matrix finally sum weight state query event true query result easy see result compute exponential time overall may generalize query evaluation algorithm obtain proof denote chain induce transition kernel input consider two case consist single strongly connect component irreducible positively recurrent ten may apply construction proposition compute probability query satisfaction otherwise compute dag strongly connect probability one random walk eventually finite number step get component one leave dag stay forever thus compute get leave consider lead leaf computation may exponential size dag turn may exponential size lead complexity perform elimination connect reside leave compute probability individual node probability factorize probability get connect component open lower complexity general case improve performance next present two simple improve worst case complexity query evaluation general may improve performance theorem exact evaluation problem query case first consider partition query evaluation smaller instance may solve independently use suggest second consider different technique query evaluation base sample partition many case large program many derive independent sense derivation one change probability derive another thus employ stage follow start original set unique identifier singleton set evaluate rule inflationary manner regular keep provenance add whenever add due application new set identifier end process set appear subsume identifier partition class partition set accord class obtain consider chain induce theorem independently find probability state within sum state query hold last overall probability p query hold multiplication class query satisfaction probability one p sample show approximate query result query p hard general however case approximation may obtain sample possible compute probability observe percentage query satisfaction difficulty lie obtain independent sample end recall section two definition mix time chain give query q q e instance q induce ergodic chain denote q mix time prove follow proposition theorem randomize absolute approximation algorithm evaluation q q induce ergodic chain may do polynomial time size q exponential size q proof sketch algorithm generate independent sample follow apply transition kernel q step step time compute intermediate query result convergence number step require convergence q convergence achieve omit compute start actual sample restart obtain sample independent sample hand proof continue proposition several study literature conductance couple nineteen characterize chain mix time polynomial number state chain case approximate query evaluation may perform identify syntactic probabilistic intrigue topic future research six conclusion relate work conclude brief overview relate work probabilistic various flavor study extensively twenty thirteen two give part sixteen suggest generalize model randomization may introduce part query via use construct show approximation possible positive fragment query language study contrast work query language study sixteen allow recursion thus less expressive particular express probabilistic process unbounded length random walk study restrict use probabilistic input data study eleven tool information retrieval set study eleven allow introduce grind consequently choice possible world fact perform choose set grind consequently model less expressive propose new may generate arbitrarily many time particular model eleven allow capture random walk instance depict similarly restrictive probabilistic version nine allow specify rule probability belong randomly sample program semantics program sample study highly expressive query iteration construct allow perform probabilistic change state illustrate query may use declaratively specify random walk complex chain stochastic process study complexity query evaluation propose query future work include design generic optimization query evaluation study restrict lower complexity query evaluation specifically syntactic case allow efficient sample seven reference one r hull v two p das c j trio system data uncertainty lineage three l c complete incomplete information back four l c query language support incomplete information system five v computational analyze human genetic thesis university san six c j introduction trio system data engineer bulletin seven p j n introduction probability press eight n efficient query evaluation probabilistic journal sixteen four nine l de h probabilistic application link discovery ten freedman chain eleven n probabilistic logic seventeen c compositional query algebra logic uncertain eighteen c h computational complexity nineteen mix tutorial chain powerful retrieval page twenty c n efficient query evaluation probabilistic data twelve c compositional framework p sen represent complex query uncertain data query correlate probabilistic thirteen j green v model incomplete likelihood probabilistic information data bull one quantitative genetics new york fourteen chain monte method approach approximate count integration approximation fifteen c approximate predicate expressive query probabilistic pod sixteen c query probabilistic record four trio project trio query language l valiant complexity compute permanent theoretical computer science eight two complexity relational query page v v approximation springer