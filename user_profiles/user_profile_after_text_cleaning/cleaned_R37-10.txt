transactional memory operate system e j e porter bhandari department computer university bhandari abstract paper quantify effect architectural design performance kernel modify use place lock several key run new hardware transaction memory model contain feature enable efficient correct interrupt handle architecture live stack overwrite corrupt stack memory require small change transaction register hardware ensure correct operation operate system also propose early release reduce spurious conflict stack memory kernel code interrupt use examine performance sensitivity individual architectural feature find polka effective contention management form transaction contention vital performance stall transaction conflict reduce transaction restart rat improve performance transaction write set small performance insensitive transaction abort cost sensitive commit cost subject processor parallel architecture operate general general term design performance transactional memory os support one introduction scale number core processor chip become de industry priority lesser focus improve performance develop take advantage permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee seven june san copyright multiple core remain challenge code deadlock convoy priority inversion lack general complexity difficulty reason parallel computation transactional memory emerge alternative paradigm program potential reduce program complexity level comparable lock without sacrifice performance hardware transactional memory aim retain performance lock lower program complexity paper examine architectural feature necessary support hardware transactional memory kernel architecture sensitivity system performance individual architectural feature many transactional memory design literature go great minimize one cost expense another fast commit slow abort absence large transactional os make difficult evaluate several important reason allow os kernel use hardware transactional memory many web spend much execution time kernel scale performance require scale performance os moreover use kernel allow exist program immediately benefit transactional memory common file system network exercise synchronization kernel control finally kernel large concurrent application use diverse synchronization os representative large commercial currently use evaluate hardware transactional memory design paper follow one examination architectural support necessary operate system use hardware transactional memory include new management two creation transactional operate system base kernel among program use first use inside kernel unlike previous study take memory trace kernel two successfully boot run full machine simulator create convert many sequence lock use hardware memory three examination use generate millions provide data useful transactional memory also compare conventional wisdom glean primitive contention policy policy definition instruction begin transaction instruction commit transaction instruction save transaction state suspend current transaction instruction restore transactional state continue transaction choose transaction survive conflict delay transaction restart table one transactional feature model four examination sensitivity system performance design individual architectural feature context allow realistic evaluation benefit feature include contention include novel policy variable commit abort cost rest paper organize follow section two describe model hardware transactional memory section three describe use properly handle interrupt transactional kernel section four describe relate issue deal stack memory section five describe transactional variant kernel section six evaluate performance across group common section seven discuss relate work section eight conclude two architectural model order evaluate system performance affect different hardware design point build system call follow particular hardware design closely bear resemblance flat nest also include novel necessary support section describe architectural feature present transactional semantics table one show transactional feature start commit become standard feature use model organize taxonomy accord data version management conflict detection whether eager lazy along either axis use eager version management new value store place eager conflict detection first detection conflict address restart rather wait commit time detect handle conflict support multiple resolve conflict transactional access one way resolve transactional conflict restart one support different contention management choose transaction restart alternately transaction request cache line own different transaction stall transaction finish policy require deadlock detection avoid circular wait whether transaction wait restart much govern policy support explicit abort restart primitive currently require either support strong atomicity four standard conflict memory reference transaction always restart transaction assume particular design transaction overflow processor cache charge overflow penalty cycle model overflow data structure reference cache line overflow must go memory manage account cache area use multiple data cost transaction commit abort also model assume commit abort specify abort handler cost allow us explore performance estimate impact run manage multiple support multiple active single thread control recent model include support multiple concurrent single hardware thread order support nest current feature escape hatch nest code access update do enclose uncommitted transaction provide completely independent hardware thread manage stack independent easier reason nest hardware support need also simpler need nest small number per cache line hold identifier several potential use independent use handle interrupt discuss section three suspend current transaction save state may continue later without need restart execute independent suspend transaction new may nest relationship multiple call support perform transaction active still account hardware order properly manage describe suspend lose conflict like run suspend transaction lose conflict restart resume analogous handle overflow nine also lose conflict restore previously transaction allow suspend transaction resume restart need combine suspend multiple concurrent lifo order restriction order restriction strictly necessary may simplify processor implementation functionally sufficient support interrupt implement could also implement particular design group suspend resume transaction fast implement push current transaction identifier stack contention management conflict occur two one transaction must pause restart potentially already invest considerable work since start transaction restart thread repeat work potential perform poorly contention high contention management intend reduce contention order improve performance model support contention management propose adapt framework hardware block model execute restart stall wait queue certain feature require adaptation summarize table two policy polite karma eruption kindergarten polka definition use empirical threshold ten case section describe type use study abort transaction do least work work estimate number unique address within transactional context karma update priority counter transactional reference reset counter restart karma variant priority boost conflict winner priority add loser higher priority future conflict will defer conflict will defer resort policy transaction win refresh restart thirty polite strategy combine karma priority accumulation number reference transaction work set approximate priority karma policy strategy exponential seed normally random delta approximate eager conflict detection least one involve conflict arbitration must write consequently policy default policy unless conflict write transaction size unique read write win size reset restart empirical threshold number restart revert avoid table two contention management explore introduce new policy call favor transaction number unique read write transaction work set implementation could count cache line instead transaction use must revert threshold number restart time transaction restart execute different code path cause different size work set time return recur conflict point recurrent mutual abort rare revert eliminate thirty interaction suspend via con tention management discuss section conflict occur one select restart decision restart occur impact performance particular high probability immediate restart simply repeat original conflict another restart would prudent wait transaction complete absence explicit notification mechanism decision long wait heuristic model support use different explore impact previous work focus exponential follow list summarize explore exponential exponential implement choose random seed one ten number time conflict transaction back raise power two multiply seed determine number cycle conflict transaction wait restart linear linear implement choose random seed one ten seed multiply number time conflict transaction back determine number cycle conflict transaction wait restart random random implement choose number cycle random wait restart maximum value none retry soon possible device initiate memory memory initiate rather part transactional context instance read page table read enter current transaction work set change kernel protocol maintain coherence processor take interrupt kernel mode store state kernel stack store transactional trap architecture transactional facility exist reraise interrupt transaction restart three interrupt trap architecture stack discipline create challenge interaction interrupt handle pose trap architecture similar pose modern believe adequately address exist present design interaction interrupt add minimal hardware complexity maintain ease use efficiency previous work present key approach recent work nine show abort active handle interrupt provide better system performance validate initial section provide background interrupt handle well exist deal interrupt cover motivation deal interrupt mechanism interrupt handle cover section contention management section next section section four explore interaction stack memory arise part strategy interrupt handle background one primary function operate system respond interrupt asynchronous request kernel interrupt split two halve interrupt handler run response device interrupt signal completion work read disk block interrupt execute disable interrupt equal lower ensure forward progress keep system response latency low interrupt relatively short execution push much work possible defer function bottom half defer function long check run defer function several place exact taxonomy defer function complex defer function run respect system call like device interrupt operate system amount work interrupt level include memory allocation synchronize access kernel data structure interrupt prime candidate program simplicity provide transactional hardware provide equivalent performance lock currently rely interrupt exist much exist work two make several interaction interrupt work assume short interrupt infrequent enough rarely occur transaction result efficiently deal interrupt unnecessary assume interrupt abort restart state use similar survive context switch nest allow transactional escape action allow current transactional context pause deal interrupt however allow thread pause transaction create new transaction design goal enable interrupt data table six show anywhere come interrupt nine make flexibility interrupt handle interrupt happen interrupt controller call os select core run inside open nest transaction affect ongoing transaction interrupt critical handle current transaction complete otherwise current transaction abort method lead long transaction repeatedly abort transaction interrupt affect motivate factor section present factor affect influence design interrupt handle system include transaction length interrupt interrupt rout transaction length one main advantage transactional memory program reduce programmer complexity due overall reduction possible system state lock provide benefit performance cost majority use research focus convert exist critical section critical section define context pessimistic concurrency control thus keep short performance reason short critical section quite complex future code attempt capitalize program advantage likely produce see today interrupt frequency data show much higher interrupt rat al nine assume io interrupt arrive every cycle mean simulate development see section full description interrupt occur every cycle average transaction length run cycle average transaction size grow cycle modest cache miss interrupt interrupt rout interrupt handle particular processor common source interrupt page fault local advance interrupt controller timer interrupt page fault handle locally synchronous processor fault local timer interrupt must handle locally os provide third source interrupt interrupt also must handle local intend interrupt page fault local timer interrupt configure high resolution five interrupt four device interrupt handle processor al nine propose rout interrupt best able deal though must process interrupt arrive even interrupt rout possible unclear best determine always execute might might execute transaction model like hardware mechanism indicate currently execute transaction would require global communication could add latency interrupt handle process best interrupt rout strategy also unclear may better system throughput route interrupt processor execute transaction rather processor execute code transaction interrupt handle consistent interrupt frequent grow length interrupt rout less flexible consider design handle interrupt without necessarily abort current transaction interrupt use order suspend current transaction interrupt arrive interrupt start suspend currently run transaction allow interrupt handler start new independent necessary interrupt return path end instruction nest relationship suspend transaction interrupt handler multiple nest interrupt result multiple suspend interrupt contention management contention management common default thirty simple implement hardware guarantee forward progress however presence interrupt multiple active processor contention management consider transaction run subsequently suspend via interrupt arrive second transaction b start interrupt handler conflict recent policy dictate b lose conflict b restart continue restart indefinitely suspend problem apply contention management policy suspend transaction continue win current transaction consequently suspend require modification basic hardware contention management favor transaction conflict processor atomic lock zero atomic lock one else return lock void call figure one simplify slightly modify version code release directory cache entry four stack memory previous work assume stack memory share thread therefore exclude stack memory work set fourteen however stack memory share thread kernel many os example set mode function ide driver add request structure request queue wait notification request complete structure fill whichever thread run io completion interrupt arrive architecture thread share kernel stack interrupt share kernel stack address require stack address part transaction work set ensure isolation interrupt overwrite stack address corrupt value stack address include transaction work set even stack address include transaction work set correctness section performance problem section span activation frame many expose language level six seven rely atomic declaration declaration require begin end activation frame support independent complicate model call occur different stack frame heavily rely work grab lock later release different function minimize work require add require call activation frame simplify version code depict figure one kernel start transaction one activation frame atomic pretransaction code would grab end another require stack memory part transaction able span activation frame introduce two issue interrupt handle correctness problem performance issue live stack overwrite problem figure two show stack memory start function call atomic set value local variable ret code store start transaction code return kernel thread execute get interrupt trap architecture specify interrupt protection switch interrupt processor already kernel mode use current value therefore processor save register point label stack value interrupt arrive interrupt handler execute suspend current transaction interrupt handler store local stack include overwrite value ret code interrupt handler finish back transaction interrupt transaction need restart stack pointer reset value value transaction begin transaction begin stack frame ret code live variable however value ret code overwrite store interrupt handler atomic also update ret code transaction incorrect value live variable change call situation live stack overwrite problem several factor contribute live stack overwrite problem one call occur different stack frame two trap architecture reuse current stack change privilege level three transaction suspend due interrupt restart eliminate live stack overwrite propose simple change trap architecture transaction active interrupt value value time interrupt value start transaction start interrupt handler stack frame processor write value stack specify processor save several register stack interrupt change privilege level include processor write location figure two value protect stack value allow interrupt write region stack active transaction begin process depict follow step change straightforward comprehensive register design literature two design register return free register pool instruction graduate processor compare current last latter lower address copy content save register start interrupt handler interrupt handler return restore value store stack last transactional dead stack problem conflict stack address performance addition live overwrite correctness already discuss dead portion stack complete procedure call remain transaction work set address spurious conflict transaction active interrupt arrive interrupt handler suspend use stack memory thread start transaction handler conflict dead stack frame address still transaction set stack memory longer use yet remain transaction work set cause unnecessary restart problem still occur even fix live stack overwrite interrupt handler stack state interrupt handler stack state flag flag b interrupt handler stack state figure two figure show animation process stack memory across time step label letter number number indicate temporal order letter indicate different one sequence another box activation frame upper leave frame bold name procedure within frame right justify name local ret code section depict live stack overwrite problem step transaction start one function atomic return interrupt arrive two show interrupt time section b depict transactional dead stack problem pick alternate start step call free call call return interrupt arrive handler conflict flag variable even though variable dead value stack pointer transaction start register value value stack pointer interrupt arrive stack grow toward lower number address figure two b show case interrupt handler needlessly interfere suspend transaction start call atomic start transaction code return call free call call local variable call flag function call within scope current transaction write stack frame part transaction write set call return interrupt arrive lower address potential live stack overwrite however interrupt handler overwrite stack write activation call flag write interrupt handler conflict suspend transaction even though suspend transaction longer care stack state activation frame suggest new mechanism call early release avoid false conflict stack memory early release twenty explicit removal memory address transaction work set transaction complete active transaction time stack pointer new value different cache line old processor release old cache line transaction set work specific stack pointer constantly adjust via delimit live range stack stack pointer relate frame pointer compiler allocate frame pointer hardware allow write address contain time interrupt might arrive time figure two b processor return call release line flag variable procedure return might release several line almost every instruction pop release one cache line flag early release interrupt handler conflict even write stack address early release performance optimization five modify use section describe make kernel version support natural approach convert exist use focus replace exist synchronization much current literature hardware transactional memory assume simple program model code capture diversity synchronization use support atomic sequence lock semaphore semaphore primitive different bias favor contention exist create modify follow subset popular primitive kernel static call sit intend short critical section caller spin poll wait critical section substitute disable interrupt conversion straightforward lock acquire release map transaction begin end respectively atomic atomic guarantee single operation atomically commit abort memory safely subsume ie processor start transaction issue atomic operation operation simply become part current transaction sequence lock lock store counter value start critical region increment counter reader reread counter end critical region value change reader code protect loop protect transaction three data structure avoid reader lock restrict class data protect dynamically allocate data structure access implementation use convert use maintain behavior dynamically allocate memory use data structure free kernel guarantee convert use approach convert incremental guide profile data select lock kernel follow slab memory allocator five directory cache translation path name use internal map address page data structure memory map section address space rout socket lock portion zone allocator six evaluation run machine simulator version experiment model machine use architecture simplicity assume one instruction per cycle memory hierarchy two level cache per processor split instruction data cache unify cache cache contain transactional data level one cache sixteen cache line cache hit cache miss penalty cache four associative cache line cycle miss penalty main memory cache coherence maintain snoop protocol main memory single share study fix conflict detection granularity level somewhat idealize optimize memory layout avoid false share disk device model data transfer fix access latency run script require user interaction finally model time network interface card support link fix latency use simulation evaluate execution base simulation important small change thread event time create change one example add latency transaction affect order thread schedule simulation allow time fee back execution study simply count number thread schedule occur trace take one disadvantage full simulation resource intensive data paper collect simulation average fifteen range six six days depend exact configuration initially explore design space find reasonable default many require perform parallel course several large cluster evaluate number application complete suite list table three counter different rest create define rest user program run atop thus create due difference keep mind present name counter configure find description high contention share counter consist eight kernel thread one per single share counter tight loop think time like two unlike thread perform fix number synchronization enforce run make j eight compile eight source file source tree link send stream data one instance per evaluate file system performance simulate development run sixteen instance first four phase modify compile phase parallel run eight parallel instance configure script one processor run eight instance find command print content directory consist file file content search text string find table three use evaluate eight counter find table four v system time second also show division total time percentage time performance table four five show execution time cache miss rat across unmodified execution time report study system time kernel convert use user code identical experiment give indication overall execution time table four also show breakdown total time user system idle time kernel touch roughly amount data locality data cache miss rat change appreciably performance two comparable exception counter see notable performance gain elimination lock variable save half bus traffic iteration loop table six show basic number create creation rate notably higher report literature instance one recent study eight report less every data counter seventeen configure find table five v cache miss rat total transaction rate transaction restart transaction restart unique restart unique restart interrupt system call live stack overwrite interrupt counter one sixteen four one sixty forty seventeen find configure eleven four sixty forty table six transaction statistics total create per second restart eight show rate restart low consonant publish data relatively low restart rat expect conversion effort direct reduce amount data protect individual lock acquire distinguish two type restart unique nonunique restart nonunique restart count unsuccessful attempt complete transaction unique restart measure many restart least example thread start transaction restart ten time complete count ten nonunique restart one unique restart distinction mind define total unique insulate effect contention management make closer property program test define transaction restart nonunique restart restart exceed total total nonunique compute data present calculate restart rate use x find show highest amount contention except counter several dozen function create approximately eighty find start two function code find get page however low contention cause restart restart cause two function get page free page bulk create five stack memory also show table six number live stack overwrite absolute number low relative number instance represent case without architectural mechanism interrupt handler would corrupt stack kernel thread way could compromise correctness table also show number interrupt number low many convert also disable interrupt however longer likely interrupt lose work restart interrupt early release prevent transaction conflict fourteen find four number small use interrupt short without many intervene function call get longer use general program early release become important work require release stack release million stack release run cycle transaction work set distribution work set n c n r f c p eighty sixty forty twenty zero n c n r f c p eighty sixty forty twenty zero counter configure find counter configure find r e n c e k p c e n b e r g f n c n f r e n c e k p c e n b e r g f n c n f r e n c r e n c r e n c r e n c e k p b e r g f n c n f r e n c e k p c e n b e r g f n c n f b c e n r e n c b c e n seven sixteen figure three transaction distribution number unique memory read write name axis represent value zero one distribution work set block r e n c r e n c r e n c e k p c e n b e r g f n c n f r e n c e k p c e n b e r g f n c n f c e n b e r g f n c n f seven cache block figure four transaction distribution number cache block read write name axis represent value zero one figure seven relative system time vary commit penalty among zero cycle distribution write set e k p c e n b e r g f n c n f e k p e k p e k p e k p e k p n f e k p b c e n e r g f n c n f e k p b e r g f n c n f e r g f n c c e n e r g f n c n f seven sixteen figure five transaction distribution number unique memory write name axis represent value zero one distribution write set block counter configure find counter configure find n c n r f c p eighty sixty forty twenty zero n c n r f c p eighty sixty forty twenty zero r e n c r e n c r e n c e k p c e n b e r g f n c n f e k p c e n b e r g f n c n f b seven cache block figure six transaction distribution number cache block write name axis represent value zero one figure three four five six present information size figure three five show distribution accord number unique involve figure four six term unique cache line block involve block size fix figure three four show total memory read write transaction location read write count multiple read write occur count well traditional definition work set indicate net work transaction exception counter work set size tiny design show small touch less eight cache block however touch eight sixteen cache block nine touch sixteen cache block one interest statistic average number memory address touch per cache block average transaction touch half half average number block touch eight since cache block size one fourth data cache block touch transaction actually use figure eight relative system time vary abort penalty among zero cycle figure five six focus memory write transaction count multiple write location provide information find traditional definition work set amount data write transaction play pivotal role system performance specifically data version management entirely focus transaction eager version management extra hardware usually provide buffer old version data lazy version management size determine amount data must transfer commit time use eager version management present result show write buffer would cover almost except five four whereas buffer would sufficient cover large across similar write buffer sufficient block range commit abort figure seven eight show normalize execution time variable commit abort different create different restart commit time function run transaction commit restart restart handler copy data log back memory figure nine relative system time use different contention management result normalize respect size matter policy table eight eager restart effect system time second percentage transaction restart exponential linear none random counter x eighty configure find x table seven policy effect system time second x represent data available due technical time restart time restart counter seventeen thirteen eight find configure eleven alternative implementation hardware polka incorporate conflict history investment work dynamic transaction priority require work set size conflict result also indicate policy good hardware complexity performance also experiment polite policy find among worst perform relative system time configure counter policy table seven show execution time across four different data show two undesirable random policy perform poorly configure compare none policy processor wait restart perform poorly configure linear exponential behave reasonably mean cycle linear policy cycle depend mean however show whole picture back stall small number cycle much smaller set much longer delay could explain low contention large difference linear exponential since difference pronounce restart time stall conflict eagerly restart one transaction whenever conflict detect possibly period exist however decide stall thread upon transactional conflict hope perhaps transaction commit soon allow stall transaction commit stall conflict reduce restart rate could improve performance table eight show execution time restart rat without expect stall conflict reduce restart rate execution time however necessarily improve slightly worse configure add benefit stall conflict become figure ten relative transaction restart rate use different contention management result normalize respect size matter policy result abort reveal subtle interplay contention management abort abort behave similarly explicit thereby reduce contention abort penalty increase performance necessarily decrease see find commit figure seven obvious negative impact performance moderate amount work commit time ie cycle perceivably change system performance counter slow twenty commit penalty cycle significantly slow cycle effect become pronounce contention management figure nine ten show normalize system execution time restart rat nonunique restart different contention management policy minimize execution time across polka contention management policy perform best average dint dramatically outperform artificially high contention condition share counter policy second best average share counter exclude best average performance polka drop light complexity polka policy moreover attractive seven relate work transactional memory root optimistic synchronization optimistic concurrency control moss introduce one hardware transactional memory recently speculative lock elision transactional lock removal thirty spark renewal interest hardware hardware implementation profound impact performance system semantics feasible several design transactional memory propose model closely resemble al term semantics impact cache coherence require less modification cache coherence fifteen replace traditional cache coherence transactional store update memory value place previous value log virtual memory eager conflict detection ensure two write memory area store new value place commit inexpensive transaction abort require read log handle like unbounded transactional memory two store update value place retain overwrite value log theory allow arbitrarily large size able survive page processor migration context switch implement even two base attempt simplify transactional memory implementation restrict size durability store update memory cache overflow hash table main memory fifteen buffer transactional write private cache commit time value write cache conflict detect conflict detection occur value update main memory restart transaction inexpensive lazy conflict detection however may lead waste work recent work nine add support virtual transactional memory augment transactional memory data structure order allow overflow cache survive context switch write update value memory transaction commit perform eager conflict detection concurrent proposal multiple active use work introduce pause primitive pause semantics two quite different pause design use case form atomicity trade performance would usable set instruction truly suspend pause active transaction allow code interrupt execute either start new completely independent multiple call allow pause hand allow new start pause moreover code actually independent pause execute pause access uncommitted transaction state target use case pause require communicate value transaction code sense transaction really pause programmer switch higher level resource management also evidence use compensate action escape action provide still isolation propose way deal system call interrupt operate well pause code execute within escape action start new transaction conflict detection version management bypass escape action allow register commit compensate action release isolation enclose transaction commit nest problem analogous transactional dead stack modify stack address via cause violation nest allow start end different stack frame publish material contain little detail suggest use bottom page delimit bottom stack heuristic work kernel many user program stack page transactional memory active area research synchronization program language sixteen twenty program generally isomorphic persistent drawback relative performance recent twelve thirteen seventeen however reduce performance gap promise direction future research investigate whether hybrid approach one introduce al eleven preserve advantage approach use evaluate hardware transactional memory usually fall two computation share counter allow straightforward illustration effect transactional memory hardware design computation spec illustrate performance transactional memory neither represent majority synchronization computer al two evaluate possible behavior kernel however evaluation base replay memory synchronization trace collect kernel additional impose transactional memory operate system kernel consider eight conclusion previously design necessary implement hardware transactional memory evaluate context micro application dependence operate extreme concurrency complex synchronization necessary achieve concurrency however make ideal evaluate synchronization hardware transactional memory potential greatly simplify operate system synchronization retain high degree concurrency operate also represent unique transactional memory due position computer hardware show asynchronous interrupt require special consideration design transactional memory hardware examine several hardware transactional mem ory implementation policy context operate system confirm polka contention management policy effective policy reduce transaction restart find best policy overall dependent except artificially high contention novel policy perform best average find contention important linear exponential work well transaction restart similar performance effect explicit nine would like thank shepherd mark hill well mike swift anonymous helpful comment draft paper would like thank academic site license program perform university department computer mastodon cluster make possible part cise research infrastructure grant partially support career award ten reference one wood variability architectural multithreaded two c k b c lie unbounded transactional memory three p use system v kernel annual technical conference track page four c lewis martin transactional semantics atomicity proceed fourth workshop duplicate debunk five j slab allocator kernel memory allocator summer six b h j c c k transactional program language seven p c v c k c v sarkar approach nonuniform cluster compute eight w g j van g b unbounded transactional memory nine j c h b c k transactional memory press ten j h c b c k common case transactional behavior multithreaded program eleven p lev v hybrid transactional memory twelve dice n transactional lock international symposium distribute compute disc thirteen ar al compiler support efficient transactional memory fourteen l b v wong b c k program transactional coherence consistency fifteen l v wong b j b prabhu h c k transactional memory coherence consistency sixteen k language support lightweight page seventeen optimize memory eighteen synchronization nineteen v synchronization queue example distribute compute twenty v w transactional memory data structure page j e moss transactional memory architectural support data structure may knight architecture mostly functional conference lisp functional program kung optimistic concurrency control six two june l concurrent read write j b c h c k architectural semantics practical transactional memory k e j j hill wood transactional memory j k l yen hill b swift wood support nest transactional memory e moss nest transactional memory model preliminary architecture sketch r j goodman speculative lock elision enable highly concurrent multithreaded execution micro thirty r j goodman transactional execution program r k lai transactional memory h c e kernel challenge transactional memory proceed workshop transactional memory june n l advance contention management dynamic transactional memory n transactional memory page c early release friend foe workshop transactional memory sun fortress language specification c l extend hardware transactional memory support wait action workshop hardware support transactional compute