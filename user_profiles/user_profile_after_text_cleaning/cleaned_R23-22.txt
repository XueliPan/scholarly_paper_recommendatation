fast scene presentation structure follow section two present detail texture base representation along algorithm compute scene discuss method compare relate work section three present three novel representation prove bene finally discuss advantage approach give evolution graphic hardware possible future research two principle scene grid de around traverse intersect find approach accomplish task graphics hardware base two first render view scene implicitly de grid outline grid give view frustum camera resolution give resolution precision frame second graphic card render view traverse every primitive intersect implicit grid indeed every fragment produce primitive x z value indicate cell classical render z value use hide face removal color fragment keep although fragment discard system access point idea keep information instead discard encode channel grid encode de ne grid place camera scene adjust view frustum enclose area camera orthographic perspective place position outside zone interest associate camera w h dimension indicate resolution grid x x represent column grid cell within column encode via value instead consider value four typically encode eight consider vector one represent cell column division column do ways natural one evenly divide range near far plan see improve camera division scheme de correspond image represent w h grid one bite information per cell use bite indicate whether primitive pass cell figure one show example grid union correspond give bite de slice consequently encode grid call grid construct polygonal scene use graphics hardware render texture use simple fragment abstract paper present novel approach use graphics hardware dynamically calculate representation scene obtain order even complex dynamic contain create store avoid unnecessary data transfer approach handle regular locally optimize better scene geometry paper demonstrate shadow calculation refraction shadow volume shadow refraction one introduction long history volume graphics still importance medical visualization represent acquire data scan three dimensional encode volumetric information oppose boundary mesh describe surface object representation thus give information matter space convert boundary well study problem example march cub extract surface potential function de grid paper present hardware base approach opposite task construct grid input mesh team laboratory joint z ecole copyright association compute machinery permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute commercial advantage copy bear notice full citation first page copyright work own must honor abstract credit permit copy otherwise republish post redistribute list require prior specific permission fee request one redwood city march indicate column grid v e w p r one zero camera view frustum tightly perform local recover scene extent render two depth render could also do use simple bound geometry two call near far depth generate render scene apply shader one use local value z f figure show generally create locally might less compare r g b bite indicate cell column figure one encode grid camera clarity four per channel color sixteen slice assume shader projection matrices set match choose grid texture initially clear black set zero must primitive intersect set correspond one primitive produce single fragment intersect depth fragment indicate slice fall use fragment program transform depth bite mask zero everywhere except one bite correspond slice depth value fragment range zero one distribution uniform world use depth slice would put much resolution close near plane enough close far plane instead use real distance camera cop transform position vertex transformation matrices distance pass fragment shader texture due interpolation fragment obtain correct z z f map linearly zero one use z z f one normalize distance use perform texture texture give mask correspond slice fall currently texture much perform arithmetic fragment program result texture refer texture format eight per channel represent slice note independent actual grid position compute could even include chip provide function convention texture imply value mask twenty nearest one farthest cell obtain texture must color frame get correct end logical operation provide functionality uniform local mention various ways divide column grid describe scheme produce uniform slice potentially waste resolution depth fragment give column range zero one end useless empty coarse capture detail see figure equation one reveal z f could choose column independently order enclose geometry column grid resolution number grid resolution therefore limit maximum size support graphic card currently x resolution huge compare typical size volumetric rarely exceed hand number slice rather small limitation slice arise fact logical apply eight bite channel nevertheless ways bypass limitation increase number slice natural one use additional every extra map require supplementary render geometry many performance would fortunately modern graphic card allow shader draw several color de multiple render target even formally equivalent perform several render geometry matrices actually much transformation assembly stag perform small amount extra process need do fragment shader decide value output color future bite logical become available even possible go four four channel slice integer would also welcome pack function current shader model four unsigned merge bitwise bite oat would already allow easy encode decode inside shader strength several bene first one use texture thus query vertex fragment several useful demonstrate section three second generate hardware mean high performance also live never need transfer moreover generate arbitrary geometry live vertex object particular geometry move within vertex shader skeleton animation mean reduce copy geometry work transform animate geometry view frustum view frustum b figure two uniform local slice slice uniformly use camera depth range yield regular grid coarse b column slice use local depth range yield distort grid generally view frustum al require several render recently construct al instead scene geometry use structure perform texture map store information rather sparse compare huge amount geometry process figure three leave primitive completely miss align view direction right one large slope z continuously three transmittance shadow map grind inside foliage p w h e c n n r p w h r n practice able scene three grid uniform resolution use local resolution need two extra render frame rate comparison base approach al take three min intersect maximum depth eight ie grid course representation much encode generation price store one bite information per typically presence matter store color number object possible decrease number slice allow per see section limit limitation encode boundary representation scene perform interior exterior consider subset intersect primitive indeed use intersect primitive give single fragment per column consequently intersect always find see right part figure three find create continuous set might hole occur slope primitive high well know problem grid even extreme case encounter primitive perfectly align view direction show leave figure three produce fragment primitive miss possible situation describe depend application may may issue important point large resolution x impact hole usually dramatic fragment continuity depth increase due smaller number slice hole become rare summarize allow fast hardware assist approximate determination boundary arbitrary together compact friendly encode relate work approximation layer matter visible camera sense relate layer depth image describe shade al general store arbitrary information per layer much costly obtain usually use image warp hardware acceleration use perform depth peel describe however require several render scene potentially number layer depend viewpoint advance avoid vary use occlusion query detect matter depth layer also achieve use occlusion query decrease leaf absorption figure four upper part standard shadow map approach close up grind emphasize lower part leave combine view shadow absorption right use three different leaf color transmittance shadow map achieve color shadow notice multicolored shadow cast grind color plate standard shadow map store depth along sample ray point along ray shadow light compare depth store one instead deep shadow map store ray one dimensional function describe light intensity along ray technique achieve realistic self shadow complex volumetric structure like hair point shade continuously base position evaluate function deep shadow map account three phenomena transmittance semitransparent surface tint glass partial occlusion light beam thin hair strand volumetric extinction fog section describe use render partial occlusion could handle do general use higher resolution interpolation figure five overview transmittance shadow map algorithm slice store channel eight color plate ai section describe use render volumetric approach section also relate opacity map kim aim real time scene decompose layer use several render pass obtain local opacity value value map interpolate linearly also possible approach let us consider foliage tree light point light source l neglect indirect illumination refraction irradiance point p leaf find trace ray light source sum traverse leave assume leave attenuate light factor amount count number leave intersect segment render local light source shade point p depth z projective texture depth get z f z point fully light z retrieve c p lie cell section projective texture get must set j zero j indeed correspond l p section mathematically correspond modulo operation c shader finally need compute number use texture texture refer texture shade compute one n attenuation factor leaf computation one n actually bake texture value must multiply instead add save shader however pass uniform parameter allow dynamically change value approach summarize figure five implement algorithm ultra use resolution three give slice system combine semitransparent object opaque object trunk tree shader extra standard generate opaque object point shadow continue transmittance shadow map generate semitransparent part test tree model contain figure four show drastic transmittance shadow map standard shadow map note variation shadow intensity foliage make shape tree lot perceptible attenuation also observe grind change dynamically vary leave close silhouette tree thus shadow become less pronounce rightmost image show chestnut tree frame rate opaque map near map far map shade five uniform local one one one one one one table one frame rate time standard shadow map transmittance shadow map uniform local slice give time twelve three near far compute transparent geometry tree model contain opaque interest variation resolution increase number therefore information per simply put use three make slice green reddish yellowish leaf single pass system turn show table one scale well geometry mostly shader bound particular evaluate shader hide fragment model high depth complexity tree defer shade could even reduce cost shader perform early experiment find render scene render get twenty speed due fact driver detect shader modify depth fragment perform cull shade thus evaluate visible fragment moment still lose performance shadow map shoot use depth recovery use object work properly test card method similar deep shadow approximation four slice without sixteen approach slice without hand one want treat partial occlusion via linear interpolation add extra cost method approximate one dimensional transmittance function function evaluate equidistant sample instead nonuniform sample deep shadow map last sample place exact location transmittance shadow map also closely relate al hair perform interactive rat directional light source author also create c c r r c r b r caster cull b clamp c receiver cull figure six principle shadow volume cull clamp shadow caster c fully shadow shadow volume cull b shadow volume c need extend contain shadow c shadow receiver r visible viewpoint shadow volume c need render around grid completely uniform hair strand sample point point transfer grid via one contain arbitrary density value whereas method presence matter detect hand grid usually contain point sample perform grid automatically enclose object tightly adjust frame even treat point light source future work area would like see whether result could use approximate soft shadow similar manner al layer depth image shadow volume cull clamp scene slice map shadow shadow figure seven shadow volume cull clamp shadow technique introduce al reduce rate incur render shadow contribute shadow current view three consider illustrate figure six shadow fully shadow cull shadow would cast create shadow al test caster visible light source test shadow map use occlusion query shadow need render around visible light source include caster potential al simply test depth observer view use occlusion query clamp shadow observer view frustum cut layer plan contain viewpoint orient accord light direction reason intersection front back face shadow layer project ex trapezoid observer view need project shadow cap layer delimit plan give layer al render potential two delimit plan clip plan projection light source caster furthest delimit plane render depth test fragment pass depth test shadow volume clamp consecutive layer test perform use occlusion query thus render time note render costly clip plan discard many transform stage geometry need send time also render time lead total cost number non cull another method perform shadow present multiple clamp yet fast enough compete contain information perform shadow way previous section describe ideal algorithm base propose hardware extension believe really easy implement describe less implementation work current hardware perform better al also show two ways even clamp shadow ideal algorithm shadow al cull test shadow map observer depth map respectively compute uniform potential computation bite section two slice must follow layer instead perpendicular light direction cell contain fragment longer use texture instead project correspond point observer view compute distance projection light along projection light direction distance compute vertices correctly interpolate fragment caster shadow volume clamp caster project need simply could do extend occlusion query mechanism every fragment content value special register initialize zero order independent do concurrently nature would return value register similarly number success return occlusion query demand kind reduction register treat order independent exist quite time case structure would even simpler value would even need lock cation occur extension clamp caster would require single render caster matter number slice cost independent number slice result total c r c b r figure eight improve cull clamp practical algorithm without propose hardware extension still use clamp solution would perform hand use matrix reduction method similar buck bite tricky set might slow instead propose use occlusion query like al run slice use fragment program test cover bite current slice set one discard fragment use occlusion query least one fragment discard decide whether clamp cost approach generation clamp total cost less shadow improve cull clamp algorithm describe far perform optimal cull clamp figure eight show two case handle leave algorithm would cull shadow volume c around whole receiver r since part one dash actually shadow another caster shadow volume clamp account situation test caster slice compare depth fragment depth shadow map strictly greater safely discard fragment ignore word caster cull oppose caster cull rightmost example show receiver visible observer actually shadow account use approach describe generate discard fragment visible observer thus fragment generate one bite amount instead receiver cull note two would work straightforwardly al although describe result implement algorithm test figure seven show result obtain simple scene validation complex exact measure could interest main intention show applicability possible gain method especially propose hardware extension become respect previous approach refraction frost glass representation use calculate approximation volume traverse ray base distance refraction increase scatter approximate color shift towards color object simulate gas simple approach obtain reasonable refraction present work inspire approach base surface normal eye ray hit object environment texture perturb idea take volume account present recently normal depth map farthest surface calculate vertex object depth along normal algorithm perturb ray base interpolation depth depth map information use together two normal map obtain ray one major problem use farthest surface approximate volume traverse eye ray correct convex object give arbitrarily wrong value case section present solution require use reliable information actual volume traverse eye ray simulate three refraction attenuation scatter relate traverse volume nevertheless input model necessary watertight otherwise proper volume de also possible determine whether draw fragment correspond front back face surface make simplify assumption volume traverse refract ray closely relate volume traverse eye ray straight ray come eye sum face intersect eye ray would result acceptable volume cube would constant point view intersect ray always hit convex object two time input model close ray hit object enter via front face point surface remain inside object exactly back face surface hit crow ray remain outside object new front face surface encounter process repeat complete traverse volume sum front face back face surface along ray obtain information face orientation two local create consider front second back face do single pass use fragment shader output fragment accord texture depend orientation achieve coherence two use local normalization although precision could still increase via two channel find practice slice therefore one texture orientation local precision obtain convince result two want ray number traverse inner lie inside volume de model number scale accord local precision obtain depth result volume approximation call naive approach would sum front back several concern simple approach first might completely fail due discrete nature representation second map well onto graphics hardware let us look algorithm fail main problem front back face surface fall qualify ambiguous conversely unambiguous contain one type orientation raise two show figure nine impossible retrieve traverse volume address simply consider whole inner one reasonable approximation give size second problem within ambiguous object surface cross unknown number time thus follow empty ambiguous unambiguous ambiguous ambiguous front back front back b front back c figure nine leave status empty ambiguous unambiguous resolve inside unambiguous front outside back b empty two ambiguous inside c outside could inner remain unresolved non empty encounter unambiguous previous state determine ambiguous nothing say practice decide include potentially wrong cation two successive ambiguous actually rare moreover two front face ambiguous choice correct create fragment program perform trivial recover apply naive algorithm would slow possibility solve integral would use texture give number inner give since two texture table approximately sixteen observation naive algorithm incremental calculate number inner position one require knowledge number inner traverse position state whether current position inside outside thus possible treat channel successively evaluation texture single channel require however still dependency state theoretically lead dependent texture need recover new state end channel since number inner eight four need encode use four remain encode new state simply add remain inside volume new state still depend old state solve store two possible two channel evaluation texture two remain channel use treat ambiguity store whether non empty back last non empty ambiguous one plus number succeed empty data use compute number inner follow manner fetch four value evaluation texture four pair dependent texture necessary pair successively previous state inside add value number inside otherwise add value case update state accordingly ai zero successive channel must check resolve front back r g b zero zero irrelevant eighty irrelevant irrelevant one zero three zero four fifty forty zero zero figure ten evaluation value pair irrelevant represent occur encounter front face inside object figure eleven various image obtain f resolution ultra color plate do look contain type information non empty channel special case channel one empty proceed two ambiguity resolve ai use add behind ambiguous position last channel treat volume compute sum inner normalize local depth interval make refraction dependent volume simple scale apply perturbation environment map simulate attenuation opacity calculate base power function scatter use hierarchical environment map build either pyramid accord al better result less sample depend traverse volume higher lower level pyramid access perturb refraction lead information ray stay inside object figure eleven show obtain twelve summarize approach frame rate far refraction model quite simple observable example part object behind shine exact border nevertheless find acceptable especially comparison simple volume estimation base depth map yield unrealistic appearance concave implementation refraction indices color absorption dynamically change intend constant could frame rate would even increase present model step direction exploit representation volumetric could interest combine approach translucent shadow map write volume value step texture could process would allow object four conclusion future work present new method quickly calculate simple representation use graphics hardware method fast complex model resolution grid high two dimension though reasonable third introduce local precision feature perfectly suit use graphics card along increase resolution approach bene structure graphic card integrate produce various several present eye interest community transmittance shadow map allow emulation simple deep figure twelve overview refraction algorithm color plate shadow map even older hardware acceptable precision frame rat hardware support improve quality approximation almost cost several achieve base information object volume approach combine advantage exact shape information form depth map approximate volume form result good overall estimation show information could use create frost glass like possible currently investigate fast particle collision detection error also remain future research believe algorithm become even valuable future graphics card particular bite precision logical become possible number slice could increase bite time four channel time four render target instead currently eight bite single pass almost supplementary cost thank e e remark insightful comment work found region ecole reference r l render soft shadow proceed annual conference computer graphics interactive conservative tile journal graphics tool ten three f c practical algorithm interactive hair animation graphics interface best student paper award j e algorithm computer control digital plotter journal four one buck crow shadow computer graphics pro c translucent shadow map proceed workshop render three x depth map query graphics forum three c interactive transparency order n complete polygonal scene journal graphics tool seven three p survey texture map graphics j g singh fast table generation proceed five kim opacity shadow map graphics render workshop f texture texture surface symposium interactive graphics press b j n k proceed shadow render association springer computer science e zero proceed annual conference computer graphics interactive publish new york deep shadow map h w two hair animation render render soft shadow proceed annual conference computer graphics interactive shade j l r layer depth image proceed annual conference computer graphics interactive press new york two nineteen generic refraction simulation l cast curve shadow curve surface proceed annual conference computer graphics interactive press new york c approximate approach interactive refraction proceed international conference computer graphics interactive press new york