international symposium computer architecture international symposium computer architecture detect survive atomicity computer science engineer university advance architecture technology laboratory abstract write parallel program among concurrency often face atomicity especially challenge happen make incorrect atomicity fail enclose memory access occur atomically inside critical section access happen interleave conflict access different thread program might behave incorrectly recent architectural arbitrarily group consecutive dynamic memory atomic block enforce memory order coarse grain provide call implicit atomicity atomic block derive explicit program paper make fundamental observation implicit atomicity hide atomicity reduce number interleave memory propose create implicit atomic block intelligently instead arbitrarily dramatically reduce probability atomicity manifest also able report atomicity might exist code provide resilience evaluate use buggy code include apache show virtually eliminate manifestation atomicity one introduction extract performance emerge multicore require parallel program however write program difficult largely inaccessible write explicitly parallel program share memory need pay special attention keep share data consistent usually do specify critical section use lock however typically often lead synchronization defect atomicity atomicity challenge concurrency happen make incorrect atomicity fail enclose memory access occur atomically inside critical section accord recent comprehensive study fifteen atomicity account two examine concurrency bug work support part national science foundation grant gift research bug hard find due subtle nature multithreaded execution hence afford assume code free bug important detect bug survive prevent manifestation interestingly manifestation concurrency bug much influence multithreaded program execute determine global interleave memory give memory semantics expose multiple valid global interleave memory choose allow subset interleave avoid concurrency bug still expose memory semantics leverage property work recent architectural arbitrarily group consecutive memory atomic block six implicit provide call implicit atomicity arbitrarily group sequence dynamic memory program thread atomic block chunk without follow program annotation significantly reduce amount interleave memory different thread interleave happen coarse granularity main goal bridge performance gap memory consistency model enforce consistency coarse grain paper show implicit atomicity interest property able hide atomicity memory happen fall within chunk build upon observation propose architecture divide dynamic instruction stream chunk intelligently instead arbitrarily increase odds atomicity violation hide figure one show simple example counter share variable read update counter inside distinct critical section protection lock l imply code free however code still incorrect call increment another thread could interleave right read update counter lead incorrect behavior two concurrent call increment could counter subtle error easy mistake make since determine atomicity necessary need group atomically difficult prone fact even program write transactional memory twelve fourteen eighteen subject atomicity insert appropriate place atomicity lead incorrect program behavior unfortunate interleave memory access differ counter share variable protect lock l bad interleave remote thread read update counter happen inside critical section void increment temp lock l temp counter unlock l temp lock l counter temp unlock l chance atomicity violation lead wrong program behavior several order magnitude reduction paper organize follow section two give background information implicitly atomic atomicity section three explain observation probability study section four present algorithm architectural present evaluation infrastructure result section five six respectively finally section seven discuss relate work section eight conclude figure one simple example atomicity violation read update counter two thread may interleave counter two background implicit atomicity thread break atomicity make programmer chance atomicity violation manifest depend chance unfortunate interleave figure two show four interleave happen traditional interleave contrast figure two b show interleave happen memory atomicity violation happen inside chunk case atomicity violation hide section three explain analyze observation detail lock l counter unlock l lock l st counter unlock l interleave lock l counter unlock l lock l st counter unlock l implicit atomic block arbitrarily define processor b figure two interleave show interleave thread happen traditional system b show interleave happen provide implicit atomicity paper make two first make fundamental observation implicit atomicity naturally hide atomicity justify observation probability analysis empirical evidence second propose architecture use hardware detect likely atomicity dynamically adjust chunk make system detect survive atomicity without require program annotation best knowledge first paper survive atomicity without require global recovery thirty since want atomicity go unnoticed programmer also able report atomicity may exist code provide resilience finally provide evaluation use buggy code real show able reduce support implicit atomicity memory dynamic instruction stream arbitrarily group atomic chunk way consistency enforcement support coarse grain chunk oppose support granularity individual six atomic sequence order implicit propose recently say provide implicit atomicity chunk follow annotation program contrast explicit atomic essence implicit atomicity take periodic every dynamic form chunk dynamic appear execute atomically isolation important note chunk program construct prototype twelve use periodic transaction commit support legacy code show implicit atomicity implement direct extension soon available commercially one goal support consistency enforcement coarse grain bridge performance gap strict relax memory model keep hardware complexity low enforce memory consistency granularity chunk complete chunk atomically allow processor fully reorder within chunk preserve order memory consistency model since order within chunk expose remote result six implicit offer sequential consistency performance relax memory model release consistency eleven support consistency enforcement implicit atomicity two interest leverage create first memory order reduce amount interleave memory different interleave granularity chunk imply effect remote thread visible chunk figure three contrast fine interleave figure three interleave happen show leave side six possible interleave show right side whereas figure three b interleave happen chunk far possible interleave two example second interest property oblivious granularity consistency enforcement allow system arbitrarily choose chunk adjust size chunk without affect program correctness memory semantics observe possible pa interleave possible interleave pa chunk b figure three fine b access interleave six possible interleave system two possible interleave system implement architecture support implicit atomicity generally system support form arbitrary atomic block dynamic instruction stream however purpose illustration paper assume underlie system similar six repeatedly execute chunk separate dynamic instruction execute outside chunk briefly describe naturally provide much implementation need irrespective underlie system important note rely specifically bulk five set hardware simplify support common multiple speculative thread task transactional memory speculation hardware module call bulk module dynamically summarize address task read write read r write w respectively signature inexact encode address follow bloom filter two subject consequently signature represent original address set also include perform signature union intersection expansion leverage cache hierarchy support bulk processor efficient memory subsystem extend arbiter guarantee total order commit processor execute chunk speculatively buffer update memory cache generate r w signature chunk complete processor send arbiter request commit together wi arbiter intersect wi w chunk empty wi save arbiter also forward interest cache commit cache use wi perform bulk potentially abort local chunk case conflict exist chunk periodic choose arbitrarily every finally forward progress guarantee reduce chunk size presence repeat chunk abort atomicity widely know concurrency defect occur conflict access different thread piece share data least one access write synchronize thread prevent simultaneous access work tool eight nine nineteen hardware support twenty detection however point al ten freedom imply concurrent program correct program still atomicity code snippet figure one data race access counter properly synchronize however code still incorrect example miss atomicity since read update counter atomic avoid unwanted interleave access counter thread atomicity noninterference property freedom point al ten atomicity violation exist code programmer make incorrect atomicity fail enclose access perform atomically inside critical section note atomicity also exist program use synchronization oppose lock programmer fail enclose memory access share suppose perform atomically inside transaction atomicity concurrent execution say mean sequential execution section assume atomic programmer one interleave occur equivalent guarantee produce final state one produce interleave occur conversely atomicity violation concurrent execution ie equivalent sequential execution guarantee produce final state apply concept directly share data access determine whether interleave memory access share variable al sixteen use analysis determine access interleave detect system table one reproduce analysis present sixteen column interleave represent interleave format c pair local memory access interleave c access remote thread example w correspond two local read access interleave remote write access interleave r r w r r w w w w r r w w r w r w w w w serialize comment yes yes yes yes interleave write make two local read inconsistent local write may depend result read overwrite remote write local write local read get expect value intermediate value write first write make visible thread table one memory interleave analysis case sixteen terminology use paper throughout rest paper use follow terminology section region code include memory suppose atomic code include read update counter figure one size atomicity violation number dynamic section opportunity interleave point execution thread operation remote thread observe correspond chunk implicit atomicity pair memory conventional atomicity violation say expose possible two memory assume atomic programmer interleave another remote memory operation ie least one opportunity interleave inside section conversely atomicity violation hide memory interleave ie interleave section atomicity violation manifest expose specific concurrent execution accord table one likely lead incorrect program behavior refer likely atomicity violation interleave could potentially happen necessarily happen local access remote access table one nearby time necessarily interleave finally refer implicitly atomic chunk granularity interchangeably three implicit atomicity hide atomicity viola section contrast chunk granularity instruction granularity show implicit atomicity chunk granularity reduce chance atomicity expose consequently manifest happen section completely enclose within chunk call phenomenon natural hide achieve effect implicit atomicity statically compiler automatically insert arbitrary program challenge could hurt performance even prevent forward progress three hand support implicit atomicity provide forward progress guarantee six probability study show analytically chunk granularity lower probability expose atomicity instruction granularity follow analysis let c default size chunk number dynamic size atomicity violation number dynamic section let probability section fall inside single chunk ie probability hide atomicity violation figure four illustrate derive probability section fall inside chunk first operation section within first c chunk total c first second fall chunk commit atomically hide atomicity violation model express probability hide atomicity violation show figure four chunk first operation fall anywhere two chunk hence atomic th instruction c atomicity lack section zero c c c figure four section within chunk probability two fall within chunk note assume instruction granularity system system chunk size equal one instruction c one imply zero since size atomicity violation least two two consistent intuition instruction granularity system hide atomicity also note worst case section bigger chunk actual zero well show chunk granularity hide atomicity never increase chance manifest figure five show probability hide atomicity violation various violation size chunk size increase accord expression show figure four expect observe increase chunk size increase probability hide atomicity violation subject diminish return violation size zero zero size chunk figure five probability hide atomicity different size function chunk size experiment observe typical atomicity violation range assume chunk size observe figure five expect probability naturally hide typical atomicity ten eight six four two l n v c g n h f l b b r p four actively hide atomicity smart chunk section three show implicit atomicity naturally hide atomicity also point section choice place chunk arbitrary affect memory semantics idea behind smart chunk automatically determine place chunk order reduce probability expose atomicity detect potential atomicity insert chunk boundary right first memory access potential hop enclose memory access section inside chunk essence infer critical section dynamic instruction stream insert chunk accordingly note process transparent oblivious synchronization construct might present code detect potential atomicity observe memory access chunk interleave memory access commit chunk system detect least two nearby access variable local thread least one recent access another thread look type access involve determine access potentially start monitor access local thread access decide chunk boundary insert keep history memory access record read write set recent local chunk recently commit remote chunk figure six seven show idea apply counter increment example assume provide implicit atomicity maintain read write set previously commit chunk call respectively recall commit chunk send write set system allow learn write recently remote commit chunk figure six execute increment chance read update counter atomic due natural hide figure six happen example read counter inside previously commit chunk p update part chunk currently build c counter update c determine counter read previous local chunk counter recently update remote processor counter characterize potential violation make counter member set possibly involve atomicity violation later figure seven access counter detect counter therefore chunk boundary insert read counter execute increase chance access counter enclose chunk make atomic atomicity violation figure six expose mean manifest also explain next section even atomicity violation naturally hide still able detect show able detect atomicity manifest lock l counter unlock l lock l st counter unlock l lock l counter unlock l lock l st counter unlock l counter counter counter might involve atomicity violation add figure six actively hide atomicity violation discover counter might involve atomicity violation add counter force chunk break lock l counter unlock l lock l st counter unlock l default chunk size figure seven actively hide atomicity violation counter access chunk automatically break belong follow section explain detail detection algorithm work decide place chunk also describe architecture build around signature implement use algorithm detect likely atomicity mention goal detect potential atomicity happen find two nearby access local thread address one recent access another thread address examine type access determine whether potentially treat potential atomicity need keep track three piece information type read write address memory operation currently execute read write set current previously commit chunk refer respectively read write set chunk commit remote previously commit chunk execute refer together read write set chunk commit current chunk execute refer table two show information use determine whether access constitute potential atomicity first column show type give local memory access second column show interleave try identify observe local memory access third column show identify example consider first two case local memory access read two possible interleave w w w detect either happen use correspond set third column specifically identify potential w interleave first check whether find local read set check whether also find remote write set chunk commit another processor either previous local chunk execute since begin current local chunk condition satisfy identify address potentially involve atomicity violation add processor note case necessarily atomicity violation remote write might actually interleave two read also since keep two chunk worth history capable detect atomicity shorter size two chunk limit factor since hide atomicity chunk local read write interleave w r w w r w w w r w expression table two case address add adjust chunk address add processor every access address local thread trigger place chunk boundary right access trigger would actually prevent atomicity violation expose see consider figure seven suppose address variable counter previously insert load counter execute trigger place chunk boundary right access store counter execute trigger place another chunk boundary point would actually expose atomicity violation instead hide intend break chunk place new chunk boundary undesirable example atomicity involve multiple access might invoke several time actually want place chunk boundary first access every single access another example case address add chance local thread still manipulate correspond variable case avoid chunk break actually beneficial intelligently determine whether place chunk boundary trigger use simple policy consist two condition figure eight show policy first condition one determine never break chunk force break newly create chunk large default chunk size second condition two determine add address execution give chunk break chunk address access yes nothing yes one current chunk already force break two current chunk change yes break chunk figure eight policy architecture base signature opera base implementation offer convenient way store read write set chunk collect information require algorithm describe section add three pair original design figure nine show use hold read write set currently execute chunk use chunk memory hold read write previously commit chunk chunk commit copy respectively signature encode local downgrade due remote read request receive current chunk execute likewise signature hold receive remote current chunk execute current chunk commit copy respectively thus encode remote happen execution previous chunk chunk abort discard keep rest memory access history intact implement use yet another signature case check address do simple membership operation signature alternatively implement extension cache tag extra bite per cache line tag indicate whether correspond line address part cache line access bite local chunk encode remote access st st previous chunk p current chunk c w remote read downgrade modify data also access require detection algorithm chunk break policy do parallel case implement extension cache tag also unlikely affect performance since data bite indicate correspond address part fetch simultaneously one final implementation detail state require would make sense preserve context switch necessary figure nine use detect likely atomicity five experimental setup simulation infrastructure check determine whether correspond address belong signature support address implementation do simply encode word address oppose line address implementation do one bite per word cache line indicate whether correspond word present two one complexity effectiveness implementation simpler require address present cache suffer false especially contain many data address implementation implementation approach complex addition information particular cache line lose cache mention want useful tool well envision make visible provide fast trap mechanism trigger every memory access address implementation discussion assume system paper support implicit atomicity leverage take example twelve system mechanism automatic implicit do write set still send commit possible record information need augment structure hold incoming write set remote commit also possible use similar structure hold read write set previously execute chunk furthermore minor also implement support implicit atomicity memory order long support form atomic block dynamically performance impact architectural structure require negligible membership operation fast involve associative search require simple logic five result access likely much faster access cache read model system resemble six use pin seventeen dynamic binary instrumentation infrastructure model include execution use represent read write set require algorithm unless otherwise note signature configuration use five since simulator base binary instrumentation run real environment subject reason present result average across large number run error bar show confidence interval average need determine whether particular section fully enclose within chunk assess often hide explicitly annotate code begin end section model check dynamically fall within chunk correspond atomicity violation consider hide important note use algorithm way sole purpose evaluate propose simulate experiment use two type bug entire goal use bug generate extreme condition section execute often real use perform stress test short amount time also include entire apache complete evaluation run use perform insert select query apache run use play media file visualizer create bug real base previous literature atomicity ten sixteen thirty make sure atomicity violation original application remain intact kernel version wherever possible also include program affect time io mimic realistic interleave behavior kernel table three list use evaluation provide number thread use average maximum standard deviation value violation size along brief description bug reasonably wide range violation size eighty dynamic violation size find real type name atomicity violation size thread dev description sweep forty zero apache zero real two two two two two five five two two six kernel version apache log system bug share bank account data structure withdrawal deposit incorrectly synchronize program may lead inconsistent final balance previous atomicity violation share work list data order bug remove process add work list may reorder work list previous atomicity violation share data structure null bug thread inconsistently manipulate share log one thread set log pointer null another read crash previous atomicity violation kernel version log system bug overflow bug ten append require lock hold another thread may change buffer append state become inconsistent log bug apache two thread access log entry without hold lock change entry length lead miss data crash security backdoor one thread close file set log status close thread access log log thread see close log discard visualizer bug media player visualizer access stream data data change free cause corruption crash table three bug use evaluate large several hundred never exceed one thousand believe reason atomicity relatively short long atomicity easier find test since bind manifest often find bug similar size real however artificially add work section evaluate violation size note apache violation size full application kernel different additional work generate random log use custom implementation real study use number thread range six bug use two thread sufficient reproduce original atomicity violation experiment present section six simulate bug forty time chunk size vary chunk size due simulation time run real five time chunk size six evaluation evaluation consist four part section show experimental validation probability study present section verify implicit atomicity indeed capable hide number atomicity violation instance section show improve number hide almost atomicity violation instance section present data dynamic behavior include comparison implementation use hardware one use exact set finally section discuss information collect use help locate bug source code natural hide validate probability study section run table three simulator configure system implicit atomicity support vary chunk size measure often atomicity violation instance fall within single chunk figure ten show percentage atomicity violation instance naturally hide bug chunk size increase line plot correspond see figure four average violation size bug kernel show table three experimental data point close line derive analytical model verify accuracy model well hypothesis implicitly atomic naturally hide atomicity figure ten include data real leave bar cluster figure eleven b show natural hide effect real chunk size also follow analytical model overall implicit atomicity chunk size small dynamic naturally hide seventy atomicity violation instance nine twelve remain artificially large atomicity prevent natural hide chunk size dynamic less keep probability natural hide lower chunk size intuitively chunk size increase difference gradually reduce result show implicit atomicity naturally hide large fraction atomicity however show next section significantly improve hide effect approach n e h n l v c f n e c r e p zero zero sweep chunk size figure ten experimental data natural hide atomicity implicit atomicity various chunk size bug point show empirical data curve show data predict analytical model active hide smart chunk section assess improve hide implicit atomicity smart chunk figure eleven show percentage atomicity hide bug kernel chunk size increase whereas figure eleven b contrast hide effect plain natural hide implicit atomicity real result show able hide virtually atomicity violation instance present include real chunk size dynamic even smaller chunk size hide majority atomicity violation instance notable three bug artificially atomicity explain section atomicity hide smaller chunk suffer early chunk break decrease chance hide atomicity smaller chunk size use however problem disappear chunk size reach dynamic chunk become large enough enclose access cause early break actual atomicity violation entirety thus hide completely overall smart chunk algorithm capable hide much higher percentage atomicity violation instance natural hide moreover reduce number expose atomicity violation instance several order magnitude compare current commercial ie hide atomicity violation instance virtually characterization sensitivity table four characterize behavior provide data collect bug use study oppose real provide control environment run faster two three reproduce data figure ten eleven respectively show percentage hide atomicity natural hide smart chunk chunk size dynamic atomicity hide naturally average smart chunk able hide virtually column four smart chunk show fraction chunk create smart chunk algorithm program execute column five unnecessary smart chunk show percentage additional chunk help hide atomicity unnecessary smart chunk large show may often create chunk unnecessarily however smart chunk typically low even create many unnecessary chunk still add small fraction chunk imply unlikely noticeable impact performance six six seven illustrate behavior atomicity violation detection algorithm column six size show many distinct data address line granularity identify involve potential atomicity violation algorithm select average four data potentially involve atomicity violation column seven break show many distinct static memory code cause smart chunk algorithm break chunk average break chunk three place program result show quite selective identify data address point program potentially involve atomicity report programmer turn reasonably precise information potential atomicity violation use application explore aspect section far discuss data implementation exclusively use hardware chunk detect chunk interleave maintain exact correspond behavior nonsignature base implementation design present section simulate ideally unlimited size exact set detect potential determine memory address chunk break present result group entitle exact table four behavior exact implementation would similar behavior implementation use cache tag way keep set address see section first important hide exact implementation column eight practically hide implementation column three show impact signature effectiveness negligible expect smart chunk four nine average higher since cause chunk break frequently however difference small phenomenon also reflect percentage unnecessary smart chunk five ten significantly lower exact note previously however negligible impact performance n e h n l v c f n e c r e p zero zero chunk size natural hide active hide sweep apache bug b real chunk figure eleven average percentage atomicity hide error bar show confidence interval natural smart unnecessary break bug hide hide chunk smart chunk size hide chunk exact smart unnecessary smart chunk sweep average zero one two one zero five four four two two eleven two three three four three three three two two four two six two three eleven zero one four one zero table four characterization signature nonsignature discussion show able hide almost atomicity violation instance demonstrate algorithm insert chunk appropriate place also able report program counter memory instruction chunk automatically insert since place program potentially buggy miss critical section use aid process locate bug code detail analysis complete tool outside scope paper able use feedback locate code bug apache use past work bug detection sixteen thirty even detect new bug use follow process locate bug collect set chunk insert group line code function appear finally traverse result list function frequently appear least examine line function frequently appear line least use process able locate bug inspect relatively small number point code table five show data experience find atomicity bug real first group program total show total number file function line code entire application second group chunk break point show number file function line code break chunk application execute third group show number file function line code inspect locate bug apache line code six file need inspect locate bug number code base almost line code identify bug previously inspect nine line code overall information provide useful direct programmer attention right region code even use simple heuristic like one present however feel sophisticate could result even effective program total file line chunk break point file line seven file line six two eight four nine apache table five characterization bug detection process real use seven relate work mechanism detect survive atomicity amount work concurrency bug detection survival widely discuss project lead contact regard bug however feedback receive time final version paper submit relevant prior work hardware support atomicity violation detection sixteen use train run extract interleave check hold future run monitor interleave extend cache leverage cache coherence protocol monitor interleave differently leverage hardware addition monitor potential might necessarily happen distinguish train detection leverage implicit atomicity survive concurrency bug violation detection thirty use heuristic infer potential critical section base data control goal determine thirty author briefly mention algorithm could possibly implement hardware envision bug avoidance via global restart like attempt infer critical section dynamically however use memory access history interleave detect potential bug avoidance rely dynamically make potential violation atomic require global restart twenty another hardware proposal target concurrency bug however focus identify survive atomicity discuss attempt automatically repair base library race pattern substantial work twelve fourteen eighteen well new construct atomicity four seven thirteen note also apply new still subject atomicity cause programmer specify incorrect atomicity eight conclusion parallel program go inevitable deal concurrency bug bug easy introduce difficult remove reason believe help detect bug also survive atomicity common challenge category concurrency bug often result incorrect atomicity make programmer paper show implicit atomicity property naturally hide atomicity significantly reduce degree memory operation interleave justify observation probability analysis extensive experimental data build top observation propose new approach detect potential atomicity choose chunk avoid expose without require special program annotation global mechanism evaluation use know bug literature full apache show reduce chance atomicity violation lead wrong program behavior several order magnitude case hide atomicity also show information derive guide chunk boundary placement use aid believe meaningful step toward system offer resilience detectability concurrency bug thank anonymous useful comment thank research feedback initial idea also thank mark kim university invaluable feedback manuscript finally thank rich alan lee feedback support support l fellowship faithful steward endow fellowship reference one sun slot transactional memory rock transactional memory rock two b bloom hash cod allowable three c e lewis martin transactional semantics atomicity workshop duplicate debunk four b h j c c k transactional program language conference program language design implementation five l j tuck c j bulk speculative thread international symposium computer architecture six l j tuck p j bulk enforcement sequential consistency international symposium computer architecture seven p c k c c v v sarkar approach nonuniform cluster compute international conference program eight din e empirical comparison monitor access anomaly detection symposium practice parallel program nine k effective static detection race condition symposium operate ten c type effect system atomicity conference program language design implementation eleven k j p b j l memory consistency event order scalable international symposium computer architecture twelve l v wong b j b k prabhu h c k transactional memory coherence consistency international symposium computer architecture thirteen k language support lightweight international conference program fourteen j e b moss transactional memory architectural support data structure international symposium computer architecture l yen hill k implement transactional memory international symposium fifteen park e learn mistake comprehensive study real world concurrency bug international conference architectural support program operate sixteen j f detect atomicity via access interleave international conference architectural support program operate seventeen c k r r muth h g v janapa k hazelwood pin build program analysis tool dynamic instrumentation conference program language design implementation eighteen k j j hill wood international symposium transactional memory computer architecture nineteen r b miller improve accuracy data race detection symposium practice parallel program twenty j use speculation data race multithreaded cod international symposium computer architecture z j revive architectural support rollback recovery international symposium computer architecture r k lai transactional mem ory international symposium computer architecture savage burrow g nelson p eraser dynamic data race detector multithreaded program computer martin hill wood improve availability share memory global international symposium computer architecture e f r p j e smith implement international conference pervasive service f tip j associate synchronization data language symposium program wee j n ge c k practical framework novel research international symposium gate array f b international symposium computer architecture thirty r hill violation detector server program conference program language design implementation p r hard race detection international symposium computer architecture