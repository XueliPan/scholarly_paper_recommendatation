characterization support development compiler use decision tree data mine institute compute architecture school university unite kingdom abstract embed successfully enter broad variety application automotive industrial control network digital media consumer equipment office many paper investigate exist fundamental application justify development tune develop approach capable identify present readily interpretable format base decision tree generate profile summarize key resource utilization issue enable compiler engineer address highlight bottleneck evaluate methodology industrial suite three popular embed find profile differ significantly application demonstrate exploit development compiler case study show average performance class network subject computer organization performance attribute general term experimentation measurement performance characterization data mine decision tree permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee june st copyright introduction embed processor use vast range different application reflect example provision offer embed consortium consortium cover embed automotive consumer digital entertainment network office domain hardware develop specialize embed digital signal network contribute efficient lower price due domain specialization however true compiler technology target embed fact compiler research area drive development new hardware largely focus target specific architectural feature dual memory bank loop buffer irregular data recently adaptive find way optimize application restrict tune select order code transformation sequence far little advantage take specialize exist particular embed domain believe due two reason lack work characterize different embed application b lack knowledge transfer characterization compiler development paper investigate data mine approach use decision tree explore broad range embed seek identify characterize specific different embed way exploit development optimize motivation characterization embed different look resource utilization processor unit unit multiplier shift branch unit branch unfortunately result study average number information provide therefore repeat experiment greater level detail show result three embed detail table five application automotive consumer network office use diagram similar figure comparison across reveal utilization functional example show relatively high proportion shift platform however effect observe arc time branch unit arc processor show higher utilization interestingly consumer exhibit higher branch utilization arc processor match two obvious correlation branch frequency across hand visual inspection diagram reveal number utilization unit significantly higher network across three furthermore automotive office result similar pattern automotive consumer processor automotive consumer arc core respectively diagram suggest certain application automotive office show similar resource utilization whereas network exhibit unique resource utilization pattern furthermore data suggest differ across shift automotive feature correlate network however remain unclear underlie cause different pattern important obvious specific could exploit tune approach put forward hypothesis successfully construct classifier distinguish different embed classifier characterization correspond application possible problem approach many artificial neural network open human interpretation thus propose use decision tree data mine simple understand interpret show work well even small data set test hypothesis induce decision tree industrial suite different application base dynamic program feature instruction mix cache utilization three popular embed experiment demonstrate induce decision tree capable accurately predict application domain hence use derive meaningful domain characterization among paper investigation decision tree characterize embed different comparison cluster base char methodology feature processor memory operation type branch shift memory cache logic move sign bite table overview aggregate feature set demonstration obtain characterization successfully use pinpoint performance bottleneck eventually identify compiler remainder paper structure follow introduce characterization methodology section present setup detail empirical evaluation section follow discussion result section case study section section establish context work exist body relate work finally summarize conclude section characterization methodology classification try predict attribute label previously unseen data item base available attribute feature item popular classification algorithm use extensively data mine machine learn decision tree decision tree algorithm easy use implement low computational complexity importantly result readily available interpretation despite information theoretical decision tree classifier induce train data set feature label present initial train period decision tree use predictive model ie predict label new data item feature associate label give however paper use decision tree differently rather use prediction use induce decision tree directly characterization case feature characterize program comprise instruction mix counter see section label correspond one application automotive network decision tree establish relationship observe counter membership particular domain internal node decision tree correspond conditional expression relate value feature constant threshold nod usually label name feature particular threshold value branch depart node correspond possible test value leaf nod hand specify label return leaf reach follow path root decision tree one leave produce sequence condition data cache miss rate greater characterize describe leaf category automotive contain differ significantly one leaf node may generate automotive automotive paper use standard decision tree algorithm introduce construction tree algorithm choose node exactly arc figure diagram show resource utilization different embed e f e g c b e f e g e f e g c b e f e g e f e g c b e f e g e f e g c b e f e g e f e g c b e f e g arc figure decision tree induce depth leave represent application branch represent feature lead highlight refer network domain contain reassembly discuss section label data cache read miss memory write sign level data cache read miss instruction miss thickness color bar leave indicate many fall leave color indicate many group platform arc branch branch take instruction set branch memory cache data cache data mem miss cache miss miss miss miss page dirty miss memory count cycle count cycle access page count cycle table overview program feature gather attribute split data effectively maximize information gain experimental setup methodology section provide outlook experimental setup evaluation methodology use suite evaluation propose characterization methodology belong one follow five application automotive consumer network office program feature program characterize set numerical feature collect simulation run use instruction set three processor consider paper essentially feature correspond counter maintain instruction event specific feature list table group feature functionality branch similar approach take group feature summarize table contrary feature consider paper primarily focus identification profile evaluate characterization methodology three popular embed architecture arc platform detail include development tool chain summarize table evaluation methodology evaluate accuracy decision tree characterization approach use cross validation technique partition data set k turn use k partition induce decision tree subsequently evaluate data partition cross validation essential avoid time provide metric well induce decision tree describe observe domain membership experiment conduct decide use special case cross validation call cross validation k set total number platform arc processor core pipeline execution order interlock yes yes vector dual issue yes yes yes simple ram native yes bus yes simple ram native arc simulator default emulate library emulate default native support branch memory system level cache level cache main memory bus simulation simulator io dev tool compiler compiler opt table detail arc follow normalization use greedy forward feature selection automatically eliminate redundant useless program feature advantage feature selection principal analysis use feature select base significance describe observe data rather variation select feature also amendable human interpretation project principal result result interpretation section present result compare obtain data mine decision tree obtain statistical cluster characterization decision tree feature feature selection group feature group w feat select arc table result decision tree characterization decision tree induce feature group function show figure addition table summarize result decision tree build feature set instruction group without feature selection strike result accuracy decision tree generally high especially feature selection accuracy range indicate program feature use successfully predict application domain hence induce decision tree trust reliable domain decision tree show figure reveal number interest first across three single important feature discriminate rate level data cache miss network particular characterize poor performance network distinguish application base single feature case study section demonstrate information use guide compiler engineer towards code data transformation specifically target network domain little significance compiler target second automotive spread several leaf nod characterize broadly different feature set indicate automotive domain exhibit homogeneous fact comprise rather heterogeneous example automotive either show low data cache miss rat high activity higher rate miss memory write activity lower utilization indicate automotive either good spatial temporal locality less nonlocal memory access pattern third occur frequently automotive consumer indicate two share make hard distinguish see color box attach leave decision tree represent actual oppose predict show label leave finally show low data cache read miss rat across time perform modest number comparison statistical cluster statistical cluster approach characterization popular use recently gain insight variation exploit similarity program performance prediction compare decision tree base approach recent cluster methodology use particular study across application hope gain additional automotive consumer decision tree average classification success rate unlike classification statistical cluster rely know label operate solely attribute describe data unsupervised learn cluster seek structure input data find cluster input point broadly share similar feature may possible input data set accord proximity cluster feature space juxtapose generate cluster know application see figure enable us investigate spread typical within single application domain similarity across information may use combination decision tree identify share similar behavior despite different application paper figure trace graph memory read reassembly use cluster characterization technique base algorithm start partition input space k initial set calculate centroid set construct new partition associate point centroid recalculate algorithm repeat convergence input cluster number k cluster initial set choose k number leaf nod generate decision tree characterization use random set know application generate cluster combine contrast figure scatter graph represent cluster whereas correspond application define suite dot scatter graph represent one particular program particular column diagram see single domain spread cluster different row however correspond single cluster show program similar behavior find different application domain bar plot next represent correspond cluster centroid figure reveal cluster rarely coincide consumer automotive see spread several cluster whereas majority office network find small number cluster consumer typically span across four six cluster vastly different run contain consumer domain deal different data image video process audio cod perform different type conversion compression automotive group span cluster correspond roughly leaf nod identify decision tree approach network fall two three distinct cluster previously discover characterize use decision tree look graph horizontally notice cluster correspond one two group whereas span almost instance cluster label show high data cache miss rat always correspond network arc figure scatter graph show relation cluster obtain cluster application comprise several cluster indicate heterogeneous similarly cluster span across indicate similar find different bar chart represent cluster number leave bar plot use reference section explain graph detail cluster label show lower data cache miss rat medium extension instruction usage correspond partly consumer partly example program present cluster across cluster necessarily homogeneous cluster include decode consumer bite allocation arc however contain subset network particular packet check packet flow consumer mainly conversion include cluster less correspondence find cluster example cluster label spread almost group contain common program except fact show value feature take account statement make summary decision tree statistical cluster capable extract define set program example distinctive behavior network pick approach similarly existence consumer application domain detect decision tree powerful instrument identify represent application three consideration clear five embed application define suite derive tree appear capable represent across cluster generate statistical cluster technique instead abstract application domain membership handle explicitly cluster represent virtual centroid specific data contain cluster cluster also appear somewhat sensitive choice require amount tune result produce cluster useful identify similarity across appear well suit represent distinct individual application combine consideration decision tree cluster approach promise especially cluster use investigate initial find produce decision tree data mine feel possible recipe like representation decision tree diagram make favorable compiler engineer seek identify performance bottleneck guidance tune give compiler typically train statistics graphical notation interpretation decision tree make accessible group case study section present case study target industry standard network inspection induce decision tree depict figure show network exhibit high cache miss rat across three fact decision tree list data cache miss rate important criteria distinguish network remain indicate focus attention cause poor cache behavior seek improve compiler performance domain header union link external char internal figure c include automotive exhibit much smaller cache miss rat accurately describe arc suffer poor behavior decision tree analysis paragraph clearly reveal network suffer data cache bottleneck hence perform detail memory access analysis identify cause bottleneck also way expect propose characterization identify compiler tune use decision tree characterization pinpoint critical resource b use specialize tool perform detail analysis particular resource lack temporal spatial locality know low cache utilization employ memory profile analysis obtain detail picture memory access figure show excerpt memory access trace reassembly generate pin inspection memory trace show figure reveal memory frequently access discrete address large unused gap lead characteristic regular access pattern discrete horizontal strip gap repeatedly access address wide never subsequently access nevertheless pollute data cache additional information available inspect application source code find store single c structure contain separate header structure define show figure complete ie header store successive order memory however reassembly ever read packet touch actual hence find useful header information interleave unused introduce previously observe gap access data identify low data cache utilization reassembly network general manually apply structure split transformation structure split split c structure propagate information use sit effect interleave remove data packet store type ie together separate fact transform code show improve data cache behavior cache hit rate increase platform arc result total respectively subsequently apply structure split complete set find transformation applicable remain network cod node decision tree reassembly surprisingly structure split genuinely network figure network structure split arc specific ineffective application contain suite full set result network show figure average arc result structure split observe vary mainly due different cache two target overall performance single target originate different buffer size well match cache line size relate work section discuss relate work characterization base adaptive compilation exist large body work characterization much focus paper concern embed originate different embed relevant research exist characterization provide consortium characterization however carry enable select relevant suite term program similarity infer expect performance figure contrast interest embed application differ feature possibly exploit future compiler development characterization methodology suit present build work follow similar cluster approach however exist number important first explicitly include feature oppose characterization interest specific second focus characterization complex distinct phase behavior whereas choose smaller representative deeply embed run single fix application finally develop human interpretable characterization support compiler engineer whereas seek identify unique diverse different suit similarly aim derive measure program feature cluster eventually cluster express single application paper use principal component analysis dimension reduction use diagram representation result introduce cluster program similarity exploit facilitate performance prediction code coverage input variability number embed study work aim support compiler architecture research identify superfluous function insufficient code coverage exist classification use decision tree employ exploration cache commercial application generation compiler optimization branch prediction dynamic power management packet classification network cluster discuss categorization adaptive compilation largely focus machine learn improve phase order optimize compiler tune optimization compiler improve performance exist help identify code generation optimization demand genuinely new rather tweak exist contrast paper apply data mine extract human interpretable information support compiler engineer develop new compiler summary paper present methodology characterization may lead identification tune propose method use decision tree produce result therefore use compiler seek identify performance bottleneck guidance address demonstrate decision tree use detect specific five embed demonstrate decision tree characterization exploit identify compiler optimization miss case study demonstrate methodology direct compiler engineer specific cache bottleneck resolve apply nonstandard data transformation network lead average arc respectively reference f e g j c use machine learn focus iterative optimization proceed international symposium code generation optimization c bishop neural network pattern recognition university press b j martin b static branch prediction use machine learn program j g f e f p rapidly select good compiler use performance counter proceed international symposium code generation optimization page computer society e l g de dynamic power management use adaptive learn tree proceed international conference design k cooper j reeve l waterman acme adaptive compilation make efficient k cooper waterman investigate adaptive compilation use compiler computer science institute ding k automatic characterization proceed b g elusive goal characterization performance evaluation review p l v r data mine base technique overcome memory bottleneck problem commercial k l characterization annual international symposium micro k l characterize unique diverse exist emerge suit international symposium performance analysis page k l cole compiler optimization level exploration proceed international symposium code generation optimization new york k l l k k performance prediction base inherent program similarity proceed international conference parallel compilation pact h c w code coverage input variability effect architecture compiler research proceed international conference architecture synthesis embed case joshi l l measure similarity use inherent program june lee c efficient code generation algorithm architecture journal signal process j lin w li z tang memory characterization spec suite proceed workshop computer architecture evaluation b x x tang packet classification algorithm multithreaded network processor proceed international conference architecture synthesis embed case least square quantization information theory r r muth h g v j k hazelwood pin build program analysis tool dynamic instrumentation proceed conference program language design implementation f r machine learn approach automatic production compiler artificial intelligence methodology page springer characterization proceed goddard mass storage conference joshi l l measure program similarity experiment spec suit international symposium performance analysis page j characterization suite j program machine learn morgan k e e cluster analysis classification perform rev v efficient variable allocation dual memory bank proceed international workshop embed skinner w understand cause performance variability proceed international symposium characterization martin meta optimization improve compiler machine learn proceed conference program language design implementation embed consortium j use machine learn compiler thesis school university wang c burn v effective exploitation zero overhead loop buffer b towards statistical theory cluster workshop statistics optimization cluster k yan characterization classification modern master thesis new state university p lee characterization relational engineer x c ding array regroup structure split use reference affinity proceed conference program language design implementation