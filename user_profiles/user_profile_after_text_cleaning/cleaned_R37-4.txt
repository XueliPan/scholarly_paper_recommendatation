laminar practical decentralize information flow control e porter bond department computer university abstract decentralize information flow control promise model write program powerful security guarantee current run commodity hardware broadly categorize two type operate language level provide guarantee security system like file operate system mediate access system inefficient monitor flow information program data structure paper describe laminar first system implement decentralize information flow control use single set os object express security label data secrecy integrity label access label data security laminar enforce security specify label laminar implement use modify virtual machine new security module paper show security ease incremental deployment limit dynamic security check allow us four application case study replace security change less ten code incur performance one whereas prior support limit type multithreaded program laminar support general class multithreaded program access heterogeneously label data subject engineer verification program language construct feature operate security flow control general term performance security security region information flow control virtual machine one introduction computer support modern life finance health care security become increasingly important current security enforcement typically sprinkle throughout application make security difficult express change audit operate system security file user coarse express many desirable protect user financial data untrusted browser furthermore poor integration program language construct operate permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee nine copyright c june system os security complicate expression enforcement security example user credit card number broadcast network whether number originate file data structure file data structure currently govern completely distinct security require understand paper address issue integrate os security allow application express uniform security enforce layer stack decentralize information flow control security model eighteen express base use data naturally match think security traditional security instance traditional access control application right read file anything file data contrast enforce powerful permit application read file disallow broadcast content file unsecured network channel implementation dynamically statically enforce user specify security track information flow throughout system model provide security allow associate secrecy integrity label data restrict flow information accord label secrecy guarantee prevent sensitive information escape system integrity guarantee prevent external information corrupt system example model consider bob want schedule meet keep calendar mostly secret bob place secrecy label calendar file thread secrecy label read thread secrecy label taint label longer write unlabeled output standard output network thread capability declassify information may remove secrecy label write data unlabeled output calendar example program obtain bob secrecy label read calendar file remove label thread ready output acceptable meet time must call function declassify result function check output contain secret information example output simply date include bob upcoming visit doctor provide two key rule legal propagation data program ability localize security policy calendar example secrecy label ensure program read data leak data whether accidentally intentionally label tie data restrict may access data decision declassify localize small piece code closely audit result system security easier express maintain modify support language level eighteen nineteen operate system twelve architecture approach rely extensive type change wrap standard augment type throughout entire program modify program structure trouble enforce data flow program data structure page inefficient mechanism control data structure track label data hardware signal still require trust manage label limit scope paper commodity hardware paper introduce new system laminar provide common security abstraction label scheme program object os file combine os minimize express comprehensive security laminar virtual machine os enforce laminar need modify portion program trust untrusted thread label unlabeled file data structure coexist system contrast exist require pervasive program label data structure function return type seventeen rely static analysis enforcement rule also exclude feature dynamic class load laminar introduce security security limit scope enforcement make easier develop deploy audit program security also reduce overhead dynamic security check label data must occur within security typical security region might read label configuration file parse label data structure since code manipulate label configuration data structure reside security region easier identify audit code unrelated data structure need modification paper one design laminar first system unify os enforce laminar feature novel division among program model os two introduction security intuitive primitive ease deployment security program implementation audit three implementation laminar make modest one virtual machine operate system four four case study security onto exist code case study require modification less ten total code base incur laminar range one advantage initial result suggest integrate os support incur low allow application developer write security encompass program data structure well system two relate work previous either use os laminar instead enforce rule program use extend os unify os first time seamless label model laminar combine previous approach improve program model label approve request modern mandatory access control mac like also limit require static collection label decentralize information flow control allow individual allocate label declassify data label provide model implement security eighteen seventeen nineteen augment type system include secrecy integrity enforce generator label program data structure object fine granularity require program intrusive type system entirely new language language base trust whole operate system provide guarantee security system like file asbestos new operate provide flume twelve reference monitor provide guarantee without make extensive change underlie operate system os provide little support track information flow application data structure different label flume track information flow granularity entire address space enforce information flow page granularity support form require thread page map compatible label use page table track information flow expensive execution time space fragmentation complicate program model tightly couple memory management enforcement laminar support natural program model thread may heterogeneous label access variety label data structure example application case study use thread different label laminar provide guarantee granularity code block data structure modest change also add security module standard operate system oppose asbestos completely rewrite os laminar os enforcement occur security module whose architecture already present within security laminar os need flume abstraction enforce security file write file pipe reference monitor check information flow operation file laminar adopt label structure distinction derive use flume formally define next section distinct use operate operate like eros use access control information combine system language security however capability enforce rule program must completely rewrite work capability program model table one summarize taxonomy design issue common laminar combine laminar handle implicit flow provide information flow control like without resort static analysis like laminar enforce security system laminar make easier deploy use information flow control introduce intuitive notion code block call security information flow control stem research security defense project nine original military eleven administrator must allocate integrate language security al observe use ensure os security violate trust system issue main modify solution nineteen compiler type system compiler os static analysis trust compute base secure individual application data structure secure file os termination time probabilistic channel handle handle implicit information flow static analysis deployment issue code must use new language type system os solution twelve one complete os two reference monitor kernel module twelve os either support inefficient page table one modify entire os two reference monitor kernel module support flume twelve handle termination channel suppress termination notification flow track granularity thread address space twelve exclude multithreaded whose thread heterogeneous security need laminar solution kernel module os dynamic analysis enforcement use kernel module handle dynamic analysis use security table one issue laminar offer better functionality combination os ten framework call siesta extend enforce fifteen mac language level aim laminar siesta orthogonal siesta provide mechanism prove system application trustworthy whereas laminar provide developer unify abstraction specify application security termination time probabilistic channel al argue implement dynamic check correct static check show program termination channel static dynamic leak arbitrary number prove correct dynamic system information flow reject program contain actual information flow laminar dynamic system security explicitly information flow attempt eliminate covert channel may use leak information eliminate time channel thirteen probabilistic channel section define discuss implicit information flow three model need mechanism denote sensitivity information privilege participate section describe use laminar rule determine safe information flow security policy define term read write data system nineteen process twelve kernel thread laminar kernel thread standard include tag label tag short arbitrary draw large universe possible value twelve tag inherent mean set tag call label system principal create new tag secrecy integrity example web application might create one secrecy tag user separate secrecy tag user data secrecy tag user prevent authentication information leak network tag user data prevent malicious user write another user secret data untrusted network connection assign label data object data object include program data structure individual object array list hash table system file previous limit granularity process support thread enforce rule granularity page system first expand support thread enforce object granularity data object principal x two label secrecy integrity tag secrecy label data object denote may contain information private tag similarly tag imply data object may contain data endorse integrity tag data integrity guarantee data exist state endorse principal example endorse data file integrity file preserve user choose trust file content trust principal label restrict interaction principal data object partial order label impose subset relation form lattice seven bottom lattice unlabeled empty label security integrity implicit empty label mean program need label every data structure os need label every file file system allow implicit empty label make laminar easier deploy principal may change label data object principal appropriate generalize ownership tag eighteen principal p capability set define whether privilege add remove tag tag let denote capability add remove tag capability allow principal data secrecy tag capability allow declassify data classification raise data higher secrecy level lower secrecy level add secrecy label capability principal add call taint tag principal taint want read secret data communicate unlabeled file taint principal must use capability untaint declassify data want write note access control information commonly define operate fourteen handle integrity similarly secrecy capability allow principal endorse data integrity tag capability allow drop endorsement principal integrity tag claim represent certain level integrity example code data sign vendor could run vendor integrity tag principal drop integrity tag example read unlabeled file lower integrity principal drop endorsement tag note capability set define tag tag assign secrecy integrity label practice tag rarely use purpose c p set tag principal p may declassify drop c p set tag p may endorse data object secrecy integrity label data object secrecy label integrity label write empty label set write capability set principal add drop write c restrict information flow program implement control access propagation data use label limit interaction among data object information flow define term data move source x destination least one principal example principal x write file send message principal information flow x principal x read file say information flow source destination x laminar enforce follow information flow rule x secrecy rule bell two introduce simple security property property secrecy enforce principal may read data higher level read write data lower level write express formally information flow x preserve secrecy note x may make flow feasible use explicitly drop add label example x may make flow feasible remove label l capability l ie l c x similarly may use c integrity rule integrity rule constrain alter information three restrict read lower integrity read write higher integrity write system enforce follow rule extend secrecy label receive information intuitively integrity label x least strong destination like secrecy rule x may make flow feasible endorse information send higher integrity destination allow x appropriate capability c x similarly may need reduce integrity level use c receive information lower integrity source label change accord previous two rule principal enable information flow use current drop add label laminar require principal must explicitly change current label al show automatic implicit label change form covert storage channel laminar principal p may change label capability add tag present drop tag formally state c p c p calendar example consider schedule meet bob use schedule server administer either bob calendar file secrecy tag bob calendar file secrecy tag b focus give ensure secrecy schedule server let read secret calendar file label thread server use capability start security region secrecy tag read calendar file server thread label longer return empty label lack capability result server thread read secret file thread thread un trust user kernel ref net file file b label empty label figure one design laminar unlabeled object implicit empty label trust shade never write unlabeled device like disk network display server thread create new file must label unreadable thread server thread communicate information derive secret file another thread thread must add tag also become unable write unlabeled channel ensure integrity schedule server run integrity tag correspond idea authority vouch safety correctness vouch allow secure network connection server execute read integrity label lower server assure input file write principal integrity label lower integrity rule give server confidence code data file tamper share trust partner bob collaborate schedule meet retain control information expose send server code module file integrity label example might access integrity label employ company run schedule server module access server call code read secret calendar file selectively declassify part instance make availability publicly available unlabeled control data flow bob communicate possible meet time discussion example specify small code module load server application completely ignorant require work module previous example would cumbersome would require run separate process would require entire application annotate enforcement integrate os language laminar substantially improve state art four design section describe laminar enforce enhance os figure one illustrate laminar architecture enforce rule within application address space os security module mediate access system os trust model example may write program use laminar label data program use label present file system read data label file data structure label compile code use standard untrusted generator laminar compiler execute laminar os execute laminar laminar ensure access label data follow rule occur security region region specify program security make easier secure audit portion program need make easier deploy laminar also decrease cost dynamic security check laminar enforcement mechanism laminar os extend standard operate system laminar security module information flow control laminar os security module govern information flow standard os include file pip os regulate communication thread different process access label unlabeled system use os communication signal os enforcement apply prevent unlabeled circumvent laminar regulate information flow heap object thread process via object flow regulate insert dynamic check application code laminar regulate flow within address space os allow data structure thread heterogeneous label thread multithreaded process without trust must label program model laminar provide language new security library new system call secure use scope security region figure two depict library include tag creation label query laminar os export security system call trust capability label management show figure three untrusted application may directly use system call manage label thread laminar thread label modify enter exit security laminar label data object file heap allocate object access inside security hence outside security region thread always empty label os allow code outside security region access label data object execution security region give thread label security region os mediate access system accord security region label security visible os thread must label end security region restore thread original label security security region code block capability set secrecy label integrity label label dictate data program may touch inside security region dictate thread within security laminar application library label return current secrecy integrity label security region tag create new tag add current principal void c tag name global drop give capability current principal set global flag drop capability permanently whereas set drop capability scope security region object object label l return copy object new label l figure two laminar library denote secrecy integrity label denote plus minus give tag also wrapper function show new system call introduce laminar os laminar system call tag tag cap return new tag add plus minus call principal write new cap set task label tag l type set type secrecy integrity label current principal drop label tid drop current temporary label thread without capability check call thread special integrity tag drop cap drop give current principal flag use suspend capability security region fork write capability capability cap send capability another thread via pipe create file label char name mode label l create label file give label label char name mode label l create label directory give label figure three laminar system call tag capability type represent single tag capability respectively label type represent set tag compose label type list region may add remove label say security region perform action mean kernel thread execute within region perform action code within security region access label data security demarcate code security sensitive ease programmer burden add security exist program programmer require wrap piece code touch label data security region routine read sensitive file data structure usually small portion code data program security sensitive security also simplify task audit code require thread access label data within security limit amount work compiler must enforce provide substantial portion execution time spend operate unlabeled data every time program read write label object os within security region system must check information flow respect current label thread execute within region example assignment w r inside security region r safe information flow r thread inside r thread w legal note laminar library figure two include routine add label thread order add label thread must start security region security provide several benefit make easier add security exist program also make easier audit security code limit effect implicit information flow section finally make implementation efficient reduce amount code require full check example figure four depict code calendar server read file belong add event common calendar export common meet schedule bob show data structure cal secrecy tag b thread enter security region initialize secrecy label b therefore read secret data guard tag integrity label restrict read data tag thread capability c declassify tag line valid information flow label thread execute b restrictive f adhere convention label line check write calendar c legal write legal cal secrecy label thread security region point line common meet time compute store note label security region line nest security region start declassify data copy legal thread capability notice line would result exception thread b capability example os check file line check line security region laminar enforce certain rule thread enter security region let security integrity capability set security region r similarly let set associate kernel thread p enter leave r laminar support arbitrary nest security p could therefore already inside security region enter r thread enter security region follow rule hold c p c p one two first rule state create principal p must either add capability label tag within security second rule state principal p retain subset current enter security region rule encapsulate common sense understand parent principal p control label pass security region system let principal create security region security principal lack rule also state security nest natural way base label thread enter nest region implicit information flow major benefit security limit amount analysis necessary restrict implicit information flow implicit information flow leak secret data control flow eight example code figure five show implicit flow control variable h data variable l look value l thread deduce value h since l low secrecy h high secrecy implicit flow violation rule system must therefore detect prohibit flow calendar cal label b output ret file f label b label secure b c schedule f schedule secure b c b figure four example read update calendar thread show require b initialize security region h label h l label invariant l false secure h c x h l true two x catch two x h label h l label l false secure h c h true catch figure five show implicit flow handle figure six leak data via termination channel laminar special construct limit implicit security region require catch block show figure five catch block execute label security region capability set time exception instance h true program attempt assignment l laminar raise exception security region right declassify h catch block give programmer chance restore program exit security region flow occur h l l never assign regardless whether h true false control flow continue block suppress inside security region explicitly catch include within catch block continue execution security region addition restrict exception control flow laminar limit implicit flow restrict security region return region control flow particular enforce security must exit via fall security use break return continue exit except trivial case control flow continue statement immediately security region end laminar thus eliminate implicit flow hide control flow security region code outside security region figure five code outside security region distinguish execution h true one false contrast rely static analysis prevent flow detect compilation eighteen laminar static analysis assume program laminar case security terminate figure six show example implicit flow via termination channel leak secret information base whether application terminate control return security region unprivileged code learn h false similarly collude application might learn h true application must explicitly kill eliminate termination channel ensure one communication prohibit notify thread termination practice termination channel low difficult exploit multithreaded environment exploitation might significantly easier instance h usually false low security thread may deduce fact high probability case program invariant difficult secure catch block simply kill process example call data structure become corrupt may want terminate program rather require notice corruption however exit program catch block create termination channel restrictive model would prevent termination channel ensure security region full kill process interface security visible os os enforce rule system call make security region must set appropriate label current kernel thread use set task label system call optimization omit set label kernel thread security region perform system call set label thread os check ensure label legal give thread acquire tag laminar acquire three ways allocate new tag inherit fork perform communication system carefully mediate capability acquisition lest principal incorrectly declassify endorse data principal allocate new tag via tag system call os security module allocate tag trust ensure tag unique principal allocate tag become owner new tag owner give plus minus new tag principal legally communicate default thread gain capability within security region retain capability exit region thread must explicitly call drop capability prevent capability propagate call context thread security form natural hierarchy kernel thread fork new thread initialize new thread subset similarly thread enter security region thread retain subset specify region general new principal create subset immediate parent os enforce pass mediate kernel specifically write capability kernel call system call check label sender receiver allow communication remove tag laminar responsible correctly set thread label inside thread enter security region first make sure thread sufficient enter region set label thread equal specify security region similarly thread exit security region restore label enter region exit nest security region restore label thread parent security region laminar language provide method remove thread capability call drop capability system call notify kernel method take argument global allow user specify whether capability drop scope security region permanently ie globally globally drop restore parent thread exit security region use set task label system call change label thread begin end security region function user call solely entry exit security laminar allow security change label rely label stay throughout prevent leak local discuss section change label middle security region thread may begin nest security region consider example thread capability start security region secrecy label laminar set label thread security region begin security region end thread must drop secrecy label even capability allow thread drop contain thread trust os run code special integrity tag call use drop label system call trust thread may drop current label thread without appropriate single thread limit exposure bug os enforce thread tag may drop label within single address space drop label small portion trust run special label capability persistence revocation capability persistence revocation always issue laminar innovate however use simple stylize os store persistent user file login os give login user persistent give access control terminal user wish revoke access resource already share capability must allocate new capability relabel data tag draw address space tag exhaustion concern label data data object label part allocation avoid race creation label label object allocate within security region label region create label label kernel call create label file system use label create thread like laminar use immutable label change label user must copy data object dynamic multithreaded environment require additional synchronization ensure label check subsequent use principal atomic respect relabel principal b without atomicity information flow rule may violate example check label b change label secret b write secret data use data atomic prevent unauthorized flow b instead laminar use immutable label avoid extra synchronization compatibility challenge although laminar design deploy implementation incompatible system instance library might result without regard label function result security region one label later call different label may attempt return value result secret attempt return prevent system code must modify work system trust compute base implement laminar add approximately two zero line code one zero line security module line kernel relatively small amount code mean laminar easily audit rely standardization os basis laminar trust addition trust base laminar require correctly insert appropriate read write call access optimize correctly read write barrier insertion localize standard many laminar assume kernel proper hook call security many project rely code base constant audit make sure necessary call make five implementation section describe implementation laminar modify operate system provide support implement laminar trust virtual machine one implementation laminar publicly available research august performance compare well commercial average performance sun fifteen worse sun sixteen subsequent use term refer version control information flow ensure program access label data occur security add instrumentation call every object read write check run time access conform rule section three start security region thread start security region check whether initialize security region specify label describe section thread store kernel cache copy current thread make check efficient inside security region restrict information flow statics enforce information flow control access three type application data reside stack register object reside heap statics reside global table lifetime local typically short track label would expensive prototype restrict one two three program model laminar statically compilation enforce follow local one local variable write inside security region may later read outside security region region secrecy label two local variable already write outside security region may read inside region region integrity label security region label dynamic simplicity implementation require every security region important exception local reference may however reference may read write allow null access reference object check read write discuss laminar prototype implementation require security region method simplify static check thus need ensure statically method security region one return value region security label two take three read write value allow however prototype implementation currently check rule instead require program adhere production implementation laminar could security enforce local variable part verification restrict information flow static laminar prototype implementation prevent security secrecy label write static prevent integrity label read statics access inside security region enforce production implementation could support label statics modest overhead static access relatively infrequent compare field array element access section seven need label static support information flow object track information flow object live heap allocation time object may assign secrecy integrity label immutable default object allocate inside security assign label region allocation point program may specify alternate label long conform rule change object label implementation provide call clone object specify label label change must conform label change rule section three allocate label object separate label object space heap allow instrumentation quickly check whether object label modify allocator add two word object header point secrecy integrity label implementation encapsulate label immutable opaque object type label support union efficiency label object may share object security thread immutable mutate union return new object need internally label use sort array hold tag label opaque observe individual value tag read use label without create covert channel compiler insert read write six instrumentation every operation application code enforce rule inside security compiler insert label object allocation constructor call set label check conform rule insert every read write object field array element inside security load access object secrecy integrity label check conform current c c secure new secure figure seven example code read mark two object label object contain secrecy integrity set security region initialize region label outside security read write check access object unlabeled equivalently empty label compiler insert inside security static access verify static read write occur without integrity secrecy label compiler insert different access depend whether access occur inside outside security region choose right barrier compile time difficult method may call code inside outside security region prototype implementation method first execute compiler compile compiler check whether thread security region insert accordingly subsequent recompilation higher optimization level reuse decision approach call static fail method call within without security region thus also support configuration compiler add dynamic check whether current thread security region execute correct barrier production implementation would use clone compile two execute approach use prior work transactional memory twenty static add overhead clone would achieve object label immutable security change label repeat check object redundant implement analysis identify redundant remove read write barrier redundant object read write object allocate along every incoming path although optimization compiler already small hot increase scope redundancy elimination example example illustrate figure seven compute sum mark obtain two different object label different secrecy value associate object contain set label label inside conform current thread program terminate security region start thread current label become present line read label object result error flow thread security region allow line allocate object label present programmer write reference use inside security region line thread attempt change label object inside nest security region allow change thread require note inner security region empty secrecy label os support implement support version security module provide hook kernel allow custom authorization rule also add set system call manage label figure two fifteen manage access control custom similar method isomorphic add new system call laminar security module contain line code line kernel support new system call tag label tag represent allocate via tag system call label store opaque security field appropriate object task file secrecy integrity label file persistently store file extend attribute standard local support extend attribute include file use laminar intercept file access use perform unopened file file handle include pip respectively laminar security hook perform straightforward check rule list section label protect content except name label protect label parent directory typical tree secrecy increase root leave create label file system tricky involve write new entry parent directory disclose secret information example disallow principal secrecy label create file secrecy label unlabeled directory leak information file name instead principal precreate file taint secrecy label formally allow principal label create label file directory label one two principal acquire label three principal write parent directory current label approach prevent information leak file creation maintain usable interface apply integrity label tree complex secrecy intuitive reason integrity label prevent attacker trick program open wrong file instance use symbolic link practical difficulty integrity task integrity label read file without label potentially include system home union integrity label administrator add home new without give integrity label exist flume solve problem provide flat use store data integrity label apply integrity label traditional directory structure bring fundamental design tension os usability minimize trust administrator laminar find middle grind label system home system administrator integrity label system user may choose trust system administrator integrity label read absolute file may eschew trust system administrator exclusively open relative worst case create environment simple relative sufficient case study paper laminar approach support incremental allow choose whether trust system administrator cost extra work integrity guarantee laminar dynamic laminar static e h r e v sixty forty twenty zero chart eclipse p b n p geo b ean figure eight laminar overhead program without security pip laminar mediate communication pip label associate pipe message buffer process may read write pipe long label compatible label pipe message delivery pipe laminar unreliable error code due incorrect label full pipe buffer leak information message deliver silently drop unreliable pip common os twelve read pipe laminar must nonblocking prevent illegal information flow standard pip deliver writer exit exit process appropriate write label send violate rule thus read nonblocking depend explicit writer change label common case pipeline label traditional pipe behavior approximate use pip program heterogeneous dynamic label may require modification environment six laminar overhead section report overhead laminar performance loss without security six seventeen depend whether dynamic compiler compile separate call inside outside security laminar os incur overhead less eight experiment include next section conduct machine processor experiment configure run two core result normalize value obtain unmodified overhead figure eight show overhead five version call experiment execute two first include compilation second disable compilation run application report run time second iteration compilation run time vary execute ten experiment take median bar show overhead dynamic check dynamically security region dynamic add seventeen overhead average lighter bar overhead use static six average discuss section mature implementation laminar would use method clone eliminate dynamic method clone comparable static code outside security region expect average overhead six also measure compilation time find average static double dynamic triple however compilation time primary concern especially program compilation time fork file create file delete latency fault null io thirteen laminar overhead twenty six six forty sixty twenty seventy seventeen table two execution time several os overhead incur use laminar lower better count run time average make barrier compilation effect run time comparable effect application execution time overhead high large part instruct compiler aggressively bloat code slow downstream lower compilation time without increase run time substantially implementation could choose less aggressively os overhead use sixteen suite measure impose unlabeled run laminar os selection result present table two general overhead laminar os less eight similar previously report security performance outlier null io overhead represent worst case laminar system call measure little work amortize cost label check sake comparison flume add factor latency system call relative unmodified twelve seven application case study section describe four case study security table three summarize detail figure nine show overhead run modify version laminar implement powerful security unmodified ten source figure break overhead laminar four part overhead application support include start end security security configuration denote extra time allocate label object assign label set static overhead read write security context know compile time finally dynamic extra overhead check context run time note battleship run correctly static calendar require dynamic call inside outside security method clone would obviate need dynamic section experiment disable well io laminar mask hence slowdown deploy would less report experiment comparison flume twelve add slowdown application flume label data granularity address space enforce rule heterogeneously label object address space small program manage grade four use three type application battleship calendar protect data student grade ship schedule membership add time six one one ten six five six table three detail various include line code data need secure line code add secure application use laminar fraction time spend security e h r e v eighty sixty forty twenty zero dynamic static one battleship calendar figure nine overhead execute laminar name j student ta j professor security set si c p c sin j p c sin j p j p j table four security set associate data object c stand security integrity capability set student ta j refer student teach assistant respectively dent main data structure object array j th object store information student mark project j sample policy state one professor cell two ta read mark modify relate project grade three view mark project table four show policy express assign label data respectively specifically guard j th entry secrecy tag si integrity tag student capability add remove si read mark project ta j capability add tag si integrity tag project grade tag ensure read mark integrity constraint prevent modify grade project grade interestingly laminar find information leak original policy policy allow student calculate read average mark project leak information mark integration laminar professor allow calculate average declassify experiment measure time take server process query different version seven slowdown compare unmodified version battleship proceed round round player shoot location opponent grid player first sink opponent ship win game start battleship program available player pi allocate tag pi label board ship capability p give anyone else ensure player declassify ship original implementation directly inspect shoot determine whether hit miss opponent boat laminar player send guess opponent update board inside security region opponent declassify whether guess hit miss send information back first player add less line code secure program run laminar experiment game play grid without figure nine show secure version add overhead static overhead high spend almost time inside security deploy battleship would display intermediate state board overhead would significantly less experiment display shoot location move run time increase laminar overhead drop one calendar like paper modify multithreaded calendar label data structure file store user calendar information user secrecy function access data wrap inside security include find available meet time multiple original program user could view calendar feature disable experiment measure time schedule meet include read label calendar bob find common meet date write date another label file read schedule code execute thread capability read data bob declassify bob data output file protect label experiment schedule meet figure nine show secure version calendar run fourteen unmodified calendar note calendar idle time high run version two core yet diagnose issue however find problem specific machine report result calendar core two quad processor run modify kernel chat server chat server write multiple connect server communicate support command create group invite change theme chat room original security policy consist authorization framework restrict command use user write form check authorization check actually check role user example user role power group ban another user group improve security code label sensitive data structure access inside security make two user battleship common board game play two player secretly place ship grid board play four five laminar localize security check class abstraction role map naturally onto integrity label example protect data structure two tag one correspond notion group add capability two tag use ban command also change authentication module ensure give right log experiment measure time process request four zero invoke three different command laminar overhead less one figure nine summary four case study reveal pattern way write first key data structure need secure like array student grade play board battleship second interface access data structure quite narrow example calendar contain function use access important data support hypothesis localize change need onto many type third data structure require heterogeneous single data structure different label correspond different heterogeneous label impractical twelve since support single label whole address space require programmer map application data structure onto label page laminar easily solve problem track label data structure example individual array object eight conclusion laminar first system unify os information flow control provide natural program model powerful security onto exist complex multithreaded program thank maxwell feedback draft paper also thank anonymous referee constructive comment reference one b c r j j barton g burke p cheng j fink grove hind hummel v j r v sarkar j serrano j shepherd smith v c h j virtual machine journal one two e bell l j secure computer mathematical technical report vol one mitre corp three k j integrity secure computer technical report electronic division four v l enforce authorization use transactional memory introspection five r garner c khan k r z guyer jump h lee j e b moss b development analysis page six l friend foe international symposium memory management seven e lattice model secure information flow nineteen five may eight e p j certification program secure information flow twenty seven nine department defense department defense trust computer system evaluation criteria dod orange book edition ten b jaeger p trust secure build execute enforce system security eleven p e w h mason c e retrospective security kernel seventeen eleven twelve yip n f e r morris information flow control standard os thirteen b w note confinement problem sixteen ten fourteen henry levy computer digital press fifteen p integrate flexible support security operate system sixteen larry carl portable tool performance analysis seventeen c practical information flow control page new york press eighteen c b decentralize model information flow control page nineteen c n l information flow release twenty yang ni bach sion jam ady tal design implementation transactional construct page c security journal select smith j eros fast capability system v flow nutshell proceed first workshop page standard performance evaluation corporation documentation release edition n j bridge j chang r g j g reis august rifle architectural framework security micro p e c f r morris label event process asbestos operate system four eleven c wright c j morris g k security general security support kernel security symposium n e make information flow explicit n h dalton c hardware enforcement application security use tag memory