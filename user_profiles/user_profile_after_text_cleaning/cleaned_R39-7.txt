page put faulty core work necromancer robust heterogeneous core couple execution scheme exploit functionally dead core improve system throughput supply hint regard program behavior necromancer partition system core multiple group share lightweight core substantially accelerate use execution hint faulty core past decade shrink process rise power lead many reliability challenge defect parametric one challenge semiconductor industry manufacture defect directly impact yield process generation next become susceptible manufacture defect owe higher sensitivity random attach wafer surface lithography issue substantial require maintain acceptable level manufacture yield traditionally hardware reliability concern tandem nonstop apply redundancy triple modular redundancy acceptable however hardware reliability major issue compute reliability acceptable investment large fraction die area devote cache protect use column redundancy use appropriate protection process core become die major source defect vulnerability consequently try tackle hard fault appear process core portion cache portion inherently irregular handle defect common solution disable faulty however chip modest number core core two dominate industry lose core significantly reduce system throughput sale price extreme lie grain unfortunately core logic fault coverage approach suggest break core pipeline stag allow one core borrow stag core interconnection introduce interconnection network processor pipeline present performance power consumption design complexity challenge diva proposal dynamically verify complex employ checker pipeline rerun instruction stream ensure correct program give diva intend tolerate defect hard fault result tenfold slowdown show defect instance program execution flow faulty core coarsely resemble program execution start architectural state give amin university michigan ann arbor publish computer society c page ninety eighty seventy sixty fifty forty thirty twenty ten zero mesa art crafty parser average mask figure one first set bar show distribution inject hard fault manifest architectural state mismatch label across different latency measure number commit second set bar show number inject fault result violation similarity index label propose necromancer enhance overall system throughput mitigate performance loss cause defect core part accomplish first relax correct execution constraint faulty core undead core next leverage execution information hint undead core accelerate execution animator core necromancer introduce additional core call animator core older generation animator core treat hint performance without impact execution correctness motivation trust aggressive core hard fault operate correctly however see still provide useful execution hint effect hard fault program execution illustrate hard fault negatively impact program execution identify average number commit observe architectural state mismatch result hard fault first set bar figure one experiment golden execution compare architectural state faulty execution mismatch happen terminate simulation report number commit point instance look percent inject hard fault architectural state mismatch ten thousand commit figure show forty percent inject hard fault immediate architectural state mismatch thus trust faulty core provide correct functionality even short program execution relax correctness try determine quality program execution faulty core relax absolute correctness second set bar figure one depict many commit faulty core get considerably correct execution path define similarity index measure similarity program counter commit faulty core golden execution program calculate similarity index every whenever drop beneath threshold stop simulation record number commit use similarity index ninety percent mean instruction window ninety percent must hit page chip exactly instruction cache line golden execution program execution faulty core see even high threshold value percent case faulty core successfully commit least thousand execution differ ten percent faulty core execution behavior coarsely match golden program execution long time extract useful information program execution faulty core send hint animator core run program symbiotic relationship two core let us animator core achieve significantly higher performance let undead core run without require absolutely correct functionality later evaluate performance boost possible necromancer system challenge couple faulty core give system two core couple together achieve higher performance performance core limit couple core overall performance two core traditionally identical however accelerate program execution one core must progress program faster three propose accomplish core run ahead leader operate higher frequency core receive execution hint checker seven architectural state mismatch happen leader frequency get adjust need two leader core run shorter version base removal ineffectual checker unmodified program run core let us leader core return invalid value scheme checker core take advantage program execution leader core receive instruction stream resolve branch cache although simple extension seem plausible necromancer encounter two major owe presence defect first type defect global hint become ineffective undead core get completely correct execution path bring undead core back valid execution point system copy animator core architectural state undead core although prior work use exact state match register applicable animate faulty core architectural state mismatch occur frequently therefore need monitor hint effectiveness long time period decide whether system undead core animator core moreover cheap relatively infrequent avoid noticeable impact animator core overall performance type defect undead core might execute commit cause similarity program two core instance undead core take wrong direction statement although quickly return correct execution path perfect data instruction stream animator core unattainable necessitate employ generic hint resilient local moreover mechanism must help animator core identify proper time get hint dead core give hint usefulness vary also leverage hint disable enhance system efficiency necromancer architecture mitigate system throughput loss due defect necromancer employ robust flexible heterogeneous core couple technique figure two illustrate necromancer design design communication unidirectional undead core animator core except signal consequently necromancer use single queue send hint micro page queue l e h e r c e n cache fingerprint hint gather fet dis mem signal hint disable information hint distribution hint disable fe de di ex e r c r n memory hierarchy share cache figure two necromancer architecture add modify highlight cache fingerprint animator core unit attach tag queue entry indicate type queue get full undead core want insert new entry stall preserve correct memory state allow dirty line undead core data cache write back share cache furthermore also disable exception handle within undead core animator core maintain precise state necromancer rely undead core multiple program furthermore necromancer approach transparent operate system require register file perform exact state match two core instead employ fuzzy approach base continuous monitor hint effectiveness initiate appropriate make hint robust two core number order execute leverage number commit hint synchronization attach number every queue entry age tag moreover introduce concept release window make hint robust presence release window help animator core determine right time use hint instance assume data cache release window twenty assume already commit animator core data cache hint age tag less equal pull queue apply hint gather distribution must send branch prediction cache hint except queue animator core undead core unit responsible gather hint cache fingerprint attach age type tag insert queue program counter commit address commit load store consider hint branch prediction hint unit send hint queue every time faulty core branch predictor get update animator core side unit receive queue compare age tag local number commit plus correspond release window size treat incoming cache hint information warm local cache animator core default branch predictor simple bimodal predictor page forty chip branch prediction release window size ten commit code sum zero j two j sum sum j chronologically sort branch prediction hint send undead core entry different time animator core age tag take take number commit take take take take take take take take nine fifteen take take take take take take take take nine fifteen perfect branch prediction take take take take take take take alpha assembly code one one one two two two three three three four zero five one zero five three one three five one five three two six six two one two two seven seven load j j pointer proceed j two figure three code example animator core receive hint improper time result low branch prediction accuracy switch animator core original branch predictor therefore beneficial code simply calculate sum branch prediction release window size normally set maximize branch prediction accuracy entire execution first add extra bimodal predictor track incoming branch prediction hint furthermore employ hierarchical tournament predictor decide give program counter whether original branch predictor take mention leverage release apply hint need however owe number execute undead core even release window guarantee perfect time hint scenario subset tournament predictor give priority animator core original branch predictor avoid performance penalty figure three show simple example achieve percent branch prediction accuracy mainly due existence tight inner loop low trip count switch original branch predictor enhance branch prediction accuracy reduce queue size must limit communication traffic beneficial hint consequently unit use two several discard recently send hint eliminate redundant hint also minimize resource contention animator core furthermore save transmission send block relate address cache hint ignore hint speculative branch prediction hint send program counter use update branch history table disable hint disable hint longer beneficial animator example program execution undead core diverge correct execution path animator core performance already near ideal case undead core get ahead animator core hint disable help four ways avoid occupy animator core ineffective hint queue fill less often mean stall undead core disable hint gather save power indicate undead core stray far correct execution path require forty micro page hint gather hint gather cache fingerprint cache fingerprint animator core hint gather hint gather cache fingerprint cache fingerprint cache bank two cache bank cache bank cache bank data switch cache bank cluster core figure four necromancer design large chip system sixteen core model sun rock processor unit responsible realize disable type hint disable cache hint cache fingerprint unit generate cache access information base commit last time interval example last commit system send fingerprint queue compare animator core cache access pattern base threshold value similarity access pattern animator core decide whether disable cache hint addition hint disable hint remain disable throughout significant time period call period apart animator core original branch predictor subset also use global disable branch prediction hint use scheme single counter every branch original branch predictor agree action require nonetheless branch correctly predict original branch predictor score counter one similarly branch original branch predictor correctly predict score counter one finally end disable time interval counter certain threshold branch prediction hint disable period undead core stray correct execution path longer provide useful hint need mechanism restore valid state accomplish occasionally two core mention accord al modern processor process take order moreover squash undead core pipeline reset rename table invalidate content take advantage information identify need instance potential policy least two hint disable necromancer design apply necromancer core figure four illustrate necromancer design system page chip grid p art e q p g crafty p two vera g e fault location program counter branch target buffer instruction fetch queue input latch rename address table integer register file float point register file reorder buffer integer integer multiplier integer divider float point float point multiplier float point divider queue seventeen ten four figure five variation animator core different hard fault across isolate hard fault impact normalize result column average necromancer couple core could achieve particular four cluster model sun rock processor cluster contain four core share single animator core show maintain necromancer design employ cluster design basic build block many die fault free avoid disable animator core leverage core accelerate operation live core exploit speculative parallelism however evaluation latter beyond scope article heterogeneous system share animator core multiple core might possible core different computational potential solution partition original set core group group several large core small core group smaller core able operate conventional core animator core defect one core within group core suitable fit many heterogeneous design many simple core cell processor evaluation methodology heavily modify model couple core use communication model information flow alpha core alpha simulate study manufacture defect affect necromancer system develop monte engine iteration monte simulation select structure inject single random fault time simulator inject hard fault fifteen different structure figure five show evaluate dynamic static use power use technology library evaluate remain miscellaneous logic shift register standard industrial consumption result describe necromancer design include cache hint cam size release window size fix architectural perform extensive design space exploration give parameter value average necromancer achieve percent animator core highlight impact hard fault achievable necromancer micro page table one summary performance benefit area overhead power overhead scheme different number core performance necromancer couple core normalize animator core average performance live core average performance necromancer performance normalize target system animator core live core overhead overhead area power share share share share figure five depict performance breakdown fifteen fault alpha pipeline result column normalize average necromancer could achieve particular eliminate advantage disadvantage come inherent suitability core couple figure show hard fault program counter integer instruction fetch harmful also reaction defect differ significantly parser conclude two main point plot first average fault exist drastically impact necromancer gain second give fault location different show various susceptibility thus heterogeneity across system help necromancer achieve higher allow suitable assign couple core table one demonstrate amount necromancer couple core achieve achieve higher overall number core increase necromancer achieve different base defect type location run system system average couple core achieve performance essentially provide appearance core animator core assume full use mean always one job per core heterogeneity across run system opportunity necromancer exploit table also show scheme area power table show area overhead gradually shrink number core increase animator core cost amortize among core nevertheless simply replicate build block construct four core area overhead remain term power overhead result show eight core undead core remain ahead animator core must stall queue full stall undead core consume dynamic power necromancer main objective improve average system throughput population manufacture chip purpose model manufacture chip randomly distribute defect base target defect rate case defect original core apply scheme hand animator core communication queue unit faulty simply disable animator core rest system continue normal operation figure six depict throughput enhancement result shade base throughput bin necromancer significantly enhance overall system throughput horizontal axis show system throughput normalize page chip enhancement cache protect ninety l e enhancement cache protect eighty thirty forty cache protection cache protection figure six achievable yield give expect level system throughput consider two system without proper protection show yield improvement necromancer apply throughput single core plot illustrate throughput bin result throughput value three four assume average one defect per five chip yield always eighty percent however small chance multiple defect hit chip preclude yield percent throughput three even protect cache cache protection necessity fortunately provide easily example column redundancy technology scale continue high performance become susceptible defect necromancer enhance system throughput exploit faulty core perform useful computation provide intrinsically robust hint effective hint disable dynamic state necromancer significantly improve distribution manufacture chip throughput bin perform moreover failure happen system operation necromancer provide graceful degradation performance simply disable break core future work plan enhance necromancer adapt number increase number faulty core number fault per core multiple fault per core quality hint faulty core generate likely deteriorate however aggregate faulty core together jointly provide set robust hint faulty core partition group faulty union nonoverlapping result group complete set work thus capable provide correct hint intelligently divide work across micro faulty core reference one design reliable unreliable challenge transistor variability degradation micro vol six two al architectural core sal multicore processor hard error tolerance ann l computer architecture nine press three n al isolation build high availability multicore ann l computer architecture seven press four j al exploit structural duplication lifetime reliability enhance l computer architecture five press five al fabric construct resilient multicore ann l micro eight press six diva reliable substrate deep submicron de sign ann l micro press seven b j improve performance core ing l parallel compilation press eight z purser k e berg study ann l micro department university michigan ann arbor research interest include focus fault tolerance power efficiency performance computer engineer university michigan associate professor electrical engineer computer science department university michigan ann arbor lead create custom research group research interest include multicore mobile compute reliable system design electrical engineer university direct question comment amin michigan hayward st ann arbor mi page micro zero press nine al beat stall ann l micro three press p ten e infrastructure computer model computer vol two eleven brook v framework power analysis ann l computer architecture zero press twelve al temperature aware model gate leakage tech report science thirteen n r optimize wire large cache cacti sixty ann l micro seven press amin candidate electrical engineer computer science department university michigan ann arbor research interest include design architectural enhance reliability deep submicron computer science engineer university michigan student member candidate electrical engineer computer science department university michigan ann arbor research interest include computer exploit interaction hardware enhance system reliability computer engineer university michigan ann arbor candidate electrical engineer computer science