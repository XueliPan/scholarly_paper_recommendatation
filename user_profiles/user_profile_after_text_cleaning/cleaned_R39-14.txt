soft error protection embed advance computer architecture lab university michigan ann arbor mi shoe arm unite kingdom abstract device scale trend dramatically increase susceptibility soft mount demand embed wide array safety critical range automobile compound importance address soft error problem historically soft error tolerance target mainly server market lead modular redundancy redundant however tend prohibitively expensive implement embed design space address problem first present thorough analysis effect soft fully synthesize implementation embed leverage analysis design two orthogonal soft error protection tune achieve variable level fault coverage function area power first technique use small cache live register value order provide nearly twice fault coverage register file protect use traditional error correct cod little additional area cost second technique statistical method use significantly reduce overhead deploy shadow latch fault detection subject reliability test test embed general term reliability design experimentation reliability soft embed one introduction soft error single event upset define transient piece incorrect machine state soft error logic occur permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee case six copyright result transient fault logic propagate storage element latch soft error memory element occur sufficient charge generate invert value store memory element transient fault result electrical noise particle strike soft due energetic particle strike typically cause either alpha emit radioactive package cosmic radiation deal alpha largely manufacture issue address neutron strike pose problem adequate shield prohibitively expensive current device scale trend suggest dramatic increase soft error rat ser inevitable device scale result lower operate turn reduce energy require voltage pulse output logic gate invert value store within sequential element thus particle strike pose threat past technology could induce transient future technology rate particle strike increase exponentially energy level decrease nineteen therefore new technology generation rate particle strike may potentially affect logical operation increase significantly trend couple explosive growth embed distribution number suggest strong need understand reliability apply embed design space traditionally reliability research focus largely server market high availability server seventeen nonstop architecture four rely large scale modular redundancy provide fault tolerance research focus provide fault protection use redundant thirteen fourteen general expensive term area power require redundant computation generally appropriate embed design design embed domain differ arena design space area power primary balance processor performance typically lead longer clock cycle time logic sequential state higher degree signal embed design high performance typically employ large amount execution hardware speculative state decrease overall utilization chip lower probability particle strike affect sensitive piece state within design increase amount fault mask general high performance core tend much area devote sequential state combinational logic invariably affect soft design since design embed domain considerably different domain stand reason fault tolerance also vary dramatically order fully understand way soft affect embed conduct thorough analysis behavior fault embed core experiment measure amount fault mask occur fault inject state combinational logic also analyze propagation behavior throughout design use study motivate two soft error mitigation appropriate embed design space first propose register value cache small efficient mechanism protect register file fault occur sequential state combinational logic within register file design provide higher fault coverage lower area overhead traditional error correct cod second propose method strategic deployment transient pulse use shadow latch provide high degree fault coverage rest design require small number work follow empirical derivation logical temporal soft error mask rat commercial embed analysis error propagation behavior soft commercial embed lightweight architectural technique protect register file fault combinational sequential logic statistical technique deploy shadow latch tolerate soft occur arbitrary logic two fault analysis processor core though effect transient fault study past eleven eighteen relatively little publish data exist regard effect embed design previous work involve typically focus effect transient fault level eight fifteen order motivate architectural soft error problem goal follow analysis understand transient fault affect embed circuit level fault propagate throughout system state section provide brief overview describe fault analysis framework present detail result describe fault mask propagation throughout core fault analysis framework soft error analysis conduct work use model one embed architecture standard five stage pipeline consist fetch decode execute memory stag core depict figure one implementation use work architecturally define register general purpose six status register four instruction cache four data cache model synthesize use physical compiler insertion instruction fetch instruction decode data interface multiply data cache write buffer bus interface shift data address logic instruction cache instruction address logic register bank mux array bus interface one block diagram pipeline reference design test design error check log fault injection fault injection error analysis framework report generation two overview soft error injection analysis framework use artisan library characterize process synthesize process clock tree synthesis physical placement fully synthesize design rule satisfy time information extract standard delay format could annotate onto simulate use use simulation pair synthesize reference design unit test annotate time information gather synthesis layout tool also include behavioral memory model use load overview soft error test harness show figure two soft error injection analysis framework use experiment compose set program interface invoke start simulation upon invocation framework probe design derive set sequential state combinational logic gate within unit test depend simulation framework may schedule fault injection experiment arbitrary point time arbitrary select random design element register logic gate fault injection target invert value node output experiment conduct target sequential state combinational logic gate analysis carry run code image process algorithm map input image color space upon framework select random point time cycle start simulation conduct first fault injection fault inject combinational logic element fault injection time randomly select fault duration randomly select interval cycle time five experiment sequential state element fault injection time schedule random future rise edge clock signal hold duration one cycle fault injection time depend type injection experiment simulate fault combinational logic sequential state random design element select fault injection unit test fault inject logic element random logic gate design select value present output invert simulate transient fault cause particle strike similarly fault register simulate random register select output invert fault inject design framework log fault site time injection pulse duration fault inject system every register unit test compare dual reference design subsequent rise clock edge output port design io bus interface test equipment input cache check ensure corrupt value escape core first cycle fault injection register cache port mismatch occur inject fault affect system new random time future select another fault injection experiment register cache port mismatch occur fault analysis framework log relative cycle site error later analysis fault analysis framework continue track progress throughout system give number cycle fault injection period present propagate cache port system clean fault successfully mask allow new time fault injection schedule port cache occur latent error still linger design yet affect architectural state simulation halt error log write analyze propagation architectural state effect though latent design may cause state still pose threat may potentially data corruption give diverse fault analysis result section provide empirical derivation soft error mask rate processor core well detail examination soft error propagation behavior soft error rate directly relate set derate factor mask fault latch output circuit three derate factor affect ser follow logical mask logical mask occur transient pulse effectively gate possible target sequential state example transient pulse output circuit zero logically mask temporal mask temporal mask mask occur transient pulse propagate state element arrive within capture window state element electrical mask electrical mask occur transient pulse attenuate subsequent logic gate pulse affect output circuit experiment present work examine effect error location state architectural state port logical mask rate one average logical mask rate soft occur sequential state logical temporal mask overall soft error rate leave electrical mask future work logical temporal mask set experiment derive rat inject fault mask affect different class processor state state architectural state output port design io bus interface test equipment image process execute processor model define architectural state set physical register define arm instruction set architecture sixteen state set state within design exclude architectural register first experiment restrict fault sequential state observe rate different class appear period cycle subsequent fault injection result experiment present table one result demonstrate average logical mask rate fault occur sequential state table one show fault occur within state element common state remain corrupt cycle subsequent fault injection six fault mask affect state though state mask rate quite low thus error rate quite high fault rarely propagate architectural register file port design potential corrupt state second row table one show eleven inject fault actually affect architectural register third row show even fault propagate outside core port within cycle experiment window since combinational logic nod consume nearly cell area design expand upon previous study next examine effect fault inject arbitrary combinational logic nod introduce two set data first present mask rat different type base pulse inject clock cycle last duration entire clock cycle experiment yield average logical mask rate fault occur arbitrary logic nod second experiment uniformly select random point time inject fault irrespective clock cycle hold fault random duration interval experiment result average combine temporal logical mask rate core result two experiment show two three respectively table two result present table two demonstrate mask rate fault combinational logic substantially higher mask rate observe fault occur sequential state nevertheless would mistake take mean fault combinational logic less fault sequential state though large disparity mask rat difference nearly pronounce interface table two show architectural mask rate fault occur logic eight greater fault occur logical mask rate logical time mask rate error location state architectural state port two average logical logical temporal mask rat soft occur combinational logic twelve one eight six four two r r r e e e r p x e f c n e q e r f state state state architectural state state port comb logic state comb logic architectural state comb logic port r r r e f r e b n sixty fifty forty thirty twenty ten zero zero fault duration one two three four five six seven eight thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty eleven ten nine twelve elapse cycle three relative frequency incorrect state observe within processor function transient pulse duration four average number incorrect various error type span twenty cycle follow fault injection fault inject sequential state combinational logic sequential state even though architectural mask rate fault occur combinational logic tend slightly higher demonstrate section fault combinational logic tend much insidious order illustrate effect mask pulse duration overall soft error rate provide analysis fault occur nod design experiment restrict fault injection output sequential state vary pulse duration randomly across clock cycle time thus ensure worst case delay propagation path fault injection site target state histogram data represent frequency give fault duration cause error show figure three figure three show definite correlation fault duration likelihood express however figure demonstrate even relatively small pulse may responsible percentage total soft error rate addition important note result present figure three conservative since particle strike likely random throughout depth circuit technology scale latch window become portion clock cycle time marginalize effect latch window mask soft error propagation behavior section analyze soft propagate throughout core time effect transient fault architectural state well port design analyze cycle subsequent fault injection experiment fault injection data fault cause least single bite error use number type present core cycle follow fault injection analyze figure four demonstrate average number state bite class error discuss previous section figure four data point represent average number bite present design particular error class give least single error class express course experiment figure four demonstrate large disparity fault occur sequential state affect processor core oppose fault combinational logic first cycle fault injection fault occur combinational logic typically incorrect state six corrupt architectural state average whereas fault sequential state typically single bite class figure four clear fault occur combinational logic accurately model single bite state important note although section show mask rate fault combinational logic eight higher design consume combinational logic mean fault likely occur combinational logic sequential state potentially offset mask fault likely corrupt significantly system state also interest note figure four average fault logic error architectural state often within register file whereas fault state rarely demonstrate effect order better understand propagation within system may potentially affect state next experiment focus solely propagation behavior soft architectural state figure five five b demonstrate relative frequency architectural state bite manifest ten cycle fault injection figure five show architectural state tend occur rarely fault inject sequential logic corroborate position simply apply error correct cod word store within register file potentially valuable tool protect effect transient fault occur state however figure five b demonstrate transient fault occur combinational logic manifest architectural state four account show spike tail end figure five b fifteen fault occur combinational logic ninety architectural state state hold cycle one cycle two cycle three cycle four cycle five cycle six cycle seven cycle eight cycle nine cycle ten cycle one cycle two cycle three cycle four cycle five cycle six cycle seven cycle eight cycle nine cycle ten one eight six four two one eight six four two c n e q e r f e v e r l c n e q e r f e v l e r c n e q e r f e v e r l c n e q e r f e v l e r one eight six four two zero one eight six four two zero zero one two four sixteen eight number architectural give number architectural state fault inject register cycle one cycle two cycle three cycle four cycle five cycle six cycle seven cycle eight cycle nine cycle ten one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty thirty corrupt per architectural register frequency give number per architectural register corrupt fault inject state element cycle one cycle two cycle three cycle four cycle five cycle six cycle seven cycle eight cycle nine cycle ten zero one two four sixteen eight number architectural b give number architectural state fault inject logic five architectural state incorrect value typically result fault occur extremely sensitive design test logic nod highlight architectural effect present figure five b also study number incorrect per architectural register corrupt time figure six majority fault inject state single bite architectural contrast figure six b demonstrate entire architectural register corrupt tend norm fault occur combinational logic often result fault occur logic register file cause incorrect register read write case incorrect write address result actually pair incorrect architectural register one incorrectly write register one register write neither could recover use soft error analysis discussion experiment conduct section lead two important efficiently provide soft error protection first majority fault combinational sequential logic affect architectural state processor actually occur within register file standard practice apply handle fault occur directly register state array provide coverage fault logic since majority cell area within register file consume combinational logic clear unlikely supply adequate protection therefore tech one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty thirty b frequency give number per architectural register corrupt fault inject logic corrupt per architectural register six number corrupt per architectural register defend register file fault state array combinational logic necessary provide protection core second insight derive observation fault occur arbitrary combinational logic exhibit high degree cause large number sequential state property exploit minimize number fault detection sit necessary provide adequate coverage use set vulnerable state nod high error guide placement fault detection possible achieve high fault coverage minimal overhead follow section present two leverage provide soft error coverage little area power overhead three fault mitigation section leverage data present section motivate two complementary address soft within embed purpose present section provide scalable address statistically portion fault minimal area power overhead show target highly vulnerable portion design achieve substantial fault coverage little expense analyse demonstrate majority fault affect operation occur within architectural register file first technique present address fault use mechanism refer register value cache section rely locality reference maintain duplicate copy recently use register data order provide high fault coverage unlike traditional protect fault occur combinational logic state array yield twice fault coverage coverage provide may increase simply add cache thus balance area power fault tolerance address fault occur outside register file leverage amount observe fault within core demonstrate section strategically deploy transient pulse high state use flush processor state correct transient occur state process determine effective location pulse insert design fully subject ongoing research demonstrate technique use translate available area power fault coverage section register value cache register file consume total core area yet fault result interface architectural register memory instruction cache data cache occur within register file imply efficient strategy tolerate soft must implement mechanism handle fault occur within register file traditional technique deal fault occur large state array employ error correct cod however context register file problematic several reason especially implement arm instruction set first arm instruction set allow three register read two write per cycle significantly complicate logic within register file require protect register file include three encode two decode correct expensive implement power area addition limit term amount fault coverage provide register file since protect fault occur directly register state array sequential state consume register file cell area particle strike assume uniformly distribute area processor core fault likely occur logic register file state array serious efficacy soft error tolerance mechanism since capable correct single bite occur actual state array fault occur register file go potentially undetected order address protect register file propose new mechanism call register value cache capable detect correct fault occur combinational sequential logic register file maintain duplicate copy recently access value within register file allow high degree fault coverage without duplicate entire register file also since input register file split feed directly control logic register file essentially duplicate detail schematic implementation show figure seven implement separate module alongside register file address enable input register file duplicate feed read operation contain request read value provide duplicate data assert appropriate valid signal read result register file compare result comparison valid signal determine error present error present processor stall signal assert processor pipeline must stall one cycle determine whether value supply correct do conduct cyclic redundancy check register value contain cache check fail value contain register file correct check pass value correct assume probability multiple particle strike register file corrupt corrupt value correspond register value negligible two main reason use rather first former much implement term area power second since already two copy register read data necessary determine two value correct actually find correct error remove need expensive error correction logic employ two purpose encode decode value cache use five bite polynomial encode two write value per cycle since value check output register file match output point processor pipeline already stall one may reuse check mismatch read value operation read write request describe follow write request write enable signal assert check see register write already entry assign value array do check index array value correspond register number index array value valid use write address value array case index array value valid least recently use value evict cache write value address calculation take place value compute forward value array read request register read request index array entry correspond register read number check valid entry entry valid associate output valid signal assert address index array entry forward value array value array set read output data value store cache forward read value well value previous value buffer read value must copy temporary buffer order handle case read value mismatch occur register read write previous cycle index array entry valid appropriate valid line output data value set output register file compare comparison fail valid line read address assert two read result temporarily buffer pipeline stall one cycle cycle conduct check previously read value check fail error signal assert buffer value register file identify correct value otherwise buffer value cache assume correct value basic register file r e c e register value cache index value error register file output logic stall unit unit index c g l n c v e r e c e r e c e error value previous value register value cache seven incorporation register value cache processor core c n e q e r f e v l e r seven six five four three two one zero shadow latch order provide fault tolerance fault occur outside register file first determine fault critical result demonstrate less thirty fault inject sequential logic observable interface occur outside register file oppose fifty fault inject combinational logic order achieve high degree fault coverage still maintain low overhead specifically target fault occur combinational logic use transient pulse though pulse ideal detect fault combinational logic also provide fault detection fault occur sequential state well maintain low power area overhead exploit fault observe section strategically place transient pulse detection high sequential state conveniently high also tend nod responsible generate interface fault inject sequential state also provide fault coverage fault occur state since use specifically protect soft occur state outside register file error detect correct simply flush processor pipeline help motivate strategic placement small subset state within design demonstrate frequency observe cycle two four eight sixteen number eight give number state fault inject combinational logic directly fault inject combinational logic result show figure eight figure eight show thirty fault combinational logic actually result result twenty ten also interest note outlying data show almost five fault result incorrect state sort occurrence especially problematic typically result fault occur nod use design test scan chain general test logic main q delay shadow latch error nine shadow latch use transition detection figure nine demonstrate design transition detection circuit use work present razor two dynamic voltage scale system figure depict standard augment shadow latch detector input signal latch split subject delay proportional width pulse detect delay input pass shadow latch error signal generate output shadow latch match particular detection mechanism capable detect fault occur logic cone feed number engineer involve implement system beyond scope paper discuss five since tool place integrate core subject ongoing research future work present manual technique place fault order determine achievable fault coverage function number detection use design determine valuable detection point first conduct statistical analysis use monte fault injection core rank order set protect base number unique fault sit would cover protect generate amount fault coverage chip improve replace traditional enhance within design allow chip systematically tweak fault coverage function area power budget available fault tolerance section explore cost versus fault coverage achieve augment transition detection circuit four evaluation section conduct number experiment demonstrate efficacy two propose soft error protection evaluate fault coverage provide technique apply isolation well employ experiment detail amount fault coverage gain respect cost term area power register value cache analysis evaluate first derive bind maximum fault coverage achievable bind calculate analyze hit rate various size multiply hit rate percentage fault occur within register file lead interface determine hit rate simulate operate set trace nine compile use cross compiler version simulate simulator three hit rat various size show figure ten show figure ten six demonstrate average hit rate ninety eight average hit rate better exhibit one nine eight e r h epic unepic average six eight ten twelve number fourteen sixteen ten register value cache hit rat function number cache hit rat cache six average hit rate require least twelve entry cache hit rat magnitude demonstrate high fault coverage gain relatively cache allow small efficient design order evaluate cost implement various design comparison traditional fault tolerance augment register file protection implement protection circuit use minimum cod describe seven protect register file require two encode one potential write three decode error correction one potential read also implement variety size range six sixteen two area result protect register file design generate physical compiler power number generate power compiler area result show figure eleven power result show figure eleven b data present figure eleven demonstrate percent area power overhead core fault tolerant register file configuration result indicate eight less consume less area power register file augment general area tend scale regularly power tend erratic largely due synthesis could utilize efficient logic cache size power two fault coverage provide protect register file bound fact fault visible interface occur within register file coverage bind reduce detect correct fault occur actual register state array register file sequential state conservatively estimate fault coverage protection estimate conservative modest fraction sequential state within register file state rather register would protect could degrade fault coverage provide since capable protect fault occur combinational logic sequential state fault coverage design bound cache hit rate multiply coverage gain protect register file assume probability multiple concurrent e g r e v c l f seventy sixty fifty forty thirty twenty ten zero e h r e v e r seven six five four three two one zero e h r e v r e w p fourteen twelve ten eight six four two zero b b b b b b b e e e e e e e e c c c c c c c c c h e six c h e eight c h e one zero c h e one two c h e one four c h e one six b b b b b b b e e c c e e e e e e c c c c c c c h e six c h e eight c h e one zero c h e one two c h e one four c h e one six percent core area overhead vary size configuration twelve fault coverage variety register file configuration test set use evaluate fault coverage achieve deploy accordingly second experiment present average achieve coverage several thousand refer result two experiment coverage limit study observe coverage respectively figure thirteen present study amount area power overhead incur augment shadow latch describe section mention section technique insert core subject future work present manual technique overhead insert present term additional logic cell overhead alone however preliminary experiment show interconnect cost significantly impact result present figure thirteen demonstrate two set data one coverage limit study one observe coverage describe limit study demonstrate best case less thirty register design would need augment order achieve fault coverage fault occur outside register file observe coverage metric figure thirteen result show average ninety fault coverage could augment approximately state within design combine approach analysis propose paper work together fashion address disjoint set fault present analysis combine fault coverage achieve employ together tolerate soft area power number show represent combine cost implement two term logic cell overhead alone figure fourteen demonstrate combine cell area overhead figure fourteen b demonstrate combine total power overhead technique discuss paper line figure fourteen fourteen b represent different register file configuration effectiveness use conjunction amount area power budget shadow latch describe graph fault coverage increase percent overhead transient pulse add design several make data first clear far less effective protect register file corruption second increase area overhead different almost negligible power overhead increase slightly dramatic however majority power overhead come addition b b b b b b n e n e n e n e n e n e b n e c c c c c c c c h e six c h e eight c h e one zero c h e one two c h e one four e c c h e one six b percent core power overhead vary size configuration eleven area power analysis register value cache particle strike negligible figure twelve present achievable fault coverage various fault tolerant register file figure twelve demonstrate eight capable deliver twice fault coverage protect register file even importantly scale fourteen increase fault coverage fault affect register file increase area power overhead one cost implement shadow latch analysis section analyze area power necessary add sufficient achieve give amount fault coverage large number monte fault conduct identify state potential augmentation shadow latch experiment counter maintain state element within design counter every time state element corrupt within first cycle follow fault injection result counter associate state element reflect number distinct fault would detect augment state element pulse detection unit set state use counter value two experiment provide list candidate state perform determine amount attainable fault coverage first experiment present limit study demonstrate upper bind number fault cover state element protect shadow latch second experiment fault injection data divide train data test data train set use generate candidate list describe previously number zero zero forty thirty twenty fifteen ten five forty thirty twenty fifteen ten five e g r e v c l f n e c r e p e g r e v c l f n e c r e p twenty one ninety eighty seventy sixty fifty forty thirty ninety eighty seventy sixty fifty forty thirty e g r e v c l f n e c r e p e g r e v c l f n e c r e p percent coverage limit percent coverage observe five one fifteen two three four two three four five six seven percent area overhead percent area overhead transient fault detection secondary x axis show number ie number augment detection percent area overhead percent area overhead combine technique area increase function number use attain fault coverage number percent coverage limit percent coverage observe zero zero one two three four percent power overhead five six b percent power overhead transient fault detection secondary x axis show number ie number augment detection thirteen area power analysis transient fault detection shadow latch tend yield diminish return lastly eighty fault coverage achieve cost less fourteen power overhead less six area overhead five relate work kim eight conduct fault injection campaign model determine soft error sensitivity logic block within design soft error sensitivity metric use work define probability soft error within give logic block processor enter incorrect architectural state fault model use work similar though author paper conduct error analysis strictly architectural level eleven al define term architectural vulnerability factor probability fault structure error program output author use performance simulator determine structure within simulate work present similar result architectural level fault inject sequential state focus effect soft less aggressive processor core wang al eighteen characterize effect soft processor core fault model twenty eight nine ten eleven thirteen twelve fifteen percent power overhead fourteen sixteen seventeen eighteen nineteen b percent power overhead combine technique power increase function number use attain fault coverage fourteen area power analysis combine technique represent time delay redundant latch technique represent error correct cod technique register file protection represent register value cache technique x number cache use work simulate single bite flip sequential state within design analysis failure exhibit simulation describe work author explore effect soft substantially different model propose detect soft base observe interface al fifteen present similar analysis effect soft occur sequential state combinational logic model error manifestation rat demonstrate work corroborate however work choose focus error propagation behavior exhibit level rather sensitivity analysis different block within design ten author present technique protect register file fault may occur clock frequency aggressively scale author specifically target large physical register file typically find store redundant live register value unused physical register though idea propose similar nature feasible large register file provide coverage register file fully utilize work leverage large body research five six twelve focus circuit detect delay fault cause electrical noise particle strike inadequate voltage level work provide basis propose strategic placement transient fault exploit embed order efficiently utilize technology six conclusion work present thorough analysis soft core analysis do order motivate soft error tolerance appropriate embed design space demonstrate soft combinational logic affect behavior soft level important embed domain mitigate soft present two complementary provide scalable fault coverage function available area power budget first technique introduce register value cache architectural mechanism provide twice fault coverage apply register file cost less implement term area power second technique present make use shadow latch fault detection identify high nod core place achieve forty fault coverage conjunction two propose fault tolerance provide approximately fault coverage incur less area overhead fourteen power overhead seven reference one arm technical reference manual two k make typical silicon matter razor computer three march three e infrastructure computer system model two four b p r j j nonstop advance architecture international conference dependable network page june five das lee pant k processor use detection correction journal circuit four six p franco e j delay test digital circuit test symposium page seven class optimal minimum cod journal research development fourteen four eight kim soft error sensitivity characterization dependability enhancement strategy international conference dependable network page june nine c lee w tool evaluate synthesize annual international symposium page ten g engineer register file international conference dependable network page june eleven c weaver j systematic methodology compute architectural vulnerability factor high performance international symposium page twelve time redundancy base tolerance rescue test symposium page thirteen k transient fault detection via annual international symposium computer architecture page june fourteen e approach fault tolerance international symposium fault tolerant compute page fifteen g p z r sensitivity control execution combinatorial sequential logic international conference dependable network page june sixteen seal arm architecture reference manual seventeen l parallel enterprise server fault tolerance historical perspective journal research development six eighteen n j wang j j patel characterize effect transient fault processor pipeline international conference dependable network page june nineteen j terrestrial cosmic ray journal research development one