integrate instruction selection register allocation compact code generation exploit mix sixteen institute compute architecture school university forum ten street unite kingdom abstract memory constrain embed code size least important performance one way increase code density exploit compact instruction format arm thumb processor either operate standard compact instruction mode consider paper different allow mix sixteen without mode switch compact use anywhere code give additional register satisfy paper present integrate instruction selection register allocation methodology develop two approach code generation simple opportunistic scheme advance instruction selection scheme implement code generator target evaluate effectiveness embed processor suite average achieve code size reduction across whilst time improve performance average subject program generation program general term experimentation measurement performance instruction selection register allocation code size dual instruction set architecture permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten canada copyright c introduction one large number embed deploy market even modest save unit cost lead substantial overall cost reduction highly integrate soc serve market provide embed part complex system integrate various peripheral chip typically occupy fraction chip area hence contribute overall cost among embed f flash storage play prominent role nonvolatile memory need large enough store full image binary executable consequence reduction code size translate directly equivalent save die area eventually unit cost example flash two per cell fabricate design rule use storage scheme occupy chip area six whereas arm processor core occupy technology node three one popular architectural approach code size reduction provision compact instruction set architecture alongside standard example arm implement compact thumb instruction set whereas similar offer call common compact processor either operate mode switch operation do mode change add certain code size overhead furthermore register available mode also accessible mode seek take full advantage compact instruction format need analyse code identify benefit compact instruction format outweigh disadvantage ie mode switch overhead increase register pressure restrict register set sig care need take performance degradation result overly aggressive use compact report eleven paper consider two implement arc series embed arm fourteen also recently introduce thirteen different compact allow mix sixteen without mode switch enable compiler generate interleave sixteen thus potentially lead greater code density without performance loss however time compiler need decide every instruction compact counterpart whether emit compact version decision depend availability equivalent compact instruction additional register need obey due instruction comprise shorter register field address eight rather register standard case register demand integrate approach instruction selection register allocation consider simultaneously failure may lead miss even worse code bloat performance loss due excessive data movement thus negate intend code size reduction effect discuss propose code generation approach detail provide motivate example highlight issue encounter selection compact consider small basic block first column table one suppose block register available use register contain value whose live range begin end basic block mix mode aggressive mix mode integrate add sub sub twenty table one three sample basic block aggressive use integrate instruction selection register allocation avoid data movement access whereas give three different basic block first one use leave column result code size six four second version second column instruct code generator use denote suffix wherever possible clearly lead problem since compact operate limit set register register allocator insert additional move spill value currently store accessible use three accessible register aggressive use compact increase overall instruction count result code size six two two four twenty better solution present third version basic block third column version replace operate register remain result spill limit accessible register register avoid thus instruction count remain constant code size reduce four two two four sixteen example demonstrate instruction selection register allocation need consider simultaneously avoid excessive register traffic fully exploit benefit compact twelve one development integrate instruction selection register allocation framework target freely compact standard code size reduction two investigation opportunistic instruction selection procedure obey register compact instruction format actively seek usage compact three development sophisticate instruction selection scheme use feedback information obtain standard instruction selection register allocation improve compact code generation four demonstration practical integration scheme compiler target five extensive evaluation industry standard suite simulator processor sixteen six comparison target platform thirteen overview remainder paper structure follow section two provide background information eleven motivate example among paper instruction set architecture particular ability mix sixteen without mode switch well cosy compiler development system one follow description code generation approach section three develop two scheme selection compact register section four evaluate effectiveness methodology present extensive result context relate work establish section five conclude section six two background section give overview processor instruction set architecture follow brief presentation feature cosy compiler construction framework relevant work present paper processor two implementation architecture particular goal create easily extensible embed support type intermix freely without additional overhead decompression stage require memory value may contain either one instruction two even combination half instruction one instruction thus frequent use could reduce code size theoretical maximum fifty practice value lower compact counterpart arc claim forty code size reduction web site two obviously compact certain compare case access limit subset core register namely eight register range immediate generally limit flag carry overflow set name table two give add correspond illustrate cosy compiler construction framework see code size reduction provide describe cosy compiler framework one use implementation propose compact code generator cosy provide compiler architecture compiler operate intermediate representation mir produce compiler front code generator execute three principal pass namely register allocation code instruction add b c add b add b reg reg reg reg reg reg reg long immediate b c reg b reg reg reg reg reg long immediate table two comparison format add instruction sion pass compute cost minimal cover mir give usual rewrite rule map nod onto processor rule associate possibly dynamic cost accord select rule mir transform direct acyclic graph dag intermediate representation annotate original mir nod later pass maintain extend user able trace back creation point node make use feature section implement instruction selection graph register allocator map actual register memory responsible insert spill code register allocator provide cosy handle several overlap register class use feature implementation separate register class accessible globally accessible register respectively finally assembly code emit node use code emission rule type node naive code generation use cosy obvious approach add support cosy compiler framework would add new rule class lower cost compiler would select wherever possible would hope measure desire effect code size naive scheme however serious due register allocation occur pass register access describe use almost exclusively effectively reduce size available register set small subset register available inevitably lead higher register pressure result increase number data move even spill memory thus even though might able reduce code size initially additional negate benefit use compact instruction format addition extra data move spill certainly degrade performance therefore highly undesirable figure one typical distribution dynamic register access three methodology discussion section become evident need balance use increase register pressure result restrict register address keep mind goal reduce code size much possible therefore want use amount move spill insert register allocation stage solely use follow section propose two achieve first one opportunistic use implement purely code emission stage require change compiler framework second one selective use direct mir use code generator feedback involve less dependent specific expect produce better result opportunistic instruction selection first compact instruction selection scheme motivate nonuniform distribution register access register lower id higher id example distribution show figure one clearly visible lower part register set access much frequently upper part partly due fact standard graph colour register allocator always select register id set possible register value addition call dictate pass register result return register finally immediate value tend small often fall within limit bound operate exploit fact accessible register already frequently use standard code construct opportunistic instruction selector aim specifically identify compact stage delay decision standard instruction selection register allocation code emission stage check instruction possess counterpart incidentally satisfy register compact instruction case figure two sequence stag opportunistic scheme instruction selection emit short instruction otherwise emit standard instruction either case leave register allocation intact type instruction affect figure two approach schematically certainly approach work coincidental match frequently use register register accessible still opportunistic scheme avoid main drawback naive solution section namely introduction additional register move spill addition compact code generation scheme low implementation complexity require local change code emission pass instruction selection opportunistic instruction selection scheme present previous section number first rely coincidence standard graph colour result code frequently satisfy register may embed register accessible short elsewhere register set simple opportunistic approach become less effective second seem conceptually unsound handle outside cost framework stage defy standard instruction selection register allocation reason appear likely may miss use therefore propose improve approach base code generator feedback illustrate figure three summary run two register allocation stag purpose first iteration attempt aggressive code generation include instruction selection register allocation end first iteration feedback gather make available second iteration code generation second code generation stage feedback use determine annotate register pressure point mir avoid allow selective use second iteration thus avoid introduction register pressure relate move register access register match pattern node relate turn allow us locate mir node give rise use link insert stage see section annotate mir node additional flag indicate node cover instruction rule avoid additional move spill finally produce iteration discard code generation one second iteration stage use mir selectively disable use instruction rule nod flag previous annotation stage achieve specify special condition available code generator description language hold rule apply two register allocation expect register allocator insert significantly additional move spill cause second iteration possible new move spill appear different place unlikely since register pressure actually result temporary short live range within basic block three code emission stage perform standard code emission target sixteen rule opportunistic scheme may find even instruction nod mark flag register use incidentally satisfy thus additionally employ opportunistic scheme use wherever possible incur extra cost example show table one would initially generate code second column however without actually emit code see figure four next would identify two insert introduce register allocator free space accessible register range respectively mark two short flag enter actual code generation stage encounter two check flag decide emit compact resort standard finally subsequent run register allocator shorter code sequence show third column table one emit important note although use feedback guide instruction selection compact code generation methodology feedback information generate statically within compiler unlike ten eleven twelve require profile figure three approach instruction selection follow paragraph explain two phase annotation code generation detail annotation one contrast opportunistic approach add separate match rule stage cost lower correspond ie use sixteen rule preference due lower cost two register allocation aggressive use likely introduce large number additional register move spill register allocation additional insert register allocator insert mir nod cause example suppose one add instruction originally locate register accessible case register allocator insert additional register move operation place value register accessible short may result move insert free temporary space accessible register set move insert actual add instruction node link set point newly create auxiliary move nod register allocation trace back exactly mir nod origin additional move spill three mir annotation pass iterate nod identify move spill directly cause base number simple tree pattern whenever node find use insert previous register allocation pass determine match pattern deactivate figure four compact code generation example table one four empirical evaluation extensively evaluate integrate code generation approach section describe experimental setup methodology present discuss result experimental setup methodology evaluate compact code generation approach eleven suite seven comprise automotive consumer network office cod build highly compiler base commercial cosy compiler development system one main interest code size therefore measure code size ie total size text segment object file form single except harness use tool size addition measure performance impact result code generation methodology use verify simulator processor table three list configuration detail target processor finally also compile full set arc port compiler full mix code generation enable order compare benefit exploit compact instruction format approach throughout section plain code feature exclusively serve code generate compiler discussion compact code generation scheme evaluation approach relative core pipeline execution order branch prediction memory system cache instruction data cache bus divisor simulation simulator io system call interlock yes hardware associative associative none default emulate table three configuration simulator due code generation become comparable code size initially discuss code size reduction due selection compact primary motivation work overall code size result diagram show figure five automotive consumer network office telecommunication present three result relate code size result opportunistic scheme b instruction selection scheme c allocation mir discard guide code virtual physical figure five code size due compact code generation eleven arc port compiler discuss result separately section opportunistic scheme code size achieve average improvement individual program code size thirty reach exceed result slightly surprise give opportunistic scheme actively seek use identify convert already satisfy register correspond six fail deliver code size ten simple scheme fourteen improve fifteen suggest initial assumption namely standard code register traffic already handle accessible register hold general see figure one scheme try improve would need identify among remain operate accessible register whilst accessible register fully information surprise instruction selection scheme perform slightly better simpler opportunistic scheme observe although average improvement much higher simple scheme instruction selection provide consistent across range reduce standard deviation mean advance scheme produce code simple scheme perform well still scheme perform similarly provide code size important note compact code generation scheme single case code size increase impossible either two arc claim forty code size reduction extensive use compact two however represent theoretical upper bind achievable compact use virtually live data fit small accessible register subset practice code generation methodology come close theoretical limit number majority cod reach hypothetical peak code size save performance next evaluate performance impact compact code generation methodology summary result show diagram figure six across range opportunistic scheme reduce cycle count average individual performance code size selection opportunistic selection figure six performance due compact code generation eleven excess thirty observe five improve less ten whereas seven program speed twenty single program suffer performance degradation result opportunistic compact code generation similar code size evaluation previous section instruction selection give slight improvement simpler opportunistic scheme average performance improve unlike case code size instruction selection perform better across entire set one two scheme clearly outperform example opportunistic scheme produce faster code whereas scheme take lead cod single program scheme result negligible performance loss investigate origin performance gain observe experiment find largely result improve instruction cache behaviour due increase code density code size instruction cache processor relatively small representative typical embed processor core code size reduction technique inevitably lead higher instruction cache hit rat application one application see minor performance degradation find cause increase number instruction cache conflict conflict avoid configure processor contain associative instruction cache rather associative cache use experiment reason prior work field nine ten eleven twelve sixteen report performance best level performance code mode switch overhead associate thumb exceed performance gain reduce number instruction cache miss due ability freely interleave compact standard without mode switch suffer penalty comparison diagram figure five six contain additional data point official arc port compiler target processor comparison code size go plain code code reveal perform significantly worse either two scheme average code generation compiler result modest reduction code size two program code size reduction exceed ten however majority program code size save less five norm poor performance cycle count selection opportunistic selection publication comment platform compiler code size red performance gain repeat instruction custom selection cache modify mem access code size level fix proprietary ten eleven nine twelve sixteen express loss six sixteen loss zero loss fourteen eighteen two loss zero table four comparison publish result code generation compiler due instruction selection register allocation stag generate without take consideration increase register pressure restrict accessible register subset performance result compiler show figure six even disappoint average generate perform worse thirteen program suffer performance degradation individual take cycle execute time possible performance gain observe remain program limit come close result propose two program deliver higher speed either two scheme overall feel modest code size achieve justify potentially large drop performance may present serious obstacle widespread adoption code generation code size performance aware five relate work compact instruction set support number commercial embed code size aware compilation target short instruction format find interest scientific community nine ten eleven twelve sixteen paper address mix mode code generation overhead associate switch compact standard instruction set paper however concern allow mix sixteen best knowledge problem yet address academic literature direct comparison result publish elsewhere difficult due different compiler least instruction set nonetheless juxtapose available result code size reduction performance impact along relevant detail relate table four nine modify target compiler flow repeat instruction selection pass propose first instruction selection stage target generic profitability analysis perform guide second instruction selection stage selection compact final step register allocation take place work similar approach compiler feedback use improve compact code generation however main difference register allocation take account consequence excessive spill may occur memory access model however almost eliminate spill cost trivial loop may lead overly optimistic performance result still show overall slowdown report code size reduction however impressive require evaluation representative feedback information use ten eleven selection arm thumb frequently execute function identify via profile heuristic base expect performance relative code size use choose arm thumb contrast approach require expensive profile stage operate purely static information available compiler overall code size reduction good higher code density translate performance gain result improve instruction cache behaviour instruction set assignment determine basis twelve require control flow analysis determine program point processor execution mode switch effort level choose depend code size budget set user order avoid excessive mode switch overhead detail profitability analysis estimate cost benefit use different instruction set different part give program require secondary goal impact use compact instruction format execution time analyse rely profile employ static feedback information within compiler overall code size reduction good four small aggressive code size budget performance penalty drastic relax performance loss compensate time code size save drop sharply slightly unconventional approach compact code generation take sixteen mix mode code generation perform post pass actual compiler addition semantics choose compact change order efficiently encode mode change result good code size without incur performance loss contrast target fix require architectural change whilst reduce code size time improve performance across entire range summary nine ten eleven twelve sixteen achieve higher code size approach result performance sixteen code size gain comparable generate faster code rely hardware method patent eight describe compilation technique target compact instruction set block code compile standard compact instruction set eventually whichever version better get choose scheme compact code generation aggressive however whenever spill occur clean operation perform memory reference register set scheme largely identical aggressive scheme show table one disadvantage arm state code size save respectively thirteen fourteen performance drop two direct comparison thumb give fifteen design variable length subject five general reduction survey four six summary develop integrate instruction selection register allocation methodology compact freely sixteen present simple yet powerful opportunistic instruction selection scheme general scheme portable unlike first scheme depend particular distribution register access experimental result base highly cosy compiler target processor demonstrate average code size reduction achieve across industry standard whilst time improve performance average result encourage show code size reduction performance mutually exclusive obtain simultaneously future work include evaluation compact code generation methodology reference one ace associate computer cosy compiler development system retrieve twelve august two arc international core retrieve twelve august three arm arm retrieve twelve august four survey reduction compute survey vol three five computer architecture news vol two six flash nonvolatile memory design id electronic pan seven embed consortium suite retrieve twelve august eight j lee peter warn method apparatus compile data processor unite state patent us two nine p n efficient compiler technique code size reduction use reduce proceed conference design test date p ten profile guide selection arm thumb notice vol seven eleven instruction set vol eight twelve lee lee chang park sing min selective code transformation dual instruction set embed compute vol six two thirteen instruction set architecture revision fourteen improve arm code density performance new thumb arm architecture arm core technology june fifteen code compression microscope embed design retrieve twelve august sixteen cheng efficient code size proceed reduction without performance loss symposium apply compute sac