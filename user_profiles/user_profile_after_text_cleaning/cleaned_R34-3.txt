safe distribute file peek b nightingale brett university michigan abstract lightweight method extend functionality distribute file specifically target file implement user level small express several hundred line code sprocket akin procedure call run inside transaction always roll back completion even sprocket execution succeed therefore make persistent change file system state instead communicate result back core file system restrict format use share memory buffer file system validate result make necessary change pass use binary instrumentation ensure sprocket safely execute file system code without make change persistent state implement perform handle within file query application conflict resolution handle custom digital evaluation show order magnitude faster execute utilize operate system service fork also show allow isolation thus catch bug implementation one introduction recent file research community propose number new extend functionality storage yet production file slow adopt advance slow rate change reasonable precaution storage system entrust persistent data computer system however file adapt new challenge present scale widespread storage data new consumer electronic need efficiently search large data must change faster paper explore method call safely extend functionality distribute file goal develop let create link file system target support three user level file system six seventeen offer extensibility granularity call read open intend smaller tweak file system behavior query resolve conflict distribute file akin procedure call link code base exist file except safely extend file system behavior one might think extend behavior distribute file system require one alter kernel functionality many distribute file ten twenty coda thirteen implement core functionality user level file target extend file system functionality kernel accomplish two five many ways extend user level code easier extend kernel code since extension implementation use operate system service sandbox user level however find exist service fork often prohibitively expensive file system hundred line code isolation insufficiently expressive capture range necessary support file system sprocket extension model base upon isolation easy implement since execute address space file system may query exist data structure file system reuse powerful function code base manipulate file system ensure safety execute inside transaction always partially roll back completion even extension execute correctly sprocket may execute arbitrary user level code compute result must express result limit buffer share file system share buffer roll back end sprocket execution result verify core file system change make file state association annual technical conference one use implement three file research community seven fourteen automatic translation file system performance result show order magnitude faster safe execution use operate system service fork yet enforce isolation prevent bug fork two design best way extend file system functionality answer question first outline wish achieve design safety important goal safe execution potentially unreliable code file system critical reliability computer system safe repository persistent data entrust crash file system may render entire computer system unusable subtle bug file system lead loss corruption data store since file system often store persistent copy data avoid cost envision many write may less familiar detail file system core may also execute rarely code core file system mean sprocket bug may go undetected longer thus expect incidence bug higher core file system therefore important support strong isolation sprocket code particular program error sprocket never crash file system corrupt data file system store buggy sprocket may induce incorrect change file operate since core file system verify semantics within file however core file system verify change semantically correct give general view file system data file attribute still internally consistent sprocket modify file entitle operate like previous design goal protect buggy rather overtly malicious particular design make extremely unlikely impossible sprocket compromise core file system design also protect intentionally leak unauthorized data covert channel ease implementation also design minimize cost implementation want make minimal change exist code core file system order support eliminate consideration design require substantial file system code add substantial amount new complexity also want minimize amount code require write new sprocket particular decide make sprocket invocation similar procedure call possible call function implement part core file system distribute file often consist multiple layer data structure sprocket save substantial work reuse function core file system manipulate also let access memory image file system extend order reduce cost design sprocket sprocket could access data pass call file system designer must carefully consider possible future design interface order make sure set data pass sprocket sufficient contrast let access data directly pass enable creation explicitly envision design performance finally design minimal performance impact file system implement far execute many time simple file system thus critical time execute sprocket small minimize impact overall file system performance fortunately envision implement hundred line code less feature lead us bias choice design toward one low constant performance cost per sprocket invoke potentially higher cost per line code execute alternative design bias would batch process sprocket much work invoke batch reduce need minimize constant performance cost execute sprocket amortize work across execution single sprocket however batch would considerably increase implementation complexity require us file system code wherever use annual technical conference association two three alternative design section discuss alternative design consider lead current design direct procedure call many possible file system straightforward one simply link extension code file system execute extension procedure call approach similar operate load execute device direct execution procedure call minimize cost implementation lead good performance however design provide isolation buggy extension crash file system corrupt data safety important design goal consider option address space second approach consider run extension separate address space simple implementation approach would fork new process call replace address space pristine copy extension execution type use web apache isolate untrusted script sophisticate approach address provide better performance spirit apache script fork process reuse several extension however form address space suffer two substantial first provide minimal protection persistent change make extension execution system call particular buggy extension could corrupt file system data incorrectly overwrite data store disk potentially could even violate file system lead crash file system read corrupt data operate provide tool system call change effective process tool coarse granularity hard allow extension access instance one might want allow extension access input file read mode output file write mode restrict privilege manner use exist operate system require much effort thus address space provide completely satisfactory isolation current operate second drawback address space considerably increase difficulty extension implementation extension file system exist separate address space extension access file system data structure mean data need execution must pass start extension reuse function implement part file system one could place code potential interest share library implementation cost would large rollback drawback lead us refine design allow execute address space original file system file system fork new process run extension however instead call load executable image extension extension instead dynamically load child address space directly call procedure extension finish child process terminate one way view implementation extension execute transaction however contrast typically commit success always roll back since fork create new image make original address space extension isolate child process file system code never see may often make persistent change file system state since unsafe allow extension make change directly divide extension execution two phase first phase extension generate description change persistent file state would like make description express format specific extension type interpret core file system second phase core file system read extension output validate represent allowable modification validation specific function expect extension may simple check change make specific file return value fall within permissible range pass core file system apply change persistent state approach similar take operate system system call point view operate system application make call execute arbitrary untrusted code yet system call validate check consistency change persistent state make result call implementation rely fact particular policy determine change need make arbitrarily complex thus best describe code set change make result policy often limit express use simple interface example consider task resolution do coda file system fourteen association annual technical conference three resolver might merge conflict update make file read perform logic finally make change merge conflict single resolve file application logic behind resolution specific type file merge possible result resolution limit conflict file replace new data thus extension implement resolution express change wish make limit format patch file easily interpret generic file system code core file system verify apply patch transactional implementation extension need way return result interpret validate apply file system allow make rollback end extension execution partial extension execute parent process allocate new region memory share child region exempt rollback extension finish parent process instead read verify apply return value share region transactional implementation still like address space isolation must rely operate system limit change extension make outside address space second drawback occur file system code extend multithreaded extension operate copy data exist parent address space time fork however copy could potentially contain data structure concurrently manipulate thread one invoke extension case state data structure extension copy address space may violate expect cause extension fail ideally would like fork extension data structure consistent one way accomplish would ask extension specify lock need hold extension execution reject alternative require extension developer correctly grasp complex lock semantics core file system instead extension infrastructure perform task behalf developer rely heuristic thread modify share data hold lock protect data use barrier delay fork extension thread currently hold lock policy sufficient generate clean copy long thread follow good program practice acquire lock modify share data greater time actually execute extension fork operate system copy page table parent cost roughly proportional size address space instance measure time fork process run operate system nineteen cost include time later spend service page fault due flush implement overall transactional implementation offer reasonably good safety excellent ease implementation ideal performance large constant cost fork four sprocket design implementation performance lead current design sprocket implementation use transactional model describe previous section implement use form fault isolation instead use address space isolation fork add instrumentation use pin sixteen binary instrumentation tool modify file system binary pin generate new text program execute use rule define pin tool run address space modify process modify text reside process address space execute use alternate stack separation original modify text allow pin turn program execution use functionality instrument file system binary sprocket execute instrument generate new code application expensive operation instrumentation must perform instruction unfortunately since pin design dynamic optimization support option available many instrumentation tool statically start run overcome artifact pin implementation run dummy data file system binary first load implement pin tool provide safe execution environment run sprocket execute pin instrumentation activate pin tool first save context call thread register state program counter heap size sprocket execute instruction write memory pin tool save original value memory location modify undo log final substantial drawback fork heavyweight operation operate extension consist hundred line code time fork process may order magnitude sprocket complete execution memory location undo log restore original value program context restore point sprocket execute pin tool save annual technical conference association four pass sprocket null zero set return buffer invoke sprocket verify read return value null fid path else handle sprocket error figure one example sprocket interface sprocket return code pass back core file system return value sprocket execution like fork implementation sprocket infrastructure allocate special region memory process address space result region roll back end sprocket execution sprocket execution abort due exception bug pin tool substitute error return code prior return pin tool disable instrumentation core file system code execute native speed ability dynamically enable disable instrumentation especially important since often call core file system function sprocket execute pin use slow instrument version function use sprocket function call core file system original implementation use instrument cache sprocket instrumentation cost need pay run instrument sprocket code save modify memory value undo log order magnitude run native version sprocket however since hundred line code total slowdown due instrumentation substantially less large constant performance cost fork perform improve performance binary instrumentation observe many memory occur stack record location stack pointer sprocket call determine region stack unused point time sprocket execute neither save restore memory unused region modify sprocket similarly avoid save restore memory sprocket allocate use finally avoid duplicate address binary instrumentation also allow us implement sprocket code rather rely operate system use pin trap system call make sprocket system call allow call describe section sprocket terminate error call include change external state also allow system call enable read file modify sprocket interface figure one show example use point view core file system sprocket invocation design appear like procedure call sprocket pass pointer argument contain arbitrary data specific type sprocket invoke since share file system address space data structure pass may include alternatively sprocket read necessary data file server address space sprocket set return data macro allocate memory region hold return value example figure one region one memory page size sprocket macro invoke sprocket roll back change except data modify five association annual technical conference designate memory region example code core file system function get need data parse verify data designate memory region region show figure one core file system may also include error handle code deal failure sprocket execution handle buggy employ variety prevent erroneous affect core file system behavior data change process address space make sprocket roll back via undo log effect sprocket bug stomp core file system data structure memory undo rollback similarly sprocket leak memory affect core file system data structure use keep process address space memory allocate sprocket automatically free undo log replay address space restore additional page acquire memory allocation sprocket execution system call type erroneous address register signal execution socket instance sprocket null pointer access invalid address register handler call handler set return value sprocket error code reset process program counter save execution context pass handler entry point rollback code thus handler finish sprocket automatically roll back change address space sprocket return specify error code handle consume much infinite loop sprocket infrastructure set timer execute extension final type currently handle erroneous system call allow via specify particular system call sprocket allow execute enforce use pin binary instrumentation tool insert check execution system call system call invoke sprocket sprocket abort roll back error code support handle system call instance keep track file open sprocket sprocket attempt close open roll back sprocket return error similarly sprocket finish execute rollback code automatically close file sprocket leave open prevent leak consumable resource one remain way buggy sprocket affect core file system code return invalid data via share memory buffer unfortunately since return value specific type sprocket invoke sprocket execution code automatically validate buffer instead code invoke sprocket perform validation use return value instance one describe section return change file file format code write invoke particular sprocket verify data return buffer fact compatible patch format use support multithreaded binary instrumentation introduce complication multithreaded program thread never allow see make sprocket important consideration file since design support high level concurrency first discuss current solution multithreaded support appropriate discuss extend sprocket design future better support file system code run current design support multithreaded rely observation typical time execute sprocket experiment much less schedule quantum thread thus thread would ordinarily sprocket run acceptable let thread continue use processor small amount time order complete sprocket execution sprocket take long execute timer expire sprocket abort effectively extend barrier implementation treat critical section thread schedule sprocket finish abort although barrier implementation slightly inefficient due lock would require expressive interface one utilize schedule solution critical section implementation problem must idle execute sprocket run one processor comprise small percentage total execution time may acceptable however see two possible would make efficient one possibility would also instrument core file system code use thread sprocket execution one thread read value modify another original value undo log supply instead solution allow thread make progress sprocket execution impose performance penalty thread since annual technical conference association six also must instrument sprocket execute alternative solution modify data shadow memory space read modify value would change read value shadow memory rather normal process address space example chang four describe one implementation use support speculative execution five sprocket use order examine utility take three propose file research community implement next three describe implementation conflict resolution use choose extend blue distribute file system twenty familiar source code like many distribute file perform functionality user level focus consumer electronic good opportunity explore use support functionality personal content type sprocket first implement semantic query file system data functionality sprocket similar transducer semantic file system seven apple spotlight allow search index attribute contain within file example one might wish search music produce particular artist take specific date information store within file tag music file header however since organization file system must understand format search index file give type sprocket extend provide knowledge implement transducer sprocket extension persistent query facility persistent query notify data store within file system application run client interest receive specify semantic query file end set interest file existence new file creation query create new object within file system server evaluate query add log record match instance example server would initially add log record query every file accessible user create query add new record every time new file create example query use either statically evaluate current state file dynamically receive make file system exist implementation persistent query could specify semantic query file system file name owner file generic mean file server easily interpret file store generic routine server call evaluate query time potential match routine return true file match semantic query specify false otherwise however generic approach easily use tag music file format tag opaque file server support extend persistent query interface allow optionally specify sprocket call help evaluate query potential match server first perform generic evaluation describe instance query might verify end generic evaluation return true server invoke sprocket specify query query sprocket read file evaluate content return value specify whether file match query sprocket return true server append record persistent query object server take action sprocket return false read data server file relatively complex operation file data may reside one three place file disk name unique identifier file log server disk memory cache use improve read performance execute sprocket within address space server improve performance sprocket reuse server memory cache avoid read data disk cache log contain recent data disk execute sprocket server address space avoid need flush cache data truncate log sprocket process read data file would read stale data cache flush log truncate sprocket design considerably reduce complexity sprocket reuse exist server function read data diverse source cache log disk storage association annual technical conference seven also encapsulate complexity organization data disk file hash store hierarchical directory structure organize hash value improve performance due reuse code size relatively small example transducer write search tag return file specific artist require line c code resolution second type sprocket perform resolution similar propose al coda file system fourteen like coda use optimistic concurrency support disconnect operation therefore possible concurrent update may make file different occur user normally ask manually resolve conflict anyone use know manual conflict resolution tedious process al observe many type file internal structure use file system automatically resolve conflict example one client add artist tag file another client add rat song file system knowledge data type determine two update orthogonal automatic resolution two update would produce file contain new artist rat however like transducer example previous section perform automatic resolution lack require knowledge data type allow automatic conflict resolution extend conflict handle code client daemon allow optional invocation handler specific data type daemon try reintegrate update make client server server may detect conflict update make another client store version number identifier last client update file order detect conflict client daemon check see conflict handler register data type specifically check see name file match regular expression file end match find daemon invoke sprocket register data type original design sprocket entire resolution read fetch current version file store server compare version store client write result temporary file however approach unsatisfying two reason first violate rule never persistently change state design require sprocket communicate server externally visible event change persistent state server communication sequence number perturb next message stream encrypt second design promote reuse resolution sprocket must separately implement code fetch data server read data client write result temporary file base design perform resolution two separate first sprocket determine data fetch server return information list data range example resolver would return contain tag execute sprocket daemon fetch require data first sprocket may invoke iteratively allow traverse data structure within file thus work generic make persistent change file system state do outside sprocket second benefit approach limit subset file data need fetch server large file substantially improve performance daemon pass second sprocket range data examine output first sprocket well correspond data client server file resolve second sprocket perform resolution return patch contain data add delete replace server version file daemon validate patch represent internally consistent update file delete replace actually exist within file send change patch file server complete resolution design fit sprocket model well since format patch well understand validate file system apply yet logic generate patch arbitrarily complex reside within sprocket bug sprocket could potentially produce invalid header however since opaque core file system bug could lead subsequent crash client daemon server write resolver compare two tag return new tag merge concurrent update two input tag first sprocket invoke twice determine range tag file second sprocket perform resolution request daemon replace version tag server new copy contain merge update typically patch contain single entry replace data original tag however size tag grow patch may also request additional insert file location original tag two require combine line c code annual technical conference association eight process final type sprocket allow read write data store different type consumer electronic prior work already allow user treat digital distribute file system file treat file within distribute consumer electronic device attach computer run client daemon daemon propagate change make device distribute file system file distribute modify since device last attach client daemon propagate change file device local storage previous support consumer electronic assume export generic file system interface read write data true example many allow use picture transfer protocol digital media typically allow data access content delivery service new type interface must extend understand read write search data device use protocol require functionality akin device modern operate logic allow consumer electronic interact file system generic particular interface use read write search data device often specific device type therefore choose structure code functionality implement generic layer call need access data consumer electronic device provide service list file device read data file create new file device create two set one export file system interface one use set could add expand number consumer electronic support potentially could link interface directly file system daemon much way device dynamically load kernel however caution poor reliability device modern operate felt could substantial source bug want faulty interface capability crash file system corrupt data store therefore implement interface isolate rest file system file system interface create implement function open file read modify improve performance allow cache intermediary data temporary directory also allow make system call interact specific device example sprocket communicate camera interface additional allow expand particular sprocket type enable extend functionality however allow make change data store instead pass buffer file system daemon daemon validate content buffer modify file system implement entire sprocket interface use line c code potential beyond three type already implement see many potential distribute file one insert client server code collect statistics file system tune better performance use refine result directory list example file locate remote storage might list directory sufficient available stream remote source play without loss could also use support data one format could potentially implement cache instance highly rat record yet view store mobile general believe promise way deal heterogeneity emerge class consumer electronic well data format support another six evaluation evaluation answer follow question relative performance implement binary instrumentation direct procedure call effect binary instrumentation performance isolation provide implement binary instrumentation direct procedure call association annual technical conference nine thirty twenty ten n c e e thirty twenty ten zero procedure sprocket fork helper helper resolver n c e l l e six four two zero match zero match procedure sprocket fork figure compare time create persistent query list band use graph via procedure call sprocket leave show result file system contain file match persistent query graph right show result none match result mean five error bar show ninety confidence fork figure two methodology performance transducer figure three evaluation use single computer four processor one ram computer act client server computer run red hat enterprise three kernel version second client require add processor ram connect switch run red hat enterprise four kernel version client configure write log cache data disk use pin version compile version result measure use system call transducer first experiment measure performance transducer extension determine whether artist tag describe section figure two show performance extension two different leave graph file system first populate file tag designate artist first bar graph show time run sprocket time file file system generate persistent query extension execute function call inside address space expect function call implementation extremely fast since provide isolation second bar show performance run extension sprocket binary instrumentation provide isolation instrumentation slow execution extension figure compare performance resolve conflict use tag resolver use procedure call sprocket helper extension invoke twice determine data need resolve resolver extension perform actual resolution bar show time resolve conflict file result mean five error bar show ninety confidence resolution factor twenty ensure buggy sprocket adversely affect server last bar graph show performance execute extension use fork describe section fork provide many benefit performance six time worse small extension performance cost binary instrumentation much constant performance cost copy file server page table flush execute fork right graph figure two show performance transducer populate file none band thus result persistent query empty result second experiment similar first however extension execute code scenario check possible existence version two tag find version one tag exist first experiment second check never execute additional code proportionally greater affect sprocket implementation high cost conflict resolution next experiment measure performance set resolve conflict within tag client send operation server file system write conflict version server client invoke extension try automatically resolve conflict require user manually intervene populate annual technical conference association one none duplicate stack duplicate stack duplicate stack three transducer conflict resolver optimization total duplicate total stack total unique duplicate unique stack unique zero zero e n c e x e e z l r n ten five zero transducer conflict resolver figure show effect performance sprocket test transducer match run application specific conflict resolver result average five ninety confidence normalize performance figure four optimization performance file three size modify two different field within tag file two different ensure one client reconcile log server flush second client log create conflict file client invoke two resolve conflict first helper extension invoke twice determine tag locate file first invocation read header determine size rest tag second invocation read rest tag second resolver extension create patch resolve conflict process repeat file figure three show performance implementation sprocket implementation substantially faster implementation though difference performance greater first two helper execute resolver extension still faster sprocket implementation fork show substantially smaller advantage table show fraction memory prevent three first three row show fraction memory prevent optimization second three row show fraction memory prevent optimization result average five run single execution extension table two effect resolver extension run longer cause cumulative cost execute instrument code approach cost fork performance binary instrumentation might improve code optimization believe substantially greater complexity one probably execute use fork best performance give set experiment next measure effectiveness propose binary instrumentation eliminate save restore data address allocate sprocket duplicate undo log section stack use sprocket three intend improve performance insert inexpensive check write perform sprocket test whether overwrite data need save undo log since optimization add test execute write must provide substantial reduction log overcome cost test figure four show time take transducer conflict resolver turn understand result first measure fraction write optimization prevent create undo log entry show upper half table two avoid either stack write duplicate already log address prevent almost new log optimization less effective transducer use conflict resolver perform write memory allocate see large overlap write cover next investigate much contribute total reduction log lower half table two show fraction write uniquely cover optimization view association annual technical conference one procedure result fork result sprocket result buggy sprocket memory leak memory stomp file leak wrong close infinite loop call crash crash crash crash correct correct correct correct correct correct correct extension terminate extension terminate extension terminate exit execute extension terminate extension terminate extension terminate table show result buggy extension execute three different execution correct mean sprocket complete successfully without negative effect file system extension terminate mean problem detect extension halt without adversely affect file system data table one result execute buggy optimization look useful write cover usually cover since transducer sprocket use optimization simply impose additional cost sprocket stack optimization alone effective add duplicate optimization prevent additional write create undo log benefit less cost test every write conflict resolver sprocket effect somewhat different stack optimization effective add produce difference suggest simple test optimization test address log within certain range break even prevent around two write trigger log good go bad next implement eight buggy observe execution affect server result show table one first extension leak memory allocate ten buffer return without buffer extension run function call file server crash repeat invocation run memory fork use child address space reclaim time sprocket exit negative effect likewise sprocket implementation exhibit negative effect due rollback address space change second extension overwrite important data structure server address space pointer head log null expect extension crash server run function call effect run use fork run sprocket extension affect server memory stomp undo extension complete another common fault illegal access memory cause third extension create fault pointer invalid memory location extension execute function call server terminate extension run via fork child process die result error message return parent process sprocket infrastructure correctly catch signal return error core file system leak file handle also problematic create extension open file forget close run extension multiple time function call server eventually crash due resource leak fork sprocket resource leak prevent cleanup execute extension finish execute buggy extension might also close open therefore create extension close open even open exit execute extension procedure call disconnect current file server prevent close port server listen incoming extension run fork server file handle affect sprocket mistake extension run sprocket system call detect sprocket try close file open abort sprocket alternatively could choose ignore close call altogether felt trigger error return best way handle bug another common danger extension code terminate sixth row table one show result extension execute infinite loop run sprocket multiple time via function call cause server run thread timer expiration trigger termination sprocket similar approach use terminate child process use fork last sprocket attempt execute new program call execute function call server simply cease exist since address space annual technical conference association one replace another program system call detect sprocket attempt disallow system call pin tool immediately roll back sprocket execution return error file system fork implementation allow extension specify executable probably desirable behavior provide safety operate restrictive interface allow certain open close write sprocket interface necessarily appropriate instead target hundred line source code seven relate work best knowledge first system use binary instrumentation transactional model allow arbitrary code run safely inside distribute file system address space use binary instrumentation isolate fault build work do al sandbox extension inside program address space however instead limit access address space outside sandbox provide unfettered access address space record undo extension complete execution vino use fault isolation context operate system however vino access full repertoire kernel functionality prevent access certain data permit kernel function specify list function must check send extension protect kernel contrast call function access data use technique device five allow code implement many service traditionally provide operate system rather focus kernel target functionality already implement several advantage include ability access tool sprocket model also introduce minimal change system extend require little core file system code make appear much like procedure call possible another approach protection spin project use language guarantee safe behavior load operate system however approach may require extra effort extension developer express desire functionality limit reuse exist file system code much currently implement take even fifteen allow provable correctness limit however applicable style extension perform arbitrary calculation extend file system functionality three file eight twelve use evaluate file system state inspire predicate use joshi al eleven detect exploitation virtual machine introspection evaluate predicate provide similar functionality transaction never commit evaluation sprocket similar extract result system without perturb system address space however since code isolate run user level provide need isolation use exist operate system instead virtual machine monitor like project hardware nine transactional memory rely hide change memory thread ensure thread view consistent state one transactional memory implementation eighteen also use log record change memory state future may possible improve performance particularly multicore leverage eight conclusion design safe fast method extend functionality file implement user level result encourage many respect able implement every sprocket attempt hundred line code sprocket implementation use binary instrumentation catch several serious bug introduce allow file system recover gracefully program sprocket performance simple order magnitude faster implementation yet also find upper limit amount complexity place sprocket binary instrumentation become expensive fork several thousand line source code probably better support via future would like explore issue greater detail perhaps create adaptive mechanism could monitor sprocket performance choose best implementation execution would also like explore use restrict sprocket functionality since implement use pin tool may able specify novel restrict particular data pass system call rather system call association annual technical conference one thirteen k j j disconnect operation coda file system computer ten one fourteen k p flexible safe resolution file conflict proceed winter technical conference new la fifteen rice e chamber c soundness proof analyse via local rule proceed symposium program new york press sixteen r muth r h k g v j hazelwood k pin build program analysis tool dynamic instrumentation program language design implementation june seventeen file proceed technical conference boston june eighteen k e j j hill wood transactional memory nineteen nightingale e b p j speculative execution distribute file system proceed symposium operate unite kingdom twenty nightingale e b j storage flexibility blue file system proceed symposium operate design implementation san ca peek j integrate consumer electronics distribute storage proceed symposium operate design implementation wa small c smith k deal disaster survive misbehave kernel proceed symposium operate design implementation n transactional memory symposium distribute compute swift b n levy h improve reliability commodity operate proceed symposium operate land r e graham l efficient fault isolation proceed symposium operate yang j p use model check find serious file system proceed symposium operate design implementation san ca allow general believe promise avenue meet extensibility need current distribute file may suit need integrate development game thank improve quality paper work support national science foundation award support career award nightingale support research student fellowship corp corp provide additional support view contain document author interpret represent official either express imply university michigan government reference one e b n e levy h effective kernel support management parallelism proceed symposium operate two b savage p e becker chamber c extensibility safety performance spin operate system proceed symposium operate copper mountain three b b c b extend ing file system computer one two spring four chang f g automatic io hint generation speculative execution proceed symposium operate design implementation new la five k j j operate system architecture resource management proceed symposium operate copper mountain seven k p j w semantic file proceed symposium operate eight j g j development layer computer twelve one nine moss j e b transactional memory architectural support data structure proceed annual international symposium computer architecture may ten j h k l g r n west j scale performance distribute file system computer six one eleven joshi k ing g w p detect past present predicate proceed symposium operate unite kingdom twelve k nelson n extensible file spring proceed symposium operate six fuse spotlight overview tech rep apple corp net ca annual technical conference association