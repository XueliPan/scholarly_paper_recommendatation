transactional memory operate system hardware transactional memory reduce synchronization complexity retain high performance model change architecture support transactional memory user process operate system operate system use transactional memory facilitate synchronization large complicate code base burden current approach evident scale number core processor chip become de industry priority reduce focus improve performance develop exploit multiple core remain challenge code include deadlock convoy priority inversion lack general complexity difficulty reason parallel computation transactional memory emerge alternative paradigm program potential reduce program complexity level comparable lock without sacrifice hardware memory aim retain performance lock lower program complexity article summarize experience add feature simulation trap let us modify kernel use transactional memory synchronization need many transactional memory design go great minimize one cost expense another example fast commit slow abort absence large transactional operate system make difficult evaluate several important reason let operate system kernel use many web spend much execution time kernel scale performance require scale operate system performance moreover use kernel let us exist program immediately benefit transactional memory common file system network exercise synchronization kernel control finally kernel large concurrent application use diverse synchronization operate system representative large commercial currently use evaluate hardware transactional memory design architectural model evaluate different hardware design affect system performance build publish computer society g e e porter bhandari primitive contention policy policy table one transactional feature model definition instruction begin transaction instruction commit transaction instruction restart transaction choose transaction survive conflict delay transaction restart instruction save transaction state suspend current transaction instruction restore transaction state continue transaction hardware model call although closely follow particular hardware design strongly resemble flat also include novel support transactional operate system create assume commit abort example specify abort handler cost let us us explore performance impact run manage account cache area use multiple data transactional semantics manage multiple table one show transactional feature start commit become standard feature use model organize taxonomy accord data whether eager lazy along either use eager version management new value store place eager conflict detection first detection conflict address restart rather wait commit time detect handle conflict support multiple resolve conflict transactional access one way resolve transactional conflict restart one support different choose transaction restart support strong isolation standard order respect memory reference provide strong isolation always restart transaction transaction conflict memory reference cost transaction commit abort also model feature support multiple active single thread recent model include support multiple concurrent single hardware thread support current escape nest code access update perform enclose uncommitted transaction provide completely independent thread manage stack independent easier reason nest hardware support need also simpler need nest small number per cache line hold identifier independent several potential use use handle interrupt discuss later hardware state save primitive suspend current transaction continue later without restart execute independent suspend transaction new might nest relationship support multiple call hardware still account perform transaction active top pick properly manage describe next suspend lose conflict like run suspend transaction lose conflict restart resume analogous overflow also lose conflict primitive restore previously transaction let suspend transaction resume restart must combine suspend multiple concurrent lifo order restriction order restriction strictly necessary simplify processor implementation functionally sufficient support interrupt although implement individual particular could implement group suspend resume transaction fast implement push current transaction identifier stack contention management support conflict occur two one transaction must pause restart potentially already invest considerable work since start contention management aim improve performance reduce waste work model adapt framework block model execute restart stall wait queue require adaptation also introduce new policy call favor transaction number unique read write transaction work set implementation could count cache line instead transaction use must revert time stamp threshold number restart otherwise lead certain feature interrupt trap architecture stack discipline create challenge interrupt handle pose trap architecture similar pose modern exist adequately address much exist work make several interaction interrupt work assume short interrupt rarely occur transaction result claim efficiently deal interrupt unnecessary assume interrupt abort restart state use similar survive context switch include support escape action could use pause current deal interrupt context however neither let thread pause transaction create new transaction important design goal enable interrupt show later eleven sixty percent come interrupt motivate factor several factor influence design interrupt handle system first factor transaction length one main advantage transactional memory program reduce program complexity due overall reduction possible system state lock provide benefit performance cost short critical section result high complexity future code attempt capitalize transactional memory program produce today second factor frequency interrupt data show much higher interrupt rat example al extend transactional memory assume io interrupt arrive every cycle modify mean simulate micro development interrupt occur every cycle average transaction length run cycle average transaction size grow cycle modest cache miss percent interrupt interrupt third factor involve flexibility lack thereof rout interrupt handler must manage many type interrupt specific processor common interrupt include local advance interrupt controller page fault interrupt propose rout interrupt best able deal even interrupt rout possible unclear best determine whereas continually execute might might execute transaction model hardware mechanism indicate currently execute transaction would require global communication could add significant latency process interrupt handle consistent interrupt frequent grow length interrupt rout less flexible assume handle interrupt without necessarily abort current transaction interrupt use suspend current transaction interrupt arrive let us current transaction interrupt start execute instruction suspend interrupt handler start new independent necessary interrupt return path end instruction nest relationship exist suspend transaction interrupt handler multiple nest interrupt result multiple suspend although choose explicit suspend resume processor perform function trap execute interrupt return contention management base time stamp common default simple implement hardware guarantee forward progress however presence interrupt multiple active processor contention management problem apply policy suspend transaction continue win current transaction consequently support suspend require modify basic hardware transaction conflict processor favor stack memory previous work assume stack memory share thread exclude stack memory however work set stack memory share thread kernel many operate system example function ide disk driver add request structure request queue wait notification request complete structure fill thread run io completion interrupt arrive thread thread initialize request likely differ architecture thread share kernel stack interrupt ensure isolation share kernel stack address stack address must part transaction work set interrupt overwrite stack address corrupt include transaction work set value many expose language rely atomic declaration declaration require begin end activation frame support independent complicate model call occur different stack frame top pick heavily rely work grab lock later release different function minimize work require add require call activation frame stack share occur create two live stack overwrite transactional dead stack live stack overwrite problem correctness issue interrupt overwrite live stack data transactional dead stack problem performance issue interrupt spurious transaction restart discuss straightforward architectural modify use modify kernel version support replace lock acquire become transaction start lock release become transaction end however example many kernel protect critical perform io device io incompatible generally roll back state determine critical safe convert consume great deal programmer test effort guide profile data select lock kernel addition also convert instance sequence lock atomic data structure use evaluation run machine simulator version experiment model symmetric machine use architecture simplicity assume one instruction per cycle memory hierarchy two level cache per processor split instruction data cache unify cache cache contain transactional non transactional data cache sixteen cache line cache hit cache miss penalty cache four associative cache line miss penalty main memory snoop protocol maintain cache coherence main memory single share study fix granularity level somewhat idealize optimize memory layout avoid false share disk device model data transfer fix access latency run script require user interaction finally model time network interface card support use link fix latency evaluate follow application n counter perform share count one thread per n execute make eight parallel compile source tree n send data stream n sixteen instance compile phase configure configure script eight instance find search directory file eight instance n model web cache file n n system activity n perform stress test counter differ rest create define rest user program run top thus create exercise micro table two system time select application system time second time counter find performance convert kernel table two show execution time across unmodified execution time report system time use user code identical experiment indicate overall execution time table two also list total time user system idle time touch roughly amount data locality data cache miss rat change appreciably two comparable except counter see notable performance gain eliminate lock variable save half bus traffic iteration loop table three show basic number create creation rate notably higher report elsewhere instance one recent study use report every data show restart rate low consonant publish relatively low restart rat expect conversion direct significant effort reduce amount data protect individual lock acquire counter find show highest amount contention several dozen function create approximately eighty percent find start two function code page however low contention cause restart two function percent restart create five percent stack memory table three also show number live stack overwrite although absolute number low relative number instance represent case without architectural mechanism interrupt handler would corrupt kernel thread stack way could compromise correctness table also show number interrupt number low many convert also disable interrupt however longer likely lose work restart interrupt interrupt early release prevent transaction conflict fourteen find four number small use interrupt short without many intervene function call get longer early release become important work require release stack cache line release million stack release million although run cycle top pick table three transaction statistics total create per second restart eight total percentage restart transaction rate transaction transaction restart unique counter configure find restart seventeen commit abort different create different restart commit example function run transaction commit result abort reveal subtle interplay contention management abort abort behave similarly explicit thereby reduce contention abort penalty increase performance necessarily decrease see find commit obvious negative impact performance although moderate amount work commit time cycle perceivably change system performance counter slow twenty percent commit penalty cycle significantly slow cycle effect become pronounce contention management figure one show restart rat nonunique restart different policy minimize restart across exclude counter best average performance polka drop time stamp light polka policy complexity moreover attractive alternative hardware implementation whereas polka incorporate conflict history work investment dynamic transaction priority require work set size conflict result also indicate policy good hardware complexity performance different contention generally small effect system execution time spend much time execute critical recent work discuss two issue detail integrate operate system lock policy favor process higher schedule priority nearly eliminate inherent lock priority inversion mix lock require transactional new let lock protect data maintain advantage synchronization let system attempt execution critical automatically roll back use lock region perform io figure two show spend less time synchronize spin abort spin allow concurrent execution critical spend percent less time synchronize use spend forty percent less time synchronize micro table three continue unique restart percentage percentage percentage interrupt system call live stack overwrite interrupt one sixty sixteen sixty eleven one forty four four allow kernel use result exclude suffer contention management pathology fix part future work come generation multicore require innovation concurrent program hardware transactional memory powerful new synchronization primitive help move domain ideal operate due position computer hardware play key role manage concurrency operate complex synchronization need also make use transactional memory show asynchronous interrupt require special consideration design transactional memory hardware expect operate continue evolve response greater hardware figure one relative transaction restart rate use different normalize result respect policy top pick figure two percent kernel time spend synchronize sixteen use concurrency start synchronization move core system service operate six press micro six c l extend reference one moss transactional memory architectural support data structure ann l computer architecture press two al transactional memory high performance computer architecture six press three al architectural practical transactional memory ann l computer six press four h al kernel challenge transactional memory workshop transactional memo support wait actional action workshop transactional compute seven j al transactional memory l architectural support program operate six press eight advance contention management dynamic soft ware transactional memory distribute compute five press nine r j goodman transactional execution pro l architectural support program operate two press ten l al program five al support nest transactional coherence transactional memory l architectural support pro l architectural support program operate fifty micro four press eleven sun fortress language specification twelve h al transactional memory operate system ann l computer architecture seven press thirteen w al unbounded transactional memory l program architectural support operate six press fourteen c al use manage hardware transactional memory operate system operate system seven press e student university research interest include parallelism large enable greater concurrency transaction model computer science university architectural support j student university research focus transactional memory architecture parallel program computer engineer university support porter ba computer science mathematics college science student university computer research interest include hardware operate system support parallel program ba computer science college bhandari graduate student computer science university research interest include transactional memory operate bhandari computer engineer university assistant professor computer science university research interest include computer architecture relationship operate system compiler electrical engineer computer science institute technology direct question comment department computer university one university station e porter student computer science university research interest include concurrent operate system information compute topic please visit digital library