shadow profile hide instrumentation cost parallelism janapa dirk peri department computer science university colorado boulder corporation abstract profile exist information overhead example incur negligible overhead information collect consequently coarse use instrumentation tool gather temporal trace path profile hot memory stream high overhead compilation need detail information aggressively optimize cost gather profile outweigh benefit shadow profile novel method sample long trace instrument code parallel normal execution take advantage trend increase number core instrument sample many millions length primary goal incur negligible overhead yet attain profile information nearly accurate perfect profile profiler require operate system hardware tunable allow greater coverage lower overhead evaluate performance accuracy new profile technique two common type profile path profile value profile overall profile collect use shadow profile framework accurate versus perfect value profile incur less one overhead consequently technique increase viability dynamic continuous optimization hide high overhead instrumentation enable collection many type profile previously costly one introduction optimization use dynamic information obtain program execution decide upon strategy optimization fall roughly two dynamic static though always clear dichotomy dynamic optimization gather profile information program execute apply run program technique become common manage eight apply native program well six traditionally static collect profile direct recompilation entire program source spike thirteen employ static binary modification apply optimization system effective must aware effectively perform optimization decide optimize sample program counter high rate enough information detect hot code even deduce stall pipeline one hardware performance monitor use gather information cache miss branch information valuable decide focus optimization also useful apply aggressive costly code however decide optimize considerably harder problem many profile use decide optimize incur undesirable overhead require instrumentation record temporal trace profile benefit must outweigh cost therefore much effort must spend ensure profile low overhead one common improve code layout formation use path profile four path profile popular deliver good performance improvement instrumentation overhead low highly optimize instrumentation type profile hot data stream profile twelve value profile nine use apply one achieve gain twenty also result substantial time original program high prohibitive profile instrumentation recently become popular instrumentation particularly desirable dynamic optimization profile cost must amortize time perform two eighteen describe reduce cost instrument code via sample technique know trace periodically alternate normal instrument code shadow profile novel technique perform instrumentation sample detail trace differ previous instrument code execute parallel program execution instead instrument application directly shadow process periodically create instrument parent continue normal execution leverage mechanism available modern operate child process replica parent although fork replicate virtual address space protect potential system side effect involve file share memory issue safety address section three shadow profile offer follow feature low overhead type instrumentation inject shadow process affect speed original application source slowdown page bus disk contention low practice many trace collect parallel number core die increase idle increasingly available profile tune sample length shadow average number active shadow enable flexible method adjust greater coverage lower overhead simplicity infrastructure leverage many present exist instrumentation use slight rest paper organize follow section two provide background information section three describe design implementation shadow profile section four explore tune evaluate performance section five discuss relate work section six outline future work section seven conclude two background program instrumentation common way observe detail dynamic execution behavior instrumentation apply number ways number point program life cycle discussion two particularly relevant probe dynamic instrumentation probe also know code patch technique work overwrite original jump bridge handle save restore register call analysis execution replace nineteen seven collect occur rarely probe alternative binary translation therefore probe commonly use function entry point function call sit system call instruction set amenable probe variable length therefore great care must take ensure instrumentation corrupt original alternately instrumentation recompile entire application interleave instrumentation original program tool atom employ static object file rewrite accomplish goal pin dynamo six actually much common virtual machine shadow profile infrastructure implement use pin system pin dynamic compiler capable insert arbitrary instrumentation unmodified binary program r r arm instruction set pin rely static compiler support also advance feature mode ability begin point execution ability attach program already run since pin dynamic compiler must store trace code cache compile instrumentation code aggressively optimize register reallocation analysis result instrument code fast one drawback approach program take noticeably longer execute time spend compile trace execute time program compilation cost amortize code cache fill hot code reuse somewhat mitigate overhead pin persistence infrastructure develop janapa persistence use cache store compile trace future run program new process begin load old code cache disk trace previously execute process exit update persistent copy disk multiple process active may race con two persistent cache protect file lock method show dramatically improve time run pin figure one shadow profile system three shadow profile infrastructure system show figure one application monitor inject original application begin probe allow monitor observe certain system call yet still permit application execute natively without incur overhead periodically monitor fork shadow process instrument profile fork occur pin switch probe mode mode point every instruction execute code cache figure two show chronological view profile run might proceed example instrument code three time native time one first shadow fork migrate two operate system shadow duplicate behavior occur original application proceed ahead three time begin time four application monitor recognize shadow zero complete another shadow create example shadow zero one show schedule different could also schedule sequentially operate system discretion program may require greater coverage may require less therefore many shadow process may execute parallel instead create less frequently rest section describe technical detail involve create shadow process make transparent original application three ideally fork two process would exact could continue execution without interference problem duplicate address space conveniently handle page system common modern operate however number issue must consider share memory file system call thread handle issue describe context application monitor application monitor first take control application invocation attach exist process since shadow allow execute certain system call effect need log may emulate original program run natively time image load probe must place particular system call log effect use probe monitor activate system call occur however desirable able create shadow arbitrary point time system call monitor gain control register signal handler invoke timer interrupt default signal use since use signal unconventional ways signal number use profile via parameter likewise regular timer interrupt must configure one option use alarm system call could interfere many normal behavior instead separate process call signaler create signal monitor sleep period signaler remain active original application complete note monitor unmeasurably small effect program performance manage overhead monitor receive signal action decide shadow create control amount processor time give shadow process user may specify load parameter give float point number example load value ten mean always single shadow actively profile user may also specify value like five mean half time shadow exist twenty mean two shadow exist concurrently time monitor receive signal update run average number active shadow average fall desire load new shadow fork fork parent return control run program fork figure two chronological example shadow profile execution shadow profiler low list dynamic execution frequency different group system call fork child process must switch probe mode pin do pin direct pin begin instrument arbitrary processor context since do inside signal handler architectural context include conveniently available pin begin instrument program profile begin shadow execute number usually many millions exit execution instrumentation proceed normal shadow must restrict action side effect original process rest system one way shadow affect original process share memory page attain via system call file write access thus fork write access page revoke child process since shadow fault attempt write share page either choose skip fault instruction terminate create new shadow practice issue arise since none spec use share page tend common still write infrequently much common way shadow process system call occur approximately time per second experimental configuration fortunately majority system call benign emulate simply ignore experiment around five dynamic system call handle safely terminate shadow process benign time system call may allow execute since side effect system output write rename unlink system call allow execute change state system emulate success assume execution continue input five read depend type access since kernel file pointer duplicate across fork open file must close reopen seek previous position pip complicate original process must transmit data read pip shadow process call emulate miscellaneous two open creat special case depend usually may allow execute unsafe five behavior also case often use dynamically load case shadow terminate signal process monitor key concept keep mind goal attain many small sample execution shadow execute hundred million four shadow fork original therefore many shadow encounter single system call encounter one two since unsafe system call rare shadow process terminate desire number profile event unsafe unknown condition encounter monitor simply create new shadow replace since pin code cache local process execute shadow process begin compile scratch compile trace lose process exit result profile number length shadow shadow high overhead result total profile segment lower total number profile conversely shadow take advantage hot code code cache allow execute unique segment somewhat alleviate overhead enable pin code cache persistence feature multithreaded program thread particularly complicate issue development system kernel native thread library one thread multithreaded program call fork thread survive new process behavior common thread familiar follow fork address space duplicate usual architecture context correspond kernel thread lose bite unintuitive reasonable since multithreaded fork would require synchronization thread synchronization could slow typical usage model call shortly fork surprise fork naturally behave unfortunately different behavior necessary shadow profile work multithreaded program would relatively simple implement multithreaded fork operate system approach would cumbersome nonportable instead currently work solution emulate desire behavior synchronize thread signal handler reproduce context child process method work follow one barrier thread program store state state two fork process recreate clone thread destroy remember address space identical lose three new thread revive previously store four continue execution virtualize thread call four performance evaluation shadow profile like sample technique balance information overhead balance control two profile tool first sample size control number consecutive shadow execute exit small sample size allow unique sample take initial overhead create shadow process total number profile lower sample less overhead since granularity may miss important program phase another parameter affect profile overhead load define average number active shadow process specific configuration define sample size load experiment evaluate sample size load value five ten twenty result total eighteen different test experimental configuration experiment run system r cache system memory run kernel version framework evaluate use spec integer suite float point omit generally exhibit highly repetitive behavior interest perspective profile experiment present average three repeat even still exist degree variability performance accuracy due random point shadow create pin ability persistently store code cache across multiple run important reduce overhead require profile however number apply feature compilation could entirely obviate create persistent cache prior run experiment would unfairly ignore one design challenge experiment new persistent cache create time program invoke cache start empty time shadow process terminate write code cache back disk use policy first shadow execute slowly must populate code cache later shadow execute faster able benefit previous trace already instrument five figure three path profile accuracy relative perfect profile higher number indicate closer match denote configuration load sample size figure four value profile difference invariance lower number indicate closer match denote configuration load sample size path profile scheme paper accuracy define path profile first describe ball four use direct compiler dynamic improve code layout create instrumentation insert compiler highly optimize entire control flow graph know type instrumentation typically result dynamic instrumentation system indirect branch target know every basic block must instrument overhead bite higher furthermore ball examine acyclic study examine span multiple function collect incur overhead optimize profiler evaluate naive implementation exemplify one key benefit shadow profile simplicity accuracy partial path profile attain compare sample profile perfect profile use method similar wall weight match accuracy pest p fact p fact p one equation f p flow path define path count divide count add together represent weight path p account set perfect path profile set use top five study hest define select partial profile equal number value profile demonstrate robustness shadow profile framework choose profile considerably higher overhead value profile use locate predictable invariant value identify compiler analysis nine value profile six figure five slowdown versus native execution value profile denote configuration load sample size figure six increase page fault rate value profile denote configuration load sample size figure seven dynamic instruction coverage value profile denote configuration load sample size use create specialize code observe common case execution observe achieve program however collect full value profile expensive implementation overhead general value profile collect instrument instruction destination register include load arithmetic comparison profiler keep table instruction entry table contain value number time observe time relevant instruction occur table update seven allow new value make way table lower half table periodically flush profile dependent abundance profile data collect sample profile compare perfect profile calculate difference invariance top value metric describe weight difference invariance two profile topmost value table exist profile invariance instruction calculate number time topmost value observe divide number time instruction execute instruction difference include average weight execution frequency perfect profile profile accuracy profile accuracy path profile show figure three test average accuracy range achieve ninety coverage every experiment main trend observe increase load sample size positive impact accuracy sample size well configuration result accuracy one overhead one exhibit trend well achieve accuracy quickly increase longer sample size effect cause fact large code footprint therefore pin spend time compile trace longer sample higher load increase code cache efficiency another interest millions unique fact perfect profiler complete without prune large number cold run memory exhibit trend similar though slightly less amplify overall path profile accuracy show shadow profile achieve good representative coverage program dynamic instruction mix demonstrate effectiveness evaluate value profile require much rigorous instrumentation previously could consider dynamic optimization system figure four show difference invariance versus perfect profile lower difference invariance indicate greater similarity perfect profile nearly perform well slightly less variation path profile average accuracy remain within perfect profile data show sample relatively small portion execution representative profile collect interestingly average accuracy greatly affect vary profile although individual difficult performance overhead shadow profile show achieve good representative coverage versus perfect profile examine overhead incur framework figure five show slowdown experience original program value profile define profile execution time divide native execution time overhead path profile present highlight trend slightly higher two trend expect occur observe figure first increase number active shadow process profile load result increase overhead second lengthen sample size result decrease overhead application fork less often hence low profile load combine long sample result overhead although shadow profile tune incur low average overhead test cause original program slow twenty experimental system two man source overhead page bus contention disk contention factor since easily fit memory figure six show increase page fault rate page fault per second observe original program shadow profile enable unlike overall performance result graph regular predictable yet correspond well performance overhead example among page rate increase also overhead note increase page fault due memory copy fault disk find achieve high accuracy overhead measure around one show framework tune profile overhead negligible yet accuracy still within perfect profile therefore shadow profile viable tool gather information dynamic optimization coverage another measurement important instrumentation sample dynamic instruction coverage figure seven show percentage dynamic capture value profile instrumentation configuration capture two total execution yet still enough achieve ninety accuracy path value profile interestingly receive four time better coverage average small code eight footprint frequent miss data cache allow instrumentation cost hide long head instrumentation time spend instrument code increase total execution time five relate work replica process traditionally use provide redundancy fault tolerant propose implement replica process use scheme similar shadow profile thirty maintain determinism among replica process interrupt multithreaded execution challenge still open research problem five forty shadow profile issue determinism simply require deterministic execution shadow process exist collect meaningful profile information require program correctness also unsafe undefined execution occur shadow process safely exit recreate best knowledge first use replica process profile tool pin atom six use instrument application collect full execution profile however overhead instrument entire execution prohibitive infeasible collect detail profile program instrumentation approach significantly lower overhead profile example periodically sample call stack approximate call context tree three use similar sample partial call context tree two instrumentation framework ephemeral profile reduce instrumentation overhead sample burst execution framework implement create two procedure execution alternate one version contain original code check procedure entry point loop back edge another instrument version code counter zero check version control transfer instrument version acyclic trace collect counter reset execution transfer back check version coin term trace technique extend allow longer trace also instead apply use binary rewrite tool eighteen sample execution time optimistically estimate two may assume negligible suppose ten one program execute instrument mode ten higher without instrumentation course nine shadow profile partially inspire however instead execute instrumentation code along original application code shadow profile shift instrumentation shadow process able run different hardware context original application proceed natively without slowdown due instrumentation benefit allow shadow profile scale allow better coverage higher overhead instrumentation profile often study collection detail profile path profile four sixteen value profile nine memory stream profile eleven whole program shadow profile orthogonal use improve overhead specialize profile hardware rapid profile via stratify sample hot spot detection hardware path profiler conte profile buffer fourteen also propose profile low overhead seventeen propose specifically profile fifteen introduce hardware profile path specific pipeline recent design performance monitor twenty contain set performance count register trigger interrupt sample one sample program counter detect stall sample show effective collect path profile ten cache miss profile value profile hardware profile promise instrumentation flexible portable hardware limit feature design furthermore functionality often make portability profile tool difficult importantly hardware often reluctant include hardware design profile hardware impact processor design cycle increase pressure top design hardware validation processor performance thus hardware profile give attention often citizen processor design trend move toward massive multithreaded multicore shadow profile aim leverage abundance extra hardware already available form extra hardware thread core shadow profile simply create shadow process instrumentation sample allow operate system schedule process leverage available hardware use similar approach instead aim replicate full execution create slice execution system call six future work since architectural trend force program shift towards multithreaded program imperative profile research adjust accordingly address issue currently develop implementation transparently recreate thread since live fork system call due job instruction schedule shadow deterministic replica fork still suitable purpose profile currently discretion give shadow create much information enough several explore domain first consideration give load rest system high system load profile load scale back better choose phase profile compiler could provide insight code would benefit profile spawn shadow process accordingly alternately performance counter monitor system could detect phase change profile phase transition occur continuous optimization system profile collect data likely converge profile stabilize sample rate reduce detect program behavior deviate exist profile statistical model similar use smart architectural simulation could likely apply profile purpose direct sample also propose method convergent profile value profile nine seven conclusion paper present shadow profile novel technique perform expensive analysis parallel run program method demonstrate best instrumentation approach show achieve high accuracy path profile value profile incur negligible overhead run program value profile shadow profile achieve average accuracy compare perfect profile path profile achieve similar result average difference invariance versus full profile case ideal coverage achieve around one overhead tool require special operate system hardware support greatly increase viability dynamic continuous optimization since profile do parallel number processor core likely increase considerably come instrumentation slowdown longer major concern focus less minimize overhead profile apply author would like thank rest pin team exceptional support provide answer many question reference one j l j dean r st r l sit c w e continuous profile cycle go sixteenth symposium operate page new york press two b g ryder framework reduce cost instrument code conference program language design implementation page three p approximate call con text tree via sample four ball j r efficient path profile international symposium page five c z r deterministic schedule algorithm multithreaded proceed international dependable network six garnett infrastructure adaptive dynamic optimization international symposium code generation optimization march seven b buck j k code patch international journal high performance compute fourteen four winter eight burke j fink grove hind v sarkar serrano v h j dynamic optimize compiler proceed conference page san ca unite state june nine b p feller value profile optimization ten h j yew dynamic trace selection use performance monitor three proceed sample national symposium code generation optimization page computer society eleven efficient quantify exploit data reference locality one proceed conference program language design implementation page new york press ten twelve dynamic hot data stream two program proceed conference program language design implementation page new york press thirteen r w p g optimize alpha spike digital tech j nine four fourteen conte b patel j cox use branch hardware support optimization proceed annual international symposium page san ca thirty press fifteen j dean j e c w e g z hardware support profile international symposium page sixteen e v profile hot path prediction less proceed international conference architectural program operate seventeen h j e smith relational profile enable parallelism virtual machine international symposium page eighteen trace framework temporal profile workshop dynamic optimization nineteen g hunt detour binary interception function symposium twenty user manual corporation two processor reference manual development optimization may j r whole program conference program language design implementation page j h yew design implementation lightweight dynamic optimization system journal parallelism six page r r muth h g v j k hazelwood pin build program analysis tool dynamic five proceed instrumentation conference program language design implementation page new york press c r trick c n j c w w profile scheme identify program hot spot support optimization proceed international symposium computer architecture may n j program supervision framework note two v j r smith persistent code cache exploit code reuse across eleven seven proceed national symposium code generation optimization san ca r j e smith rapid profile via stratify sample proceed annual international symposium computer architecture page fay v j path profile information generate performance monitor hardware interact five proceed annual workshop interaction computer interact five page computer society thirty v j transient fault tolerance via dynamic process redundancy proceed workshop binary instrumentation b sprunt four feature micro four page b sprunt performance monitor hardware always low priority second class feature processor design workshop hardware performance monitor atom system build program analysis tool proceed conference program language design implementation new york press smith ephemeral mentation lightweight program profile k j n hardware path profiler five proceed international symposium code generation optimization page computer society w wall predict program behavior use real estimate profile proceed conference program language design implementation page new york press k hazelwood parallelize dynamic instrumentation performance seven proceed international symposium code generation optimization san ca j portable profiler machine page r b j hoe smart accelerate simulation via rigorous statistical sample annual international symposium computer architecture june forty w l p deterministic schedule multithreaded proceed workshop dependable c b g profile proceed international symposium computer