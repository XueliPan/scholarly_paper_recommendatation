optimism optimistic concurrency warrant e porter department computer university abstract optimistic synchronization allow concurrent execution critical section perform dynamic conflict detection recovery optimistic synchronization increase performance critical data critical section access disjoint data time optimistic synchronization transactional memory improve performance complex like operate system kernel kernel critical reasonably high rat data independence paper introduce novel method tool call explore potential benefit optimistic synchronization measure data independence potentially concurrent critical section experimental data indicate kernel enough data independent critical section benefit optimistic concurrency smaller achieve require data structure reorganization increase data independence one introduction shift scale clock frequency place multiple simple processor core one chip renew interest concurrent program benefit limit unless effectively leverage parallel hardware provide new concurrent program share memory system require lock synchronize thread execution lock many know include deadlock convoy priority inversion make concurrent program share memory model difficult addition lock conservative synchronization always assure mutual exclusion regardless whether thread actually need execute critical section sequentially correctness consider modify binary search tree tree large evenly distribute safely occur par lock protect entire tree needlessly serialize one solution problem conservative lock synchronize data access finer granularity rather lock entire binary search tree lock individual nod modify present two first data structure enforce lower bind lock granularity data structure bind may high fully realize available data parallelism second break lock many lock significantly increase code complexity lock scheme become complicate correctness jeopardize alternative conservative lock optimistic concurrency optimistic system concurrent access share data allow proceed dynamically detect recover conflict access specialize form optimistic concurrency data structure include many like data structure four five data structure optimistic general purpose solution data structure require data structure implementation meet certain correctness condition also general method atomically move data among different data structure transactional memory six provide hardware support designate arbitrary code appear execute atomicity isolation consistency provide generic mechanism optimistic concurrency allow critical section execute concurrently automatically rollback effect data conflict able reduce code complexity retain concurrency lock benefit optimistic concurrency however critical section must substantial amount data write one critical section must disjoint data read write critical section concurrently execute thread critical section concurrently modify data data con critical section one begin critical section node end critical section critical section two begin critical section node end critical section w r w r critical section three begin critical section node root end critical section r w table one three critical section could execute tree figure one address set read mark asterisk conflict write critical section three optimistic concurrency control serialize access critical section case optimistic control perform much worse conservative lock due overhead require detect resolve conflict paper present novel section two tool section three investigate limit optimistic concurrency measure data independence critical would protect lock apply methodology tool kernel present result section four two limit optimistic concurrency general way determine data independence compare address set critical section address set critical section set memory read write code critical section access disjoint memory effect execute concurrently execute serially addition address set need entirely disjoint write set critical section must disjoint address set potentially concurrent critical section word harmless multiple critical section read data long data concurrently write another criterion know conflict widely use due relative ease detect conflict conflict pessimistic model however two critical section conflict yet safely execute parallel example two critical section conflict final write still safely execute concurrently one finish issue conflict write data structure make guarantee allow critical section write concurrently safely relatively rare beyond scope select term data conflict data dependence avoid confusion mean figure one simple binary tree paper guarantee correspond view compute view hence rarely use practice nine paper use conflict exclusively example conflict consider simple binary tree figure one three different critical section operate tree along address set list table one critical section one two read many memory write address set therefore data independent could safely execute concurrently make sense intuitively modify different branch tree critical section three however modify right pointer root tree execute concurrently critical section operate right branch tree reflect address set critical section three write set read set critical section one two simple example determine data dependence critical section simple static analysis case however static analysis insufficient function modify data structure generally determine modify base input parameter thus data independence critical section largely depend program input require investigation common case synchronization behavior order determine whether employ optimistic concurrency case structure critical section code limit concurrency critical section data independent conflict small portion address set lock data structure reorganization may remove conflict instance slob allocator kernel use share pointer available heap space read begin write end every allocation thus two needle conflict pointer never data independent also case high degree data independence argument consolidation overlap critical section optimistic concurrency program lock multiple lock acquire release nest overlap critical section minimize time lock hold increase performance optimistic model outermost critical section generally data independent avoid nest critical section yield reduction code complexity potential increase performance three measure data independence critical section present tool call synchronization characterization run module version seven simulator track synchronization behavior kernel include lock acquire release contention lock acquire track address set memory read write critical section thread acquire lock kernel compare thread address set complete critical section address set critical section wait determine conflict two thread wait lock touch completely disjoint data could optimistically execute critical section concurrently rather needlessly wait lock compare address set thread happen lock one execution provide limit window latent concurrency lock base application determine general limit optimistic concurrency lock release compare address set address set previous critical section protect lock record compare address set multiple critical section less sensitive particular thread interleave measure execution ideal analysis would identify compare possible concurrent rather last however would require track thread fork join structure concurrent execution addition number possibly concurrent could make compare address set infeasible substantial length compare window critical section capture many likely concurrent minimize false conflict result serialization support window critical section base sensitivity study window size change window size fifty affect data independence result lock less five commercial effort date eighty core machine one also represent reasonable upper bind size likely develop near future compare critical across different thread determine whether two critical section thread parallelize complex problem determine whether critical section different thread execute concurrently possible would require substantial code rewrite sort speculation fourteen however paper focus benefit replace exist critical section filter type memory access address set critical section avoid false conflict first filter address lock necessity modify every critical section filter lock address current lock address multiple lock hold simultaneously optimistic synchronization eliminate read write lock also filter stack address avoid conflict due reuse stack address different activation frame kernel object like directory cache recycle cache lifetime lock contain object bound lifetime object directory cache entry emerge free pool lock initialize consider new active lock lock consider inactive object release back free pool lock make active address set history lock ide lock lock lock lock file lock total acquire eighty seventeen twenty fourteen twenty data conflict mean set mean fifty eight four seventy zero eight zero zero fifteen table two fifteen spin lock total acquire number time lock acquire process different instance lock distinguish virtual address number acquire require process spin obtain lock include percent total acquire data conflict column list percentage acquire data conflict mean set average address set size conflict critical section whereas mean average number conflict clear even though reside address previous incarnation schedule new process kernel acquire lock protect one lock hold across context switch release different process lock actually hold two process one critical section avoid compare address set prior address set either process finally protect concurrent attempt execute io actually conflict memory address currently detect io result lock serialize io may falsely appear data independent four experimental result run experiment simulate machine fifteen one four one ram use fifteen maximum support simulate simplicity one fix disk access latency processor instruction cache data cache zero cycle access latency share cache access time sixteen cycle main memory access time cycle use version kernel simulate realistic development environment experiment run execute make j thirty compile source file source tree parallel data independence lock data independence kernel lock present table two two three show total number time lock acquire percentage acquire low level lock contention kernel lock least acquire uncontended invest heavy engineer effort make kernel lock time two thread lock determine whether critical section execute data conflict show column four lock high rate data conflict indicate critical section execute safely parallel many lock list protect process link list link list data structure particularly optimistic concurrency modification element near front conflict access list one noteworthy lock protect critical highly data independent lock global lock lock protect data structure associate cache directory virtual directory represent type file enable quick resolution path name lock hold wide range often access disjoint directory entry cache case critical section data con measure number address set number conflict list five six particularly small address set indicate lock already fine grain little potential optimistic execution example protect small global control structure use manage work update lock hold subset structure four modify lock immediately release experimental data closely follow pattern lock critical section access average seven five conflict work set small set conflict indicate opportunity reorganize data structure amenable optimistic synchronization lock protect two link list page search identify page frame reclaim replace link list data structure avoid conflict traversal could substantially increase level data independence limit kernel data independence investigate limit data independence kernel compare address set critical section address set last address set lock discuss section three purpose compare multiple address set investigate much inherent concurrency present kernel law govern gain exploit concurrency inherent within critical section lock hold period time contribute parallel result table three present ten hold lock conflict acquire vary though average data independence across weight number cycle hold level data independence keep average four busy data structure reorganization increase amount data independence one interest lock table three kernel synchronization primitive provide form optimistic concurrency allow speculatively read data structure detect concurrent modification check sequence number read data structure modify retry use internally protect concurrent sequence number effectively serialize write protect data sequence number modify every time lock hold lock lock ide lock lock mean table three limit study data ten hold kernel spin lock data take compare address set last address set lock rather acquire table two conflict acquire percent acquire conflict data access mean conflict show average number conflict percentage total address set size lock critical section never data independent although seem limit concurrency first blush remain great deal parallelism construct arbitrarily large number process read data protect parallel sometimes lock protect conflict data set limit concurrency enable concurrency higher level abstraction data conflict lock distract attention ability concurrently access data structure lock protect data structure base occasional access another tend extremely low degree data independence fine grain common case however data lock protect access one represent large degree overall concurrency leave extend methodology multiple level abstraction future work transactional memory provide comparison performance synchronization optimistic synchronization run hardware transactional memory model thirteen version several key synchronization convert use hardware measure time spend acquire time lose restart convert acquire reduce time lose synchronization overhead eight reduction largely attributable remove cache miss lock variable data indicate convert lock yield exploit however gain even greater concurrency require data structure redesign reference five relate work paper employ parallel program tool evaluate limit optimistic concurrency large body previous work performance tune tool program three fifteen work different tool concern identify upper bound performance rather performance tune verify correctness modern like data structure specific approach optimistic concurrency four five data structure attempt change data structure optimistically dynamically detect recover conflict access transactional memory general form optimistic concurrency allow arbitrary code execute atomically moss six introduce one transactional memory recently speculative lock elision ten transactional lock removal eleven optimistically execute lock transactionally several design transactional memory hardware propose six conclusion paper introduce new methodology tool examine potential benefit optimistic concurrency base measure data independence critical section early result indicate sufficient data independence warrant use optimistic concurrency smaller data structure reorganization necessary realize greater paper motivate detail study relationship concurrency enable different level abstraction ease efficacy data structure redesign seven would like thank anonymous research support part cise research infrastructure grant career award one get serious memory two l v wong b j b prabhu h c k transactional memory coherence consistency three j harrow check multithreaded spin page visual thread four synchronization five v synchronization queue example six j e moss transactional memory architectural support data structure may seven j al full system simulation platform computer eight k e j j hill wood transactional memory nine c concurrent update j four ten r j goodman speculative lock elision enable highly concurrent multithreaded execution micro eleven r j goodman transactional asp free execution program twelve r k lai transactional memory thirteen de porter os bhandari e transactional memory operate system fourteen j g c b c scalable approach speculation fifteen w efficient detection data race condition via adaptive track