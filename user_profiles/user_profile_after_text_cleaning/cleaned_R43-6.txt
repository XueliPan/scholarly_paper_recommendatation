automatic documentation inference r department computer science university abstract exception handle powerful program language abstraction construct robust unfortunately introduce flow control difficult reason failure correctly lead security breach encapsulation number safety policy present fully tool statically infer characterize condition program tool base analysis output tool use documentation exceptional condition evaluate output tool compare instance exist exception documentation almost two million line code find output tool least good exist documentation time better time subject specify verify reason program specification distribution maintenance enhancement documentation general term documentation human factor documentation documentation inference exception handle one introduction modern exception handle allow error detect one part program handle elsewhere depend context exception scheme permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee eight copyright base replacement model sixteen forty method may enough information handle erroneous otherwise exceptional condition case method raise throw exception parent method farther call stack sufficient context exist properly handle event control flow simultaneously convenient problematic uncaught poor support exception handle report major one three four argue best defense class problem complete correct documentation use check force declare presence uncaught partial solution however practice many find burdensome requirement often catch trivially ie action take resolve underlie error mechanism purposely circumvent thirty reason program use difficult also automatic tool analyse seven eight fifteen seventeen propose relieve part burden present algorithm infer condition may give method raise exception automatic approach base symbolic execution analysis alert presence leak may aware well cause also make plain concrete type mask subsumption design exception handler often require precise exception type information thirty finally importantly tool use automatically generate documentation benefit system maintenance traditionally define modification make system delivery dominant activity engineer report place maintenance ninety total cost typical project one main maintenance lack documentation ten result study indicate forty sixty maintenance activity spend simply study exist p p improve documentation thus paramount importance many case propose algorithm addition algorithm fully automatic quite efficient make reasonable run nightly thus prevent drift maintain program documentation many tool exist allow automatic extraction documentation popular tool study past common use among commercial open source project allow document condition throw many exist project documentation incomplete inconsistent fourteen nineteen report prefer documentation among provide appropriate level detail complete correct documentation produce prototype tool integrate directly evaluate term completeness correctness use information main paper study documentation several exist open source project automatic algorithm determine condition sufficient exception throw condition use generate documentation experimental evidence tool generate documentation least accurate generate case structure paper follow section two present motivate example relate exception documentation inference present algorithm section three describe prototype tool base algorithm section four section five study exist program motivate need automatic exception documentation section six present experimental result efficacy algorithm program present future work section seven section eight conclude two motivate example section illustrate challenge document simple example draw game class question call unit intend many time move unit exception l l e g l e e x c e p n move illegal public void throw new l l e g l e e x c e p n unit move clear flag false one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen goal determine raise condition sufficient raise surface seem fairly simple result call return object type throw line nine consider however method invocation include line eight line thirteen potential throw exception well thus need inspect see may throw additionally class likely extend method invocation handle dynamic dispatch call either method may resolve implementation subclass unit may contain method find relevant exception source thus require trace complex code get harder become track must true reach throw address part problem require throw clause check limit check declare however unchecked c problem remain evolution maintenance present additional major concern throw statement add method reachable documentation potentially many include method call would amend notice also human provide documentation method move illegal hide constitute illegal move might desirable expect implementation might change later however tool could provide specific useful documentation would easy keep synchronize evolve code base algorithm present paper generate throw three algorithm description present algorithm generate documentation characterize sufficient method throw exception first algorithm locate track flow program second algorithm symbolically execute control flow lead symbolic execution generate predicate describe feasible yield formula program formula satisfy time method invoke exception raise first phase algorithm refinement six thirty method generate set possible exception type could throw thus escape method algorithm contain two previous work call graph increase speed precise treatment throw ensure soundness phase take input program call graph result analysis dynamic dispatch produce output map information throw second phase algorithm start exception information generate first phase use produce predicate describe throw predicate become documentation describe condition exception throw second phase use form symbolic execution trace method body gather input information r input program call graph c build use r input maximum desire propagation depth output map exception information one c two three end four c five topological sort six empty seven eight nine c ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen end nineteen twenty end end end end end change explicit e l zero throw e l e l method call l r l e l e l explicit l enclose catch e e e depth e l add call figure one algorithm determine method exception information e l propagate leak exception e location l e already propagate case able prune infeasible ie method exception type method may raise output phase two documentation instance represent condition may method raise exception type line thirteen monotonic ie learn additional method may raise never subtract information underlie lattice finite height ie worst method raise possible mention program process method consist determine set exception instance method raise consider explicit throw line eight also method line nine possible source associate new exception instance give method throw exception catch enclose catch clause line eleven thus may propagate caller respect source consider analysis conservative may report could never throw one two throw exception consider possible source division raise exception may utility system attempt exhaustively track generally indicative program rather design inclusion documentation might often consider inappropriate fourteen furthermore estimate implicitly throw likely result many false note thirty strictly speak statement throw exception algorithm refinement six thirty primary sort call graph also maintain completeness consider throw instead operand new object allocation also track additional information exception instance depth define depth minimum number exception must propagate reach method question example exception explicitly throw method body depth zero foo call bar bar raise exception exception depth one foo section section five relate depth likelihood documentation phase one exception information phase two generate documentation goal phase produce map information throw figure one describe algorithm formally method call separate exception escape method propagate exception instance exception instance opportunity documentation exception instance throw directly method question throw catch call method exception instance trace statement raise propagate produce set exception instance method input program require program call graph c map r method set concrete could invoke approach take form algorithm consider process turn since propagate method first process leaf make process method precise information may invoke process terminate update first phase algorithm derive throw phase use information discover exception might throw specifically use symbolic execution discover predicate program would sufficient trigger throw statement figure two describe algorithm formally algorithm produce map e doc raise exception e doc true algorithm fix point computation use method process turn line seven fix point reach change infer documentation line twenty process method involve determine path predicate describe condition may propagate method process method first enumerate control flow line nine lead method head previously determine raise construct control flow start statement work backward input map method exception information input information r input program call graph c build use r output documentation method exception predicate c e l p start l symbolically execute p l method call one c e two e false three end four c five topological sort six empty seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty end end end add call end change r l e e end end end else e e e figure two algorithm infer exception documentation explain exception throw e p method raise exception e p true predicate p documentation control flow graph method reach method entry point ignore forward edge traversal thus obtain statement two duplicate information explore analysis thus potentially exponential full control flow path symbolically execute line ten nine track conditional evaluate guard predicate use current symbolic value collect result predicate together form constraint call path predicate describe condition path take two five twenty path predicate analysis could also use interleave path predicate generation method process efficiency statement dynamic dispatch method invocation process information concrete method may invoke line eleven use conservative receiver class analysis obtain information line twelve method invocation thus handle assign actual formal include body thus model execution extend way original throw statement method raise exception e condition e caller reach point path predicate propagate exception occur condition e line thirteen guarantee termination enumerate explore contain loop involve backwards branch consider loop body evaluate filter infeasible path predicate employ common heuristic thirteen us miss instead us generate predicate thus documentation case make trade favor speed precision condition typically depend particular value loop induction see section six interest document term term local loop induction condition often depend whether loop conditional take rarely depend detail iteration condition fix point reach path predicate become documentation exception instance one exception type throw via multiple different path predicate combine logical disjunction form single path predicate result method exception raise method expression program satisfy sufficient exception raise documentation result path predicate produce final documentation output tool employ small number recursive phrase common succinctly example true become always false x become x x null become x null x become x become x next become x element also apply basic replace x x false complicate transformation use replace x x z x z term rewrite engine algebraic simplification tool could easily employ experiment generate exception documentation involve term could simplify arithmetically four prototype tool experimental setup evaluate effectiveness algorithm elect target program anticipate could use exist documentation basis comparison choose several popular detail figure three experiment algorithm require call graph map invocation sit possible concrete target problem name risk weka total mean domain file share version development program analysis game text editor data presentation game guide machine learn throw seven fifteen nine document figure three set program use study column give total number reachable main throw column give number throw contain document column give percentage document comment name risk weka total mean seventeen eighteen instance mean depth nine fourteen total figure four run tool generate documentation every exception number control flow enumerate symbolically execute instance number generate mean depth mean distance method documentation generate original throw statement receiver class analysis implement include time load parse program file exception flow analysis phase one documentation generation phase two include post process experiment conduct dual core system construct accurate precise call graph dynamic typically involve receiver class analysis alias analysis many exist fact problem become one program analysis eighteen employ spark produce call graph spark reasonably fast terminate less one hour integrate soot twelve analysis framework use parse input program use eclipse parse source code extract five exist exception documentation claim complete documentation important incompleteness lead security reliability encapsulation well maintenance section provide evidence demonstrate condition real world program raise often completely document evaluate documentation completeness first explore rate type document would expect complete documentation either include every instance particular exception type raise almost instance hypothesize deem worth document time worth document time similar assumption use al eleven find bug code notion consistency allow possibility may consciously decide document certain view partial documentation exception type mistake experimentally find many inconsistent documentation figure five present frequently document yet sometimes neglect exception type choose two commonly document exception type list exception type list static percentage document exception percentage throw exception determine algorithm see section consider stub indicate exception type without additional comment throw exception actual since convey information regard trigger exception may automatically insert development environment conjecture unlikely documentation particular exception type need appropriate ninety raise need desire ten interest note associate standard library exception type also hypothesize exception instance may document difficulty lack programmer interest p manually model exception propagation figure six indicate propagation depth exception practice strong inverse correlation probability document particular quite rare documentation appear exception explicitly raise cur figure six exception documentation function exception propagation depth line represent average exception instance within vertical bar indicate maximum minimum observe value include exception instance explicitly throw within method question depth zero higher indicate number method exception must propagate rent method ie exception instance depth zero propagation three documentation become almost nonexistent claim lack exception documentation practice follow difficulty develop lack need serve evidence presence inconsistent incomplete six evaluation purpose algorithm automatic construction useful documentation section compare documentation produce prototype implementation documentation already present program run tool figure three generate documentation exception restrict attention instance comment exist exception instance pair exist piece documentation documentation suggest tool manually review documentation pair categorize accord whether documentation better worse version present code consider documentation bet precise example worse inappropriate us better parameter also consider documentation better contain complete information otherwise include figure five frequency exception documentation column represent document give exception express percentage throw exception two frequently document rate list case forget documentation example worse id null us better id null often piece documentation convey example insufficient amount gold us case consider documentation worse typically happen human create documentation contain special insight relationship program express information program state could readily infer set predicate without additional knowledge example better queue empty us worse private variable null tie difficult resolve favor exist documentation total time take evaluate documentation pair determination usually quite direct figure seven show relative quality documentation produce tool exception instance ten leave give individual three rightmost give overall performance describe detail also measure whether generate condition could express strictly term property generally beyond control although involve use express predicate term certain instead predicate private local might useful mean might clear system directly affect furthermore documentation involve private potential expose implementation detail intend hide experiment documentation instance involve private local involve public surprisingly however documentation instance involve private nearly good better exist construct strictly term public follow largely descriptiveness private variable name consider indicative example class could find us private contain parameter even though private field may even know type object generate documentation still good one private descriptive example weka show better matrix must square us worse private private n without know n matrix dimension documentation useful general need always reject generate documentation contain private reference decision accept reject depend several factor extent encapsulation concern relative readability private public data intend purpose documentation internal external use finally note section provide experimental evidence utility tool primarily respect ie four comparison general represent figure seven relative quality documentation produce tool exception instance already complex predicate clear point become complex useful human documentation case see figure four inference algorithm fact scale large program nearly control flow enumerate sometimes average greater five practice determination exception type document likely depend concern mean exception well usage whether documentation employ aide documentation supplement seven future work find documentation produce tool surprisingly readable simple however would interest enhance readability simulate human prose rearrange predicate even though generate documentation involve complex logic suspect system capable symbolic algebra simplification would useful certain application generate tool involve predicate program however information available source code might provide additional insight exceptional condition example might incorporate argument typically string provide exception constructor associate documentation obvious case implementation prune infeasible integrate theorem prover would allow us rule infeasible thus reduce false finally course experiment notice certain exception type frequently document standardize manner example nearly every correspond comment variation throw class could find case may appropriate copy exist documentation structure rather infer eight conclusion paper describe algorithm automatic exception documentation two phase phase one determine may throw propagate algorithm slight refinement previous work analysis conservative miss may report false phase two primary contribution work characterize condition path predicate may throw analysis also conservative may generate poor predicate depend loop call graph imprecise convert predicate documentation able generate documentation involve public instance associate line code documentation instance generate least accurate create instance strictly better study exist documentation suggest many exception instance remain undocumented practice especially true propagate algorithm completely automatic handle propagate local efficient enough use nightly take two million line code thus reduce drift implementation documentation time cost low require potential benefit large believe work solid step toward make automatic documentation generation reality nine reference one g c e c enhance fault tolerance management concurrency eight three two ball j r efficient path profile international symposium page three van discover l scale analysis fault exception handle six proceed international conference engineer page use spark g editor compiler construction international conference volume page warsaw springer four exception handle false sense security j practical exception eight grove hind v sarkar efficient prentice hall upper saddle river c report six nine five l carter b b l carter j path analysis rename predicate instruction schedule international journal parallel program six six chang jo k exception analysis sac one proceed symposium apply compute page seven r b g ryder w complexity analysis presence six precise model analysis program workshop program analysis tool engineer page nine das program verification polynomial time notice five ten c b de n k de study documentation essential maintenance international conference design communication page eleven r bug inconsistent behavior general approach infer code symposium operate page twelve r al soot optimization framework proceed page thirteen c k r g nelson j b r extend static check program language design implementation page fourteen forward c relevance documentation tool survey two proceed symposium document engineer page fifteen c fu b g ryder analysis reveal exception handle architecture server engineer international conference page may sixteen j b exception handle issue propose notation eighteen twelve seventeen hind optimize program presence conference program page eighteen hind pointer analysis solve problem yet workshop program analysis tool engineer page nineteen tilley towards documentation maturity model international conference documentation page twenty r r path slice program language design implementation page documentation source code comment case study international conference computer documentation page advance exception handle page k l model check tool construction analysis page r miller issue exception handle conference program page g k ward say want documentation conference design communication page l engineer theory practice practical maintenance best practice manage investment sons p g c murphy regain control exception handle technical report computer science university one thirty p g c murphy static analysis support evolution exception structure twelve two g efficient path condition dependence graph international conference engineer page b g ryder smith n shah static study use international conference compiler construction page r c g lewis modernize legacy engineer process business practice publish boston c small k smith deal disaster survive misbehave kernel symposium operate design implementation page j criteria test construct program page j support development maintenance test presence implicit control flow b tilley documentation engineer need aid system understand international conference computer documentation page tilley h simple document annotation facility international conference documentation page w g c find prevent error handle mistake conference program page forty berry modular verifiable exception handle mechanism program seven two