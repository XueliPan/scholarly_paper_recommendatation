detect survive atomicity hardware play significant role improve reliability thread recent architectural arbitrarily group con dynamic memory atomic block enforce coarse grain memory order provide implicit atomicity author article observe implicit atomicity hide atomicity reduce number interleave memory propose create implicit atomic block intelligently instead arbitrarily dramatically reduce probability atomicity manifest extract performance emerge multicore require parallel program however write program difficult largely inaccessible write explicitly parallel program must make sure share data keep consistent usually involve specify critical section use lock however practice typically lead synchronization defect data race atomicity atomicity challenge concurrency occur make incorrect atomicity fail enclose memory access occur atomically inside critical section accord recent comprehensive atomicity account examine concurrency bug find bug difficult subtle nature multithreaded execution hence one afford assume code free bug important detect prevent manifestation interestingly manifestation concurrency bug considerably influence multithreaded program execute determine global interleave memory give set memory semantics expose multiple valid global interleave memory exist system allow subset interleave avoid concurrency bug still expose memory semantics leverage property work recent architectural arbitrarily group consecutive memory atomic block provide university university c publish computer society top pick read update counter happen inside critical section counter share variable protect lock l void increment temp lock l temp counter unlock l bad interleave remote thread lock l temp counter unlock l temp temp lock l counter temp unlock l lock l counter temp unlock l figure one simple example atomicity violation read update counter two thread could interleave counter process finally evaluation use buggy code real show reduce several order magnitude chance atomicity violation lead incorrect program behavior atomicity data race widely know concurrency defect significant work hardware detection however al point freedom imply concurrent program correct program could still suffer atomicity violation figure one show simple example atomicity example counter share variable read update counter inside distinct critical section protection lock l imply code free data race however code still increment rect call another thread could interleave read update counter lead incorrect behavior example two concurrent call increment could counter subtle error easy mistake make determine atomicity necessary must group atomically difficult prone code snippet figure one counter data race access properly synchronize however code still incorrect example miss atomicity read update counter atomic avoid unwanted interleave access counter thread atomicity violation exist code programmer make incorrect atomicity fail enclose access perform atomically inside critical section atomicity also exist program use instead lock programmer could fail enclose memory access perform atomically transaction call implicit atomicity arbitrarily group sequence dynamic memory program thread atomic block chunk without follow program annotation significantly reduce amount interleave memory different thread interleave occur coarse granularity aim support memory consistency model high performance enforce consistency coarse grain article show implicit atomicity hide atomicity memory fall within chunk support observation probability analysis empirical evidence build observation propose mechanism detect dynamically avoid atomicity behalf without require program annotation architecture use hardware detect likely atomicity avoid dynamically adjust chunk best knowledge first article survive atomicity without require global allow find atomicity report atomicity could exist code aid micro table one memory interleave analysis interleave serialize comment w w w w yes yes yes yes interleave write make two local read inconsistent local write may depend result read overwrite remote write local write local read get expect value intermediate value write first write make visible thread lock l unlock l lock l counter st counter unlock l interleave lock l unlock l lock l counter st counter unlock l implicit atomic block arbitrarily define processor b figure two interleave traditional provide implicit atomicity b violation manifest atomicity lead incorrect program behavior interleave memory access different thread break programmer make atomicity chance atomicity depend chance unfortunate interleave figure show four interleave occur traditional contrast figure show interleave occur atomicity violation memory inside chunk case atomicity violation hide property concurrent program execution code assume atomic programmer interleave code another thread execution produce result state interleave execution thus atomicity violation manifest execution execution apply concept directly share data access determine whether interleave memory access share variable al use analysis determine access interleave detect system see table one seven top pick possible interleave b possible interleave b chunk b figure three b access interleave six possible interleave system two possible interleave system chunk first operation fall anywhere two chunk hence atomic c one th instruction c atomicity lack section zero c one c c c figure four atomicity violation within chunk probability violation execute entirely one chunk first column represent interleave format c pair local memory access interleave c access remote thread example w correspond two local read access interleave remote write access work leverage analysis consider interleave access potential atomicity code programmer assume atomic implicit atomicity several recent example atomic sequence order nine implicit describe support implicit atomicity memory dynamic instruction stream arbitrarily group atomic chunk allow hardware memory consistency enforcement oppose instruction granularity enforcement consistency enforcement let us system support sequential consistency performance relax memory model release consistency implicit atomicity two interest leverage first amount interleave memory different reduce interleave occur chunk result effect remote thread visible chunk figure three contrast fine interleave figure interleave occur six possible interleave figure interleave exist chunk far possible two example second oblivious granularity chunk use let system arbitrarily choose chunk adjust size chunk dynamically without affect program semantics implement architecture support form arbitrary atomic block stream article assume system similar repeatedly execute chunk separate local dynamic instruction execute outside atomic chunk implicit atomicity naturally hide atomicity chunk granularity naturally hide atomicity reduce probability code assume atomic actually interleave chance execute completely inside one atomic chunk figure four illustrate derive probability atomicity violation execute inside chunk let c default size chunk dynamic size atomicity violation dynamic let probability violation execute inside single probability hide atomicity violation first operation violation within chunk first c one first last micro violation fall chunk commit atomically hide atomicity violation express probability hide atomicity violation show figure four model instruction granularity system one chunk size equal one instruction c fourteen one hence fourteen zero size atomicity violation least two two consistent observation instruction granularity system hide atomicity also worst case atomicity bigger chunk prevent violation hide fourteen zero result chunk granularity hide atomicity never increase chance manifest validate model empirical data figure five show percentage atomicity violation instance naturally hide bug chunk size increase experimental data point close line derive analytical model verify model accuracy well hypothesis implicit atomicity naturally hide atomicity figure five show chunk size yield probability naturally hide atomicity range percent exclude whose atomicity longer actively hide atomicity smart chunk use technique call smart chunk automatically determine place chunk reduce probability expose atomicity detect potential atomicity insert chunk boundary first memory access potential thus attempt enclose memory access atomicity violation inside chunk essence infer critical section stream l n e h n v c f n e c r e p zero zero sweep chunk size figure five experimental data natural hide atomicity implicit atomicity various chunk size bug point show empirical data curve show data predict analytical model chunk insert accordingly process transparent oblivious synchronization construct might present code detect potential atomicity observe memory access chunk interleave memory access commit chunk system detect least two nearby access variable local thread least one recent access another thread examine type access involve determine whether access potentially accord table one start monitor access local thread access insert chunk boundary keep history memory access record read write set recent local chunk recently commit remote chunk counter example increment figure six show idea apply give figure one assume provide implicit atomicity use hardware efficiently keep read write also maintain read write set previously commit chunk recall commit top pick lock l counter unlock l lock l st counter unlock l lock l counter unlock l lock l st counter unlock l counter counter counter might involve atomicity violation add b counter force chunk break lock l counter unlock l lock l st counter unlock l default chunk size figure six actively hide atomicity violation discover counter might involve atomicity violation add counter access chunk boundary automatically insert belong b chunk send write set system allow learn write recently remotely commit chunk figure execute increment although chance read update counter atomic due natural hide case figure example read counter inside previously commit chunk p whereas update part chunk currently build c counter update c determine counter read previous local chunk counter two recently update remote processor counter two characterize potential violation make counter member set possibly involve atomicity later access counter figure detect counter two therefore chunk boundary insert read counter execute increase chance access counter enclose chunk make atomic although atomicity violation figure expose mean manifest interleave might actually occur also even atomicity violation naturally hide still detect show detect atomicity manifest detect likely atomicity find goal detect potential atomicity occur two nearby access local thread address one recent access another thread address examine type access determine whether potentially micro local chunk encode remote access previous chunk p current chunk c st st w remote read downgrade figure seven use detect likely atomicity treat potential atomicity violation need keep track three piece information show figure seven type read write address memory operation currently execute read write set current previously commit chunk read write set chunk commit remote previously commit chunk execute along read write set chunk commit current chunk execute table two show use information determine whether access constitute potential atomicity violation first column show type give local memory access second column show interleave try identify observe local memory access third column show identify interleave example consider first two case local memory access read two possible interleave w w detect whether either occur use correspond set third column specifically identify potential w interleave first check whether local read set two two check whether also find remote write set chunk commit another processor either previous local chunk execute two since begin current local chunk two condition satisfy identify address potentially involve atomicity violation add processor case necessarily atomicity violation remote write might actually interleave two read also keep two chunk worth history capable detect atomicity shorter size two chunk limit factor hide atomicity chunk use keep read write set simple evaluate necessary set adjust chunk address add processor every access address local thread trigger mechanism place chunk boundary immediately access trigger would actually prevent atomicity violation expose see consider figure suppose address variable counter previously insert load counter execute would trigger could place chunk boundary immediately access store counter execute would trigger place another chunk boundary point would actually expose atomicity violation instead hide intend break chunk place new chunk boundary undesirable example atomicity involve multiple access might invoke several time actually want place chunk boundary first access top pick table two case address add local operation interleave expression read write w w w r every single access another example address add likely local thread still manipulate correspond variable case avoid chunk break actually beneficial avoid undesirable chunk break detect condition describe see full version article evaluation model system resemble use pin dynamic binary instrumentation also model execution read write set require algorithm unless note signature configuration use use run experiment real subject reason show result average across many run error bar indicate percent confidence interval average check whether atomicity violation hide annotate one check whether fell within chunk invisible sole purpose evaluate capability experiment two type bug full bug let us experiment condition buggy code execute often full also include three full apache x system evaluation test use test apache use test play media file visualizer create bug use previously carefully preserve bug original application possible include io mimic realistic behavior range widely eighty approximately dynamic large several hundred never exceed reason relatively short long easier find test likely manifest often experiment vary size chunk experiment use instruction chunk active hide smart chunk figure show hide nearly percent almost chunk size three bug artificially enlarge atomicity artificially large large execute within small chunk hence could hide except chunk suffer early chunk break decrease ability hide smaller chunk chunk size reach however chunk large enough enclose access cause early break violation ensure survival figure contrast hide effect implicit atomicity alone full result show eighty micro eighty sixty forty twenty n e h n l v c f n e c r e p natural hide active hide e h c p l q x chunk size n e h n l v c f n e c r e p eighty sixty forty twenty zero b zero h c p c c k n b c c k n b p e e w c pro g l two p e e w c pro g l q b g figure eight average percentage atomicity hide bug real chunk b error bar show percent confidence interval hide virtually percent atomicity chunk figure eight clearly show smart chunk algorithm hide far higher percentage atomicity implicit atomicity alone moreover reduce number expose atomicity several order magnitude compare current commercial fact hide percent atomicity addition help survive atomicity also report program counter memory instruction data address add point execution detect potentially interleave point could help developer locate bug code simply sort list code point detect potentially interleave accord frequency appear list able locate buggy code apache use prior bug detection even detect new bug apache line code six file need inspect number large code base nearly line code identify bug previously know inspect nine line code overall information provide useful direct programmer attention correct region code even use simple heuristic like one present sophisticate could result even efficient methodology work relate significant work concurrency bug detection survival widely address relevant prior work hardware atomicity violation detection extract interleave train check whether hold future run monitor interleave use cache different use hardware monitor potential might necessarily occur leverage implicit atomicity detect help survive concurrency bug another hardware proposal target concurrency however top pick focus data race atomicity attempt dynamically repair data race basis library race pattern violation detection heuristically infer critical section base data control attempt determine author suggest algorithm could implement hardware could avoid bug via backwards error recovery ber use global restart like attempt infer critical section dynamically however use memory interleave detect potential moreover unlike ber bug avoidance require global restart build observation implicit atomicity naturally hide atomicity choose chunk avoid expose without require special program global mechanism achieve effect implicit atomicity statically compiler automatically insert arbitrary program would challenge could hurt performance even prevent forward progress hand support implicit atomicity facilitate forward meaningful step toward system offer resilience detectability micro concurrency bug three savage al eraser dynamic data race detector multithreaded pro computer vol thirty four article twenty four j use speculation data race thread cod ann l computer architecture three press five c type system atomicity sig plan program language design implementation three press six moss transactional memory architectural support lock free data structure ann l computer architecture press seven al detect atomicity via access interleave l architectural support program operate six press eight l al bulk enforcement sequential consistency ann l computer architecture seven press nine al store ann l computer architecture seven press ten e al implement l pervasive service five press reference one al learn mistake eleven b al detect survive atomicity l computer architecture comprehensive study real world con press currency bug twelve al pin build l architectural support pro program analysis tool dynamic operate eight press program language design implementation five press two r hill share ability violation detector thirteen l al bulk memory server program sig speculative thread plan program language design ann l computer implementation five six press micro science graduate student computer university research interest include hardware support dynamic analysis concurrent focus increase reliability computer science university member science graduate student computer university research interest include model intersection architecture program engineer computer science university member researcher research advance development affiliate assistant professor department computer science engineer university research interest encompass enable adoption include hardware support computer science university member assistant professor department computer science engineer university research interest include computer architecture improve computer science university member direct question comment article computer science engineer po box wa information compute topic please visit digital library