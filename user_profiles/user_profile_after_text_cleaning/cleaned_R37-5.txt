operate system e porter j benn department computer university abstract must able synchronize access operate system order ensure correctness face concurrency system system allow programmer specify update heterogeneous system os guarantee atomicity consistency isolation durability acid system efficiently cleanly solve persistent concurrency difficult address example system eliminate security file system cause race condition system enable unsuccessful installation roll back without disturb concurrent independent update file system paper describe variant implement system use new implementation provide fast strong isolation fairness system activity prototype demonstrate mature os run commodity hardware provide system reasonable performance cost instance transactional installation incur ten overhead compilation incur negligible overhead make central os abstraction enable new transactional service example one developer transactional file system less one month subject operate process program concurrent program operate organization design general term design performance security operate race condition transactional memory permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee nine big sky montana copyright one introduction often need group access operate system file signal logical multithreaded must group access share data structure critical example local user group account similar operate store across three file need mutually consistent currently struggle make consistent update system current operate individual system call generally atomic isolate rest system difficult impossible condense complex single system call simple case use powerful single system call like rename atomically replace content file complex update like file lock clumsy difficult program presence concurrency problem exacerbate exist often insufficient protect series system call interference buggy malicious current proliferation multicore concurrent process become ubiquitous expose inability traditional system call interface ensure consistent access example manage local user account spend substantial effort create tool minimize fail eliminate consistency help ensure user account format correctly mutually consistent address concurrency system tool create lock file mutual exclusion careless administrator however corrupt file simply edit directly tool also use sync rename command ensure individual file corrupt system crash ensure update multiple file consistently propagate instance suppose system crash write write system new user able log yet fail think user already exist leave system administrator manually repair file proliferation tool mitigate simple problem well tool incompleteness indicate need better consistent system access practice os address lack concurrency control system call ad manner new system call complex add solve new arise critical problem eliminate file system race condition motivate add dozen new system call last seven add flag fifteen system call recent version thirteen eliminate race condition tween call open individual file introduce new address consistency need file system support atomic append sixteen recently adopt support registry require lobby os new system call file system feature meet concurrent program need allow solve support composition multiple system call arbitrary atomic isolate paper propose system allow group access system logical execute atomicity consistency isolation durability acid system easy use code consistency enclose within system call user abort transaction place system call within transaction alter semantics result publish rest system outside transaction action system visible soon relevant internal kernel lock release within transaction access keep isolate commit time atomically publish rest system system provide simple powerful way express consistency concurrent os paper describe implementation system call provide transactional semantics os include file system memory management signal process creation efficiently provide strong guarantee implementation redesign several key os data structure internal subsystem make core os abstraction enable user os create powerful service example give initial implementation single developer need less month prototype transactional file system paper make two primary first describe new approach os implementation support efficient commodity hardware strong atomicity isolation guarantee secondly demonstrate prototype implementation system whose strong guarantee good performance enable new one eliminate security exploit file system race condition two roll back unsuccessful install upgrade without disturb concurrent unrelated update transactional install add ten overhead increase safety three provide lightweight alternative concurrency management crash consistency yield simpler application code system administration replace flat file system storage directory service improve performance four allow transactional program make system call transaction remainder paper structure follow section two provide motivate system section three describe program system implementation section four describe design section five provide kernel implementation detail section six describe certain key provide transactional semantics section seven measure performance overhead system evaluate number application case study section eight position relate work section nine conclude two motivate range seemingly unrelated application share root lack general mechanism ensure consistent access system section review two common application consistency system remedy system allow recover without disrupt concurrent independent update file system system also eliminate race condition inherent file system exploit undermine security installation upgrade new patch increasingly common system activity time market pressure good network connectivity combine make update frequent yet upgrade remain dangerous activity example recall prerequisite patch vista service pack one cause endless cycle boot generally partial upgrade leave system unusable state current adopt mitigate provide solution update problem take disk state install something go wrong roll back certain key structure like registry system file thirty like entire file system installation fail system restore preinstallation file system image erase file system update concurrent independent installation partial mitigate problem lose ability recover application corrupt file system moreover user system must create manage make sure valid image always available finally bad installation affect volatile system state errant program corrupt file unrelated fail installation collectively severely decrease usability system provide simple interface address installation user execute installation update within transaction isolate rest system installation successfully complete installation upgrade need roll back independent update make concurrently remain undisturbed eliminate race security figure one depict scenario application want make single consistent update file system check access file conditionally write common program pattern source major persistent security problem modern operate attacker change file system name space use symbolic link victim access control check file open perhaps trick program overwrite sensitive system file like password os provide way application tell operate system need consistent view file system name space although common file system system race race exploit os local use vulnerable similar race creation connection suffer socket race exploit al victim access foo attacker secret foo victim attacker secret foo foo write access foo foo write secret foo figure one example attack follow example eliminate race use system attacker serialize order either transaction attacker see partial update victim transaction change low user steal another one plash system suffer similar vulnerability two demonstrate race signal use crack include screen conceptually simple pervade deploy difficult eliminate time write search national vulnerability term attack yield hit recent work al seven exploit fundamental flaw defeat two major class dynamic race kernel probabilistic race continuous arm race measure countermeasure suggest attack eliminate change practice race address ad extension system add new flag fifteen different system call eliminate race condition call open al demonstrate use family system call construct deterministic many race traverse directory tree check user application however protect race without even particular incompatible flag open use prevent exploit temporary file creation nine fix race condition arise effective strategy complicate name security risky code complexity often enemy code security four system provide deterministic safety guarantee natural program model general mechanism eliminate race condition three overview system design provide natural abstraction ensure consistent access system section describe semantics behavior system follow overview system support prototype implementation system within system system provide acid semantics update os file pip signal program model transactional system call may access system state os responsible ensure access correctly serialize contention arbitrate fairly interface system intuitive simple allow programmer wrap block unmodified code transaction simply add system transaction semantics system share several likely familiar system recoverable read allow commit data repeatable correspond highest isolation level level three eighteen atomic system always roll back pretransaction state durable transaction result commit survive system crash ensure isolation kernel enforce invariant kernel object may one writer time except allow multiple disjoint two concurrent system successfully commit access kernel object least one access write say conflict system detect conflict abort one update object read write active system transaction also prevent system either system suspend work update abort transaction prevent conflict access kernel object system provide conflict commonly use enforce efficiently system make durability optional durability often increase transaction commit latency programmer always need increase commit latency come flush data slow block storage device like disk eliminate race file system example system transaction require durability durability system control programmer use flag table two kernel thread may execute system transaction transactional update isolate kernel thread include thread different process call kernel thread execute system transaction transactional kernel thread interaction transactional thread os serialize system system call provide guarantee intuitive semantics eighteen programmer serialization transactional update call strong isolation five previous os transaction design leave interaction activity semantically murky intuitive semantics mix transactional access crucial maintain simple interface system strong isolation prevent unexpected behavior due transactional access system presence system change behavior activity underlie operate system system call already isolate atomic important example serialize read write os system non transactional system call still exhibit behavior respect system call serialize example one call read system transaction correctly serialize write system transaction progress operate system guarantee system system two b commit system select one restart let us say b example ensure decision remain consistent continue b restart conflict os restart b see detail guarantee progress transactional thread presence thread require support os os support kernel thread present since guarantee progress long run thread would impede progress transaction os several regulate progress use matter policy instance allow long run transaction isolate system indefinitely undesirable os may want policy limit size transaction limit transaction system analogous control process abuse system memory disk space kernel thread system system state although system provide acid semantics system state provide semantics application state system state include os data structure device state store operate system address space whereas application state include data structure store application address space system transaction abort os restore kernel state pretransaction state revert application state expect use library system transparently manage application state well system simple case example developer could manage application state provide automatic restore mechanism application address space mark page similar speculator enable flag table two section describe system integrate hardware transactional memory provide complete transactional program model multithreaded communication model code communicate outside transaction require response encapsulate single transaction communication outside transaction violate isolation example transaction may send message thread channel system might buffer message commit transaction wait reply channel application deadlock programmer responsible avoid idiom within transaction communication among thread within transaction unrestricted paper consider system single machine future work could allow system span multiple machine subsystem process tot thirteen part one three communication total fifteen thirteen zero four six partial fork clone exit partial pipe link access dup open close write time partial partial fourteen grand total unsupported process memory file communication administration total nice fifteen mount sync flock fourteen eight twelve eighteen splice tee select poll socket alarm time table one summary system call completely support tot partially support part follow system call transaction support partial support indicate execution system call full transactional semantics architecture total system call overview implement system isolate data read write transaction use exist kernel memory buffer data structure application write data file system device update generally go os buffer first allow os optimize device access make buffer isolate transactional data access commit must fit main memory although limit could raise future work swap uncommitted transaction state disk isolate update kernel data structure use recent implementation transactional memory departure log lock approach historic transactional operate isolation optimistic allow concurrent assumption conflict rare table one summarize system call support transactional semantics include file system process credential management signal pip partially support system call mean process fully transactional example essentially large switch statement support transactional semantics every case partially support call support transactional semantics unsupported call issue system log warn abort transaction depend flag pass ideal support system would include every reasonable system call support subset system call show table one count support system call show relative maturity prototype also indicate incomplete count unsupported system call proportionately represent importance challenge function name flag void description begin transaction flag specify transactional behavior include automatically restart transaction abort ensure commit result stable storage durable abort unsupported system call issue return status code end transaction return whether commit succeed abort transaction transaction start restart set override flag restart transaction table two work many network primarily use common file system instance extend include network real challenge would increase count support call five whereas transaction support extend file attribute fairly straightforward extension would add twelve support system call remain count system call fall three substantial memory management communication straightforward perhaps less common important process management remain file highly unlikely useful inside transaction mount support transactional semantics enough kernel demonstrate power utility system four design system guarantee strong isolation retain good performance simple section outline design achieve fairness allow flexible interaction transactional kernel thread efficiently provide strong isolation inside kernel require system call follow lock discipline require annotate access kernel object thread transactional access kernel object first time must check conflict annotation arbitrate conflict detect many case check perform time thread acquire lock object weak spot previous transactional transactional conflict transaction thread call asymmetric conflict must resolve abort transaction approach undermine fairness asymmetric conflict often detect thread enter critical region option suspend thread allow fairness thread manage transactional state historical transactional operate typically update data place maintain undo log approach call eager version management isolate lock data access hold lock commit technique call lock usually employ lock distinguish read write access generally globally consistent order data access deadlock example one thread might read file write file b different thread might read file b write file possibility deadlock complicate program model eager transactional deadlock commonly address expose parameter set properly challenge short starve long destroy performance system eager version management degrade responsiveness ways acceptable operate system interrupt handler high priority thread thread abort transaction must wait transaction process undo log restore pretransaction state safely proceed wait jeopardize system ability meet time contrast use lazy version management operate private copy data structure never hold kernel lock across system call lazy require hold lock long enough make private copy relevant data structure enforce global order kernel lock avoid deadlock abort winner conflict incur latency abort transaction process undo log primary disadvantage lazy commit latency due copy transactional update speculative version stable version data structure discuss section five minimize overhead split object turn entire object pointer copy integration transactional memory system protect system state application state multithreaded program os efficient mechanism save restore memory state individual thread transactional memory however design provide efficient transactional semantics memory thread isolate roll back system call integrate user system create simple complete transactional program model system fix one troublesome transactional memory system call disallow user violate transactional semantics system call traditional operate system isolate roll back transaction fail example file append perform inside hardware user transaction occur arbitrary number time time transaction abort retry repeat append system integrate application make system call begin system transaction transactional memory system handle buffer possibly roll back application memory state system transaction buffer update system state update system state commit abort kernel atomically commit abort transaction programmer see simple abstraction atomic block contain update user data structure system call see section implementation detail section evaluation five kernel implementation section describe system implement kernel provide transactional semantics system call present table one support system call include process creation termination reference count data object cache page list kernel bookkeeping conflict detection data object header common data field unsigned long figure two simplify structure decompose header data object header contain reference count lock kernel bookkeeping data object manage transactionally object contain field commonly access system call update transaction replace pointer header management send receive signal file system system add roughly line code transaction management line object management also require line minor change convert kernel code use new object type system insert check asymmetric conflict execute data maintain multiple kernel data structure system isolate effect system call commit order undo effect complete data structure private process current user id file table simple restore scheme share kernel data structure however implement system borrow transactional memory recent concurrent program transaction access share kernel object acquire private copy object call shadow object system call within transaction use shadow object place stable object transaction commit abort use shadow object ensure always consistent view system state transaction commit shadow object replace stable transaction complete simply discard shadow object give kernel object may target several object present challenge replace stable object shadow object naive system might update object object commit unfortunately update mean write object contain write point object transaction may create conflict access abort otherwise nonconflicting two concurrent successfully commit must write disjoint object split object header data order allow efficient commit lazy data decompose object stable header component volatile transactional data component figure two provide example decomposition object header contain pointer object data commit change object replace pointer header modify copy data object header never replace transaction eliminate need update object point header also contain data access instance kernel garbage collection thread periodically scan directory entry cache look cache file system data reuse keep data kernel bookkeeping reference count list figure two header scan never access associate object avoid restart active decompose object data also provide advantage type system ensure transactional code always speculative object instance virtual file system function take convert shadow type modify use type system allow compiler find code need acquire speculative object ensure completeness type system also allow use minimize time spend look shadow object example path name resolution code initially acquire shadow data object pass shadow object directly helper function virtual file system code acquire shadow object entry pass lower layer minimize need code reacquire shadow object multiple data object decompose object multiple data house data access disjointly instance contain file owner map file block cache page memory process may often read write file without update object separately allow data file execute concurrently safe object many kernel object read transaction parent path avoid cost make shadow copy kernel code specify access object mark object data length transaction data object transactional reader reference count writer win conflict object nonzero reader count must create new copy object install new stable version os garbage collect old copy via update transactional release task constraint ensure active reference old version release free task see consistent view kernel data caveat task block must reacquire data object use wake may replace free transaction commit although complicate kernel program model slightly mark data object transaction structure way eliminate substantial overhead memory allocation copy special support common optimization transactional technique support efficient concurrent access data conflict detection resolution discuss section serialize activity well serialize access kernel object leverage current lock practice augment stable object information transactional transactional thread use information detect access would violate conflict acquire kernel object conflict occur transaction attempt write object read write another transaction asymmetric conflict define similarly thread attempt write object transaction read write vice embed object header portion share kernel object access within transaction object include pointer transactional writer reader list writer pointer indicate active transactional writer empty reader list indicate lock prevent acquire object concurrently access thread thread detect conflict use field determine conflict conflict arbitrate contention manager note reader list attach stable header object whereas reader count use garbage collect obsolete data object lock test transactional writer field detect transactional asymmetric conflict contention management conflict detect two transaction thread invoke contention manager resolve conflict contention manager kernel code implement policy arbitrate conflict among dictate conflict may continue conflict must abort default policy adopt policy always select process higher schedule priority winner conflict eliminate priority policy inversion transactional conflict process priority conflict older transaction win policy know forty guarantee liven within give priority level asymmetric conflict conflict transactional thread call asymmetric conflict transactional thread always abort roll back thread roll back must freedom resolve asymmetric conflict favor transactional thread otherwise asymmetric conflict always win undermine fairness system possibly starve thread roll back often allow lose conflict transactional thread kernel recent feature allow kernel thread execute system call inside kernel unless inside certain critical thread detect conflict transactional thread actually update state usually acquire lock kernel data structure thread simply lose conflict state process abort transaction many time kernel still prevent starve transaction place process wait queue next time make state exclusive attempt access list conflict cur description rent owner write read number allow provide access read allow may task number transactional allow conflict active thread may perform operation transaction must first upgrade read write mode table three state transactional list multiple state allow list tolerate access pattern would conflict previous transactional system call kernel reschedule process transaction commit kernel thread thread hold interrupt handler additional restriction conflict thread hold one semaphore otherwise risk deadlock transaction might need lock commit use kernel lazy version management flexibility transactional thread previous transactional operate minimize conflict list kernel rely heavily link list data structure apply list simple conflict semantics produce number false instance two allow add list even though add element list write adopt previous transactional memory define conflict list precisely isolate list update lock define conflict accord state describe table three instance list write state allow concurrent transactional long access entry individual transactionally add remove annotate transaction pointer use detect conflict write transaction also attempt read list content must upgrade list exclusive mode abort read state behave similarly design allow maximal list concurrency preserve correctness manage transaction state manage transactional state add transaction object kernel store statistics transaction kernel thread control block point transaction object show figure three thread one active transaction though flat nest mean nest subsume enclose transaction thread multithreaded application transaction multiple thread even different process may share transaction discuss section figure three summarize field transaction object transaction include status word status another thread win conflict thread update word atomically instruction kernel check status transaction status do commit undo abort figure three data contain system transaction object point user area word attempt add new shadow object check commit transactional system call reach point complete conflict another thread must immediately abort execution abort require write unmanaged language safely follow consistent view memory allow rollback arbitrary point execution transaction store register state stack begin current system call field system abort transaction midway system call restore register state jump back top kernel stack like c library function transaction hold lock resource abort support abort involve small overhead track certain within transaction clean abort must defer certain commit time free memory deliver signal file system monitor ie field store similarly must undo transaction abort release lock hold free memory allocate store field field use contention manager see section field store number time transaction abort skip list store reference object transaction private copy list sort kernel lock discipline fast commit entry contain pointer stable object pointer shadow copy information whether object set commit abort lock unlock release transactional thread add object thread reference count stable copy increment prevent object unexpectedly free transaction still active reference kernel object dynamically ensure nonzero reference count sufficient guarantee memory address remain unchanged duration transaction commit protocol system transaction call ready begin commit protocol flow commit protocol show figure four first step transaction acquire lock keep sort accord kernel lock discipline enable fast commit eliminate possibility deadlock among commit specifically object sort kernel virtual address header follow list sort kernel virtual address list lock last maintain order directory traversal code figure four major step involve commit transaction change mode commit code first lock replace header data pointer shadow finally transaction free use transactional bookkeeping unlock iterate object twice acquire block lock second time acquire nonblocking lock careful acquire block lock release block lock acquire release semaphore process sleep sleep hold deadlock system acquire lock transaction final check status word atomic instruction set abort transaction successfully commit instruction transaction linearization point commit process hold relevant object lock commit thereby exclude transactional thread would compete object acquire lock transaction copy update stable object transaction bookkeeping data remove object lock release release transaction perform defer like memory deliver file system monitor perform pending write stable storage commit hold lock otherwise hold time kernel result extend lock discipline slightly instance require rename lock order kernel virtual address also introduce additional lock object list lock although additional complicate lock discipline also allow elide lock protect update hash table directory cache memory eliminate lock improve performance individual system call abort protocol transaction detect lose conflict must abort abort protocol similar commit protocol simpler require object lock transaction hold kernel lock first release avoid stall process transaction iterate work set lock object remove reference object transactional state unlock object next transaction free shadow object reference count stable transaction walk undo log release memory allocate within transaction swap new data order transactional memory system use system system must commit application state commit system transaction section provide commit major class use simplify variant commit protocol seventeen commit transaction system transaction commit consist follow step one user prepare transaction two user request system commit transaction system call three system commit abort four system communicate outcome user return code five user commit abort accordance outcome system transaction protocol naturally follow flow control user kernel require user transaction system support prepare state define prepare transaction finish add data work set safe commit currently lose conflict thread guarantee remain able commit win future conflict end protocol word transaction prepare another thread must stall rollback try perform conflict operation system use lock protect commit prepare accomplish simply hold lock require commit call successful commit system commit state user compete access share state serialize user commit depend implementation detail user implementation additional integration effort may require implementation instance lazy need ensure transactional write system call issue correct version buffer optimization check return code system call within transaction detect abort system transaction sooner examine commit add extra return check sufficient hardware transactional memory use single instruction respectively perform commit prepare stage unnecessary instead commit protocol kernel issue commit instruction behalf user kernel validate system transaction commit abort together depend upon result specific commit instruction support require hardware allow kernel suspend entry kernel every proposal support os support suspend avoid mixture user kernel address hardware transaction mix user kernel address create security vulnerability also kernel need able issue instruction behalf application though support run commodity hardware require special support six kernel section discuss various kernel support semantics several case transactional semantics need develop scratch implement extend functionality already present subsystem example use journal provide true durability leverage support defer signal delivery manage signal send transactional thread transactional file system simplify task write transactional file system detect conflict manage data virtual layer os provide transactional semantics update detect conflict file system need provide ability atomically commit update stable storage via journal ensure commit change write single journal transaction convert transactional file system file automatically transactional use within system dominant paradigm application development composition simple powerful utility program complex task follow pattern may wish transactionally fork number child process execute wait result return pipe support program paradigm natural way allow multiple thread participate transaction thread transaction may share address space multithreaded application thread may reside different address space thread transaction share synchronize access speculative state process fork child inside transaction child process execute within active transaction perform exit exit consider implicit transaction commit task transaction issue method process management allow transactional program call convenience function like system easily create process use full complement functionality program run transactional semantics though might contain explicitly transactional code child process commit longer part transaction subsequent call begin completely independent parent system call modify process state example allocate memory signal faster transactionally fork task process system state abort simply terminate process rollback require signal delivery signal semantics provide isolation among thread different well isolation transactional thread signal send thread part source transaction defer commit place deferral queue regardless whether receive thread transactional signal queue deliver order transaction commit discard transaction abort thread begin transaction flag specify whether incoming signal deliver speculatively within transaction speculative delivery defer commit defer delivery speculative delivery enable transactional responsive input signal deliver speculatively must log transaction abort signal receive thread sender perspective signal disappear transaction speculatively receive signal commit log signal discard signal delivery defer incoming signal place queue deliver order transaction commit abort defer signal allow ensure atomic respect signal enclose signal handle code transaction ensure system call handler atomic force call handler serialize transactional handle signal eliminate race condition without need additional complexity address signal handler atomicity within single thread make make signal atomic respect thread application block ignore signal outside transaction preserve special status signal deliver directly transactional thread even transaction start defer delivery mode speculative defer delivery apply delivery incoming signal send thread different transaction commit transaction send signal thread outside transaction buffer commit thread transaction send receive signal freely thread transaction future work yet provide transactional semantics several class os currently either log warn abort transaction attempt access unsupported resource programmer specify behavior via flag subsection consider challenge inherent support leave future work network network among important within system transaction network communication could buffer delay commit could send logically roll back communication protocol transaction abort network often write explicitly tolerate repeat request drop reply would cause restart open challenge find combination high performance across wide range network retain reasonably simple transaction communication currently support kernel thread system transaction support transactional signal pip range remain could support include system v share memory message queue local much common network present additional relevant task system system admit creative approach abort transaction receive message transaction later abort user exchange message user inside transaction unlikely become popular paradigm although transaction cross text abort nature user natural fit transactional program model like communication channel however os could naturally support read write user io device buffer relevant data maintain responsive user interface likely mandate keep involve short log may wish explicitly exempt certain output isolation inside transaction primarily log log useful abort also important security sensitive instance authentication utility may wish log fail attempt minimize exposure password guess attack attacker able subvert policy wrap utility transaction abort password guess system reasonably integrate system however extend may complicate program interface slow implementation future work determine system worth cost seven evaluation section evaluate overhead system well behavior several case study transactional installation transactional server transactional file system elimination race scalable atomic integration hardware transactional memory perform experiment server one two total four eight core run four memory experiment use machine take use eight core machine compare unmodified kernel version version extend create hardware transactional memory experiment use version simulate machine sixteen level one four level two cache miss cost cycle miss cost cycle use contention management policy linear restart system call key goal make transaction support efficient take special care minimize overhead incur evaluate performance substantial measure average compilation time across three build kernel unmodified three second three second slowdown less two indicate negligible scale single system call however average overhead currently could cut fourteen improve compiler support table four show performance common file system system call run system call one million time discard first last average remain time elapse cycle measure use instruction purpose table analyze transaction realistic use case system call already atomic isolate wrap single system call call access open unlink link read write base static ten ten eleven twelve twelve eleven eleven seven eleven eleven twelve thirteen sixteen eleven eleven eight fourteen thirteen fourteen fifteen fourteen twelve thirteen nine fourteen thirteen thirteen seventeen thirteen thirteen eleven thirty thirteen eighty seventy thirty table four execution time processor cycle common system call performance relative base basic overhead introduce data structure code move without overhead transactional list static emulate compile two kernel function one transactional code one code include transactional list possible compiler support indicate current speed system call indicate speed system call another process run transaction background cost system call inside transaction exclude include system call transaction worst case performance little work across amortize cost create shadow object commit base column show base overhead add geometric mean three twenty include performance improvement write incur mostly increase lock extra indirection necessitate data structure reorganization separation header data object low show transactional support significantly slow activity replace simple link list complex transactional list transactional list allow concurrency eliminate transactional conflict introduce lock list expense higher latency static column add due transactional list base roughly ten though link static column assume compile two system call one use transactional thread use thread prototype use dynamic check frequent expensive compiler support achievable column present current prototype dynamic check determine thread execute transaction column system call active system transaction different thread system call need perform extra work detect conflict background column show overhead system call system transaction overhead high represent rare use case column include system call table five show performance range measurement average three run slowdown relative also list postmark file system simulate behavior network news client use version transaction amino small file operate file large file read write file rab modify scale modern initially rab create file contain content next measure execution time four distinct phase phase create phase copy generate file result copy file phase calculate disk usage file command phase search file short string find content size phase choose take roughly similar amount time test machine transactional version phase wrap transaction make wrap compilation transaction install installation wrap entire installation transaction discuss follow subsection across overhead system quite reasonable twelve often system speed postmark small file create rab phase repeatedly write file transaction large file sequential write small file create phase efficient transaction commit group write present io improve disk arm schedule increase locality block outperform much factor require extra memory buffer update survey several memory focus small large two representative sample utilization pattern vary across different portion physical memory consider low memory use kernel data structure separately high memory allocate page cache buffer file content memory high memory proportional amount data write large write large stream data use thirteen high memory whereas small write many small file introduce less one space consumption overhead look page cache isolation allocate many page unmodified pressure kernel reserve portion physical memory low memory five higher across overhead come primarily kernel slab allocator allocate much memory slab bench postmark small create read delete large write read write read rab make install two acid nine six four three nine seventeen two fourteen thirteen three eight nineteen three fourteen two eleven three nine one twelve twenty three two ten fourteen eleven ten fourteen seventeen two fifteen four eight seventeen fourteen five twenty sixteen three nine one thirteen six eleven five ten two two eight nine eleven eleven seventeen table five execution time second several transactional slowdown relative represent acid represent durable full data use general allocation via common kernel object like memory use indicate buffer transactional update memory practical especially consider trend toward dram address installation wrap system command transaction extend make make install package manager provide acid installation first test make build text editor version consist source file total line code next test make install installation subversion revision control system version finally test package version package modify restart daemon script responsible send signal wait run daemon exit defer signal commit script could rewrite match signal production system table five show overhead add quite reasonable especially consider qualitative benefit instance check return code transactional wrapper able automatically roll back break build concurrent task able access invalid package file installation transactional server many fairly modest concurrency control stable data storage yet use heavyweight server example lightweight directory access protocol commonly use authenticate maintain contact information large system provide simple lightweight storage solution demonstrate system provide lightweight concurrency control server modify server flat file storage module call back end search single search add twenty table six throughput query per second server higher better add increase throughput list parentheses storage module use use flat file consistency update augment storage module use system flat file provide crash consistency guarantee double write throughput use system server support number storage default use distribute load generation exercise server run mode table six show throughput unmodified storage module storage module augment simple cache use system search single experiment exercise server single item read request whereas search column submit request give directory add test measure throughput add measure throughput read performance search single search storage module within three read serve cache throughput request modify add delete however module use file lock synchronous write mechanism ensure consistency provide acid guarantee update compare read performance similar update record use system outperform provide guarantee storage module respect concurrency recoverability crash transactional addition measure durable validate correctness transactional implementation power machine series machine power back mount disk replay journal run disk validate consistent state verify result commit present disk partial result uncommitted visible facilitate script perform check use system successfully pass give us high degree confidence correctly provide atomic durable update stable storage eliminate race attack system provide simple deterministic method eliminate race system qualitatively validate claim reproduce several race attack recent literature validate prevent exploit attacker code use al six defeat dean probabilistic countermeasure eleven attack code create memory pressure file execution time five five system call allocate page table seven execution time number system call allocate page genome simulator sixteen allow programmer combine simpler system call perform complex yield better performance simpler implementation figure five compare unmodified implementation rename call link unlink divide rename across number thread worse performance make four system call system call quickly recover performance perform within six two outperform rename eight difference directly due use lock implement whereas must use lock maintain fast path rename keep implementation complexity reasonable experiment representative real show solve consistency modestly complex system call like rename either harm performance introduce substantial implementation complexity lock atomic pair outperform pair factor nineteen eight integration qualitatively verify system integrate exist transactional memory extend hardware implementation use system integrate system follow commit protocol commit user level transaction invoke system call add return code check abort system outline section test integration modify tornado multithreaded web server publicly available use tornado protect data structure transparently protect concurrent read write data file interfere original code use file lock one synthetic version faster seven thread integration hardware genome stamp transactional memory suite lack integration hardware system operate system result unavoidable memory leak genome allocate memory transaction allocation sometimes call transaction restart roll back allocator bookkeeping result system call thereby leak memory system integrate make part system transaction properly roll back transaction abort table seven show execution time number system call within transaction number allocate page end unmodified run roll back unsuccessful allocate figure five time perform rename divide across number thread lower better implement rename call link unlink use four system call every rename call despite higher overhead provide better outperform eight eight also outperform simple combination nineteen system cache force victim disk io thereby lengthen amount time spend check path name use additional time allow attacker win nearly every time victim successfully resist attacker read consistent view directory structure open correct file attacker attempt interpose symbolic link create conflict update occur transactional access check start put attacker sleep asymmetric conflict performance safe victim code statistically indistinguishable vulnerable victim demonstrate improve robustness preserve simplicity signal reproduce two attack describe first attack representative vulnerability present attacker induce signal handler second attack representative vulnerability screen utility exploit lack signal handler atomicity attack lead root compromise first fix use rather signal second modify signal attack wrap handler code pair provide signal handler atomicity without require programmer change code use experiment serialize handler code respect system therefore defeat attack concurrent performance system call like rename open use ad lack atomic action system call strong semantics rename atomic within file system result complex whose performance scale example rename serialize rename single lock would risk deadlock problem performance tune rename difficult would substantially increase implementation complexity entire file system include unrelated system call three less heap memory application performance affect source code change require detect transactional possibility leak know problem several propose include open nest transactional pause instruction previously propose complicate program model hardware system address memory leak hardware user feature low overhead kernel implementation root framework file simple programmer interface kernel transaction amino valor yes yes yes yes two yes yes three yes yes yes yes yes yes eight relate work section contrast previous research os transactional memory speculator transactional file distribute speculator previous transactional operate locus quicksilver twenty operate support use implementation isolate data structure lock roll back fail undo log shortcoming approach simple lock even lock capture semantics container object directory multiple concurrently safely create file directory long none use file name read directory unfortunately create file require write lock directory serialize write eliminate concurrency compensate poor performance lock allow directory content change transaction reintroduce possibility race condition system ought eliminate contrast implement system lazy version management sophisticate asymmetric conflict detection allow provide higher isolation level minimize performance overhead transactional memory transactional memory provide mechanism provide atomic isolate update application data structure transactional memory implement either cache coherence hardware twelve hybrid two eight ten al extend compiler support deferral rollback common system call perform memory transaction implement single application isolate transaction effect kernel thread different process ensure durable update file support need perform transactional installation support system support solve fundamentally different problem solve variant use hardware transactional memory synchronization primitive protect os data structure within kernel whereas export transactional user program use build enforce consistency kernel memory access within short critical however insufficient implement must guarantee consistency across heterogeneous system must support system span multiple system call require hardware transactional memory support whereas run currently available commodity hardware table eight summary feature support recent transactional file speculator apply isolation rollback mechanism operate system similar allow system speculate past remote file system transactional semantics provide user program complicate endeavor must isolate speculator design share speculative result access data speculator eliminate attack occur speculator attacker victim would part speculation allow attack succeed speculator extend parallelize security check system configuration fifty provide acid semantics speculation thus insufficient like atomic transactional file simplify task write transactional file system detect conflict data virtual file system layer previous work fifteen inversion provide file system interface implement server provide atomic isolate update local disk address problem access stasis transactional file amino support transactional file operation semantics interpose system call use rely store manage file system data file implement transactional semantics directly file system illustrate valor transactional also know fourteen table eight list several desirable transactional file system compare recent amino must host native file system use root file system use root file system programmer must ensure local system commit participate distribute transaction like valor provide kernel support page cache simplify task add new file valor support memory currently valor primarily provide log lock file directory require lock directory valor like quicksilver conservative necessary respect concurrent directory update provide kernel transaction manager commit across transactional individual still responsible implement rollback conflict detection support transactional registry addition vista introduce transactional registry kernel transaction manager allow create kernel transaction object transactional update transaction commit individual kernel component must implement rollback conflict detection contrast minimize work require file system provide conflict detection isolation share virtual code also represent different point design space transactional application require transactional access explicit whereas allow unmodified wrap transaction require system call explicitly transactional conservative design unsupported compile whereas detect dynamically key downside interface require individual application aware access deadlock completely unrelated system access two file opposite order implement system contrast deadlock arbitrate conflict accord section without expert knowledge developer provide simple natural interface augment three system call table two transactional file require application understand implementation detail deadlock detection log lock mechanism valor distribute number include sinfonia three provide support distribute transactional language library level service isolate system without os support nine conclusion paper argue system natural way synchronize access system problem currently solve ad manner support system include file system signal memory allocation process management although system limit size scope involve solve number important number include file system race condition paper describe novel implementation system efficient minimize effort require extend transaction support additional convert give file system implementation transactional file system ten extend thank bond nightingale jean yang anonymous careful read draft shepherd valuable feedback also thank help develop research support career award computer science study panel phase one thank academic site license program equipment donation eleven reference one two three k merchant shah c sinfonia new paradigm build scalable distribute new york four j security ten ten five c e c lewis k martin atomicity fourth annual workshop duplicate debunk six n r n fix race fun profit abuse security seven x r exploit race via algorithmic complexity attack eight c j n j c k effective hybrid transactional memory system strong isolation guarantee nine c c wright g kernel protection temporary file race security page ten p lev v hybrid transactional memory eleven dean j fix race fun profit use access two security page twelve dice n transactional lock disc page thirteen secure file handle eight fourteen e gal transactional flash file system fifteen n h v w file system interface sixteen h st file system seventeen j gray note data base operate operate advance course eighteen j gray transaction process morgan nineteen l v wong b j b prabhu h c k transactional memory coherence consistency june twenty r g recovery management quicksilver six one e transactional boost methodology transactional object v n transactional memory data structure p j wing correctness condition concurrent object twelve three transactional memory operate system kulkarni k b walter g k l p chew optimistic parallelism require new york press j r transactional memory morgan h e e commit conflict c porter h bhandari e use manage transactional memory operate system b p r internals implementation press p j e al full f j experience system simulation platform computer quicksilver p pull buggy vista r sear e brewer stasis flexible transactional file information week p e exploit defer destruction analysis update operate system thesis thirty system restore c c j c k stamp transactional k e j j hill wood transactional memory j j k e l yen hill b swift wood support nest transactional memory n murphy vernal design implementation file system e b nightingale p j speculative execution distribute file system e b nightingale peek p j parallelize security check commodity hardware national vulnerability design implementation inversion file system w pugh skip list probabilistic alternative balance tree forty r j r goodman transactional execution program h c porter bhandari e storage transaction support file system international conference data engineer z j l r distribute reliable r e c p wright enable transactional file access via lightweight kernel fast fifty j improve configuration management operate system causality analysis hertz silva portably prevent file race attack path resolution technical report research report hertz silva portably solve file race hardness amplification fast e b yee dynamic detection prevention race condition file access security h j tack n swift safe io memory j j w page b k g j synchronization distribute operate system c p wright r g e extend acid semantics file system storage three two four deliver signal fun profit c l extend hardware transactional memory support wait action transact