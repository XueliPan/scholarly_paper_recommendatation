transactional memory operate system j e e porter bhandari abstract first operate system use hardware transactional memory synchronization primitive first manage modification first transactional memory modification architecture support general specifically paper describe measure model support greatly benefit new primitive call transactional allow lock protect data maintain advantage synchronization integrate architectural support eliminate priority inversion several one introduction increase performance hardware turn away scale clock speed focus scale number core chip increase performance new hardware require find ways take advantage parallelism make available multiple hardware process burden place directly programmer new hardware increase performance user unless something do make concurrent program easier need accessible approach parallel program increasingly urgent current approach achieve concurrency use parallel program rely heavily thread multiple sequential flow control thread execute time use lock protect critical section lock guarantee mutually exclusive access share unfortunately parallel program use thread lock remain quite difficult even experience lock suffer number long lament deadlock convoy priority inversion compose poorly require complex order discipline use multiple lock also unattractive associate lock lock simple reason sacrifice concurrent performance lock may enable high performance make code complex harder maintain dependent difficult express enforce focus much recent research attention technique provide performance lock code complexity lock program model greatly simplify parallel program programmer demarcate critical section may access share data sequence memory either execute completely commit effect abort system responsible ensure execute atomically either completely isolation mean transaction see effect active visible system commit provide abstraction completely serial execution critical section system actually execute optimistically allow multiple proceed concurrently long atomicity isolation violate programmer benefit system provide atomicity reason partial critical section longer necessary compose suffer deadlock freely compose base provide efficient hardware implementation appropriate use os operate benefit use provide simpler program model lock instance operate system lock discipline specify order lock must acquire avoid deadlock discipline become complex time difficult master require order discipline many spend significant fraction kernel make system call read write file another benefit os increase performance user program without modify recompile however management support operate system require innovation architecture operate system simply replace eliminate lock operate system two main reason first many kernel critical section perform io actually change state like disk network card io problem assume conflict occur one transaction abort roll back start however os perform io actually change se ember vol n nine research highlight state device write data network revert previous state write operation complete transaction perform io roll back second reason kernel critical section highly currently lock efficient highly critical section contention optimism unwarranted perform system significantly reduce performance transactional new primitive address problem io allow lock work together protect data maintain advantage previous require every execution critical section protect either lock transaction allow critical section data structure access different critical section sometimes protect lock sometimes transaction dynamically automatically choose lock attempt execute critical section default processor detect io attempt roll back ensure thread critical section exclusively block transactional thread additionally provide convenient convert code use enable solution problem priority inversion due lock priority inversion occur high priority thread wait lock hold low priority thread demonstrate necessary hardware nearly eliminate priority policy inversion moreover os improve schedule help manage high contention leverage thread transaction history calculate thread dynamic priority conflict thread paper make follow one two three four creation transactional operate system base kernel among program use first use inside kernel novel mechanism transactional synchronization critical region transactional call transactional non transactional thread exploit greater parallelism enable novel mechanism handle io within perform io restart hardware acquire conventional lock mechanism nearly eliminate priority inversion two primer section provide background parallel program lock give overview program c om vol nine thread synchronization lock current parallel program practice rely heavily thread abstraction thread sequential flow control private program counter call stack multiple thread may share single address space allow communicate memory use share thread make possible single logical task take advantage multiple hardware instruction example move task different process execute parallel thread allow application remain responsive get work do wait input slow device disk drive human be multiple parallel compute resource hardware level multiple thread parallel compute resource operate system level thread require synchronization share data communicate memory avoid race condition race condition occur thread access data structure concurrently way violate data structure instance race condition two thread insert link list could create loop list synchronization eliminate race condition maintain data structure like every list null terminate lock allow thread synchronize concurrent access data structure lock protect data structure enforce mutual exclusion ensure one thread access data structure time thread exclusive access data structure guarantee see partially complete change make thread lock thus help maintain consistency share lock introduce many challenge program model deadlock priority inversion importantly though often mismatch programmer real need intent critical section express consistency constraint lock provide exclusion ultimately programmer enclose set critical section represent assessment must execute atomically either completely isolation without visible partial update order preserve consistency data manipulate critical section provide hardware support precisely abstraction atomic isolate execution critical section lock provide abstraction conservatively ensure two thread ever execute critical section concurrently contrast provide abstraction optimistically allow concurrent execution critical section detect isolation dynamically restart one response revert state change do transaction transaction commit result globally consistent order many lock like lock sequence lock lock reduce amount exclusion give critical section improve performance allow thread concurrently execute critical region however use particular particular critical region read data structure lock reduce performance lock reduce complexity fact increase complexity code must continue reason whether particular lock variation still safe particular critical region hardware primitive definition instruction begin transaction instruction commit transaction instruction restart transaction synchronization replacement synchronization sequence lock simpler reason lock improve performance eliminate lock coherence cache miss associate improve allow concurrent execution thread attempt update data compose thread execute transaction call module start another transaction second transaction nest inside first contrast lock compose one function take lock call another function eventually try take lock thread deadlock research transaction nest semantics active flat nest nest subsume outermost transaction easy implement use flat nest pattern transaction nest free deadlock design share key high level feature manage detect conflict call conflict detection handle conflict occur contention management table provide glossary define important list add machine show italics generic design show italics specific start end respectively start transaction cause hardware enforce isolation read write memory transaction commit update become visible rest system commit instruction provide mechanism explicit restart set memory read write transaction call respectively conflict occur two intersection one transaction union read another transaction informally conflict occur two access location least one access two conflict one proceed select discard change restart execution implementation policy choose lose transaction responsibility contention manager contention manager implement hardware underlie contention management impact advance issue contention management include asymmetric conflict one instruction get current transaction identifier zero currently active transaction instruction save transaction state suspend current transaction use receive interrupt instruction restore previously save transaction state continue transaction use interrupt return value variable equal argument enter variable transaction transaction ex return true otherwise return false enter variable compare swap instruction subject thread contention manager policy conflict one transactional thread write address read write another transactional thread asymmetric thread read write address conflict write read write transactional thread also contention know violation strong isolation multiple thread attempt acquire resource access particular data structure transaction encode information current transaction status word include reason recent restart return conflict access perform thread outside transaction three operate section discuss motivation use synchronization operation system consider common approach change program use use operate system modern operate use available hardware parallel finite hardware among many user process concurrently os delegate critical task service network swap unused page independent kernel thread schedule intermittently process one kernel thread kernel thread schedule directly os result aggressive parallelization os work substantial share kernel data structure across multiple thread within kernel task appear unrelated create complex synchronization os consider example code figure one simplification file system function function invoke update parent directory modify time file access update delete two separate user process write different file directory concurrently two kernel thread call function se ember vol nine communication research highlight time update parent directory modify time manifest contention parent directory p p well lock os provide abstraction single sequential operation involve single thread control thread coexist kernel even os manage access different file different program use concurrently result os must synchronize access ensure integrity data structure involve maintain good performance presence share pattern many require great programmer effort make synchronization lock protect minimum possible data however synchronization make os program maintenance difficult one comprehensive study bug bug involve synchronization another find four confirm eight unconfirmed deadlock bug kernel complexity synchronization evident source file c fifty line comment top file describe lock order use file comment describe lock use call depth four function file lock component must know lock take another component order avoid deadlock help reduce complexity synchronization like function multiple lock involve os must follow lock order discipline avoid deadlock would unnecessary lock illustrate release subsequent acquisition p could elide function call different parent code still force serialization lock however allow concurrent critical section data modular lock provide greater concurrency lock operate benefit convert figure one also illustrate common paradigm introduce program map lock acquire release transaction begin end respectively first approach take use call feature static instance result convert also convert base profile data collect lock use nine convert use take six year create ultimately convert approximately thirty dynamic lock call use conversion kernel expose several serious challenge prevent rote conversion operate system like use include idiosyncratic use lock function control flow difficult follow heavy use function importantly io order ensure isolation must able roll back effect transaction lose conflict however roll back processor state content physical memory effect device io hand roll back execute io part transaction break atomicity isolation transactional design guarantee know output commit problem six computer system function figure one perform io kernel function correctly transaction abort alone insufficient meet synchronization need figure one three adapt file system function handle update parent directory file access update delete leftmost version use lock middle version use bare correspond code rightmost version use correspond note function io void p p p p p p p p void p p p p p p void p p p p p p p p c vol nine operate system critical section protect lock restart may freely perform io always need lock synchronization operate system operate able take advantage wherever possible give lock coexist realistic implementation lock essential four lock order allow conventional lock operate system propose synchronization afford seamless integration call transactional allow different single critical section synchronize either lock freedom enable concurrency possible enforce safety lock necessary lock may use io protection data structure read hardware page table access particular data structure performance might suffer excessive restart also provide simple upgrade path let kernel use place exist synchronization necessary kernel allow user program model remain simple need directly access io operate perform io call os block direct user access common os design decision allow os safely multiplex among user program sophisticate user program want lock coexist use require use conventional within possible maintain mutual exclusion however conventional reduce concurrency lack fairness conventional prevent multiple transactional thread execute critical region concurrently transactional thread critical region must read memory location obtain lock must write obtain lock release write share among transactional thread prevent concurrent execution even concurrent execution real work critical section safe moreover conventional help io problem transactional thread acquire restart therefore perform io progress transactional thread unfairly throttle thread use conflict transactional thread asymmetric conflict always resolve favor thread provide isolation guarantee either thread always win asymmetric conflict like transactional thread always win asymmetric conflict like either convention traditional unfairness transactional thread transactional allow single critical region safely protect either lock transaction thread perform io inside protect critical section without concern undo restart many transactional thread simultaneously enter critical section protect share data improve performance simple return cod allow choice lock make dynamically simplify programmer reason ensure set allow transactional non transactional code correctly use critical section maintain fairness high concurrency multiple transactional thread may enter single critical section without conflict lock variable thread exclude transactional thread enter critical section transactional thread poll use instruction allow thread check value lock variable without enter lock variable transaction enable transaction avoid restart lock release another thread write lock variable especially important acquire nest thread do transactional work attempt acquire thread acquire use instruction arbitrate transactional contention manager enable fairness lock contention manager implement many favor thread thread transactional figure two show implementation acquire use two function function take lock address argument replacement safe almost lock do kernel page table lock lock whose ownership pass thread protect run queue optimistically attempt protect critical section use code path within critical section protect require mutual exclusion transaction restart acquire lock exclusively code figure one fail due io bare function take advantage optimism function io retry exclusive access control always require mutual exclusion always perform io optimize access data structure may execute transactionally use allow different critical synchronize mix se ember vol nine communication research highlight figure two implementation attempt execute critical section start transaction use spin lock free critical section attempt io hardware retry transaction return flag instruction result call wait lock free acquire lock use instruction atomically compare swap lock variable invoke contention manager arbitrate conflict lock exit critical section either end current transaction release lock use restart io attempt acquire lock contention manager release critical section void lock status else lock return void lock one lock one lock one zero break void lock else lock one assure maximum concurrency maintain safety convert conversion kernel replace select bare replace address os context make possible convert lock make possible much quickly contrast six developer require create require single five aware schedule section describe allow os communicate schedule hardware conflict manger hardware subvert os schedule policy priority policy inversion lock invert os schedule priority result thread wait thread like deal priority inversion priority inheritance wait thread temporarily donate priority thread hold lock recent implement priority inheritance well priority inheritance complicate technique shorten length priority inversion eliminate addition require conversion block conversion provide upper bind latency face priority inversion slow response time overall eliminate problem simple hardware contention management invert os schedule priority focus simple hardware contention management guarantee free deadlock transaction policy c vol n nine deadlock refresh transactional transaction eventually become system succeed process higher os priority start transaction process lower priority start one conflict policy allow lower priority process continue violation occur higher priority process force restart lock invert schedule priority schedule policy well support soft process like allow thread synchronize thread synchronization policy inversion thread wait thread policy inversion serious priority inversion process regular process higher priority os treat differently process exist always schedule process priority inversion many contention management bring policy inversion lock domain contention manager respect os schedule policy largely eliminate policy inversion contention manager system nearly eradicate policy priority inversion contention manager invoke one transaction intersection union read another transaction contention manager resolve conflict favor thread higher os schedule priority experience priority inversion contention management use os priority eliminate priority policy inversion interface os communicate schedule priority policy hardware contention manager mechanism suggest implement novel contention management policy call policy hybrid contention management first prefer transaction schedule value os give small number schedule priority value tie conflict priority rare next employ hybrid contention management policy induce total order therefore single register architecture allow os communicate schedule contention manager encode process dynamic schedule priority schedule policy single integer call conflict priority write privilege status register process schedule process register write os user code change value value register change schedule quantum instance schedule policy might encode upper conflict priority schedule priority lower value sufficient record priority value process upon detect conflict contention manager favor transaction whose conflict priority value policy free deadlock conflict priority compute instruction execute os never change conflict priority lifetime transaction design allow continue multiple schedule quanta equal default default set size equal hence conflict priority size age induce total order make policy free deadlock six evaluation run machine simulator version follow experiment model machine sixteen one instruction per cycle memory hierarchy use split instruction data cache sixteen cache line cache hit miss level one data cache extra tag manage transactional data unify second level cache four associative cache line cycle miss penalty main memory coherence maintain transactional snoop protocol main memory single share one disk device model data transfer fix access latency script require user interaction evaluate number application p denote number make j p compile part source p instance configure configure script subset p tree compile phase instance find search directory file p model activity web cache p instance instance stress test split across p process important note none use directly exercise kernel turn use synchronization performance figure three show synchronization performance use bare use sixteen break time spend spin lock time spend abort retry spend one six kernel time synchronize spend one twelve kernel time synchronize however average reduce synchronization time forty respectively generally reduce synchronization overhead double time lose loss due restart continue fail since substantial creation deletion small file single directory result contention file system code result pathological restart behavior file system code handle update high contention kernel data structure cause situation repeat restart effectively starve use restart technique handle high contention may insufficient complex transaction system may need queue consistently complete average show two slowdown sixteen two slowdown sixteen case result pathological restart situation discuss pathology present case figure three synchronization performance sixteen abort spin g n z n r h c n n e p e l e n r e k f n e c r e p fourteen twelve ten eight six four two zero x n l x n l x x n l x x c x n l x x n l x x n l x x c x n l x x x n l x x c x n l x x n l x x n l x x c x n l x x n l x n l x x n l x x c x n l x x x n l x x c x n l x find se ember vol n nine f research highlight bare without show sixteen see one sixteen performance negligible demonstrate conclusive performance increase however argument operate system reduce program complexity result show enhance without negative impact performance priority inversion performance figure four show frequently transactional priority inversion occur case priority inversion mean default contention management favor process lower os schedule priority decide win transaction conflict result contention management similar show significant percentage transactional conflict result priority inversion average across kernel test find priority inversion tend decrease number trend strict show increase higher processor count number distribution transactional conflict chaotic change number change conflict behavior contention management policy eliminate priority inversion entirely performance cost one contrast ameliorate priority inversion lock priority inheritance provide upper bind priority inversion require take performance hit turn poll lock block lock frequency naive contention management violate os schedule priority argue strongly mechanism let us os participate contention management communicate hint hardware seven relate work due limit space refer interest reader complete survey relate literature figure four percentage transaction restart decide favor transaction start processor lower process priority result transactional priority inversion result show sixteen transactional priority inversion thirty twenty fifteen ten five zero p ake find sixteen ninety c om vol n nine brief provide thorough reference research end give one design many since focus architectural support support overflow hardware involve date allow os use synchronization paper however examine issue arise use os os support goodman explore execution critical section fall back lock isolation violate similar less general technique execute transactional context revert lock io detect io io fall three basic camp give isolation escape delay io transaction guarantee thread perform io serious escape hatch introduce complexity correctness condition restrict program model easy violate common program delay io possible code perform io depend result device register read might return status word os must interpret order finish transaction finally guarantee transaction commit severely limit flexibility highly result serial bottleneck deadlock thread conflict guarantee thread force stall guarantee thread commit work likely lead lose timer interrupt deadlock kernel schedule operate implement sophisticate provide different class variety schedule class patch support priority inheritance help mitigate effect priority inversion work also address priority inversion patch implementation convert guarantee upper bind priority inversion policy allow contention manager effectively eliminate priority inversion without require primitive block involve eight conclusion paper first description operate system use synchronization primitive present innovative schedule lock demonstrate provide comparable performance lock simplify code coexist synchronization modern os primitive enable solution problem io ease conversion lock significantly introduction ninety synchronization primitive os reduce time waste synchronize average occur traditional lock high contention critical section large enough incur overhead aware schedule eliminate priority inversion investigate reference one ar lewis b v murphy b r b compiler support efficient transactional memory june two c j lewis e c martin k make fast case common uncommon case simple unbounded transactional memory three b h j c c k transactional program language june four yang j b study operate five w g j v g b unbounded transactional memory six e wang survey seven k effective static detection race condition eight l wong v b j b prabhu k h c k transactional memory coherence consistency june nine atomic block program three ten moss j e transactional memory architectural support data structure may eleven porter e c j h e e solve difficult without difficult hardware transact workshop twelve j r r transactional memory morgan thirteen j b c c h c k architectural semantics practical transactional memory june fourteen k e j j hill wood transactional memory fifteen j j k e yen l hill b swift wood support nest transactional memory sixteen moss e nest transactional memory model preliminary architecture sketch seventeen moss j e b n graham h abstraction recovery management fifteen two eighteen porter e e optimism optimistic concurrency warrant nineteen r goodman j speculative lock elision enable highly concurrent multithreaded execution micro twenty r goodman j transactional execution program h c porter bhandari e transactional memory operate system evaluate transactional memory h c e kernel challenge transactional memory workshop transactional memory june c j porter e h e b e use manage hardware transactional memory operate system w n l advance contention management dynamic transactional memory yen l j k e h hill swift wood hardware transactional memory cache j e e porter bhandari bhandari department computer university technology technology technology quarterly publication encompass many discipline computer engineer management security knowledge discovery data mine network distribute performance one roof toit bring sharper focus result individual discipline relationship among extensive coverage place new application social issue public shape development se ember vol n nine