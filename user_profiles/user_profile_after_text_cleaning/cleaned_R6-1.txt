conflict simplify concurrent language semantics precise hardware university research abstract argue paper concurrency treat ie behavior precise semantics propose exception model base conflict precisely detect broad class show provide enough guarantee simplify program language semantics significantly enforce traditional detection make performance cost enforcement negligible propose architecture support accurately detect precisely deliver evaluate suitability model well behavior architectural use parsec suite commercial result show exception model largely reflect already write code main memory traffic performance enforcement propose low subject processor multiple data stream program concurrent program program language construct feature general term design reliability memory consistency model thread bug detection permission make digital hard copy part work personal classroom use grant without fee provide copy make distribute profit commercial advantage copy bear notice full citation first page copy otherwise republish post redistribute list require prior specific permission fee ten june copyright one introduction become pervasive grow need simplify process develop share memory parallel program nature share memory particular make hard test parallel program moreover similar concurrency bug manifest normally lead either data corruption crash well past point buggy code actually execute finally major program language two twelve collectively issue lead severe reliability issue address follow approach make deliver exception race manifest ie code race allow execute treat major execution stop exactly point race happen also improve safety exception either exit program avoid delay could trigger recovery action prevent misbehavior importantly support behavior major specification program two twelve avoid define semantics thus eliminate need complex least satisfactory piece example memory model specification eight support one detection mechanism false two must strong precisely define three performance degradation need negligible use four exception delivery need precise ie instruction trigger exception execute prior must complete believe hardware support instrumental achieve negligible performance cost several past hardware support concurrency bug detection take approach enable cost accurate detection higher state overhead performance cost unfortunately approach unsuitable us require precise semantics low performance cost hand implement precise race detection sixteen seventeen vector clock expensive address issue propose exception model still fully precise incur high cost race detection fundamental observation race sufficiently distant execution therefore directly affect leverage observation propose new property separate synchro execution interact concurrently execute execution either race racy access sufficiently distant one another detect property much full detection associate additional access information primarily cache data add reasonable overhead cache area negligible main memory overhead make follow one present case behavior argue hardware support enabler two propose exception model provide benefit full race detection without prohibitive cost three propose reference architecture implementation base standard coherence protocol cache four evaluate propose architecture support well suitability exception model remainder paper explain problem provide background section two describe exception model discuss formally specify guarantee section three appendix describe architecture support section four provide detail evaluation model hardware section five finally discuss relate work section six conclude section seven two background motivation memory model language architecture memory consistency model program language define value retrieve share memory access must obey across entire system stack include compiler system hardware memory model sequential consistency execution behave global interleave memory although sequential consistency simple define leave little room compiler hardware perform example compiler design allowable special condition sequential consistency impose give rise variety work relax memory model relatively recently concentrate primarily hardware community three occasional largely disconnect effort program side last decade become pervasive relax memory model start receive attention program community bring light number prior approach thirteen many case reflect historical disconnect hardware program language sequential consistency program treatment share memory program converge normally term sequential consistency program four thirteen approach divide memory two synchronization lock volatile atomic data usual define two conflict access memory location least one write define two conflict concurrent access least one data long programmer prevent language implementation guarantee program language level variable scalar object field usually view memory location simultaneous access adjacent field constitute consistency apply example often use core specification thirteen next c standard unlike full sequential consistency approach allow hardware compiler reorder memory access code section synchronization possible freedom guarantee execution code section appear indivisible obvious benefit model compiler example loop nest synchronization optimize largely case less obvious benefit indivisibility execution program affect granularity data memory access double word intermediate value produce execute purely sequential library call example library routine store password global variable overwrite thread program observe password deal freedom contract programmer system easy understand difficult enforce statically even spite explicit prohibition program result race common program language leave semantics completely undefined way bind damage cause untrusted code contain make difficult race somewhat acceptable c like must guarantee security would violate untrusted code could somehow conjure reference object represent password undefined behavior prevent value hand successful attempt preclude elusive since many seemingly unimportant case surprisingly difficult distinguish real important compiler eight three ways deal one attempt define semantics program actually execute take route result entirely satisfactory overly complicate surprise unfortunate compiler optimization eight two design program language statically preclude race past variety static type effect one eleven nineteen propose ensure freedom yet widely adopt three continuously monitor dynamically detect problematic execute raise exception instead execute since program design safe treat error report programmer greatly simplify programmer job subtle accidental report directly point occurrence produce easily describable last alternative three explore paper problem race detection major obstacle treat implementation difficulty know report precisely even without hardware support sixteen seventeen unfortunately time space cost prohibitive use race check frequent potentially every memory access large amount state two standard base shall ensure access memory location one thread control thread process restrict thread control read modify memory location another thread control may modify thread k x rel k l rel l thread separate dash line represent note also form code outside critical section conflict exception deliver precisely region note even though conflict exception essence difference full conflict access conflict level x rel exception deliver figure one example conflict exception associate object vector clock potentially need remember time object last read thread determine whether write properly order respect read since object small may require many time stamp thread process possibly system every pair thread interact regularly think background thread fail synchronize thread long time case often find real large information may need maintain essentially indefinitely propose seventeen still result system mandate language specification use detection enforce freedom need precise detection mechanism time cost low space overhead gap fill propose exception model implementation preserve utility precise race detection fraction cost prior approach three conflict propose new property enforce freedom thread section execution demarcate synchronization region conflict mean region interact code execute concurrently must result free conflict execution may still conflict must separate potentially unrelated synchronization operation particular execution program conflict exception deliver right point execution conflict happen precisely right instruction cause conflict commit figure one show example thread three thread one note form code outside critical section construction never nest conflict memory location exception deliver right also note x race x generate exception execute concurrently illustrate key difference conflict detection conflict provide benefit de articulate benefit simpler program language semantics conflict provide follow nice one compiler hardware reorder memory access eliminate redundant load store within region without affect semantics program two always appear atomic thus semantics program independent granularity memory access moreover semantics library depend order memory access inside three execution guarantee sequentially even presence compiler hardware four fundamental program rule unchanged programmer need avoid need understand memory order issue program exhibit sequential consistency largely abstract complexity relax memory model five program exhibit much well define behavior current even malicious code try exploit introduce security hole violate atomicity expect facilitate reason security similarly code accidental violate property expose compiler might otherwise produce unexpected result manifestation race result enable natural reason buggy program make easier six need complex problematic causality rule two eliminate since sequentially consistent ever produce longer need choose comprehensible security note hardware enforce sequential consistency fifteen eighteen sufficient offer many nice conflict one two five compiler one often critical performance granularity independence two important appendix formally articulate guarantee conflict ex provide program language perspective benefit full detection free conflict ensure code segment interact way concurrently execute code equivalently every code section behave though execute indivisibly ie isolate main prove statement appendix fraction utility full race detection data access observe interfere effect concurrently execute region lead conflict exception likely cover large fraction observable manifestation although longer directly interfere region possible conflict miss race discuss however every miss exist schedule would lead conflict exception note full dynamic detection also miss race programmer perspective due coincidental intervene synchronization call key difference full detection conflict full detection fool manner thread perform match coincidental synchronization acquire release lock conflict fail detect conflict even result unmatched coincidental synchronization result acquire release different lock case though race would detect different schedule execution recovery action support although indicate thus violation program rule might reasonable continue execution may possible shut offend subsystem since raise visible may even feasible simply retry access continue log error four architectural support conflict support conflict three one interface two record memory access inside region granularity individual three monitor conflict concurrent deliver precise exception one occur natural implementation two three extend cache line keep access information leverage exist cache coherence perform monitor resemble conflict detection hardware transactional memory six thirty however afford monitor record access granularity line would lead false spurious unacceptable one major challenge face design interface system divide execution thread demarcate special intend usage scenario exactly encapsulate region ie code execute two synchronization thread code outside instruction singleton region code figure one synchronization implement singleton execution singleton within example read x later write x atomic update x also thread repeatedly call acquire release lock synchronization inside may impose order consequently prevent race particular thread schedule without hide result atomicity violation include note represent desire behavior singleton sequentially consistent behavior lead face conflict access singleton give thread preserve program order ie never reorder respect say region active begin end yet access raise conflict exception one write active region perform read write operation address two read active region perform write operation address exception deliver precisely actually commit previous thread commit inside singleton raise unless conflict explicit protocol state without loss generality describe protocol extension protocol maintain cache coherence within private cache state cache line associate four bite access contain many cache line access keep track within active region local thread well active remote thread table one describe local set local processor access data remote set coherence message coherence request carry local cache access set line name local read local write remote read remote write clear record read local thread active region write local thread active region read thread active write thread local read active set local read access end region local write local thread access local read write miss end region remote thread originally set bite write miss table one access bite associate cache line purpose description protocol operation protocol explain detail section basic description follow region start local clear access perform within region local bite set accordingly cache suffer miss receive local thread accumulate correspond remote logical operation region end local cache send message cache might access information remote clear accordingly local cache clear local access nest one active region per thread perform access cache check exception condition exception throw cache detect conflict local access remote active region local read access remote write bite set exception throw precisely operation perform table two enumerate possible conflict detect use access conflict local type access remote access raw read write waw write write war write read condition one condition two local write bite clear thread remote write bite set read thread remote write bite set write thread write remote read bite set local write bite clear table two conflict condition detect condition must true exception throw state type bite set local read local write three e remote read remote read remote write one two four five invariant local read bite set local thread read correspond within active region local write bite set local thread write correspond within active region remote read bite set cache least one thread local one read correspond within active region remote read bite set cache least one thread local one read correspond within active region remote write bite set cache least one thread local one write correspond within active region table three guarantee extend protocol table three show guarantee protocol invariant concern particular combination coherence state access second column show local state cache line third column indicate type access bite set invariant apply last column state invariant example consider invariant three cache line state modify exclusive remote read bite set least one thread local one read correspond within active region invariant three say write access complete require modify exclusive state cache remote read reflect exactly read thread within active guarantee remote read time exception check perform write access section explain detail hold add support coherence protocol addition access add supply bite cache line indicate whether line supply cache active region also add three cache one bite indicate whether local thread currently active region two supply bite use summarize whether cache line access within active region supply another cache three bite use indicate whether line access evict state use record information cache line store separate state table basic geometry number set ways cache show figure two table back main memory explain section basic operation explain protocol assume operation ie eviction line access set miss always service peer cache cover operation section write model operation protocol check introduce section indeed hold provide detail check section start region processor execute instruction set bite instruction effect full fence instruction exception check memory access within active region allow proceed cache perform exception check exception condition describe table two cache hit exception check cache set correspond local read write bite cache miss miss service line arrive local cache access incoming line accumulate remote access bitwise exception incoming write bite set correspond local write bite also set case remote access bite necessary keep invariant five table three global read miss cache indicate local read set request line line bring memory share state instead exclusive necessary keep invariant three table three service remote read miss request cache supply data read miss append reply message one bite indicate whether line local read bite set local write remote write supply set service remote write invalidate miss request cache receive write invalidate request send local read write requester set even line invalid state independent able supply data cache set supply invalidate cache line preserve supply access associate cache line end region instruction execute supply bite clear bite clear together supply local access supply bite set cache iterate supply append follow message line address correspond local read write cache line supply bite set message send cache may receive access end receive clear instruction act full fence process incoming message cache receive message check presence access address message remote bite present set cache check correspond bite message also set cache clear remote bite addition clear bite remote read bite cache line state allow write hit e line downgrade state disallow necessary guarantee remote read incoming write bite correspond local write bite set indicate cache suffer miss original writer case conflict exception would throw supplier cache do efficiently way distribution leverage directory instead indicate data directory could indicate cache share data supply access clear yet clear directory do lazily invalidate cache respond access avoid extra complexity table line offset cache tag tag tag tag tag global local table bite bite supply bite cache line local read local write remote read remote write supply bite figure two cache conflict exception detection new structure show grey processor write cache line avoid multiple read within active invariant three table three singleton memory access singleton set access therefore conflict access two singleton lead however singleton region conflict explicit region exception deliver instruction singleton region operation operation common case cache may occasionally evict cache line access set line evict supply local access set need save use three one cache evict line suffer another miss line two cache evict line end region three another cache suffer cache miss line choose save evict state two distinct structure memory local table table store list address access evict within active region use case one two global table table individually save supply local thread evict use three case global table organize hierarchically like page table index use physical address line augment cache two memory one table see figure two also augment directory state cache line bite indicate whether thread save access line memory extend operation describe save search restore access supply explain cache cache line evict supply local bite set line address save local table local save global table bite set directory notify set bite correspond line cache miss miss bite directory set thread local retrieve memory access global table correspond supply bite set retrieve memory remote together local receive cache bite set cache also search global table supply local read local write case previously evict restore end region bite set even supply bite set cache retrieve evict line address local table supply local global table append message supply bite set cache clear local ta process well correspond global table figure three show example operation simplicity involve cache line x two long cache active region initially cache write zero set local write bite zero one cache b suffer miss attempt write one send invalidation cache two invalidate line send data local read local remote write cache b three cache b receive remote read write perform exception check exception throw attempt write one complete write operation set local write bite one later cache c attempt read zero suffer miss send read request cache b four b respond data single bite indicate read clear local remote write five finally cache c receive response b ignore read bite transition share state receive write remote write ready perform exception check six exception throw cache c attempt read zero find remote write bite zero set indicate another cache write active region figure three b show another example read zero set local read bite zero one c read zero set local read bite zero two next b write one three collect local read c set remote read bite zero four c end region send message five message arrive cache b six b clear remote read bite zero downgrade line b suffer write miss zero seven send invalidate collect local read bite set remote read bite zero finally throw exception eight note line downgrade b would detect conflict figure three c show operation example simplicity assume single cache line x cache active first cache write zero set local write bite zero one cache evict line x send supply local read local write memory two point directory set bite correspond line later cache b suffer write miss attempt write one send write request directory three respond notify b another cache local memory four b perform global table walk retrieve local set correspond supply bite memory five b local retrieve remote check continue six notice b attempt write zero would correctly throw exception would remote write bite zero set even though retrieve information directly cache global table b c zero one zero one one w zero one one two w three zero one one zero one one one four r five resp six exception zero one eleven b c b one r zero one one zero one three w two r zero one one one w zero one one evict two one four global table walk three w five zero one one one six five four zero one one grade one zero one one six eight seven w end region exception zero one one b c figure three operation b operation downgrade c operation cache b c access cache line x consist two letter parenthesis show coherence state hold justify propose hold sufficient guarantee exception specification exception check do memory operation complete memory operation reach point cache controller must already perform relate coherence action line must stable state valid state read e state write guarantee remote need exception check time accurately reflect whether thread touch line within currently active region table four show protocol guarantee first consider twelve local read local write set clear base local follow directly local cache operation next consider column four say remote read bite set thread imply thread access correspond within still active region guarantee protocol remote always local thread protocol guarantee clear region set end consider invariant three column five say state line modify exclusive remote read accurately represent read access thread within active protocol guarantee invariant collect local read thread write miss transition exclusive state thread local read bite set notice invariant four guarantee access within active region one thread imply set remote read bite another thread cache line state own share issue state allow write hit conflict throw finally consider last column invariant five invariant concern remote write say accurately represent write access thread protocol guarantee invariant enforce exclusiveness serialization write cache line coherence ensure write set within active communicate cache supply cache line local write remote write guarantee writer set remote write line propagate subsequent system issue exception cleanup exception raise system still leave current region active support access need keep throughout execution handler however support must provide prevent handler code affect access access associate specific thread physical cache therefore architecture need context switch do extend thread context contain local global table supply bite bite bite save thread switch moreover cache line access need send log access reset note potential cost mitigate context switch tend happen synchronization point often case memory page disk os need associate correspond access local global table virtual address page send disk page bring back os need remap old new physical address state type bite set local read local write three e remote read remote write one two four five reason set bite imply access within active region reason access within active region imply bite set follow directly local access action set access clear region end read miss result exclusive state local read line set thread transition state require local read write thread remote combination local thread message clear remote previously set data supply cache include local cache enforce access happen remote write satisfy data supply cache write cache write later combination local remote write guarantee properly propagate table four reason hold exception check speculative load avoid control speculative load ie perform load might request programmer control path introduce issue appear experiment moreover typically replace five evaluation evaluation one understand costly protocol two assess space traffic overhead access storage transfer three assess suitability exception model experimental setup model check ensure correctness protocol operation use zing seven use three cache two per cache line four request could check due space explosion problem inherent model check believe configuration successfully check sufficient show indeed hold simulation evaluate performance use simulator base pin simulator faithfully model exception detection cache coherence protocol include operation give goal understand protocol simulator include time model model eight core cache line program write scratch assume exception model yet nevertheless model intuitive enough legacy program tend conform model leverage fact use exist parallel program evaluate architecture support section execution call consider ie return function call next call function include code outside critical section inside library consider singleton use parsec suite nine input set apache utility performance table five characterize dynamic region count size two three false share active large variance region size among example many small memory whereas large memory false share also vary significantly among performance evaluation purpose message access bite memory occur cache miss characterize message table five first note less two send message many time close zero column seven moreover message typically contain access handful line column eight many time single line however often must get information memory column nine find couple term percentage message term average number line per message even fraction message higher nine worst message contain line note size large enough amortize cost message expect false share also message tend show opportunity reorganize code reduce false share potentially eliminate message reduce number line message among desirable performance benefit overall message unlikely performance issue analyze main source access memory ten eleven table five show frequency remote access bite column ten happen thread need fetch access remote thread generally costly remote bite infrequent never seven per million memory low highest cost frequent false share lead increase remote bite local bite column eleven occur whenever line access evict access region observe correlate cache miss rat rate local bite modest less ten every memory around one every high cache miss rat note remote local access bite happen cache miss fraction also unlikely lead performance degradation also reduce access bite victim buffer explore work mem false share mem message reg mem mem mem total ferret apache mean fifty region waw war raw w line mem zero eighty zero zero zero fourteen zero one zero zero eight seven zero zero zero zero six zero fifteen zero zero zero one two five zero zero nine zero eight zero one one three zero one one zero seven one two one one zero zero traffic reply zero zero zero seven zero three zero zero twenty zero thirteen zero eleven two two zero six zero six three one seven one one fourteen zero one five zero zero zero seven one zero one seven table five protocol detect conflict mem refer issue load store space traffic table five characterize storage traffic report maximum memory overhead keep local global table access fraction maximum application footprint column twelve memory overhead less often less one ferret highest overhead due frequent eviction line access case extremely long three source traffic overhead addition access coherence message thirteen fourteen send message column fifteen cost preserve access memory column sixteen dominant source traffic overhead send access memory line evict across overhead seventeen number tend high two case bad locality lead frequent ferret long longer likely lead work set much capacity cache nine result relatively frequent moreover relatively long average mem source traffic overhead much less function false share higher false share higher apparent higher derive cause still low overall one suitability analysis important use system support conflict write program familiar way show change run table six show code size column two fraction experience column three well number unique column four line code column five function column six involve several run unchanged experience involve fifty line code typically line function average group code suggest make change eliminate would hard examine code lead find handcraft synchronization common culprit instance use flag variable master thread line ferret ferret apache mean five nine thirteen thirteen zero fourteen zero zero zero zero five zero zero zero zero zero six one zero zero zero zero zero six one zero sixteen thirteen fifty zero zero zero zero four one twelve six seventeen table six number distribution throughout code similar mechanism use communicate loop termination condition thread case implement synchronization incorrectly use data variable eliminate throw synchronize around access flag change affect three line straightforward ferret many throw ferret employ pipeline parallelism pipeline stag task queue properly synchronize eliminate throw see ferret table six cause true race effect experimental could result unexpected behavior case aid guide racy code note although completely clear certain race find clearly disallow provide alternative correctly write code enable automatic insertion eliminate six relate work discuss accurate race detection section two addition desire behavior discuss recently informal twelve fourteen first concrete proposal al five address problem whether race detect execution necessarily reflect possible race execution hence represent race enforcement sequential consistency actively investigate fifteen eighteen forty hardware level definitely valuable provide many crucial guarantee simple language semantics precise race detection atomicity memory access granularity independence enforce sequential consistency share similar hardware approach conflict fundamentally solve different problem transactional memory namely provide behavior concurrency result miss incorrect synchronization oppose provide better synchronization primitive relate several ways two feature may prove synergistic precise conflict detection mechanism could use several current ten provide conflict detection result spurious transaction abort also much problem emerge transactional memory twenty detail implementation language semantics combine system beyond scope paper one could argue could convert guarantee would similar conflict although conceptually correct provide inferior functionality substantially increase cost use way could mask example consider identity function id happen acquire release lock unrelated x forget lock around atomically increment x either approach put around would eliminate hope detection still produce incorrect output conflict would correctly identify problem miss synchronization also cost approach higher form expect quite long would buffer amount data moreover conflict require neither memory support concurrently work al propose memory model address program language semantics issue address approach program either contain raise exception guarantee sequentially consistent execution unlike work guarantee atomicity bound short full thus provide guarantee programmer disallow common compiler especially unbounded loop return bind additional state need maintain detect conflict detect conflict lazily rather point conflict access therefore provide precise exception delivery seven paper argue behavior however provide precise race detection low enough cost challenge address challenge conflict provide enough guarantee significantly improve enable design simple parallel language semantics evaluation show conflict enforce low cost suitability study show exception model fact largely reflect already write multithreaded program support intuitiveness model go forward advocate hardware spend improve believe hardware help also provide enough guarantee even program rely thank anonymous helpful feedback thank group university invaluable feedback manuscript insightful special thank go dan joe work support part career grant research faculty fellowship eight reference one c type safe lock static race detection program two v memory model case rethink parallel hardware appear author preliminary version three v k share memory consistency model tutorial computer twelve four v hill weak new definition international symposium computer architecture five v hill b p miller r h b detect data race weak memory international symposium computer architecture six c b c c e lie unbounded transactional memory international symposium computer architecture seven k j zing exploit program structure model check concurrent concur eight j memory model good bad ugly vamp nine c j p singh k li parsec suite characterization architectural international conference parallel compilation pact ten j n hill swift wood efficient execution large hardware transactional memory international symposium computer architecture eleven r v dig r j p h sing type effect system deterministic parallel conference program twelve h simple thread semantics require race detection fit open group standard efficient correct execution thirteen v c concurrency memory model conference program language design implementation fourteen l j b case system support concurrency fifteen l j tuck p j bulk enforcement sequential consistency international symposium computer architecture sixteen goldilocks race conference program language design implementation seventeen c efficient precise dynamic race detection conference program language design implementation eighteen c b n international symposium computer architecture may nineteen p b program language concurrent engineer june twenty sun draft specification transactional language construct c version ten august program language c final committee draft march l make computer correctly execute program j lee hide relax memory consistency international conference parallel compilation pact atomicity via access interleave international conference architectural support program operate c k r r muth h p g v j k hazelwood pin build program analysis tool dynamic instrumentation conference program language design implementation j w pugh memory model symposium program singh simple efficient memory model concurrent program conference program language design implementation j f j j cherry early resource recycle international symposium micro thirty k k e j j hill wood transactional memory international symposium computer architecture j data race detection international symposium computer architecture c nelson concurrency memory model final revision c committee paper j use speculation data race multithreaded cod international symposium computer architecture w pugh memory model fatally flaw concurrency practice experience twelve six r k lai transactional memory international symposium computer architecture j b j tuck w l sarangi p sack k p simulator j validity program memory model conference program parallel program share memory program unite state department defense reference manual program language standard springer forty e f r p j e smith implement international conference pervasive service international symposium computer architecture p r hard race detection international symposium computer architecture appendix formal specification conflict thread execution consist sequence function categorize different load store tid assume disjoint set j f detect f b follow range correspond set e f r w e define follow set e e subset synchronization e e subset thread e subset load address e subset load e subset store address e subset store execution e source satisfy follow condition one e set two partial order e hence synchronization independent three map total order e overload refer partial order four map total order e overload refer five source map order e e e e source e e thus source provide load event correspond store event supply data give execution define two set e causal relation causal order store event w every load event r see value write w relation order load event r every store event w come later source r accord w r causal w source r r w e w e source r w execution address two e f e one e f unordered transitive closure two e store three f store f load set execution partition collection one three one set data thread first synchronization event two set data thread two synchronization three set data thread last synchronization event let projection onto set e e constraint graph execution graph r n r set execution n set edge define follow p q n p different q exist e p f q e order f transitive closure causal execution isolate constraint graph acyclic exception mechanism provide follow two guarantee one execution isolate two execution throw exception definition isolation also guarantee absence exception execution project onto data sequentially consistent present proof guarantee guarantee translate directly program language spec define specify program always execute interleave one simple adjustment second two access race execution may raise exception lemma one isolate execution project data sequentially consistent proof constraint graph isolate execution acyclic therefore must case transitive closure causal also acyclic hence partial order let l linearization partial order since l total order l clearly respect order perform thread since causal l total order l respect store load every load event e address return value write last accord l store event f prior e therefore total order l witness sequential consistency isolate execution