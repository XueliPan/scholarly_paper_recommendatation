Navigating in Complex Mashed-Up Applications∗

Daniel Deutch
Tel-Aviv University

Ohad Greenshpan
Tel-Aviv University &
IBM Research Labs

Tova Milo

Tel-Aviv University

ABSTRACT
Mashups integrate a set of Web-services and data sources,
often referred to as mashlets. We study in this paper a
common scenario where these mashlets are components of
larger Web-Applications. In this case, integration of mash-
lets yields a set of inter-connected applications, referred to
as Mashed-up Applications (abbr. MashAPP). While inter-
actions between the mashlets enrich the individual applica-
tions, they also render navigation within them more intricate
for the user, as actions in one application may aﬀect oth-
ers. To assist users in their navigation through MashAPPs
we provide a solution based on a simple, generic model for
MashAPPs and navigation ﬂows within them. Queries over
the model allow users to describe navigation ﬂows of in-
terest, and an eﬀective query evaluation algorithm provides
users with recommendations on how to navigate within the
MashAPP. The model and algorithms serve as a basis for
the COMPASS system, built on top of the Mashup Server.

1.

INTRODUCTION

Mashups integrate a set of Web services and data sources,
often referred to as mashlets. For instance, a health-care re-
lated mashup may integrate the following components (among
others): (1) a patient’s personal list of prescribed drugs, (2)
a pharmacies directory and (3) a map service. A mashup
may glue these mashlets by feeding the drugs list to the
(search facility of the) pharmacies directory, obtaining all
pharmacies oﬀering these drugs, and feeding addresses of
retrieved pharmacies to the map service, to present their lo-
cation. Such connections are called Glue Patterns (GPs)[11].
Previous works on mashups typically considered mashlets
as isolated atomic services [11, 17, 23]. In real-life, however,
mashlets are often incorporated as services within larger ap-
plications. For instance, the patient drugs list may be part
of an Electronic Health Record application (EHR); the phar-

∗This research was partially supported by the Israeli Min-
istry of Science, the Israel Science Foundation, the US-Israel
Binational Science Foundation, and IBM Research.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee. Articles from this volume were presented at The
36th International Conference on Very Large Data Bases, September 13-17,
2010, Singapore.
Proceedings of the VLDB Endowment, Vol. 3, No. 1
Copyright 2010 VLDB Endowment 2150-8097/10/09... $ 10.00.

macies directory may be part of a pharmaceutical Web site,
etc. The gluing of mashlets, in this case, yields a set of inter-
connected Mashed-up Applications (abbr. MashAPP). The
development of such MashAPPs is a current trend, and their
number, as well as the number of their users, are estimated
to signiﬁcantly grow in the near future [15, 16].

Users of MashAPPs may navigate, in parallel, in several,
interacting applications. For instance, consider a patient
wishing to ﬁnd out where her prescribed drugs are sold.
Without exploiting the interactions between applications,
she could navigate separately within the EHR, pharmaceu-
tical, and map applications: this may require her to login
to her EHR account, retrieve the prescribed drugs, then
login to the pharmaceutical application, manually search-
ing for pharmacies that oﬀer these drugs, then turn to the
map and repeatedly search for the location of relevant phar-
macies. Alternatively, she can exploit the MashAPP inter-
connections to complete her navigation much faster: she
may still need to ﬁrst login to her account at the EHR and
at the pharmaceutical application, due e.g. to security con-
straints imposed by the applications, but now a single click
on each prescribed drug feeds the data to the pharmaceuti-
cal application, that retrieves pharmacies oﬀering this drug,
and the pharmacies locations then appear on the map.

The above example illustrates two connections within the
MashAPP, but there are typically many others (e.g. infor-
mation on pharmacies oﬀering deals may be found in med-
ical forums, payment may be done online, etc.). This im-
plies that the number of possible relevant navigation ﬂows
in a MashAPP may be very large (even in a single applica-
tion, the number of ﬂows is large [4] and inter-connections
between the applications further increase it). Some of these
navigation options exploit the MashAPP structure in a much
better way and are signiﬁcantly better for the user than oth-
ers (e.g. save work, induce less errors, etc.), but identifying
them may be a signiﬁcant challenge [22].

The growing popularity of MashAPPs [16], along with the
diﬃculty of users in optimally exploiting such MashAPPs
[22], calls for a solution that assists users in their navigation.
The present paper depicts the development of such system,
based on a generic model that describes the MashAPP struc-
ture, the interaction between participating applications, and
the possible navigation ﬂows within the MashAPP. The
model allows to weigh the possible ﬂows based upon user-
speciﬁed criteria such as number of clicks, required manual
user input, popularity etc. We then introduce a simple query
language allowing to specify navigation ﬂows of a MashAPP
that are of interest to the user. Last, we develop an eﬃ-

320cient algorithm that, given such query and the current user
location within the MashAPP, ﬁnds the k best weighted
continuations of the user navigation. These possible contin-
uations are presented to the user, assisting in her navigation.
Our experiments indicate the run-time eﬃciency of our al-
gorithms as well as their contribution to users.

The model and algorithms described here served as the
basis for the development of COMPASS, a system that as-
sists users in their navigation through MashAPPs. Users of
COMPASS are presented with an abstract graphical repre-
sentation (similar to a site-map) of the MashAPP. By click-
ing on this site-map, users may easily form queries. The
system then computes top-k navigation ﬂows satisfying the
query. The ﬂows are ranked based on a user-chosen metric
(currently, choices popularity and number of incurred clicks
are suggested as metrics). Then, the recommendations are
displayed along-side the MashAPP itself, as a list of instruc-
tions for navigation (e.g. press button X, follow link Y,
etc.). Users may either follow the recommendation as is, or
may follow other paths than those proposed, in which case
new recommendations, consistent with the actual choices
made by the user, are automatically computed. COMPASS
is integrated with the Mashup Server and its operation was
demonstrated in ICDE ’10 on a real-life IBM patient portal
[10]. The demonstration [2] only provides a high-level de-
scription of the system, while the current paper presents the
underlying model and algorithms.

Note. We focus in this paper on the structure of the MashAPP:
which mashlets are connected and in what way this connec-
tion aﬀects the navigation ﬂow within the MashAPP. Such
connections can be thought of as a generalization of a site-
map, typically used for stand-alone Web-sites, to MashAPPs.
Naturally, the semantics of the individual mashlets (e.g.
their implementation, the data they manipulate etc.) also
need to be considered. However, previous works have shown
that one quickly meets undecidability or very high complex-
ity [18, 6] when considering such semantical features. For
a navigation assistance system to be eﬀective, it must be
interactive and respond in split-seconds (as oppose to e.g. a
static analysis tool [18]). Consequently, our algorithms fo-
cus on analyzing MashAPPs structure, but allow for plug-ins
that implement application-speciﬁc, semantics-aware analy-
sis, where an eﬃcient such analysis is possible.

Related Work. We conclude the Introduction with a brief
overview of related work, highlighting our contribution.

Recent work has led to the development of many platforms
which assist mashup designers [17, 11, 7]. In contrast, our
work is the ﬁrst (to our knowledge) to assist mashup users
in their navigation.

Various works [4, 6, 5] considered analysis of navigation
ﬂows within the context of a single application. Most of
these works analyze also the data manipulated by the Web-
Application; as noted in [5, 6], querying the combination of
execution ﬂows and data they manipulate, and the interplay
thereof, incurs very high complexity. The work in [4] took
an approach similar to ours of querying application struc-
ture and suggested a PTIME evaluation algorithm for the
restricted setting of a single isolated application.
In con-
trast, we show that there is an inherent added hardness in
the MashAPP settings, as if P (cid:54)= N P such PTIME algo-
rithm does not exist here. This added hardness calls for
the dedicated algorithms and optimization techniques that

Figure 1: Real-Life MashAPP

we present here. We also note that while our model resem-
bles that of Petri Nets (PNs) [19], it bears a weaker (yet
suﬃcient for capturing the structure of real-life MashAPPs)
expressive power allowing for eﬃcient query evaluation

Top-k queries were studied extensively in the context of re-
lational and XML data [9, 14]. In graph theory, the problem
of k-shortest paths was studied extensively [8, 21]. We show
that the multiple-application settings of a MashAPP ren-
ders top-k query evaluation harder than for a single graph,
but, as shown in Section 3, we exploit such k-shortest paths
algorithms as tools within our evaluation algorithms.

Paper Organization. The paper is organized as follows.
Section 2 describes our data and query model. Section 3
analyzes the complexity of the top-k problem and provides
a practically eﬃcient query evaluation algorithm. Section 4
describes the implementation of the COMPASS system and
our experiments. We conclude in Section 5.

2. PRELIMINARIES

We start by presenting our MashAPPs model, along with

intuitive examples.

Mashlets, Glue Patterns, and Applications. A mashlet is
a module implementing some functionality and supporting
an interface of input and output variables. Taking a syntac-
tic viewpoint, we ﬁrst consider only the mashlet interface.
We will consider the incorporation of semantic analysis, that
also takes into account the mashlets logic, later on.

We assume a domain L of mashlet names; following [11]
each such mashlet name l ∈ L is associated with two sets
of relations: a set of input relations, denoted by in(l), that
must all be fed so that the mashlet may operate, and a set
of output relations, denoted by out(l), that are the output
of the mashlet operation.

A Web-Application is then modeled as a directed graph,
corresponding to a site-map. To formally deﬁne such appli-
cations, we assume a domain N of nodes, each bearing a
unique identiﬁer. Nodes are labeled by mashlet names from
L; the same mashlet name may annotate multiple nodes.

Definition 2.1. A Web-Application is a node-labeled di-
rected graph A = (V, E, λ), where V ⊆ N is the set of nodes,
E ⊆ V × V is the set of edges, and λ : V (cid:55)−→ L is a la-
beling function over V . A has a distinguished single node
start(A) standing for its starting point, and a non-empty
set of nodes end(A) standing as its possible end points. We
use N odes(A) (Edges(A)) to denote V (resp. E).

We then deﬁne the notion of a MashAPP as a collection
of Web-Applications whose mashlets are inter-connected via
Glue Patterns (abbr. GPs).
Intuitively, a GP connects a
source mashlet of one application to a target mashlet of
another application, supplying some of its required input.

Show phone numberShow drug listBuy onlineShow drug detailsShow deal detailsloginShow personal detailsloginDrugstoreEHRShow clinical detailsChoose a drugSearch drugsPrint drug nameDrugs in ABuy with creditBuy with cashPharmaciesOnlineSearch by drugSearch by pharmacyShow pharmaciesPharmacies in AShow drugsChoose a pharmacyChoose a drugdrugs in AShow deal detailsBuy with cashBuy with creditBCBCChoose a drugMAPEdit addressShow on mapZoomShow pharmacy detailsloginMain pageBCConfirmShow Consumption ProfileBrowse drugsSelect a drugPayment options321Definition 2.2. A MashAPP is a pair M = (Apps, GP s)
where Apps is a set of Web-Applications and GP s is a set
of Glue Patterns. A Glue Pattern (GP) is a pair gp = (s, t)
where s and t are two nodes of distinct applications in Apps.
We call s (t) the source (resp. target) of gp, and denote it
by source(gp) (target(gp)).

We require that for every mashlet in Apps that is the
source of multiple GPs, the target nodes of these GPs be-
long to distinct applications in Apps.

The reason for this last requirement will become apparent
when we discuss below the role of GPs in navigation ﬂows.
Example 2.3. Fig. 1 depicts a graphical abstract view
of a part of a real-life MashAPP, namely a patients por-
tal [10]. This partial MashAPP consists of four applications
(Drugstore, Electronic Health Record, a Map application and
Pharmacies Online). Each application has a unique start
node (marked as a full circle), and possibly multiple end
nodes (marked with doubly bounded circles), representing the
completion of some task (e.g. the purchase of a drug from
Pharmacies Online or Drugstore). Regular edges detail the
logical ﬂow within each application (e.g. in the Map applica-
tion, Show on map follows Edit address and may receive its
input address from it). Dashed edges stand for GPs (e.g. the
same mashlet may also receive input from Show pharmacy
details in Pharmacies online). Note that a single mashlet
may be the source of several GPs whose targets reside in dis-
tinct applications. For instance, “Choose a drug” in EHR is
the source of one GP whose target is “Show drug details” in
Drugstore, and also of another GP whose target is “Search
by drug” in Pharmacies Online.

2.1 Navigation Flows

A Navigation Flow is an actual instance of navigation
within a MashAPP, consisting of a sequence of navigation
steps. Intuitively, a ﬂow of a single stand-alone application
starts at the application starting point and follows its edge
relation, with the input of each mashlet along the ﬂow being
fed either by the output of the previously activated mash-
let, or by the user. The navigation point of each application
is captured by the location (node) the application along its
ﬂow. As for a MashAPP that consists of several such ap-
plications, the navigation point is modeled via a Program
Counter (PC) signifying the current locations (nodes) of the
ﬂow in all applications.

A navigation ﬂow in a MashAPP induces a parallel navi-
gation in all participating applications and is captured by a
sequence of PCs. In the absence of GPs, a navigation step in
a MashAPP is a single step in one application, updating the
corresponding PC node and keeping all others intact. How-
ever, GPs allow to bypass the standard application ﬂow, and
have mashlets be activated by other applications and receive
their input from them. Thus, a mashlet m in an application
A may be activated even if the PC node of A has not reached
it, but rather the combination of the output of mashlets (in
other applications) that are glued to it, along with the out-
put of its current mashlet in A, feeds its required input. In
this case, the PC node of A may “jump” to m, continuing
the ﬂow from that point. We next formalize these notions.
Definition 2.4. Given a MashAPP M = (Apps, GP s)

with applications Apps = {App1, ...Appm}, a Program Counter
is a tuple P C = [n1, ..., nm] where ni is a node of Appi.

We say that [n1, ..., nm] →(ni,n(cid:48)

i) [n(cid:48)

1, ..., n(cid:48)

m] if:

i) ∈ Edges(Appi), and

1. (ni, n(cid:48)
2. for each j such that there exists a gp (n(cid:48)

i, target) ∈
GP s, with target ∈ Appj, and where condition (*)
(given below) holds, n(cid:48)

j = target(gp), and

3. n(cid:48)

j = nj for all other indices j.
Condition (*) states that for every n(cid:48)
i) (cid:83){out(nk) | (nk, n(cid:48)

out(nj) (cid:83) out(n(cid:48)

j, in(n(cid:48)

j) ⊆

j) ∈ GP s}.

Intuitively, for two PCs P C, P C (cid:48), we say that P C →(ni,n(cid:48)
i)
P C (cid:48) if P C (cid:48) is obtained from P C by the user advancing in
application Appi, from ni to n(cid:48)
i, consequently (possibly) acti-
vating GPs that cause PC nodes of the corresponding appli-
cations to “jump”. (ni, n(cid:48)
i) is referred to as the user choice.
A navigation ﬂow is then a sequence of program counters
and user choices F = P C0 →e1 P C1... →et P Ct. We say
that F is successful if each node in P Ct is an end-node of the
corresponding application. A successful ﬂow is full if P C0 =
[start(App1) , ..., start(Appm)] and is otherwise referred to
as a continuation.

Example 2.5. Consider a simple navigation ﬂow in the
MashAPP of Fig. 1. We use in the sequel the notation
AppName.MashletName to refer to the node annotated by
“MashletName” and appears in the “AppName” application.
Assume that the user navigates in parallel in the Drugstore
and EHR applications, reaching the “Drugstore.searchDrug”
and the “EHR.Show Drug List” nodes; in particular, this
means that the user has already logged into Drugstore. Now
assume that the user continues navigating in EHR, reaching
the “EHR.Choose a Drug” node and making a choice of a
drug. Now, note that there is a GP connecting “EHR.Choose
a drug” to the “DrugStore.Show drug details”, supplying to
the latter the chosen drug name. Focusing on the latter
mashlet, we assume that its required input consists of user lo-
gin information (as only registered users can see drug details
using this service), as well as a requested drug name. Since
the PC at Drugstore already passed the “Drugstore.login”
mashlet, user login information was also provided (and we
assume that it is passed from one mashlet to the next), thus
the PC of Drugstore “jumps” to “Show drug details”. The
user may then proceed and make navigation choices in any
of the mashed applications.

In this example the user input caused a “jump” in a sin-
gle application, but in general it may cause such jumps in
multiple applications, taking place in parallel.

We note here that, except for the GPs, the order in which
one advances in the diﬀerent applications (i.e. whether we
ﬁrst perform a given step in one application and then in the
other, or vice versa) is not signiﬁcant, as long as for each
individual application the sequence of traversed nodes (and
its ordering) stays intact. Two navigation ﬂows that defer
only in the above sense are considered to be equivalent (a
formal deﬁnition of this equivalence relation is given in the
Appendix).

2.2 Top-K Queries

So far we have discussed the notion of navigation ﬂows and
distinguished between successful and non-successful naviga-
tions based on whether or not some end-nodes deﬁned by the
application are reached. In many cases, there is also a set
of nodes that the user wishes to traverse in a speciﬁc order.
To that end, we next introduce the notion of queries that

322describe the navigation ﬂows that are of interest. We deﬁne
a query Q over a MashAPP as an acyclic graph, deﬁning
nodes that must appear in a qualifying ﬂow and a required
partial order over their traversal. An edge of Q may be
marked as transitive, and then its end-nodes do not have to
appear consecutively in the navigation sequence.

Definition 2.6. A query Q over a MashAPP

M = (Apps, GP s) is a pair (G, T ), s.t. G = (V, E), where
V is a subset of the nodes appearing in Apps, E ⊆ V × V
is an acyclic edge relation over V and T is a subset of the
edges in E, that are marked as transitive.
A successful navigation ﬂow P C0 →e1 ... →et P Ct of a
MashAPP M satisﬁes a query (G, T ) if for each node n of
G, there exists t(cid:48) s.t. n ∈ P Ct(cid:48) , and furthermore for each
edge (n, m) in G ( (n, m) ∈ T ), there exist t(cid:48)(cid:48) = t(cid:48) + 1
(t(cid:48)(cid:48) > t(cid:48), resp.) such that m ∈ P Ct(cid:48)(cid:48) .

Note that as the application graphs may be cyclic, the
same node may appear multiple times in the navigation ﬂow.
Deﬁnition 2.6 requires that each constraint is satisﬁed by at
least one of these occurrences. This requirement follows in
spirit the notion of bisimulation [18], commonly used for
process analysis.

In general, there may still be many qualifying ﬂows to
a given query, and users typically prefer some ﬂows over
others. To this end, we introduce a weighted model for
MashAPPs and for navigation ﬂows within them, as follows.

Weighted Model. We assume a domain W of weights and
use a weight function that assigns a weight we ∈ W to each
edge e (possible user choice) in each application in Apps.
The edge weight intuitively reﬂects its cost in terms of user
input, its likelihood of being chosen in a random naviga-
tion ﬂow etc. The individual edge weights occurring along
a navigation ﬂow are aggregated to obtain the ﬂow weight.
The aggregation function aggr : W × W → W receives two
weights as inputs; the ﬁrst intuitively corresponds to the ag-
gregated weight computed so far, and the second is the new
edge weight to be aggregated with the previous value. For
instance, when computing total number of clicks, aggr = +
and W = [0, ∞); choices popularity may be modeled by a
likelihood function, and then aggr = ∗ and W = [0, 1].

We consider here aggregation functions that satisfy the

following intuitive constraints:

1. aggr is associative and commutative, namely for each
x, y, z ∈ W, aggr(aggr(x, y), z) = aggr(x, aggr(y, z)),
and aggr(x, y) = aggr(y, x).

2. aggr has a neutral value, denoted 1aggr. Namely for

each x ∈ W, aggr(x, 1aggr) = aggr(1aggr, x) = x.

3. aggr is monotonically increasing or decreasing over
W. Namely, either for each s, x, y ∈ W x ≥ y =⇒
aggr(s, x) ≥ aggr(s, y) and aggr(s, x) ≥ s, or the same
for ≤.

Given a navigation ﬂow F = P C0 →e1 P C1 →e2 ... →et
P Ct we deﬁne WF , the weight of F , in a recursive man-
ner as follows: W[P C0] = 1aggr, and W[P C0→e1 ...→ei P Ci] =
aggr(W[P C0→e1 ...P Ci−1], Wei ). A weighted MashAPP is then
a MashAPP along with such weight functions.

Note. The model introduced here assumes that the weight
of each individual choice does not depend on previous choices.
This is sometimes the case in practice (e.g. for weight func-
tions reﬂecting number of clicks), but sometimes is not (e.g.

Figure 2: Query and Answer

for popularity of choices). For simplicity of presentation, we
will assume below independence between choices, but stress
that our results go through to an extended model allowing
dependency. We explain the adaptations required for sup-
porting this model in the Appendix.

Top-K Answers. Observe that when aggr is monotonically
increasing (resp. decreasing), so is the weight of execution
ﬂows. Generally, when aggr is monotonically increasing (as,
e.g., for total number of clicks), users are interested in the
k ﬂows having the lowest weight (e.g. requiring the least
overall number of clicks). When f W eight is monotonically
decreasing (as, e.g., for popularity of ﬂows), we will be in-
terested in k ﬂows having the highest weight (e.g. the most
likely ones). We refer to both problems uniformly as top-k.
The top-k results of a query Q with respect to a weighted
MashAPP M and the user current Program Counter (nav-
igation point) P C, denoted top − k(Q, M, P C) are thus de-
ﬁned as a set of k-best (highest for decreasing functions,
lowest for increasing functions) weighted successful naviga-
tion ﬂows of M satisfying Q, starting at P C (if there are
multiple such sets, we pick one arbitrarily). Due to the fact
that two navigation ﬂows may be equivalent (in the sense
described after Example 2.5), in order to allow diversity of
recommendations to the user, we output at most one navi-
gation ﬂow from every equivalence class.

Example 2.7. Re-consider the MashAPP M depicted in
Fig. 1 and assume a simple weight function that assigns
equal weights to all edges, with aggr = +. This function
counts the number of mashlets being traversed during navi-
gation, and assume that we wish to to minimize it. Further
consider a user that wishes to shop for a drug that appears
in her Electronic Health Record (EHR). The user wants to
check the drug price in an online drug store, and in phar-
macies close by to her place of residence. She may issue a
query Q, as depicted in Fig. 2(a). The query requires ﬂows
to traverse the “Choose a drug” mashlet in EHR to choose
the prescribed drug, then go to “Show deal details” in Drug-
store to ﬁnd the price for the chosen drug. The choice of
drug is also followed by “Show deal details” in Pharmacies
Online, to show details of deals in pharmacies oﬀering this
drug, and the latter is in turn followed by “Show on map”
in the Map application, to show the pharmacy location.

Fig. 2(b) depicts the nodes and edges traversed in the top-
1 navigation ﬂow of M satisfying Q. The ﬂow starts by nav-
igating to “Choose a drug” in the EHR, then utilizing a GP
that causes a “jump” in DrugStore to “Show drug details”,
showing the chosen drug details. The ﬂow continues by nav-
igating in Drugstore up to “Show deal details”, which is con-
nected by a GP to the pharmacies site and causes a jump in
Pharmacies Online to “Show pharmacies”. Then, it contin-
ues navigating in Pharmacies Online to ﬁnd the pharmacy
of interest, and ﬁnally uses a GP connecting the pharmacies
site to the map, to show the location of the chosen pharmacy.

EHR . ”Choose a drug”Drugstore . “Show deal details”PharmaciesOnline . “Show deal details”Map . “Show on map”(a)(b)3233. TOP-K QUERY EVALUATION

We study in this section the evaluation of top-k queries
over MashAPPs. Unfortunately, as we next show, no PTIME
(data complexity) algorithm for computing top-k query an-
swers is possible, unless P = N P . Let BEST-FLOW be the
problem of deciding, given a weighted MashAPP M , a query
Q over M , and a bound B, whether there exists a success-
ful navigation ﬂow of M that satisﬁes Q and further has a
weight higher than B.

Theorem 3.1. BEST-FLOW is NP-complete in the size of
the input MashAPP M . Furthermore, this holds even if all
applications in M have the form of a chain.

The proof (deferred to the appendix for lack of space) is
based on a reduction from 3-SAT.

A naive EXPTIME algorithm can be obtained by looking
at the conﬁguration graph G of the MashAPP, namely the
nodes of G are the MashAPP Program Counters, and its
edges correspond to the →e relation over such PCs. Note
that there are many algorithms (e.g.
[8, 21]) in the liter-
ature that ﬁnd top-k paths in a single graph, with poly-
nomial complexity in the graph size. The naive algorithm
would ﬁrst choose an order of traversal over the query nodes,
then choose for each query node a corresponding node in the
conﬁguration graph (namely a node whose PC at the ap-
propriate application is at the query node), and repeatedly
apply a top-k paths algorithm over G, to ﬁnd top-k sub-
paths in-between the chosen nodes, according to the chosen
order of their corresponding query nodes. By considering
all such choices, the top-k ﬂows of the given MashAPP can
be found. However, the number of nodes in G, and thus
the algorithm complexity, is exponential in the number of
applications, with the exponent base being the size of each
individual application.
If the applications graphs contain
thousands of nodes (as is often the case in practice [13]),
the complexity of this naive algorithm becomes infeasible.

Fortunately, a more careful analysis of the NP-hardness
source (and the consequent complexity of query evaluation)
shows that in fact it depends on the number of GPs inter-
connecting applications in the MashAPP and on the query
size, and both are relatively small in practical cases. Indeed,
we show below that we can obtain a practically eﬃcient algo-
rithm with complexity where the exponent depends on this
quantity, and the basis of its exponent is a small constant.

Simplifying Assumptions. We make below three assump-
tions, for ease of presentation: we assume that (1) each ap-
plication has at most one end node, (2) end nodes of ap-
plications are not sources of GPs, and (3) each GP source
can provide, by itself, suﬃcient input for the activation of
its target (independently of the current PC location in the
target application, or in other applications). We stress that
these assumptions are made solely for ease of presentation,
and we explain in the Appendix the necessary changes to
our algorithms when these assumptions do not hold.

3.1 Observations

Before depicting our top-k algorithm, we present key ob-
servations utilized in its development. Consider a MashAPP
M = (Apps, GP s), a query Q = (G, T ), s.t. G = (Nq, Eq),
and an arbitrary navigation ﬂow F that satisﬁes Q. F tra-
verses all nodes of Nq, in some order conforming to E and
T (we call such order compatible with the query).
It also

possibly traverses some nodes that are sources of GP s, and
terminates with all PCs residing at accepting states. Let
us denote by SourcesSet the GP source nodes traversed by
F . Now, consider all possible navigation ﬂows that traverse
(cid:83) SourcesSet in the same order that F
nodes of N = Nq
does. Denote this class of navigation ﬂows by Γ(F ). A
key observation is that, to ﬁnd the top-k ﬂows of Γ(F ), we
may compute independently the top-k sub-ﬂows leading from
U serP C, the current PC of the user, to a P C1 containing
the ﬁrst node of N , then compute the top-k sub-ﬂows lead-
ing from P C1 to a P C2 containing the second node of N and
so forth up until the last node of N . The overall top-k ﬂows
are the k best-weighed concatenations of these sub-ﬂows.

These top-k sub-ﬂows computations may be done inde-
pendently due to the fact that the order chosen over N de-
termines in particular an order over the GP sources. We
thus know that a valid sub-path starting from one node of
N and ending at the next node, does not traverse any GP
sources along the way. This observation is important in two
ways: (1) it allows to compute the next P C from which the
next step of computation will start, independently of the
choice of actual path at the current step: this next P C is
the same as the current P C for all applications except for
that of the next node n of N and for the target applications
of GPs that n is their source, and (2) it allows the computa-
tion to be restricted to top-k paths in the single application
where the next node of N resides. As we shall show below,
this allows to plug-in an application-speciﬁc top-k analysis.
So far we considered top-k ﬂows corresponding to a single
Γ(F ) set. More generally, the top-k ﬂows satisfying q can
be found by repeating this procedure for all possible choices
(cid:83) SourcesSet that
of SourcesSet and of an order over Nq
is compatible with the query.

3.2

TOP-K Algorithm

We start by depicting a black-box plug-in used by our

algorithm, then depict the algorithm itself.

T opKP aths. We use in our algorithm an external plug-in
called T opKP aths, that given a single application graph G
and two end nodes n1 and n2 in G, computes top-k paths
from n1 to n2. T opKP aths may be implemented in a purely
graph-theoretic way, as a shortest (weighted) paths algo-
rithm [8]. However, we stress that this is the point where
a semantic analysis, when can be performed eﬃciently, may
take place. As our algorithm applies T opKP aths on a sin-
gle application graph at a time, T opKP aths may implement
an application-speciﬁc, semantic-aware analysis [4, 5] that
is incorporated in a transparent way within our algorithm.
Algorithm. We next depict an eﬃcient algorithm for top-k
query evaluation. The algorithm receives as input a MashAPP,
a query, a Program Counter indicating the current user po-
sition, and a number k of requested results, and outputs
the top-k qualifying navigation ﬂow continuations in a data
structure referred to as Out. The algorithm considers all
compatible (as deﬁned above) orders over the query nodes
and a subset of the GP sources. For each such order O, the
algorithm computes the top-k navigation ﬂows conforming
to O, by computing the top-k partial navigation ﬂows in-
between each two consecutive nodes in O, then combine the
results to obtain top-k full navigation ﬂows for each such
order. For eﬃciency, the algorithm advances in parallel in
the computation done for the diﬀerent orders; this parallel

324computation is done in a branch-and-bound style.

sub-ﬂows to those stored in O.T opK.

The details of Algorithm TOP-K are given in Algorithm
1. It initializes the Out structure (Line 1), then uses (Line
2) a priority queue F rontier of possible orders, with prior-
ities set by the top-1 (partial) navigation ﬂow computed so
far for each order.
Initially, all orders have the same pri-
ority. At each iteration TOP-K pops (Line 4) the order O
having highest priority out of F rontier and ﬁrst checks for
our stop condition (Line 5) - namely whether k full ﬂows
that are better (weight-wise) than the top-1 computed sub-
ﬂow of O, were already found.
If so, we break the loop
(Line 6) and terminate. Otherwise, we look at O.index, sig-
naling the index of the last node reached in computation
for O, and continue the computation from this point by in-
voking HandleSubN av. As shown below, at each iteration
HandleSubN av computes (and stores in a data structure
called O.T opK) the top-k sub-ﬂows from UserPC to the
(O.index)’th node of O. The algorithm then raises the index
of O by 1 to indicate the point where the next computation
for O will start from (Line 11).
If this value reaches the
size of O, then we have ﬁnished the computation for O and
the top-k ﬂows found for it (stored in O.T opK) are merged
with the overall top-k (Line 13). Consequently (Line 14),
the priority of O in F rontier is updated. Recall our notion
of equivalent EX-ﬂows; only EX-ﬂows that are not equiva-
lent to already existing ones are added to the overall top-k.
Finally, we output the top-k results (Line 16).

.
Algorithm 1: TOP-K
Data: MashAPP M = (Apps, GP s), a query

q = (G, T ); a Program Counter U serP C of M ,
number of requested results k

Result: top − k(q, M, U serP C)
Init Out as empty array of size k of navigation ﬂows ;
Initialize Frontier as a priority queue of all Orders ;
while not done do

O ← pop(F rontier) ;
if T opW eight(O.T opK) ≥ BotW eight(Out) then

break ;

end
i ← O.index;
CurrP C ← U serP C ;
HandleSubN av(CurrP C, O, i) ;
O.index ← O.index + 1 ;
if O.index = |O| then

Out ← M ergeSort(Out, O.T opK) ;
update(F rontier, O)

end

end
Output Out ;

1

2

3
4

5

6

7

8
9

10

11

12
13

14

15

16
17

HandleSubN av Method. The subroutine HandleSubN av
is given as input CurrP C, O, and an index i in O. O
consists of (1) an order over the nodes that should be tra-
versed and (2) a set of top-k sub-ﬂows from U serP C to the
(i − 1)’th node of O (stored in O.T opK). CurrP C is the
PC obtained after traversing one of these top-k sub-ﬂows
(as explained above, this PC is unique among choices of
sub-ﬂows). Then, HandleSubN av extends these sub-ﬂows
to be the top-k sub-ﬂows from U serP C to the i’th node of
O (O[i]), and updates CurrP C appropriately. It does that
by ﬁrst computing top-k sub-ﬂows from CurrP C to a PC
containing O[i], then ﬁnding top-k concatenations of these

To ﬁnd the top-k sub-ﬂows from the CurrP C to O[i],
HandleSubN av sets O[i] as its target node and its source
node (src) to be the node of CurrP C corresponding to
the same application A that target resides in (Lines 1-2).
We then perform a top-k analysis (Line 3) for paths in-
between src and target. This analysis is performed, using
T opKP aths mentioned above, over a single graph G ob-
tained from the application graph of A, by omitting all GP
source nodes other than src and target. The top-k anal-
ysis results are now concatenated (Line 4) with the top-k
sub-ﬂows found so far for O; the top-k such concatenations,
forming top-k sub-ﬂows from U serP C to O[i], are kept.
This is done using the ConcatSort method that computes
the top-k concatenations incrementally (each time choosing
either the next sub-ﬂow or concatenation, according to the
weights order). Finally (Lines 5-7), CurrP C is updated ac-
cording to the target location. Furthermore, this may aﬀect
PCs in other applications, due to GPs (recall that due to
assumption (2), a GP is activated whenever its source is
reached). We thus ﬁnd all GPs whose source node is target
(Line 6). CurrP C is updated correspondingly (Line 7), also
performing all “jumps” incurred by these GPs.

Algorithm 2: HandleSubNav
Data: A Program Counter CurrP C, order O, location

i in O

Result: Computes Top-k sub-navigations from

CurrP C to O[i], and updates the top-k
computed preﬁxes for O, along with CurrP C

target ← O[i] ;
src ← CurrP C in app of target ;
P artialT opK ← T opKP aths(src, target) ;
O.T opK ← ConcatSort(O.T opK, P artialT opK) ;
Update CurrP C with target ;
foreach gp ∈ GP s s.t. source(gp) = target do

Update CurrP C with target(gp) ;

1

2
3

4

5

6
7

8

end

Complexity. We recall that an algorithm A is Fixed Pa-
rameter Tractable FPT [12] if for every input of size x and
parameter p, A operates in time O(f (p) ∗ P oly(x)) for some
function f . Where the parameter p is typically relatively
small, intuitively an FPT algorithm is “almost polynomial”.
In our case, we can use p =| N |=| sources(GP s) | + | NQ |,
namely the number of distinct sources of GPs in M , plus the
number of query nodes. The following theorem holds.

Theorem 3.2. The worst case time complexity of TOP-K
is O(p! ∗ poly(| M |, k)), with p as above. Consequently,
TOP-K is FPT, when taking p as a parameter.

As we shall see in Section 4, the value of p is typically
rather small, and the algorithm performance is very good in
practical cases. Note that TOP-K incurs space that is expo-
nential in p, but this exponent is typically small enough to
allow the required space to ﬁt in main memory. Where this
is not the case, one may “group” together subsets of orders,
where each such subset is small enough to ﬁt in memory,
and perform TOP-K over a single subset at each iteration,
then take the top-k overall results.

4. EXPERIMENTS

The model and algorithms described in this paper served
as the basis for the development of COMPASS, a system

325Figure 3: Dependency on MashAPP Size

Figure 4: Dependency on # of Glue Patterns

that assists users in their navigation through MashAPPs
(due to lack of space, the detailed architecture of COMPASS
is given in the Appendix). We next describe our experimen-
tal study of the algorithm performance (on both real-life and
synthetic data) as well as the system contribution to users.
The system is implemented as plug-in to the Mashup Server,
and the experiments were performed on a Pentium 1.65GHz
Dual-Core and 2GB RAM. Each performance experiment
was run 10 times and the graphs show the average results.
In all cases, the standard deviation did not exceed 5%.

4.1 Synthetic Data

The synthetic data was generated with varying character-
istics, such as the number of nodes in an application, the
number of GPs inter-connecting them, the number of tar-
gets that a single GP is connected to, etc. To gain intuition
on typical values of these parameters, we (1) examined Pro-
grammableWeb.com, the most extensive MashAPP reposi-
tory available on the web, with over 4500 MashAPPs, (2)
referred to the statistics available in [13] on Web Applica-
tion sizes and (3) examined MashAPPs developed at IBM
over the Mashup Server.

Typical Parameter Values. [13] states that the size of a
typical, large-scale, Web-Application is approx. 2000 nodes.
Our analysis of ProgrammableWeb shows that 99% of the
MashAPPs in this repository bear 4-6 applications, ren-
dering the total size of a typical MashAPP to be around
10000 nodes. The average number of GPs in the examined
MashAPPs is approx. 15, with 5 distinct GP sources.

While these numbers seem relatively small, the obtained
MashAPPs are still rather complicated for the users. First,
there are many possible navigation paths even within a sin-
gle application. The combination of 5 such applications in-
creases the number of options by a power of 5, and the exis-
tence of GPs introduces intricate connections in-between the
applications and further complicate the navigation process.
Furthermore, to show scalability of our algorithm, we ran
our experiments with parameter values ranging from 1 up
to 10 times the typical values found for real-life MashAPPs
(and up to approx. 5 times the maximal values found).

We also considered various structures for the applications
participating in the MashAPPs, to examine their eﬀect on
the algorithm performance. We varied the number of GPs
from 1 to 120 (with number of distinct GP sources rang-
ing from 1 to 12). The locations of GP sources and targets
were chosen from a uniform distribution over the application
nodes (while guaranteeing that multiple targets of GPs re-
side in diﬀerent applications). For weight functions, we used
multiplication for aggregation and examined, for the individ-
ual edge weights, various distributions over [0, 1] (uniform,
Gaussian, Zipﬁan, equal weights for all edges). We observed
no signiﬁcant change in performance, and thus show here
only the results obtained for the uniform distribution. We
varied the number of query nodes from 1 to 20, and k (num-
ber of requested ﬂows) from 1 to 20; we report the the results

for 3 representative values (1, 10, 20) of k.

Experimental Results. The ﬁrst experiment examines the
eﬀect of the size of a given MashAPP on the performance
of the TOP-K algorithm. We ﬁxed the number of GPs to 15,
the query size to 10, and varied the MashAPP size from 1 to
120000 nodes. Fig. 3 depicts our algorithm execution time
as a function of number nodes composing the MashAPP.
We observe that for such MashAPPs, the execution time of
TOP-K does not exceed 0.11 seconds, for k = 20. Further-
more, it is apparent that the execution time of our algorithm
grows very moderately with respect to the MashAPP size.
Even for a MashAPP with 100000 nodes (approx. 10 times
the size of a typical MashAPP), query evaluation time is
about 0.1 seconds.

The second experiment examines the eﬀect of the number
of GPs on the algorithm performance. We varied here the
number of GPs from 1 to 120, while ﬁxing the number of
applications to 6, the MashAPP size to 120000, and the
query size to 10. Fig. 4 shows that the execution time of the
TOP-K algorithm is again below 0.1 seconds even for 120 GPs
(nearly 10 times the typical value). We further examined
the eﬀect of query size; not surprisingly (see Thm. 3.2),
the execution time behaves similarly to its behavior with
respect to the number of GPs. We thus omit the obtained
performance graph.

We also note on the memory consumption of TOP-K as
observed in our experiments. While we studied parameter
values that are up to approx. 10 (5) times the typical (max-
imal) values observed in real-life MashAPPs, the memory
consumption of TOP-K was low enough to ﬁt in main mem-
ory. When this is not the case, we may employ a “grouping”
mechanism (see Section 3) to parallelize the work over sub-
sets of the possible orders, that do ﬁt in main memory. The
execution time of the reﬁned algorithm then grows approx.
linearly with the number of such subsets (which is dependent
on the ratio between required and available memory).

4.2 Real-life Data and Effectiveness

To assess the algorithms performance on real-life mashApps,

as well as the eﬀectiveness of our system assistance to users,
we have considered a real-life MashAPP, namely MedickIT
[10], a patient personal portal consisting of ﬁve applications
(Drugstore, Electronic Health Record, a map service, Phar-
macies Online and an SMS messages service). The size of
the MashAPP is approx. 10000 nodes, and it contains 15
GPs inter-connecting its applications.

We next explain the necessary steps for applying COMPASS

over a real-life MashAPP, using MedickIT as an example for
such MashAPP. We then describe our experimental results.

Setup. Recall that our algorithm requires an abstract model
consisting of (1) a graph representation (site-map) of each
application participating in the MashAPP, (2) a descrip-
tion of the Glue Patterns (GPs) inter-connecting these ap-
plications, and (3) a weight function over application graph

00.020.040.060.080.10.120100002000030000400005000060000700008000090000100000110000120000MashAPP SizeRunning Time (seconds)k=20k=10k=1MedickIT00.050.10.150.20.250.30.350.40.450.5102030405060708090100110120Number of GPsRunning Time (seconds)k=20k=10k=1MedickIT326edges, and over GPs. For MedickIT, the involved applica-
tions structure was given since they were built in-house. We
note however that many Web-Applications are speciﬁed in
declarative languages e.g. BPEL [1], allowing automated ex-
traction of their site-map. The GPs connecting the mashlets
were automatically retrieved from the Mashup Server. As
for weight functions, two such functions were employed: the
ﬁrst weighs ﬂows by the total number of clicks required, and
the second captures popularity of choices. Weights account-
ing for navigation steps were obtained from the applications
site-map; the popularity weights were obtained as follows:
for ﬂow edges connecting services of a Web-Application, in-
formation about transition popularity was obtained by sta-
tistically analyzing user logs. For GPs, popularity ranks
were obtained from the MatchUp system [11] that computes
such ranks for connections in-between mashlets.

Once the abstract model is in place, COMPASS allows
users to issue queries over the model. To that end, the sys-
tem has a UI that enables the user to (1) view a graphical
representation of the site-map of the loaded MashAPP, (2)
compose a query, by consecutively clicking on nodes of the
site-map in some particular order, (3) be presented with
COMPASS top-k navigation recommendations and (4) ex-
amine various recommendations by clicking on them and
viewing their highlighted image on the MashAPP ﬂow-map.
The UI of COMPASS is presented along-side that of the orig-
inal MashAPP, allowing the user to continue her navigation,
while viewing the recommendations. While experimenting
with the system, we have witnessed that the interface was
easily used by most users to design queries; however, a small
subset of users, that lack experience in working with com-
puters, had some diﬃculties with designing queries. There-
fore, we enhanced the system with a repository of stored,
commonly used, queries available to users.

Experimental Results. We sum up the section by report-
ing the system performance and the experience of its users,
in the context of assistance for MedickIT. The performance
results comply with our reported results for synthetic data,
and are depicted in Fig.
3 (the vertical line stands for
MedickIT). The top-k recommendations were computed, on
average, in 0.01 seconds for k=1, 0.03 seconds for k=10, and
0.05 seconds for k=20, and with variance of less than 5%.

We have then performed eﬀectiveness experiments with a
group of 80 users, half already familiar with MedickIT and
half not, and measured the time it took the users to navi-
gate within the MashAPP, with and without the assistance
of COMPASS. We split both the experienced and inexpe-
rienced users groups into two sub-groups: users of the ﬁrst
sub-group navigate by themselves while being able to ob-
serve the site-map of MedickIT, and those of the second sub-
group are assisted by COMPASS during navigation, beneﬁt-
ing from the query-based recommendations it provides. All
users were given three tasks, as follows: (1) Find the details
of the physician that is closest to your work address, (2)
ﬁnd the details of the physician that is closest to your work
address and send to your cellular phone an SMS message
containing the physician’s details, and (3) view the personal
graph of drug consumption of a given patient.

The average time it took inexperienced users that were
not aided by COMPASS to complete each of these relatively
simple tasks was 8:06 minutes; for experienced users, this
average time was only 3:04 minutes. In both groups, users

performed signiﬁcantly better in their tasks, when assisted
by COMPASS (an overall average of 71% improvement, with
variance of less than 4%):
Inexperienced users now per-
formed the tasks in 1:47 minutes on average, constituting a
78% improvement for them; experienced users now achieved
an average time of 1:08 minutes, better by 63% compared
to their performance without the system assistance. We see
signiﬁcant contribution of COMPASS for both users classes.
5. CONCLUSION

We consider in this paper the diﬃculties encountered by
users while navigating in complex MashAPPs. We presented
a solution that assists users in their navigation through
Mashed-Up applications. Our solution is based on a simple,
generic model for MashAPPs and navigation ﬂows within
them, and an intuitive query language that allows users to
deﬁne navigation ﬂows of interest. We studied the complex-
ity of top-k query evaluation in this context, provided an
eﬃcient algorithm that assists users in navigation, and ex-
plained how the algorithm is utilized for developing COMPASS.
Future research includes the incorporation of knowledge on
user context and preferences, and on mashlets semantics,
and automatic inference of the MashAPP model.
6. REFERENCES
[1] Business Process Execution Language for Web Services.
http://www.ibm.com/developerworks/library/ws-bpel/.

[2] D. Deutch, O. Greenshpan, and T. Milo. Navigating through

mashed-up applications with compass. In ICDE ’10.

[3] D. Deutch and T. Milo. Evaluating top-k projection queries

over probabilistic business processes. In ICDE ’09.

[4] D. Deutch, T. Milo, and T. Yam. Goal Oriented Website

Navigation for Online Shoppers. In VLDB ’09.

[5] A. Deutsch, R. Hull, F. Patrizi, and V. Vianu. Automatic

veriﬁcation of data-centric business processes. In ICDT ’09.

[6] A. Deutsch, M. Marcus, L. Sui, V. Vianu, and D. Zhou. A

veriﬁer for interactive, data-driven web applications. In
SIGMOD ’05.

[7] R. J. Ennals and M. N. Garofalakis. Mashmaker: mashups for

the masses. In SIGMOD ’07.

[8] D. Eppstein. Finding the k shortest paths. In FOCS, 1994.
[9] R. Fagin, A. Lotem, and M. Naor. Optimal aggregation
algorithms for middleware. J. Comput. Syst. Sci., 2003.
[10] O. Greenshpan, K. Kveler, B. Carmeli, and P. Vortman.

Towards Health 2.0: Mashups To The Rescue. In NGITS ’09.
[11] O. Greenshpan, T. Milo, and N. Polyzotis. Autocompletion for

[12] M. Grohe. Parameterized complexity for the database theorist.

mashups. In VLDB ’09.

SIGMOD Rec., 31(4), 2002.

[13] T. C. Jones. Estimating Software Costs. McGraw-Hill, 2007.
[14] B. Kimelfeld and Y. Sagiv. Matching twigs in probabilistic xml.

In VLDB ’07.

[15] N. Kulathuramaiyer. Mashups: Emerging application
development paradigm for a digital journal. J. UCS,
13(4):531–542, 2007.

[16] C.-J. Lee, S.-M. Tang, C.-C. Tsai, and Y.-C. Chen. Toward a
new paradigm: Mashup patterns in web 2.0. WSEAS Trans.
Info. Sci. and App., 6(10):1675–1686, 2009.

[17] B. Lu et al. sMash: semantic-based mashup navigation for data

API network. In WWW ’09.

[18] Z. Manna and A. Pnueli. The temporal logic of reactive and

concurrent systems. Springer-Verlag, 1992.

[19] T. Murata. Petri nets: Properties, analysis and applications.

Proc. of IEEE, 77(4), 1989.

[20] P. L. T. Pirolli and J. E. Pitkow. Distributions of surfers paths

through the world wide web: Empirical characterizations.
World Wide Web, 2(1-2), 1999.

[21] E. Ruppert. Finding the k shortest paths in parallel.

Algorithmica, 28(2), 2000.

[22] J. Wong and J. I. Hong. Making mashups with marmite:
towards end-user programming for the web. In CHI ’07.

[23] J. Yu, B. Benatallah, R. Saint-Paul, F. Casati, F. Daniel, and
M. Matera. A framework for rapid integration of presentation
components. In WWW ’07.

327APPENDIX

A. EQUIVALENT NAVIGATION FLOWS

Recall that we have informally introduced, in Section 3,
the notion of equivalent navigation ﬂows, that is important
to allow diversity of the results that are shown to the user.
Intuitively, two diﬀerent ﬂows are equivalent if they induce
the same ﬂow in every application in separate, and diﬀer
only in the order in which the advancements in diﬀerent
applications interleave (e.g. whether the ﬂow has ﬁrst ad-
vanced in some application A and then in application B, or
vice versa). Our TOP-K algorithm then outputs at most one
out of each equivalence class.

To deﬁne this formally, we deﬁne the restriction of a ﬂow
to an application, signifying the relevant part of the ﬂow to
this application. Thus, two ﬂows are equivalent if they have
same restrictions for all involved applications. Furthermore,
note that only parts of ﬂows restrictions in which an advance
has been made are “interesting” for studying equivalence.
Thus, consecutive PCs in which the state stays the same
are ignored. This will be captured by the notion of canonic
restriction deﬁned next.

Definition A.1. (equivalent navigation ﬂows) Given a
Program Counter PC and an application App, denote by
P C|App the node of App appearing in the PC. For a naviga-
tion ﬂow F = P C0 →e1 P C1 →e2 ... →et P Ct we then de-
ﬁne F |App, the restriction of F to App, as the nodes sequence
[n1 = P C0|App, n2 = P C1|App, ..., nt = P Ct|App]. Further-
more, we deﬁne the canonic restriction of F to App obtained
from F |App by repeatedly omitting from it every node ni such
that ni = ni−1, until no such ni exists. Finally, we say that
two navigation ﬂows F1, F2 of a MashAPP M are equivalent
if for each application App in M , the canonic restriction of
F1 to App is the same as the canonic restriction of F2 to
App.

B. PROOF OF THEOREM 3.1

(cid:86) C2

Proof. We show NP-hardness by reduction from 3-SAT.
We ﬁrst show a reduction where some of the graphs do not
have a chain form, then reﬁne the proof. Given a 3-CNF
(cid:86) ...Cm over variables x1, ...xn, we gener-
formula C1
ate a MashAPP M as follows. M consists of n + m appli-
cations, Ax1 , ...Axn , AC1 , ..., ACm . AC1 , ..., ACm are simply
very long chains, with length L = 4 ∗ n, whose ﬁnal nodes
are end-nodes. Each Axi consists of a single root, with two
children corresponding to assignments of true or f alse to
xi. Their corresponding true / false children are connected,
by GP, to all end-nodes of paths corresponding to clauses in
which the literal appears positively / negatively. The weight
function W assigns 1 to every edge, aggr =(cid:48) +(cid:48) and we set
B = 3 ∗ n.

A slightly diﬀerent construction uses only chains: instead
of Axi we have two applications, Axi=t and Axi=f . Each
such application is a chain of three nodes. The second node
of Axi=t (Axi=f ) is connected by a GP to the third node in
the chains of all clauses containing xi (¬xi), as well as that
of Axi=f (Axi=t).

As for inclusion in NP, we note that Algorithm TOP-K may
be easily transformed into an NP algorithm for BEST-FLOWS,
as follows: the NP algorithm “guesses” an a subset of the GP
sources, then guesses an order O over the nodes Nq and the

chosen subset, and veriﬁes that this order is compatible with
the query edges Eq; if so, then it checks for the existence of
a ﬂow that conform to O and has a better weight than the
given bound B, as done by Algorithm TOP-K.

B.1 Withdrawing Assumptions

Throughout the paper, we have made several assump-
tions to ease the presentation of our model and results. We
next withdraw these assumptions, and explain the necessary
changes to the model / algorithm.

Model. We have assumed above (Deﬁnition 1) that the
weight of every edge along the ﬂow is independent of previous
ﬂow activities. In some practical cases such independency
does not hold: for instance, consider a weight function that
measures popularity of choices. Users that use the “Search
drugs” mashlet in Drugstore are possibly more likely to ﬁnal-
ize a reservation without resetting (once getting to the “Buy
online” mashlet), than users that navigate to the “Browse
drugs” mashlet. This is because users that manually click
their drug name of choice are typically certain about the
drug they wish to purchase.

To account for such dependencies, we ﬁrst extend our
weighted model such that the weight function W is no longer
a function of a single edge, but rather is a function of an edge
along with the sub-ﬂow that preceded it (referred to as ﬂow
“history”). We then follow lines similar to that of the al-
gorithm in [3], to generate a new MashAPP M (cid:48) where we
encode, within the node labels, a suﬃcient amount of in-
formation about the ﬂow history that preceded it. We may
than construct a weight function W (cid:48) that is independent of
the ﬂow history, and simulates W . All of our algorithms
then apply to (M (cid:48), W (cid:48)).

The size of M (cid:48) is greater than that of the original MashAPP
by a factor that depends only on “how much” of the history
aﬀects the weight, namely how many previous choices need
to be recorded to decide the weight of a given edge. Stud-
ies of Web-Applications [20] show this number to be very
small (approx. 4) in real-life cases, allowing our algorithms
to remain highly eﬀective even in presence of dependencies.

Algorithms. To simplify the presentation of our algorithms
we have assumed that (1) each application in the MashAPP
bears a single end-node, (2) the end nodes of applications are
not sources of any GPs, and (3) every GP may be activated
when its source is reached, independently of the current PC
location.

First, to relax assumption (1), if multiple end-nodes exist
for a single application then we simply insert them to the
orders O studied, after the query nodes and GP sources, in
any order in-between them. Assumption (2) may also easily
be relaxed, as follows: we ﬁrst create a new MashAPP M (cid:48)
by adding a single child n(cid:48) to each end-node n, then marking
n(cid:48) as end-node, instead of n, then we apply our algorithms
over M (cid:48). To relax assumption (3), we extend our algorithms
as follows. For every order O, and for each node s in O that
is the source of some GP, we generate new orders O1, ..., Om.
Each such order is obtained from O by choosing some subset
of nodes that allow the GP activation and some order over
the chosen subset, then inserting these new nodes, in order,
to O, right before the appearance of s. These new orders
are then traversed by Algorithm TOP-K as depicted above.

328C. SYSTEM ARCHITECTURE

We next present a brief overview of the system architec-
ture. COMPASS is developed on top of the Mashup Server
developed in IBM Haifa Research Labs. The server allows to
compose mashups (and thereby MashAPPs) and use them.
The architecture of COMPASS is depicted in Fig. 5. We de-
scribe below the main system components and explain how
they work together.

Figure 5: System Architecture

COMPASS UI. This component is the user interface for
navigating through MashAPPs. To construct the UI of
COMPASS, we used as a basis the user interface of the
Mashup Server, and enhanced it with plug-ins enabling the
user to (1) view the ﬂow-map of a given MashAPP, (2) set
navigation goals; (3) obtain from COMPASS top-k naviga-
tion recommendations and (4) examine various recommen-
dation by clicking on them and viewing their (highlighted)
image on the MashAPP ﬂow-map.

MashAPP abstract Model. The MashAPP model, stored
in the COMPASS database, includes the ﬂow-map of each
participating application, as well as the GPs connecting
them. The ﬁrst component, namely the ﬂow-map for each
application, was manually conﬁgured for all applications
participating in the demonstration, following their logical
structure. We note however that many Web applications are
speciﬁed in declarative languages such as BPEL [1], allowing
automated extraction of their ﬂow-map. The GPs connect-
ing the applications mashlets were retrieved from Mashup
Server, along with input and output speciﬁcations of each
mashlet. Last, we consider the construction of a weight
function over ﬂows. We demonstrate here two weight func-
tions: the ﬁrst weigh ﬂows by the total number of navigation
steps (user clicks and input) taken, and the second captures
the total popularity of user choices. Weights accounting for
navigation steps are easily obtained from the applications
ﬂow-map; the popularity weights were obtained as follows:
for ﬂow edges connecting services of a Web application, we
obtain information about transition popularity by an ex-
perimental study, collecting and statistically analyzing user
logs. For GPs, we employ the MatchUp system [11] that
computes popularity ranks for connections in-between two
mashlets.

MashAPP Adaptive Query Engine. This last component
computes and provides users with recommendations. This
engine, querying the abstract model Database, is incorpo-
rated as a plug-in to the Mashup Server. Queries are re-
ceived through the COMPASS UI, directed to the Query
Engine that processes them and returns the result back to
the COMPASS UI for presentation. Furthermore, the Query
Engine remains active throughout the navigation process,
to receive from the UI a report on each user navigation
step. Then, new recommendations consistent with the user
choices are computed and sent to the UI, and so forth.

User Navigation GoalsFlow MapTop-K Recomm.Screens, ActionsUser SelectionUser Navigation GoalsTop-K Recomm.(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:3)(cid:4)(cid:9)(cid:10)(cid:11)(cid:3)(cid:1)(cid:2)(cid:3)(cid:4)(cid:12)(cid:13)(cid:3)(cid:4)(cid:14)(cid:5)(cid:15)(cid:7)(cid:16)(cid:17)(cid:7)(cid:3)Flow Map(cid:6)(cid:18)(cid:19)(cid:5)(cid:19)(cid:10)(cid:2)(cid:20)(cid:13)(cid:21)(cid:5)(cid:22)(cid:3)(cid:4)(cid:23)(cid:3)(cid:4)(cid:19)(cid:10)(cid:2)(cid:20)(cid:24)(cid:25)(cid:25)(cid:5)(cid:26)(cid:27)(cid:28)(cid:3)(cid:29)User SelectionFlow Map(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:4)(cid:7)(cid:8)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:4)(cid:7)(cid:8)MashupsDataWidgetsScreens, Actions329