2008 Real-Time Systems Symposium
2008 Real-Time Systems Symposium

A Multi-Mode Real-Time Calculus

Linh T.X. Phan

Samarjit Chakraborty

P S Thiagarajan

Department of Computer Science, National University of Singapore

E-mail:{phanthix, samarjit, thiagu}@comp.nus.edu.sg

Abstract

The Real-Time Calculus (RTC) framework proposed in
[Chakraborty et al., DATE 2003] and subsequently ex-
tended in [Wandeler et al., Real-Time Systems 29(2-3),
2005] and a number of other papers is geared towards the
analysis of real-time systems that process various types of
streaming data. The main strength of RTC is a count-based
abstraction, where arrival patterns of event streams are
speciﬁed as constraints on the number of events that may
arrive over any speciﬁed time interval. In this framework,
algebraic techniques can be used to compute system prop-
erties in a compositional way. However, the main draw-
back of RTC is that it cannot model state information in a
natural way. For example, when a scheduling policy de-
pends on the ﬁll-level of a certain buffer or there is a shift
from one type of data stream into another. In this paper, we
extend RTC in a manner that enables state information to
be easily captured while limiting the state-space explosion
caused by ﬁne grained state-based models such as timed au-
tomata. Our model, called multi-mode RTC, speciﬁes event
streams as ﬁnite automata whose states are annotated with
functions that specify constraints on the arrival patterns of
event streams or the service available to process them. Our
new framework combines the expressiveness of state-based
models with the algebraic and compositional features of the
RTC formalism. In particular, system properties within a
single mode can be analyzed using the RTC-based alge-
braic techniques and state-space exploration can be used
to piece together the results obtained algebraically for the
individual modes. We show how to determine typical sys-
tem properties with the focus on efﬁcient approximate tech-
niques and illustrate the advantages of multi-mode RTC us-
ing two case studies.

1 Introduction

The increasing complexity of real-time embedded sys-
tems has prompted the need for modeling and analysis
techniques that go beyond those traditionally studied in
the literature. Many of these systems process irregular
data/event streams and rely on highly dynamic resource
management policies that cannot be modeled using stan-
dard periodic/sporadic event models and ﬁxed-priority or
deadline-based scheduling policies.

1052-8725/08 $25.00 © 2008 IEEE
1052-8725/08 $25.00 © 2008 IEEE
DOI 10.1109/RTSS.2008.47
DOI 10.1109/RTSS.2008.47

59
59

Figure 1: System model.

In this context, the Real-Time Calculus (RTC) frame-
work was introduced in [4, 16] and subsequently extended
in a number of other papers (e.g., see [17, 18]). RTC is de-
signed to model and analyze heterogeneous real-time sys-
tems in a compositional manner. The key feature of RTC
is that it relies on a count-based abstraction to model the
timing properties of the input streams, as well as the avail-
ability of the resources. In particular, the timing properties
of an event stream are speciﬁed as a constraint on the max-
imum and minimum number of events that may arrive over
every time interval of length Δ. A collection of such con-
straints for different values of Δ are captured as functions
αl(Δ) and αu(Δ) that denote lower- and upper-bounds on
the event arrival process. Hence, αl(Δ) (αu(Δ)) speciﬁes
the minimum (maximum) number of events that may arrive
within any time interval of length Δ. Clearly, these func-
tions will admit a rich collection of arrival sequences. Stan-
dard event models such as periodic, sporadic and periodic
with jitter turn out to be special cases of such a speciﬁca-
tion. Resource availability can also be speciﬁed in a similar
fashion. Here, β l(Δ) (βu(Δ)) will specify the minimum
(maximum) number of events that can be processed by a
resource within any time interval of length Δ. Given the
functions α, denoting (αl, αu), and β denoting (β l, βu), it
is possible to compute – using purely algebraic techniques
– bounds on system properties such as the maximum delay
suffered by the event stream and the maximum backlog of
events in front of the resource. Further, it is also possible to
compute α(cid:2) = (αl(cid:2)
, αu(cid:2)) which denotes bounds on the timing
properties of the processed event stream. α (cid:2) may now serve
as the input to the next resource which further processes this
stream, and the output from which may be denoted as α (cid:2)(cid:2).
This is repeated for all resources until the timing properties
αout of the output stream is computed (see Fig. 1).

In Fig. 1, PE 1, . . . , PE n denote n resources which
process an input stream in a pipelined fashion. Each PE i
has an input buffer which stores the incoming events wait-
ing to be processed. As explained above, the service pro-
vided by each PE i is bounded by β i. Similar to α(cid:2), it is
possible to compute βi
which denotes bounds on the re-
maining service, that can be used to process other event/data
streams. Apart from the buffer requirement and the delay
suffered by the input stream at each resource PE i, it is also
possible to compute the utilization of each resource, output
jitter, the maximum end-to-end delay and the total buffer
requirement in the system from the bounds α and α out.

(cid:2)

1.1 Our Contributions

Due to its functional nature, analysis in the RTC frame-
work involves algebraic manipulations which allows very
efﬁcient computation of system properties in a fully com-
positional manner. However, it does not allow the modeling
of state information in a natural way. As a result, common
scenarios such as the one where the service offered by a re-
source depends on the ﬁll-level of a buffer cannot be mod-
eled easily. On the other hand, ﬁne-grained modeling of
state information, e.g. using timed automata [1, 7] or event
count automata [5] will often lead to state space explosion
when applied to realistic problems. To bridge this gap be-
tween expressiveness and ease of analysis, in this paper we
extend the RTC framework to include state information in
a natural way while retaining the fundamental link to RTC.
Our model is a multi-mode RTC where the arrival process
of an event stream or the availability of a resource are mod-
eled as ﬁnite automata whose states are annotated with ar-
rival/service functions. Our new framework combines the
expressiveness of state-based models with the algebraic and
compositional features of the RTC formalism.
In partic-
ular, system properties within a single mode are analyzed
using the RTC-based algebraic techniques, and state-space
exploration is used to piece together the results obtained al-
gebraically for the individual modes.

The system model in multi-mode RTC is the same as in
the RTC framework (shown in Fig. 1). The key difference
is that the functions α and β are now replaced by arrival and
service automata Aarr and Aserv respectively. Each mode s
in Aarr (Aserv ) is annotated with an arrival (service) func-
tion αs (βs) which represent bounds on the event arrivals
(service rates) in that particular mode. The triggering of
transitions in Aarr and Aserv will depend on the amount
of time spent in the current mode and on external signals
generated by the environment. Given A arr and Aserv we
show how the service automaton A(cid:2)
arr that captures the tim-
ing properties of the processed stream and A (cid:2)
serv that cap-
tures the bounds on the remaining service can be obtained.
A(cid:2)
arr can then be used as an input for the next resource,
exactly as in the RTC framework and thus form the basis

for a compositional analysis method. Similarly, A (cid:2)
serv can
be used to process other event/data streams. Further, we
also show how Aarr and Aserv can be used to compute the
buffer space required to store events waiting to be processed
and the maximum delay suffered by the event stream. All
of these questions involve the algebraic techniques used in
RTC along with standard state-space exploration methods.
It may be noted that multi-mode RTCs are closely re-
lated in spirit to hybrid automata [9]. As a result, there is
straightforward approach to obtaining the required analysis
results by translation into event count automata (ECA) [5],
which may be viewed as a simple form of hybrid automata.
However, this will involve high computational costs since
ECAs are a ﬁne grained state-based model. Hence, we de-
velop approximate analysis methods which are more efﬁ-
cient. Our methods are conservative over-approximations.
For instance, the actual maximum buffer ﬁll-levels are guar-
anteed to be less than the upper bounds we provide. We use
standard RTC techniques to analyse the timing properties
for a speciﬁc combination of modes of an arrival/service au-
tomaton and combine it with a state exploration techniques
similar to the ones used for determining the boundedness of
places in Petri nets [10]. We also identify the special case,
where the synchronization between an arrival and service
automaton is tightly bound with the help of external sig-
nals, so that their mode changes always take place together.
In this, so called synchronous setting, our constructions are
considerably simpler and the estimates become tighter. We
also provide experimental validation of our analysis meth-
ods using two case studies.

1.2 Related Work

There are two broad lines of work that are related to
the model proposed in this paper. The ﬁrst is concerned
with task and event models that generalize classical peri-
odic or sporadic event models and assumptions on the ﬁxed
execution time requirements of tasks. Towards this, timed
automata and related automata-theoretic formalisms have
been recently used in a variety of setups to model and ana-
lyze task scheduling problems (e.g., see [1, 6, 7]).

To overcome the lack of state-based modeling in the RTC
framework, we had proposed event count automata (ECAs)
[5] that retain the count-based abstraction used in RTC, but
at the same time allows for the detailed modeling of state
information. ECAs, although syntactically similar to timed
automata (and in fact hybrid automata), use count rather
than clock variables that get incremented upon the arrival
of events. However, they are semantically very different.
In particular, in contrast to timed automata which – in this
setting – explicitly record the arrival times of events, ECAs
only record the number of events that arrive over any time
interval. Often this is an adequate and more appropriate ab-
straction for event streams and service availability.

6060

While ECAs are much more expressive than the ar-
rival/service functions used in RTC, they suffer from the
state explosion problem. Hence, it is difﬁcult to analyze
large system architectures when modeled as a network of
ECAs. The multi-mode RTC framework that we propose
in this paper can be seen as sitting in between the detailed
state-based ECA modeling and the original RTC framework
that is completely stateless. Thus, our formalism allows suf-
ﬁcient expressiveness, while mitigating the accompanying
state-space explosion problem.

Yet another direction of related work focuses on extend-
ing models and schedulability analysis techniques from the
real-time systems literature to accommodate more complex
behaviors. For example, the framework presented in [3] al-
lows certain tasks to intentionally change their execution
periods, which is a type of mode change. The associated
scheduling technique then adapts the periods of the other
tasks within allowable limits in order to maintain a schedu-
lable system. Similarly, the model proposed in [15] allows
a system to be in multiple modes, where each mode consists
of a set of tasks possibly overlapping with other modes. The
system uses Rate Monotonic scheduling for all the modes.
The problem is then to select suitable parameters for all the
tasks, such that the system is schedulable in all modes.

Different mode change protocols have been studied in
[8, 14] and have been classiﬁed in [13]. Here, again, a sys-
tem consists of multiple modes, where each mode consists
of a set of tasks. A mode change is triggered by a mode
change request (MCR), and transitions from an old to a new
mode take non-zero time. During this transition, the sys-
tem has tasks from both the old and the new modes, which
might produce a temporal overload. However, MCRs can-
not arrive during a transition period. The goal is to develop
techniques that ensure that no deadlines are violated dur-
ing the transition periods. Such techniques consist of suit-
able mode change protocols (e.g. to restrict mode changes
only at pre-speciﬁed time instants, or allow only synchro-
nous mode changes), as well as analysis techniques to ver-
ify the feasibility of the system in the different modes and
during the transition periods.

In contrast to the above approaches, we make the sim-
plistic assumption of instantaneous mode changes. How-
ever, as mentioned before, the arrival and service functions
associated with our modes allow arbitrary event streams and
resource availability which cannot be modeled using stan-
dard event models. Finally, our compositional approach
readily ﬁts into the framework reported in [11] where a net-
work of heterogenous components modeled as RTCs and
event count automata were analyzed by computing suit-
able interfaces between components of different types. Our
framework, however, is more uniform in the sense all the
components and data streams are modeled as automata and
the interfaces are also computed as (arrival) automata.

1.3 Organization of the Paper

In the next section we present our multi-mode RTC
framework. In particular, we deﬁne arrival and service au-
tomata and their behaviors. In Section 3 we develop our
analysis methods. After sketching the means for doing ex-
act – but expensive – analysis, we present in detail our
approximate techniques to compute maximum buffer ﬁll-
levels as well as the output data stream generated by a
processing element in the form of an arrival automaton. In
Section 4 we present experimental results using two case
studies derived from an MPEG-2 decoder to validate the
accuracy and the efﬁciency of our analysis methods. The
concluding section discusses the prospects for extending the
study of multi-mode RTC initiated in this paper.

2 Arrival and Service Automata

We now formulate a multi-mode version of arrival and
service functions. In particular, a service automaton con-
sists of a ﬁnite state automaton (FSA) in which each state
is associated with a service function. Mode changes are ef-
fected by invariants associated with the modes as well as
guards associated with the transitions. These invariants and
the guards are constraints based on time intervals. In ad-
dition, we also use external signals and buffer ﬁll-levels to
specify the guards.

2.1 Arrival and Service Functions

As outlined earlier, the basic idea in Real-Time Calculus
(RTC) is to bound the number of data items/events that can
arrive or be serviced within a speciﬁed length of time. An
arrival function α typically speciﬁes, for a ﬁnite number of
time interval lengths Δ1, . . . , Δk, the maximum number of
events that can arrive in any time interval of length Δ i. Such
a speciﬁcation captures a class of arrival sequences x(t) that
satisfy the following inequalities:

x(t + Δi) − x(t) ≤ α(Δi), ∀t ≥ 0 ∧ 1 ≤ i ≤ k

In fact, in RTC , one often describes an arrival pattern via a
pair of arrival functions (αl, αu) where the arrival pattern is
understood to be bounded by the inequalities:
αl(Δi) ≤ x(t+Δi)−x(t) ≤ αu(Δi), ∀t ≥ 0 ∧ 1 ≤ i ≤ k
Similarly, to model the varying processor bandwidth made
available by a resource, a pair of service functions β =
(βl, βu) can be used to specify lower and upper bounds
on the number of events that can be processed by the re-
source within any time interval of a speciﬁed length. Let
c(t) denote the number of events that can be processed dur-
ing the time interval [0, t]. Such a service is bounded by
β = (βl, βu) if the following inequalities hold.

βl(Δ) ≤ c(t + Δ) − c(t) ≤ βu(Δ), ∀t ≥ 0, Δ ≥ 0

Again, the bound on the service would typically be spec-
iﬁed for a ﬁnite number of time interval lengths. Now,

6161

given the bounds (αl, αu) on the arrival process of a stream
and the service bounds (β l, βu) offered by a resource,
[4] presented a calculus that allows us to compute (i) the
minimum buffer size required at the input side of the re-
source, (ii) the maximum delay that can be suffered by an
event, (iii) bounds on the timing properties of the processed
stream, and (iv) bounds on the remaining service. Fur-
ther, when a stream is processed by multiple resources (see
Fig. 1), these bounds can be successively transformed and
the timing properties of the fully processed stream can be
computed in a compositional manner.

However, as pointed out earlier, the calculus presented
[4] is purely functional and can not model setups where the
arrival patterns and the processing of a stream depend on
the state of the system.

2.2 Arrival Automata

s, αu

An arrival automaton models an incoming event/data
stream. It is a FSA where each state s has a pair of arrival
functions (αl
s ) associated with it. When the automa-
ton’s current mode is s, the number of events that arrive in
any time interval of length Δ is at least αl
s(Δ) and at most
αu
s (Δ). There is too an invariant in the form of a time inter-
val [Ls, Us] that speciﬁes the minimum amount of time L s
the automaton must spend in s and the maximum amount of
time Us it may spend in s after entering it.

An input signal and a time interval [L, U ] is associated
with each transition (si, sj). The automaton can only take
the transition on the arrival of the input signal a and pro-
vided it has been staying at si for at least L and no longer
than U units of time. We assume that upon entering a new
state, all the bounds given by the arrival functions associated
with the previous state are forfeited; only constraints given
by the arrival functions of the present state are applicable.
In the formal deﬁnition of arrival automata that follows, N
denotes the set of non-negative integers and INT is the set
of ﬁnite intervals over N. In other words, each member of
INT is of the form [L, U ] with L, U ∈ N and L ≤ U .

Deﬁnition 1 (Arrival automaton). An arrival automaton is
a tuple Aarr =

(cid:2)
(cid:3)
S, sin, Σ, Inv , α, −→

where

• S is a ﬁnite set of states
• sin ∈ S is an initial state
• Σ is a ﬁnite set of signals
• Inv : S → INT is an invariant function associated

with the states, where Inv (s) = [Ls, Us].

• α is an arrival function that assigns to each s ∈ S, a
s ) giving the lower and

pair of arrival functions (αl
upper arrival functions associated with s.

s, αu

• −→⊆ S × Σ × INT × S is a transition relation.

l
α2(1) = 3
u
α2(1) = 14

s2
α2

l
α1(1) = 2
u
α1(1) = 5

s1
α1
[4, 6]

a

b

[2, 10]

Figure 2: An arrival automaton.

2, αu

1, αu

1(1) = 2 and αu
2(1) = 3 and αu

An example of an arrival automaton is shown in Fig. 2.
It captures an event stream whose arrival patterns are gov-
erned by two modes. In the ﬁrst mode – which is also the
initial one – at least 2 events and at most 5 events arrive in
every time unit. In the second mode at least 3 events and
at most 14 events arrive in every time unit. Accordingly,
α1 = (αl
1 ) and there is just a single constraint, namely
for the time interval 1 with αl
1 (1) = 5. Sim-
ilarly, α2 = (αl
2 ) with αl
2 (1) = 14.
Starting from t = 0, at some time during [4, 6], events start
to arrive at a faster rate as signalled by the external signal a
presumably generated by the network interface or the down-
stream component generating this event stream. Notice that
there is no timing guard associated with the transition from
s1 to s2. Similarly, the state s2 does not have an invariant
associated with it. To comply with the formal deﬁnition,
one can introduce and use the default guard [0, ∞] for this
purpose. To complete our example, once the automaton en-
ters the mode s2, after 2 to 10 units, the arrival rates slow
down to the one associated the mode s 1 and the correspond-
ing transition from s2 to s1 is signalled by the conjunction
of the arrival of the signal b and the guard [2, 10].

We assume that the transitions are executed in an urgent
fashion. If the automaton is in the mode s at time t and one
of the outgoing transitions of s is enabled then one of the
enabled outgoing transitions of s will be taken at t. In case
more than one transition is enabled, the choice of which
transition to take will be made non-deterministically.

An arrival automaton speciﬁes a language of arrival se-
quences. By an arrival sequence we mean a sequence of
positive integers c1c2 . . . ci . . . where ci represents the num-
ber of events that have arrived during the unit time interval
[i − 1, i). To bring this out, let α = (αl, αu) be an arrival
function with αl and αu specifying lower and upper bounds
for the set of time intervals {Δ1, Δ2, . . . Δk}. Then an ar-
rival sequence according to α is a sequence of positive inte-
gers c1c2 . . . cn such that for each i and j in {1, 2, . . . , n},
if i < j and j − i = Δm for some m ∈ {1, 2, . . . , k}, then

αl(Δm) ≤ (ci+1 + ci+2 + · · · + cj) ≤ αu(Δm).

Thus 3 2 5 is an event sequence according to α 1 speciﬁed
above, while 3 4 6 is not.

Next let Aarr be an arrival automaton as in Deﬁnition 1.
Then an execution sequence of this automaton is a ﬁnite
sequence of the form:

6262

σt2(cid:2)(cid:2)(cid:3) s1

σt1(cid:2)(cid:2)(cid:3) s0

a1−→ s1

s0
such that s0 = sin and the following conditions are satisﬁed
for each i with 0 < i ≤ n:

a2−→ s2 . . . sn−1

an−→ sn

σtn−1(cid:2)(cid:2)(cid:3) sn−1

• ti is a positive integer and σti is an arrival sequence
according to the arrival function α si−1 associated with
the mode si−1.
• ti ∈ Inv (si−1)
• There exists a transition (si−1, ai, I, si) ∈−→ such

that ti ∈ I.

We say that σt1 σt2 . . . σtn is the arrival sequence induced
by the above execution sequence. The set of all such ar-
rival sequences is the language of arrival sequences spec-
iﬁed by the arrival automaton. For the example shown in
Fig. 2, 3 2 5 4 7 11 12 2 is an arrival sequence correspond-
4 7 11 12
ing to the execution sequence s 1
(cid:2)(cid:2)(cid:3)
2
(cid:2)(cid:2)(cid:3) s1. On the other hand, 3 9 7 11 2 5 4 is not an
s2
arrival sequence because in the second time unit, the system
must be at s1 and hence there cannot be 9 events that arrive.

3 2 5
(cid:2)(cid:2)(cid:3) s1

a−→ s2

b−→ s1

2.3 Service Automata

A processing resource is modeled as a service automa-
ton.
Its syntax and semantics are identical to that of an
arrival automaton except that the number of events that ar-
rive in a unit time interval is now interpreted as the number
of processor cycles (in terms of the number of events that
can be processed) that are available in this time interval.
In addition, the transitions can also have guards specify-
ing linear constraints on the ﬁll-levels of the input and out-
put buffers associated with the processing element. In the
present instance, where we do not consider multiple data
streams, there is just one associated input buffer and one
output buffer as shown in Fig. 1. In the general case, there
is one input-output buffer pair for each stream.

Assume a ﬁnite set of (positive) integer valued variables

B standing for buffers with B ranging over B.
Buffer constraints: A buffer constraint is a conjunctive for-
mula of atomic constraints of the form B ∼ n with B ∈ B,
∼∈
and n ∈ N. We use ΦB to denote the
set of buffer constraints, ranged over by ϕ.

≤, <, =, >, ≥

(cid:4)

(cid:5)

Deﬁnition 2 (Service automaton). A service automaton is
a tuple Aserv =

(cid:2)
(cid:3)
S, sin, Σ, Inv , β, ΦB, −→

where

• S is a ﬁnite set of states
• sin ∈ S is an initial state
• Σ is a ﬁnite set of signals
• Inv : S → INT is an invariant function associated

with the states, where Inv (s) = [Ls, Us].

• β is an arrival function that assigns to each s ∈ S, a
s ) giving the lower and

pair of service functions (β l
upper service functions associated with s.

s, βu

• −→⊆ S × Σ × INT × ΦB × S is a transition relation.

The new feature is that a mode change can be also be
constrained by the current ﬁll-levels of the input and out-
put buffers. For deﬁning execution sequences, we need to
track the current number of events in the buffers. This how-
ever requires information about the arrival processes which
are depositing events into the input buffers and the service
processes that are removing events from the output buffers.
Hence, we do not work out the details here.

3 Analysis Techniques

We now consider the multi-stage processing of an event
stream as shown in Fig. 1. Our objective is to analyze the
behavior of the system and determine properties such as
the maximum ﬁll-level of the various buffers, the end-to-
end delay experienced by the input event stream, the timing
characteristics of the output event stream and the remain-
ing resource at each stage after processing the event stream.
We start with the ﬁrst stage where the input stream modeled
as the arrival automaton Aarr deposits events into the input
buffer B of PE 1 which is then processed by the processing
element PE 1. The service provided by PE 1 in terms of the
number of events can be processed per unit time is mod-
eled by the service automaton Aserv . We wish to estimate
the maximum ﬁll-levels of the input buffer B and compute
the characteristics -in the form of an arrival automaton- of
the output stream being deposited into the buffer B (cid:2). We
ﬁrst sketch how these properties can be computed exactly.
In [5] we showed how Event Count Automata (ECAs), can
be used to model arrival and service functions. Indeed, for
each arrival function we can effectively construct an ECA
such that the language of arrival sequences accepted by the
ECA is exactly the set of arrival sequences deﬁned by the
arrival function. Similar assertions hold for service func-
tions as well.
It is easy to extend these constructions to
arrival and service automata. Thus for each arrival (ser-
vice) automaton we can effectively construct an ECA such
that the two mechanisms deﬁne the same set of arrival (ser-
vice) sequences. Furthermore, we also showed in [5] how
a network of ECAs can be translated into a Petri net such
that the set of reachable markings corresponds to the set of
reachable conﬁgurations of the network of ECAs. An ex-
haustive analysis of this Petri net can reveal whether any of
the buffers can become unbounded. One can also determine
-when all the buffers are bounded- the sequences of data
streams being deposited into the internal and output buffers
of the network. We can use these constructions involving
networks of ECAs and Petri nets to determine the proper-
ties we are after. However this a computationally expen-
sive route and scalability is difﬁcult to achieve. Hence we
propose below a more viable but conservative approximate
scheme.

6363

3.1 Worst-Case Analysis

(cid:2)

(cid:3)
S, sin, Σ, Inv , α, −→

(cid:3)

Let Aarr =

in, Σ(cid:2), Inv (cid:2), β, ΦB, −→(cid:2)

be an arrival
automaton describing the data stream being deposited
Let A serv =
into the input buffer B of PE 1.
(cid:2)
S(cid:2), s(cid:2)
be a service automaton de-
scribing the process cycles provided by PE 1 that processes
the events arriving at B. We ﬁrst describe a method for com-
puting -approximately- the maximum ﬁll-level of B. This
will then lead to the method for constructing an arrival au-
tomaton that captures the processed data stream being de-
posited into the output buffer B (cid:2). To start with, suppose we
are given an arrival function α which speciﬁes constraints
for the temporal lengths {Δ1, Δ2, . . . , Δk}. Suppose fur-
ther we are given a time interval I = [L, U ]. Then we can
extend α with constraints for each t ∈ I as follows:

• α(t) = α(Δ1), if t ≤ Δ1;
• α(t) = min
α(Δi), min
0≤d≤t

(cid:4)

if Δi−1 < t ≤ Δi;

{α(d) + α(t − d)}

(cid:5)
,

• α(t) = min
0≤d≤t

{α(d) + α(t − d)}, if t > Δk.

Thus we allow as many items as possible to arrive in a time
interval of length t subject to the constraints speciﬁed by α
being satisﬁed. A similar extension is deﬁned for the ser-
vice function β whose constraints are deﬁned for the set of
temporal lengths {Δ(cid:2)

2, . . . , Δ(cid:2)

1, Δ(cid:2)

m}:

• β(t) = 0, if 0 ≤ t < Δ(cid:2)
1;
• β(t) = β(Δ(cid:2)
i), if t = Δ(cid:2)
i, for 1 ≤ i ≤ k;
if Δ(cid:2)
• β(t) = max
0≤d≤t
m.

{β(d) + β(t − d)},

or t > Δ(cid:2)

i−1 < t < Δi

Thus we permit as few service cycles as possible to be pro-
vided in a time interval of length t subject to the constraints
speciﬁed by β being satisﬁed.

We can now turn to the problem of computing the
maximum ﬁll-level of the buffer B. We shall construct
T , a ﬁnite tree whose nodes are of the form v =
(s, s(cid:2), [Lπ, Uπ], π, Bπ) with s ∈ S, s(cid:2) ∈ S(cid:2) and [Lπ, Uπ] ∈
INT . Further, π is the path from the root to v, L π and Uπ
are the earliest and latest time instants at which the system
enters v, and Bπ is the maximum buffer ﬁll-level when the
system enters v. We will compute for each π the functions
π) and βπ = (βl
απ = (αl
π(Δ))
and αu
π (Δ)) are the minimum and maximum num-
ber of events that arrive (can be processed) in the last Δ
units of time before the system enters v, for 0 ≤ Δ ≤ U π.
It then follows that Bπ ≤ bufmax (π), where
π(Δ) − βl

bufmax (π) def= max

π, αu
π(Δ) (βu

π) where αl

π(Δ) (βl

π(Δ)}

π, βu

{αu

(1)

0<Δ≤Uπ

The set of nodes of T we wish to construct will be denoted
as C and its edge relation by ⇒. It will be convenient to
deﬁne the transition relation (cid:2)(cid:2)(cid:3)⊆ (S × S (cid:2)) × (Σ ∪ Σ(cid:2) ×
INT ) × Φ(B) × (S × S(cid:2)):

• Suppose s a,I−→ s1 and a ∈ Σ − Σ(cid:2) and s(cid:2) ∈ S(cid:2). Then

1 and a(cid:2) ∈ Σ(cid:2) − Σ and s ∈ S (cid:2).

(s, s(cid:2))

a,I
(cid:2)(cid:2)(cid:3) (s1, s(cid:2)).
a(cid:2),I (cid:2),ϕ(cid:2)
−→(cid:2) s(cid:2)
a,I (cid:2),ϕ
(cid:2)(cid:2)(cid:3) (s, s(cid:2)

• Suppose s(cid:2)
Then (s, s(cid:2))

1).
• Suppose s a,I−→ s1 and s(cid:2)

a,I∩I (cid:2),ϕ(cid:2)

a,I (cid:2),ϕ(cid:2)
−→(cid:2) s(cid:2)

1 and a ∈ Σ ∩ Σ(cid:2).
1). (if I = [L, U ] and I (cid:2) =

Then (s, s(cid:2))
[L(cid:2), U (cid:2)], then I ∩ I (cid:2) = [max{L, L(cid:2)}, min{U, U (cid:2)}]).

(s1, s(cid:2)

(cid:2)(cid:2)(cid:3)

In this paper we focus on the synchronous case where an
arrival automaton and a service automaton communicating
through a buffer must always make their moves together.
The analysis for the general setting where arrival and ser-
vice automata may make their transitions asynchronously is
done similarly with a slight modiﬁcation in the computation
of the functions associated with each node. The details may
be found in [12].

We start with vin = (sin , s(cid:2)

in , [0, 0], (cid:7), 0) ∈ C. As usual,
(cid:7) denotes the null path. We declare vin to be a non-terminal
node. Furthermore, it is the root of T . Since no event has
arrived, α(cid:5) = β(cid:5) = 0.

a,I,ϕ
(cid:2)(cid:2)(cid:3) (s1, s(cid:2)

Suppose v = (s, s(cid:2), [Lπ, Uπ], π, Bπ) ∈ C is a non-
terminal node with α(s) = (αl, αu) and β(s(cid:2)) = (βl, βu).
Assume inductively that απ(cid:2) and βπ(cid:2) have been deﬁned
for all sub-path π (cid:2) of π that starts from vin . Suppose
τ = (s, s(cid:2))
1) with a ∈ Σ ∩ Σ(cid:2). The path to
1) is then πτ . Let [L, U ] = Inv (s) ∩ Inv (cid:2)(s(cid:2)) ∩ I.
(s1, s(cid:2)
Roughly speaking, [L, U ] is the interval in which, if the sig-
nal a arrives, then the transition (s, s(cid:2))
1) can be
taken. Thus, the earliest and latest instants at which τ is
taken are Lπ + L and Uπ + U . Since (i) there are at least
αl
π(x) and at most αu
π(x) events that arrive in the last x
units of time before the system enters v and (ii) the system
must stay in v for at least L time units, the minimum and
maximum number of events that arrive in the last Δ time
units before the system enters (s1, s(cid:2)
1) are computed for all
0 ≤ Δ ≤ Uπ + U as follows:

a,I,ϕ
(cid:2)(cid:2)(cid:3) (s1, s(cid:2)

• If Δ ≤ L, αl
• Otherwise,

πτ (Δ) = αl(Δ) and αu

πτ (Δ) = αu(Δ).

αl

πτ (Δ) = min

0≤x≤Uπ

L<Δ−x≤U

αu

πτ (Δ) = max
0≤x≤Uπ

L<Δ−x≤U

(cid:4)

(cid:5)
αl
π(x) + αl(Δ − x)

(cid:4)

(cid:5)
αu
π(x) + αu(Δ − x)

Similarly, we obtain βπτ by substituting α with β in the
above formulas. In addition, as the maximum buffer ﬁll-
level when the system enters v is Bπ, the buffer ﬁll-level
when the system enters (s1, s(cid:2)

1) is at most
{Bπ + αu(Δ) − βl(Δ)}

buf (Bπ, s, s(cid:2)) def= max
0≤Δ≤U

6464

Suppose Bϕ is the largest value of B that satisﬁes the buffer
constraint ϕ. Combine with Eq. 1, we obtain

Bπτ = min(buf (Bπ, s, s(cid:2)), bufmax (πτ ), Bϕ).

1).

πτ (Δ2) − βl

Let Δ1 be the smallest interval such that αu
πτ (Δ1) −
βl
πτ (Δ1) satisﬁes ϕ and Δ2 be the largest interval such
that αu
πτ (Δ2). Then, at all time points before
Δ1 and after Δ2, the transition τ cannot be taken. Deﬁne
[Lπτ , Uπτ ] = [Lπ + L, Uπ + U ] ∩ [Δ1, Δ2]. Then Lπτ and
Uπτ are the earliest and latest instant at which the system
enters (s1, s(cid:2)

We now add v1 = (s1, s(cid:2)

1, [Lπτ , Uπτ ], πτ, Bπτ ) as a
node in C and (v, v1) as an edge in ⇒. We declare v1 to
be an un-bounded terminal node in case there is an ancestor
node u of v1 in T with u = (s1, s(cid:2)
1, [Lσ, Uσ], σ, Bσ) such
that (i) none of the guards associated with the transitions
from u to v1 contains B ≤ n or B < n for n ∈ N and (ii)
K > 0 where K = max
πτ (Δ)} − Bσ.
In case (i) does not satisfy or K ≤ 0 we declare it to be a
normal terminal node. If v1 does not have an ancestor node
with the same state components, then it is deemed to be a
non-terminal node.

πτ (Δ) − βl

Δ>Lπτ −Lσ

{αu

Note in the above that if K > 0, as the system cycles
through the path from u to v (denoted as ρ), the maximum
buffer ﬁll-level each time the system enters (s 1, s(cid:2)
1) is in-
creased by at least K. If none of the buffer guards of the
transitions in ρ impose upper bounds on the ﬁll-level (i.e.
condition (i) holds), by cycling through ρ an inﬁnite num-
ber of times, the maximum buffer ﬁll-level when the system
enters (s1, s(cid:2)
1) will become unbouded. On the other hand, if
K ≤ 0, the maximum buffer ﬁll-level as well as the arrival
and service functions associated with the paths that repeat
ρ one or more time will be bounded by that of σ. Simi-
larly, if (i) is not satisﬁed, these functions are bounded by
the functions of τ π. Hence, we do not need to consider the
successor nodes of v1.

We then consider the next transition from v or mark v as
visited if all out-going transitions from v have already been
explored. We repeat the above process until all non-terminal
nodes in C are visited.

We claim that T is a ﬁnite tree whose construction ter-
minates after a ﬁnite number of steps. Suppose otherwise,
there exists an inﬁnite path π in T . Since S and S (cid:2) are
ﬁnite, there are s ∈ S and s(cid:2) ∈ S(cid:2) such that (s, s(cid:2)) appears
inﬁnitely often in π. This contradicts to the construction
that every node v of π with the same state components as
that of its ancestor is a terminal node and is present exactly
once. Hence, T is ﬁnite. Each non-terminal node in C
is marked as visited exactly once, hence the construction
terminates after a ﬁnite number of steps.

Buffer ﬁll-level analysis: To compute the maximum buffer
ﬁll-level of B, we declare the buffer to be unbounded
if there is an unbounded terminal node in T .
If not,

we ﬁrst compute the maximum ﬁll-level maxbuf (v) at-
tained at each node v as follows.
Suppose v =
(s, s(cid:2), [Lπ, Uπ], π, Bπ) with α(s) = (αl, αu), β(s(cid:2)) =
(βl, βu), Inv (s) = [Ls, Us] and Inv (cid:2)(s(cid:2)) = [Ls(cid:2) , Us(cid:2)]. The
maximum number of events that arrive in any interval of
length Δ that ends when the system is at v is
αu

π(x) + αu(Δ − x) | 0 ≤ Δ − x ≤ Uv}

{αu

v (Δ) = max
0≤x≤Uπ

where Uv = min(Us, Us(cid:2) ). This comes from the condi-
tions that at most αu
π(x) events arrive in the last x units
of time before the system enters v and at most α u(Δ − x)
events arrive in Δ − x time units while the system is at v.
Analogously, the minimum number of events that can be
processed during any interval of length Δ that ends when
the system is at v is
βl
v(Δ) = min

π(x) + βl(Δ − x) | 0 ≤ Δ − x ≤ Uv}

{βl

0≤x≤Uπ

{αu

max

0≤Δ≤Uπ+Uv

v (Δ) − βl

Thus, the buffer ﬁll-level when the system is at v is at
most maxbuf (cid:2)(v) =
v(Δ)}.
In addition, since Bπ is the maximum buffer ﬁll-level
when the system enters v, the buffer ﬁll-level at v is at
most maxbuf (cid:2)(cid:2)(v) = max
{Bπ + αu(Δ) − βl(Δ)}.
the maximum buffer ﬁll-level of B is
As a result,
maxbuf (v) = max(maxbuf (cid:2)(v), maxbuf (cid:2)(cid:2)(v)). It follows
that the maximum buffer ﬁll-level of B is the maximum of
maxbuf (v) for all v ∈ C}.

0≤Δ≤Uv

End-to-end delay analysis: We compute the maximum end-
to-end delay of the data stream based on T . At any instant
t, the system is in some node v = (s, s(cid:2), [Lπ, Uπ], π) ∈ C
with Lπ ≤ t ≤ Uπ + Uv. For all 0 ≤ Δ ≤ t, the
maximum number of events that arrive in [t − Δ, t] is
αu
v (Δ) and the minimum number of events that can be
processed in [t − Δ, t + d] is βl
v(cid:2) (Δ + d) for v(cid:2) = v or
v(cid:2) = (s1, s(cid:2)
1, [Lπ(cid:2), Uπ(cid:2)], π(cid:2)) ∈ C such that π ⊂ π(cid:2) and
Lπ(cid:2) − Lπ ≤ d. Let succ(v, d) be the set of all such v (cid:2).
Thus the maximum delay of an event that arrive at t is
the minimum of d such that αu
v(cid:2) (Δ + d) for
all 0 ≤ Δ ≤ t and v(cid:2) ∈ succ(v, d). As a result, the
maximum end-to-end delay of any event that arrives when
the system is at a node v is delay(v) = min{d | αu
v (Δ) ≤
βl
v(cid:2) (Δ + d) ∀ 0 ≤ Δ ≤ Uπ + Uv ∧ ∀ v(cid:2) ∈ succ(v, d)}.
The maximum end-to-end delay of the event stream is then
the maximum of delay(v) for all v ∈ C.

v (Δ) ≤ βl

Arrival automaton of the output stream: When the maxi-
mum buffer ﬁll-level of the system is bounded, we can com-
pute an arrival automaton representation of the processed
data stream being deposited into the output buffer B (cid:2) (see
Fig. 1). To this end, we derive αl
v , which give the
lower bound on the number of events that arrive and the up-
per bound on the number of events that can be processed in
any interval of a given length Δ that ends when the system is

v and βu

6565

v and βl

at v for all v ∈ C. This is done using similar arguments that
derive αu
v described above. We then compute for all
v ∈ C the arrival function α(cid:2)
v ) that bounds the
processed event stream when the system is in v as below.

v = (αl(cid:2)

v , αu(cid:2)

Let v ∈ C. At any instant t when the system is at v, the
number of events that are processed in [t − Δ, t) is at most
βu
v (Δ). Moreover, it is upper bounded by the maximum
number of events that are processed in [t − Δ − λ, t) sub-
tracted by the minimum number of events that are processed
in [t − Δ − λ, t − Δ) for all λ ≥ 0 and λ ≤ t − Δ. First,
observe that at time t − Δ, the system is either at v or some
ancestor node v(cid:2) = (s1, s(cid:2)
1, [Lπ(cid:2), Uπ(cid:2)], π(cid:2), Bπ(cid:2) ) of v such
that Lπ − Lπ(cid:2) ≤ Δ. Thus, the minimum number of events
that are processed in [t − Δ − λ, t − Δ) is β l
v(cid:2)(λ). Sec-
ondly, the maximum number of events that are processed in
[t − Δ − λ, t) does not exceed αu
v(cid:2)(cid:2) (Δ + λ − d) for
all 0 ≤ d ≤ Δ + λ and v(cid:2)(cid:2) = (s2, s(cid:2)
2, [Lπ(cid:2)(cid:2) , Uπ(cid:2)(cid:2)], π(cid:2)(cid:2), Bπ(cid:2)(cid:2)),
π(cid:2) ⊆ π(cid:2)(cid:2) ⊆ π and Lπ − Lπ(cid:2)(cid:2) ≤ d. As a result,
αu(cid:2)

v (d) + βu

max

min

αu

v (Δ) = min

v (d)

(cid:6)

(cid:7)

(cid:4)

λ≥0∧πv(cid:2) ⊆πv
Lπv −Lπ
v(cid:2) ≤Δ

πv(cid:2) ⊆πv(cid:2)(cid:2) ⊆πv

Lπv −Lπ

v(cid:2)(cid:2) ≤d≤Δ+λ

+ βu

(cid:5)
v(cid:2)(cid:2) (Δ + λ − d)

(cid:8)

(cid:9)

− βl

v(cid:2) (λ)

, βu

v (Δ)

where πv denote the path that leads to v in T . Similarly, we
can also compute αl(cid:2)

v for all v ∈ C.

v and β(cid:2)

s,s(cid:2) , αu
v (Δ) | v ∈ Vs,s(cid:2) } and αu

Now let Vs,s(cid:2) be the set of all nodes v in C that con-
tain (s, s(cid:2)) as their state components. The set of states
arr is the set of all (s, s(cid:2))
S(cid:2)(cid:2) of the arrival automaton A(cid:2)
such that Vs,s(cid:2) is non-empty, with (sin, s(cid:2)
in) being the initial
state. The invariant associated with each state (s, s(cid:2)) ∈ S(cid:2)(cid:2)
is [Ls,s(cid:2), Us,s(cid:2) ] = Inv (s) ∩ Inv (cid:2)(s(cid:2)). The arrival func-
tions associated with (s, s(cid:2)) is α(s, s(cid:2)) = (αl
s,s(cid:2) ) with
s,s(cid:2) (Δ) = min{αl(cid:2)
αl
s,s(cid:2) (Δ) =
max{αu(cid:2)
v (Δ) | v ∈ Vs,s(cid:2) } for all Δ ∈ [0, Us,s(cid:2)]. The transi-
tion relation −→ of A(cid:2)
arr is deﬁned using the edge relation
of T and the transition relation (cid:2)(cid:2)(cid:3). Speciﬁcally, suppose
(s, s(cid:2))
1) is a transition in(cid:2)(cid:2)(cid:3) such that the set
of all edges of T that are constructed using this transition
(cid:11)
(cid:10)
(s, s(cid:2)), a, I (cid:2), (s1, s(cid:2)
1)
is added to the
is not empty. Then
arr with I (cid:2) = I ∩ Inv (s) ∩ Inv (cid:2)(s(cid:2)).
transition relation of A(cid:2)
arr has been constructed, it can
be combined with A2
serv , the service automaton capturing
the service provided by PE 2 to compute the maximum
buffer ﬁll-level of the output buffer B (cid:2). Thus the system
level analysis of the whole cascade can be carried out in a
compositional way.

We note that once A(cid:2)

a,I (cid:2),ϕ
(cid:2)(cid:2)(cid:3) (s1, s(cid:2)

Service automaton of the remaining service curve: The ser-
vice automaton A(cid:2)
serv that represents the residual service
cycles of PE 1 after processing the data stream arriving at
B is the same as A(cid:2)
arr , except that each state (s, s(cid:2)) is asso-
ciated with a service function βs,s(cid:2) which is computed sim-

(cid:10)
(cid:11)
(s, s(cid:2)), a, I (cid:2), (s1, s(cid:2)
1)

ilarly to the computation of αs,s(cid:2) . Furthermore, each tran-
sition
is additionally guarded with a
buffer constraint ϕ that comes from (s, s (cid:2))

a,I,ϕ
(cid:2)(cid:2)(cid:3) (s1, s(cid:2)

1).

It can be derived from our analysis that the bounds we
obtain are conservative ones in that the actual bounds are
less than or equal to the ones we compute.

4 Case Studies

We present two case studies to illustrate the effect of
mode switching on the timing properties of a system. These
case studies also serve to demonstrate that our approach
improves the performance estimates of realistic stream
processing systems.
In the ﬁrst study, we analyze an
MPEG-2 decoder in which the processor operates at two
different frequencies. The mode switchings between the
two frequencies are steered by the ﬁll-levels of the input
buffer. In the second study, we examine a system where
its resource allocation is adapted to the arrival rates of the
incoming event stream. In both case studies, we analyze
the maximum buffer ﬁll-level of the buffer as well as the
end-to-end delay of the input stream and compared the re-
sults against the monolithic RTC framework. Additionally,
we use Event Count Automata to compute the optimal so-
lutions in order to compare the relative accuracy of our and
the RTC frameworks.

4.1 Case Study 1: An MPEG-2 Decoder

Fig. 3 shows an MPEG-2 decoder application that is par-
titioned and mapped onto two processing elements PE 1 and
PE 2. The processor PE 1 runs the VLD and IQ tasks while
PE 2 runs the IDCT and MC tasks. The (coded) input bit-
stream enters this system and it is stored in the input buffer
B. The macroblocks in B are ﬁrst processed by PE 1 and
the corresponding partially decoded macroblocks are stored
in the buffer B (cid:2) before being processed by PE 2. The result-
ing stream of fully decoded macroblocks is written into a
playout buffer B (cid:2)(cid:2) prior to transmission by the output video
In the above system, the coded input event stream
device.

Figure 3: An MPEG-2 decoder application.

arrives at a constant bit-rate. PE 1 operates at two different
frequencies depending on the state of the input buffer B. It
initially starts with frequency f0 and changes to a higher fre-
quency f1 whenever the ﬁll-level of buffer B is more than
50% of its capacity. PE 1 is guaranteed to maintain the fre-
quency f1 for up to T time units before switching back to

6666

S0

S1

(cid:4)0

[0, (cid:2)]

(cid:4)1
[1, t]

.

S0

α

[0, (cid:2)]

B (cid:3) C

S0

(cid:4)2
[0, (cid:2)]

(a) Arrival automaton

of the input stream

(c) Service automaton

of PE2

(b) Service automaton

of PE1

Figure 4: The multi-mode RTC model of the decoder in Fig. 3

frequency f0 while PE 2 is assumed to operate at a ﬁxed
frequency f2. In this system, we are interested in comput-
ing the maximum ﬁll-level of the buffer B (cid:2) given the rate of
the incoming input stream, the clock frequencies f 0, f1 and
f2 of the two processors as well as the capacity of B.

4.1.1 Obtaining Arrival and Service Functions

We collected execution traces of the different tasks by sim-
ulating their execution using a customized version of the
SimpleScalar instruction set simulator [2]. From these
traces, we measured the execution demands of the VLD and
IQ tasks for each macroblock in a video sequence while
considering (i) the constant arrival rate of the compressed
bit stream at the input of PE 1 and (ii) the number of bits al-
located to encode each macroblock in the stream. Based on
these execution demands, we derive a function x(t) which
gives the number of macroblocks arriving at B during the
time interval [0, t]. From x(t), we computed the arrival
function α = (αl, αu) of the input event stream according
to the deﬁnition of an arrival function in Section 2.1.

Similarly, based on the obtained execution demands of
the VLD and IQ tasks for each macroblock, we computed
the workload function γ at the ﬁrst PE, where γ(k) gives the
minimum and maximum number of cycles required by any
k consecutive macroblocks. By combining γ and the fre-
quencies f0 and f1, we deduce the corresponding service
functions β0 = (βl
1 ) for PE 1. The
service function β2 = (βl
2 ) that represents the process-
ing capability of PE 2 is computed analogously using the
execution demands of the IDCT and MC tasks for each mac-
roblock and the frequency f 2.

0 ) and β1 = (βl

0, βu

1, βu

2, βu

4.1.2 Using Multi-mode RTC

The multi-mode RTC model of the application is depicted in
Fig. 4. The arrival automaton Aarr of the event stream has
a single mode with no out-going transitions. This mode is
associated with an invariant [0, ∞] and the arrival function
α calculated above.

The service automaton Aserv that models PE 1 has two
modes s0 and s1 associated with invariants [0, ∞] and [1, T ]

respectively. The corresponding service functions of these
modes are the obtained β0 and β1. The transition from s0 to
s1 is guarded by a buffer constraint B ≥ C, with C being
half the capacity of B. As soon as there are at least C events
in the buffer B, the automaton will switch from s 0 to s1 and
will stay there for at most T unit of times. Unlike PE 1, the
second PE has only a single mode that with the associated
service function being β2 and the invariant being [0, ∞).

To analyze the ﬁll-level of buffer B (cid:2), we ﬁrst compute
the arrival automaton A(cid:2)
arr for the output event stream gen-
erated by PE 1. This is obtained from A arr and Aserv with
the help of the analysis technique described in Section 3.
The resulting A(cid:2)
arr is next composed with the service au-
tomaton A(cid:2)
serv of the second PE to derive the maximum
ﬁll-level of buffer B (cid:2).

4.1.3 Using Standard RTC

Following the standard RTC approach, the event stream is
modeled as α = (αl, αu), the arrival function described
above. Since mode switching is not explicitly modeled
in the RTC framework, the maximum resource offered by
PE 1 is assumed to be the upper bound of β u
0 and βu
1
whereas the minimum resource offered by PE 1 is assumed
to be the lower bound of β l
1. In other words, the
service offered by PE 1 is modeled as the service function
β = (βl, βu) such that βu(Δ) = max{βu
1 (Δ)} and
βl(Δ) = min{βl
1(Δ)} for all Δ ≥ 0. As might be
expected, PE 2 is modeled as the service function β 2. Our
analysis of this RTC model follows the standard methods
associated with the RTC framework [4].

0 (Δ), βu

0 and βl

0(Δ), βl

4.1.4 Analysis Results

Fig. 5 reports the estimated maximum ﬁll-level of the buffer
B as we increase the frequencies of f0 for (i) our multi-
mode RTC method, (ii) the standard RTC method, and (iii)
the exact method using ECA. The frequency f 1 is chosen to
be f0 + 100 (Mhz) and the frequency f 2 is 600 (Mhz). The
results shown here are obtained for a ﬁxed value of T . How-
ever, our experiments with other values of T show similar
performance patterns for the three methods. As shown in
the ﬁgure, the ﬁll-level of the buffer get smaller as we move
from left to right. This reﬂects the expected behavior of the
system in that, given a ﬁxed input stream, the ﬁll-level of
an input buffer is a decreasing function of the processor fre-
quency. Observe that the maximum ﬁll-levels of the buffer
corresponding to the multi-mode RTC is the same as the
ones corresponding to the ECA method. These values are
always smaller than that of the standard RTC method. This
illustrates the chain effect of mode switching in PE 1 on the
output stream and subsequently the buffer B (cid:2). By captur-
ing this characteristic of the system, our multi-mode RTC
method is able to achieve the optimal results (as given by

6767

1 and s(cid:2)

from s1 to s2 and vice versa are indicated by the signals a
and b. Accordingly, the service automaton changes between
2, where s(cid:2)
two modes s(cid:2)
1 has the associated service
function β1 = (βl
1 ) providing a lower level of service
and s(cid:2)
2, βu
2 )
providing a higher level of service. The service automaton
of the second PE has the same structure, except that the ser-
vice functions associated with its modes are different.

2 has the associated service function β2 = (βl

1, βu

The RTC model of the system consists of an arrival func-
tion α = (αl, αu) and a service function β = (β l, βu) for
each PE such that αu(Δ) is the maximum of αu
i (Δ) and
αl(Δ) is the minimum of αl
i(Δ). β is as deﬁned as in case
study 1. Fig. 7 shows the maximum ﬁll-level of the second

Figure 7: Case study 2: Maximum buffer ﬁll-level analysis.

buffer for the multi-mode RTC and the standard RTC. In
the ﬁgure, each bubble denotes a ﬁll-level of the buffer. The
larger its diameter, the higher the buffer ﬁll-level. Observe
that the bubbles corresponding to the multi-mode RTC fall
nicely inside the ones corresponding to the standard RTC
method. Similarly, the maximum end-to-end delay of the
event stream for the multi-mode RTC and the standard RTC
are given in Fig. 8. We have not shown the corresponding
optimal values since they coincide with the multimode RTC
values. Thus our multi-mode version of RTC improves the
accuracy of the analysis -in comparison to the standard RTC
approach- signiﬁcantly.

4.3 Eﬃciency

To evaluate the efﬁciency of our method, we measured
the average running time for computing the maximum
buffer ﬁll-levels for the three methods. As might be ex-
pected, the standard RTC costs the least computational ef-
fort. The multi-mode RTC comes in next with an average
of 100 seconds. Not surprisingly, on the average, the ex-
act method is an order of magnitude slower than the multi-
mode RTC.

6868

Figure 5: Case study 1: Maximum buffer ﬁll-level analysis.

the ECA method). On the other hand, the standard RTC’s
estimates are more pessimistic.

4.2 Case Study 2

In this case study, we examined a system in which the
resource offered by the processors is adapted to changes in
the average arrival rate of the incoming event stream using
common signals. The system has the same architecture as
the previous case study with two PEs processing an event
stream sequentially. The event stream arrives at two differ-
ent rates R1 and R2. The stream arrives at the rate Ri for
a minimum of Li and a maximum of Ui units of time be-
fore it switches to the other rate. Whenever the input inter-
face detects this change from one rate to another, it informs
the processor by emitting a signal. Upon receiving this sig-
nal, the processor will switch to the corresponding level of
service. Fig. 6 shows the arrival automaton of the event

S1

α
1

[L1, U1]

S2

α

2

[L2, U2]

'
S1

'
S2

(cid:5)1

[0, (cid:2)]

(cid:5)2
[0, (cid:2)]

b

a

b

a

(a) Arrival automaton

(b) Service automaton

Figure 6: The multi-mode RTC model of Case study 2.

stream and the service automaton of the ﬁrst PE. As shown
in the ﬁgure, the arrival automaton has two modes s 1 and s2
which correspond to the two arrival rates R 1 and R2, with
R1 < R2. Each mode si is associated with an arrival func-
tion αi = (αl
i ) that is obtained based on the rate R1
using the method described in case study 1. Additionally,
si is associated with an invariant [Li, Ui] which gives the
lower and upper bounds on the amount of time the automa-
ton can stay in this mode. A transition of the automaton

i, αu

Figure 8: Case study 2: End-to-end delay analysis.

[3] G. C. Buttazzo, G. Lipari, and L. Abeni. Elastic task model for adap-

streams. Using such interfaces, one can begin to study the
compatibility of components; i.e. when they can be safely
connected together via buffers with pre-speciﬁed capacities.

References

[1] Y. Abdedda¨ım, E. Asarin, and O. Maler. Scheduling with timed au-

tomata. Theoretical Computer Science, 354(2):272–300, 2006.

[2] T. Austin, E. Larson, and D. Ernst. SimpleScalar: An infrastructure
for computer system modeling. IEEE Computer, 35(2):59–67, 2002.

tive rate control. In RTSS, 1999.

[4] S. Chakraborty, S. K¨unzli, and L. Thiele. A general framework for
analysing system properties in platform-based embedded system de-
signs. In DATE, 2003.

[5] S. Chakraborty, L. T. X. Phan, and P. S. Thiagarajan. Event count
In

automata: A state-based model for stream processing systems.
RTSS, 2005.

[6] E. Fersman, P. Krc´al, P. Pettersson, and W. Yi. Task automata:
Information and

Schedulability, decidability and undecidability.
Computation, 205(8):1149–1172, 2007.

[7] E. Fersman, L. Mokrushin, P. Pettersson, and W. Yi. Schedulability
analysis of ﬁxed-priority systems using timed automata. Theoretical
Computer Science, 354(2):301–317, 2006.

[8] G. Fohler. Changing operational modes in the context of pre run-
time scheduling. IEICE Transactions on Information and Systems,
E76-D(11):1333–1340, 1993.

[9] T. A. Henzinger. The theory of hybrid automata. In LICS, 1996.

[10] K. Jensen. Coloured Petri Nets. Basic Concepts, Analysis Methods
and Practical Use, volume 1, 2 and 3 of Monographs in Theoretical
Computer Science. Springer-Verlag, 1997.

[11] L. T. X. Phan, S. Chakraborty, P. S. Thiagarajan, and L. Thiele. Com-
posing functional and state-based performance models for analyzing
heterogeneous real-time systems. In RTSS, 2007.

[12] L.T.X. Phan, S. Chakraborty, and P.S. Thiagarajan. A multi-mode
real-time calculus.
report, Department of Com-
puter Science, National University of Singapore, October 2008.
www.comp.nus.edu.sg/˜phanthix/papers/multimodeRTC.pdf.

Technical

[13] J. Real and A. Crespo. Mode change protocols for real-time systems:
A survey and a new proposal. Real-Time Systems, 26:161–197, 2004.

[14] L. Sha, R. Rajkumar, J. Lehoczsky, and K. Ramamritham. Mode
change protocols for priority-driven preemptive scheduling. Real-
Time Systems, 1(3):244–264, 1989.

[15] Y. Shin, D. Kim, and K. Choi. Schedulability-driven performance
analysis of multiple mode embedded real-time systems. In Design
Automation Conference (DAC), 2000.

[16] L. Thiele, S. Chakraborty, M. Gries, and S. K¨unzli. A framework
for evaluating design tradeoffs in packet processing architectures. In
39th Design Automation Conference (DAC), 2002.

[17] E. Wandeler, A. Maxiaguine, and L. Thiele. Quantitative character-
ization of event streams in analysis of hard real-time applications.
Real-Time Systems, 29(2-3):205–225, 2005.

[18] E. Wandeler and L. Thiele. Workload correlations in multi-processor
hard real-time systems. Journal of Computer and System Sciences
(JCSS), 73(2):207–224, 2007.

In summary, we have demonstrated through our case
studies that while the simpler RTC model is computation-
ally efﬁcient, it does not achieve high accuracy. On the other
hand, an exact method that explores the complete search
space often suffers from inefﬁciency. Our multi-mode RTC
is able to extend the standard RTC model in terms of expres-
sive power while incurring acceptable additional computa-
tional costs. This method enables a more accurate analy-
sis for systems that have state information which cannot be
exploited by the standard RTC while being much more ef-
ﬁcient (but possibly less accurate) than ﬁne grained state-
based models.

5 Concluding Remarks

We have formulated here a state-based extension of RTC
called multi-mode RTC. The arrival and service automata
that arise in this setting have a syntax very similar to that
of hybrid automata. They can describe complex arrival and
service patterns by associating an arrival or service func-
tion with each mode and using external signals, timing con-
straints and -in the case of service automata- buffer con-
straints to perform mode switching. We have sketched how
exact analysis can be performed in this setting. We have
also provided a more detailed description of a worst-case
based approximate analysis method using which basic sys-
tem properties can be computed accompanying with exper-
imental evidence to validate our analysis techniques.

It will be interesting to explore this model in the setting
where multiple data streams are being processed by each
processing element. In this case the automata that repre-
sent the remaining service as well as scheduling policies
will come into play. It will also be interesting to establish
methods for tuning the parameters of the arrival and service
automata in order to obtain the desired system level proper-
ties in terms of buffer capacities, end-to-end delays, etc.

It will be challenging but useful to establish bounds on
the degree of approximations (say, for buffer ﬁll-levels)
as well as the time complexity of our analysis methods.
Finally, arrival and service automata appear to be an
expressive and convenient mechanism for describing the
interfaces of networks of processing elements and data

6969

