Event Count Automata:

A State-based Model for Stream Processing Systems

Samarjit Chakraborty Linh T. X. Phan

P. S. Thiagarajan

Department of Computer Science, National University of Singapore

E-mail:

samarjit, phanthix, thiagu @comp.nus.edu.sg

Abstract

Recently there has been a growing interest in models and
methods targeted towards the (co)design of stream process-
ing applications; e.g.
those for audio/video processing.
Streams processed by such applications tend to be highly
bursty and exhibit a high data-dependent variability in their
processing requirements. As a result, classical event and
service models such as periodic, sporadic, etc.
can be
overly pessimistic when dealing with such applications. In
this paper, we present a new model called Event Count Au-
tomata (ECA) for capturing the timing properties of such
streams. Our model can be used to cleanly formulate prop-
erties relevant to stream processing on heterogeneous multi-
processor architectures, such as buffer overﬂow/underﬂow
constraints.
It can also provide the basis for developing
analysis methods to compute delay/timing properties of the
processed streams under different scheduling policies. Our
ECAs, though similar in ﬂavor to timed and hybrid au-
tomata, have a different semantics, are more light-weight,
and are speciﬁcally suited for modeling stream processing
applications and architectures. We present the basic aspects
of this model and illustrate its modeling potential. We then
apply it in a speciﬁc stream processing setting and develop
an analysis technique based on the formalism of Colored
Petri Nets (CPNs). Finally, we validate our modeling and
analysis techniques with the help of preliminary experimen-
tal results generated using the CPN simulation tool.

1 Introduction

Models and algorithms speciﬁcally targeted towards
“stream processing” have recently been the subject of ex-
tensive study in the embedded systems domain (see for ex-
ample [23, 12]), as well as in other areas of computer sci-
ence such as databases. A large number of applications such
as audio/video and network packet processing can be natu-
rally modelled, designed and analyzed using the “stream”
abstraction. Such applications often handle multiple and
potentially inﬁnite streams of data and run on devices rang-
ing from mobile phones, PDAs, set-top boxes and network
routers. The widespread use of such applications has led
to new “stream-centric” programming languages and com-

pilers [10], processor architectures [11] and design method-
ologies [18, 26].

In line with these developments, in this paper we intro-
duce a simple and novel modeling formalism called Event
Count Automata to study stream processing systems.
In
our view of such systems, an application is partitioned and
mapped onto multiple processing elements (PEs). A stream
(or possibly multiple streams) of data enters a PE, gets
processed by the task/function mapped onto this PE, and
the processed stream enters another PE for further process-
ing. Between any two neighboring PEs, there is a buffer
which stores the partially processed stream. After a series
of such steps, the stream is fully processed and leaves the
system. This view covers a variety of architectures targeted
towards stream processing (such as the one described in
[22]).
In this setup, we wish to address questions of the
following form: Will any of the buffers in the architecture
overﬂow? What is the maximum delay experienced by any
stream? When multiple streams are being processed by the
architecture, does there exist schedulers for the PEs, such
that the delay experienced by a given stream is less than a
predeﬁned upper bound? These and other related questions
naturally arise in the system-level design of (hardware and
software) architectures of stream processors. But there are
several reasons why these questions turn out to be difﬁcult
for many applications: (i) The arrival process of a stream
often tends to be highly bursty [25]. As a result, most of
the classical event models (such as periodic and sporadic)
are either not appropriate, or tend to be overly pessimistic.
(ii) The processing time required for data items in a stream
can vary considerably. For applications like video process-
ing, the ratio of the worst-case and the average load on a
processor can be as high as a factor of 10 [22]. (iii) The
input-output rates of a task can also vary. i.e. a single data
item consumed by a task can result in multiple (processed)
data items at the output and vice versa.

A Motivating Example: Figure 1 shows an MPEG-2 de-
coder application, which has been partitioned and mapped
onto two PEs. The ﬁrst PE runs the VLD and IQ tasks,
while the second runs the IDCT and MC tasks. The (coded)

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

Figure 1. An MPEG-2 decoder application, partitioned
and mapped onto two PEs.

. Finally,

input bitstream enters this system at a constant rate and gets
stored in the input buffer. This buffer is read by the ﬁrst PE,
whose output is a stream of partially decoded macroblocks
which are written into the buffer . This buffer is read by the
second PE and the resulting stream of fully decoded mac-
roblocks is written into a playout buffer
is
read by the output video device at a pre-speciﬁed constant
rate. We are interested in analyzing the part of the archi-
tecture enclosed by the rectangular box. More speciﬁcally,
given the rate at which the stream of partially decoded mac-
roblocks is written into the buffer
, the clock frequency
with which the second PE is being run, and the rate at which
the
is being read, we would like to verify that neither
buffer overﬂows and that the buffer
does not underﬂow.
One can also ask: given the sizes of
and
, what is the
minimum clock frequency with which the PE can be run?

Although the coded bitstream enters this system at a con-
stant rate, the number of bits consumed by the ﬁrst PE to
generate each partially decoded macroblock varies because
of the VLD task. Further, the number of processor cycles re-
quired to produce each such partially decoded macroblock
is also not constant. Therefore, when the ﬁrst PE runs
at a constant clock frequency, the stream of partially de-
coded macroblocks that gets written into the buffer will be
highly bursty. Further, each partially decoded macroblock
also requires a variable number of processor cycles to get
processed by the IDCT + MC tasks. Therefore, to answer
the above questions it is necessary to realistically charac-
terize this burstiness in the arrival pattern of the stream and
also the variability in its processor cycle requirements.

A model for specifying timing constraints associated
with such streams has been recently studied in [7, 15, 19,
27]. The basic idea is to specify upper and lower bounds
on the number of data items or events that can arrive within
any speciﬁed length of time. Suppose a stream is composed
of a sequence of data “items” where an item might be a bit,
a partially decoded macroblock, or a fully decoded mac-
roblock, depending on which stage in the architecture it is
in. Let
denote the number of items that arrive at the
. We say that this ar-
buffer
rival process is bounded by the arrival curve
if the following inequalities hold.

during the time interval

and

are therefore lower and upper bounds on

the number of items that can arrive within any time interval
of length . Typically, such bounds would be speciﬁed for a
and such
ﬁnite number of time interval lengths
a speciﬁcation would capture a class of arrival patterns
that satisfy the following inequalities.

Similarly, to model the variable processing requirements
of the data items, a service curve
speciﬁes
lower and upper bounds on the number of items that can
be processed by the PE within any time interval of a speci-
ﬁed length. Let
denote the number of items that can be
. Such a service is
processed during the time interval
if the following inequalities hold.
bounded by

Again, such a bound on the service would typically be spec-
iﬁed for a ﬁnite number of time interval lengths. Now, given
the bounds
on the arrival process of a stream and the ser-
vice curve
offered by a PE, [7] presented a calculus using
which it is possible to compute (i) the maximum number of
data items that can be backlogged at the input of the PE,
which is a measure of the minimum buffer size required
(e.g. the size of
in Figure 1), (ii) the maximum delay that
can be suffered by any item, (iii) bounds on the timing prop-
erties of the processed stream (again in terms of an arrival
curve), and (iv) bounds on the remaining service (in terms
of a service curve).

For example,

(1)

(2)

Bounds on the timing properties of the processed stream
and the remaining service can also be computed similarly
[7]. As a stream is processed by multiple PEs, these bounds
get successively transformed and as a result the timing prop-
erties of the fully processed stream can be computed in a
compositional manner.

(i.e.

the PE stalls if

but also on the state of the buffer

However, the calculus presented [7] is purely functional
and can not model setups where the processing of a stream
depends on the state of the system. As an example, in Fig-
ure 1 the second PE might implement a blocking write for
the buffer
is full). Hence, the
service offered by this PE not only depends on the ser-
vice curve
. Hence,
Eqns. (1) and (2) can no longer be used and the maximum
backlog in and the delay experienced by the stream would
also depend on the size of the buffer
and the consump-
tion process from this buffer. Another example is when the
amount of service offered by the PE depends on the ﬁll level
of one or more buffers. Finally the arrival pattern itself
might be history-dependent due to the behavior of the ex-
ternal components generating them.

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

Our Contribution: The main contribution of this paper
is an automata-based model called Event Count Automata
(ECA) using which ﬂexible state-based speciﬁcations of ar-
rival and service patterns can be obtained. In addition, they
can be used to model and analyze setups where the process-
ing of a stream depends on the state of the system. For
example, the service provided by a PE might depend on the
state of the buffer or on the arrival process of the stream.
Similarly, the arrival process of the stream might itself de-
pend on factors such as the buffer ﬁll level and the consump-
tion process of the stream by an output device, which can
generate back-pressures in networks to constrain the arrival
pattern. Apart from the ability to model such architectural
features, important analysis problems that a system designer
will be interested in can now be formulated as standard ver-
iﬁcation questions.

In addition, ECAs can naturally model a wide variety
of protocols and scheduling policies. In contrast, even stan-
dard scheduling policies such as EDF and FCFS are difﬁcult
to capture within the framework of the calculus developed
in [7, 19, 27]. As a result, the computed bounds on the max-
imum buffer ﬁll, delay, timing properties of the processed
stream, etc., will not be tight.

Timed automata [4] have been used to specify the ar-
rival patterns of tasks so that schedulability analysis can be
performed using the zone-based reachability analysis tech-
niques for timed automata [20, 16]. Further, timed automata
has also been used for task graph and job-shop scheduling
problems [1, 2]. However, for many of the analysis ques-
tions thrown up by stream processing applications, the exact
arrival time of the data items is not relevant. Rather, it is the
number of items that can arrive within a speciﬁed interval
of time is what is of relevance, and this is precisely what
is recorded by ECAs. That said, ECAs do bear a strong
resemblance at the syntactic level to timed and in fact (rec-
tangular) hybrid automata [4, 13]. However, at the semantic
level ECAs are quite different and much simpler. This will
become clear once we explain in more detail our model.

In the next section we present ECAs and its basic the-
ory. In Section 3 we model multiprocessor architectures as
networks of ECAs. We then show how such networks can
be syntactically converted to Colored Petri Nets for the pur-
pose of carrying out analysis. This is followed by an exper-
imental case study in Section 4 to illustrate the usefulness
of the model. Finally, in the concluding section, we outline
several fruitful lines of future work.

2 Event Count Automata

An Event Count Automaton (ECA) captures arrival pat-
terns by counting the number of data items that arrive in a
unit interval of time1. This count is used to update the count
variables associated with the automaton. Guards based on

A

x < 10;

[1,3]

x > 5

x > 10

C

[2,4]

x =10;
x:=0

B

x <= 5;

[1,2]

Figure 2. An example ECA.

where

the values of these count variables can be used to determine
at which discrete time instances should the automaton take
a transition. In this paper the guards will be formed as con-
junctions of atomic predicates of the form
is
and is an integer con-
a count variable,
stant. As a part of a transition -assumed to be instantaneous-
some of the count variables can be reset to . Thus at any
given instant, the value of a count variable will record the
number of items that have arrived since this count variable
was last reset. We also specify for each state of the automa-
ton, a rate interval
. This speciﬁes that in
the current mode, in each unit interval of time, at least and
items will arrive. Finally, we associate a state in-
at most
variant predicate with each state to constrain the values of
the count variables for which the automaton is allowed to
stay in the state.

with

and at most

An example of an ECA is shown in Figure 2 with just
one count variable . The arrival pattern represented by this
automaton occurs in three modes. In the initial
-mode, at
least
items will arrive in each unit of time.
At any time instant, if the total number of items that have
arrived exceeds
is entered if the current
count is exactly
is entered if the current
count exceeds
units of
after at most
time and not earlier than
is re-
entered (follows from the minimum/maximum number of
items that can arrive at each mode). Once the mode
is
entered it is never left again. Thus

then the mode
or the mode
. In the mode

units of time, the mode

is a possible run of the automaton rep-
resenting the arrival pattern
. As
this example suggests, we do not make use of action la-
bels to model external events triggered by interactions with
reactive components. We shall say more about this in the
concluding section.

2.1 The Basic Theory

An ECA is a tuple

is a set of control (mode) states and

initial state.

where

is the

1We assume a suitable granularity of time has been ﬁxed.

is a set of count variables.

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

is a function, which assigns to each state , an
is

where

invariant constraint
the set of constraints over

given by:

where

If

then there exists a transition of the form
such that

. Furthermore,

satisﬁes

and
.

Here, and in what follows,
integers.

ranges over non-negative

If
.
Moreover there does not exist a transition of the form

then

and

is a rate function, which assigns to each state

an interval
that represents the lower and
upper bounds on the arrival rate of events when the
system is in state .

as usual,
require that

is the set of subsets of
for each transition

.

is a transition relation where,
Further, we

is a set of ﬁnal states.

and

An event count automaton describes arrival patterns of
the form
denotes the number of items
with
arriving during the interval
. At time the automa-
ton instantaneously makes a move. This could consist of
it staying put in its current state or taking a transition and
moving to a new state. As a part of each such move, the au-
tomaton signals the number of items that have arrived in the
previous unit time interval. This dynamics is captured by
-called the associated behavioral au-
the automaton
tomaton - whose states are conﬁgurations of the form
where
is a state of
non-negative integer
variable in

is a valuation which assigns a
-its current value- to each count
where
is initial valuation; often, this will be the valuation that
assigns
to each count variable. If at time instance , the
automaton is in the conﬁguration
items arrive
in the next unit time interval, then at time
, it can make
the move
must satisfy the
following conditions. For stating these conditions and for
later usage, it will be convenient to adopt some notational
conventions.
Suppose
the notion
deﬁned in the expected manner:

is a constraint. Then
- is inductively
with
iff
iff
and
, we deﬁne
. Secondly, for a non-negative integer

. The initial conﬁguration is

is a valuation and

satisfying

. Further,

-denoted

where

and

to be the valuation given by:

for every . Thus
variable by , starting with the valuation

,

is the valuation given by

simply increments every count
. Finally, for
if
resets
to . All other count variables
can now be

. Thus,

. The transition relation

. Otherwise,

all the count variables in
are as assigned by
deﬁned.

such that

and

with

.

Some remarks are in order. Firstly, if at a state the num-
ber of items that arrive in a unit interval does not fall in the
range
(i.e. the arrival violates the arrival rate constraint
associated with ) then these items are simply discarded.
We have imposed this convention mainly for convenience.
Through a more sophisticated transition relation and the use
of the state invariants we can easily record and detect vio-
lations of the rate bounds speciﬁed for the states. Secondly,
all our states are “urgent” in the sense, if at a conﬁguration,
at least one transition leading out of the state is enabled,
then one of these transitions must be taken. The automaton
stays put in its current state only if none of the transitions
going out of the state is enabled. Again, we choose this
route mainly for convenience as also in assuming implicitly
that the automaton will never get stuck. Finally, given the
“urgent” semantics, state invariants are not really needed
but they are very convenient to have around.

, let

To deﬁne

be the maximum of the set of integers

and
.
is the maximum number events that can arrive in any

let
Thus
mode in the arrival patterns speciﬁed by

for each

. Then

in

given by:

is the set of valuations.

, called the alphabet of

.

is the set of ﬁnal states of

.

is

,

,

are as in the deﬁnition of an ECA and

as deﬁned above.

We note that

is an inﬁnite set and hence

is
a potentially inﬁnite state automaton accepting (and reject-
ing) sequences over the ﬁnite alphabet
. To
bring this out, let
.

be a sequence in

Then a run of

over

is a sequence

is in

with

(in other words,

ing if
said to be accepted by

. The run is accept-
is
. It is in this sense, the sequence
is accepted by the automaton of
is not accepted by this au-
be the set of sequences accepted by
. It represents the arrival patterns speciﬁed by the automa-

Figure 2, while the sequence
tomaton. We let L

) and

iff the following conditions are satisﬁed.

ton.

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

The basic theory of ECAs follows from the fact that the
associated behavioral automaton of an ECA can be quo-
tiented into a ﬁnite state automaton which accepts the same
set of ﬁnite sequences. This can be established by using ar-
guments similar to but much simpler than the ones used for
constructing the regional automaton for a timed automaton
[4]. Given below are the main details.

Let

be an ECA and

, let

. For instance, in the ECA shown in Figure 2,

We say that two valuations
noted as

be its associated behavioral automaton.
For each count variable
be the maximum of all
the integers that appear in constraints involving the variable
.
are equivalent, de-
, either
. Two conﬁg-
are equivalent -written
and
partitions the inﬁnite set of states of
into a ﬁnite number of equivalence classes. Indeed,

urations
again for convenience as

, iff for every count variable

. Clearly

or
and

- iff

and

and

of

the number of these classes is bounded by
where is the maximum of all the
to the different count variables).

values (corresponding

Conﬁgurations belonging to an equivalence class ex-
hibit the same behavior in the following sense: Suppose
. Then there ex-

and

ists a conﬁguration
and furthermore,

.
To see this, we ﬁrst observe that if

such that

then

for any constraint

iff
tablished by induction on the structure of
suppose

is an atomic constraint of the form

. This can be easily es-
. For instance,
. If
and hence
. This implies that
, which
. The remaining cases can be dis-

. Clearly

. Hence

it can not be the case that

then

since

leads to
posed off equally easily.

Now let

Suppose
Then
implies

. Then

and

and

. Consider ﬁrst the case

. But then
and as observed above

.

.

. Thus by the deﬁnition

implies

and

of the

relation, we have

Next consider the case

sition of the form

verify that

where

.

such that

. Then there exists a tran-
and
. Set
, it is easy to
. Thus

satisﬁes

and

as required.

. Furthermore,

. Using the fact

,

with

We now deﬁne the quotiented version of

to be

the ﬁnite state automaton

where:

is the
other words,

-equivalence class containing
.

and

is a valuation where
. In

.

.

iff there exists
such that

in

in

and

Clearly,

can be effectively constructed using the
. It should also be clear that the language

presentation of
of ﬁnite strings accepted by

is exactly L

Towards stating our main result concerning ECAs, let

be a ﬁnite alphabet and
deﬁnable iff there exists an ECA such that L
note that in this case must be of the form

. We will say that

is ECA-
. We

.

Our main result concerning ECAs can now be stated.

Theorem 1

1. Let

be a ﬁnite alphabet of the form

. Then

is ECA-deﬁnable iff

and
is a regular

subset of

.

2. The class of ECA-deﬁnable languages is closed under

boolean operations.

3. Given an ECA , one can effectively determine if L

is empty.

Proof: See [8].

Relationship to Hybrid and Timed Automata: Readers
familiar with timed and hybrid automata [4, 3, 13] would
have noticed their resemblance to ECAs. Indeed, the be-
havioral equivalence we deﬁned is inspired by the -much
more sophisticated - regional equivalence associated with
timed automata. This resemblance however is a purely syn-
tactic one since the clock variables of timed automata are
used to record the times at which interesting events happen
in a real time system whereas the count variables of an ECA
merely count the number of items that arrive in a unit time
interval; the times at which these items arrive within the
interval are not of interest and are not recorded.

ECAs Representing Arrival and Service Curves: Ar-
rival and service curves can be systematically represented as
ECAs. There is no distinction between an ECA represent-
ing an arrival curve and one representing a service curve,
apart from the fact that the former bounds the arrival process
of data items and the latter bounds the processing of these
items. An example will illustrate the main idea. Consider
the upper arrival curve shown in Figure 3, along with its
ECA representation.

This ECA will change its current state at every time in-
stant. All the states are associated with the state invariant
true. At the end of the ﬁrst (unit) time interval, the con-
straint
items have arrived
during the previous interval (which is also redundantly en-
sured by the rate vector
).

associated with the state

veriﬁes that at most

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

lead to state explosion and hence one will have to adapt
one or more of the existing techniques for coping with the
state explosion problem in order to obtain practically feasi-
ble analysis methods. Our goal here however is to lay the
groundwork for building such analysis methods backed up
by tool support. We discuss this issue in more detail in Sec-
tion 4.3.

We now wish to show how the CPN representation of
a network of ECAs can be constructed and used to answer
various questions about the timing properties of the stream
processing system under study. Often, these questions will
be about quality-of-service constraints associated with these
streams. Further, a number of common problems such as
optimal buffer sizing, determining optimal schedulers, etc.
can also be formulated as standard analysis or veriﬁcation
problems using the CPN. We begin with brief introductory
remarks on CPNs.

Colored Petri Nets: Colored Petri Nets (CPNs) are a
powerful extension of ordinary Petri nets in which the to-
kens have attributes associated with them. These attributes
can correspond to complex data types and the transitions
can encode intricate manipulations of these data types. This
is so because, in a CPN, the ﬁring of a transition depends
not only on the number of tokens being present on its in-
put places; in addition, the “colors” of the tokens on its
input places must also satisfy the constraints imposed by
the arc-expressions associated with its input arcs. Similarly,
the colors of the tokens placed by a transition on its out-
put places are constrained by the arc-expressions associated
with the output arcs of the transition. As a result, CPNs
constitute a ﬂexible and powerful graphical notation for de-
scribing a variety of applications such as communication
protocols, distributed reactive systems, automated produc-
tion systems and work ﬂow processes.

CPN Tools [9] is a tool kit developed by the CPN
Group, University of Aarhus, Denmark. This tool kit
provides support for editing, simulating and analyzing
CPNs.
It has a GUI, that allows users to draw CPNs
and declare variables or functions. Besides features such
as incremental syntax checking, code generation, etc.,
the tool kit has a simulator and a state space analysis
tool. Using the state space analysis tool, full and par-
tial state spaces can be generated and analyzed. Detailed
information concerning the theory, analysis and applica-
tions of CPNs including tool support can be found in
[14]. Information concerning other simulation and analy-
sis tools for CPNs can be found at: www.informatik.uni-
hamburg.de/TGI/PetrNets/Tools/db.html.

CPNs for ECAs: Because of its structure, an ECA can be
systematically encoded as a CPN. Furthermore, by exploit-
ing the regular structure of ECAs representing arrival or
service curves, such ECAs can be encoded as CPNs which

Figure 3. An arrival curve and its corresponding ECA.

associated with the transition from

The constraint
items have arrived in the previous
will ensure that at most
two unit intervals. It is easy to see how the four count vari-
ables are read from and reset in a cyclic fashion to enforce
the constraints speciﬁed by the upper arrival curve with four
entries (specifying constraints over time intervals of lengths
to ). A service curve (see Section 1) can also be similarly

represented using an ECA.

Networks of ECAs:
In most stream processing applica-
tions, it is useful to compose ECAs with the help of point-
to-point buffers. Suppose
denotes a buffer.
into
are processed by a processor. The idea is that
are deposited in

represents the arrival process of items
represents the pattern in which these items
items
whenever the behavioral automaton of

are two ECAs and

and

and

makes a transitions of the form
items are removed from

whereas
havioral automaton of

whenever the be-
makes a transition of the form
. This complex structure consisting
of two ECAs communicating via a buffer can then be de-
scribed as a Petri net. Indeed, for more complex networks,
one can obtain succinct descriptions by using Colored Petri
Nets (CPNs) [14] instead of ordinary Petri nets. This will
be brought out in more detail in the next section.

3 Modeling Multiprocessor Architectures

We will use networks of ECAs to model stream process-
ing on multiprocessor architectures, where different parts of
an application run on different PEs which communicate via
buffers (see Figure 1).

Our goal here is to show that it is straightforward to ex-
tract an executable speciﬁcation from a network of ECAs
and perform analysis using this executable representation.
We deploy here Colored Petri Nets (CPNs) to represent a
system of ECAs communicating via buffers. Before getting
into the details, we wish to emphasize that CPNs are not
the only possible vehicle to serve as an executable mecha-
nism for networks of ECAs. We have chosen CPNs mainly
because they are supported by a good tool environment in-
cluding a simulator [9]. We also wish to emphasize that a
global model of a complex network of ECAs will inevitably

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

contain only two places and one transition. Examples illus-
trating the encoding of ECAs as CPNs may be found in [8].
It is crucial to note here that the encoding of an ECA as a
CPN follows a purely syntactic construction and does not
involve the behavioral automaton describing the semantics
of the ECA. Hence, this encoding can be done very efﬁ-
ciently. Further, we show in the next subsection that the
composition of different CPNs (each corresponding to an
ECA) can also be done in a syntactic fashion.

3.1 Modeling an Architecture as a CPN

We consider the architecture model introduced in Sec-
tion 1, i.e. multiple PEs process one or more streams in
a pipelined fashion and exchange data (partially processed
streams) through unidirectional buffers. Let us ﬁrst consider
the single stream case. Let ECA be the ECA that bounds
the arrival process of a single input stream. ECA , ECA ,
, ECA
are the ECAs bounding the service offered by
PE , PE ,
is the number of
PEs in the architecture. ECA is the ECA representing the
consumption of the processed stream.
denotes the input
buffer,
,
and
is the output buffer between PE and the output de-
vice. For simplicity, we will restrict our discussion to the
case of only two PEs, i.e.
. The extension to multiple
PEs is trivial.

the intermediate buffer between PE and PE

, PE , respectively, where

The CPNs encoding the different ECAs can now be com-
posed into a single CPN (representing the full architecture)
using additional places and arcs. This construction is as fol-
lows. We create three places of type integer, each of
which represents a buffer in the architecture (recall that we
have two processors, and hence three buffers). For each
transition in a CPN, we add an arc between this transi-
tion and some of the newly added places (representing the
buffers). Some of these arcs encode the arrival of data items
into a buffer and the others encode the consumption (or
processing) of these items. Associated with each outgoing
(incoming) arc from (to) each of these places is an integer
variable whose value represents the number of items in the
corresponding buffer before (after) these items arrive or are
taken from the buffer. Hence, the value of the token in the
place corresponding to a buffer denotes the number of items
in the buffer at the current time. In addition, we use another
place to control the order in which data items in the stream
arrive and the order in which they are processed by the dif-
ferent PEs. Arcs between this place and the transitions of
the different CPNs are added and are guarded in a manner
that respects the sequential order of the arrival and process-
In other words, this is to
ing of the items in the stream.
ensure that an item is processed by
only after it has
been processed by

.

Figure 4. ECAs describing the arrival process of a stream,
its processing (service provided) by two PEs and ﬁnally its
consumption by an output device (see Figure 1). The initial
valuations of the count variables for ECA , ECA , ECA
and ECA are
respectively.

and

,

,

these four CPNs are shown in Figure 4. CP models the
complete architecture (consisting of two PEs) speciﬁed by
the four ECAs given in Figure 4.

From the construction, it can be shown that the execu-
tion of CP is a sequence of steps, each of which begins with
a transition in CP , followed by a transition in CP , then
a transition in CP
and ﬁnally a transition in CP being
ﬁred. CP , CP , CP and CP are the CPNs encoding
ECA , ECA , ECA
and ECA respectively (shown in
Figure 4). One execution step in
corresponds to the
execution/processing that is carried out by the architecture
in one unit of time. As a result, the status of CP after each
execution step represents the (stable) status of the architec-
ture after it has ﬁnished the equivalent of one time unit of
execution. In particular, suppose the system starts at time
execution steps
are the number
,
respectively in

and the values of the tokens in
of items left in the buffers ,

are denoted by

, then at time

, CP ﬁnishes

respectively.

and

and

and

,

Figure 5.
3.2 Analysis

The resulting CP described above can be used to analyze
various properties of a multiprocessor architecture in which
the processing of a stream is described using a set of ECAs.

Figure 5 shows a CPN, called CP, which is composed
of four communicating CPNs. The ECAs corresponding to

Computing Maximum Buffer Fill Levels: The maxi-
mum ﬁll level of a buffer can be obtained by computing the

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

initNodeA

NODE_A

a

initNodeB1

NODE_B1

initNodeB2

NODE_B2

initNodeC

NODE_C

b1

b2

c

(0, x1+k, 
x2+k)

(x1,x2,x3)

x_a+k

( 0, y1+h,
   y2+h, 
   y3+h)

x_a

[ECA_A ( 
x1+k,  x2+k, 
x3+k )]

t_A

x_a

x’_a

(y1,y2,y3,y4)

(0, z1+d, 
  z2+d)

(z1, z2, z3)

(0, w1+m)

(w1, w2)

[ECA_B1(y1+h,
y2+h, y3+h,
y4+h)]

0

p_b

INT

x_b

x’_b

t_B1

h

0

p_a

INT

1

2

2

3

genB1

initB1

INT

[ECA_B2( z1+d, 
  z2+d, z3+d)]

Max(x_c-m, 0)

x_b

x_c

t_B2

x’_b

x’_c

0

p_c

INT

t_C

[ECA_C(
  w1+m,
  w2+m )]

x_c

d

initB2

INT

genB2

3

4

4

1

m

genC

initC

INT

k

initA

genA

INT

input (h, x_a, x_b);
output (x’_a, x’_b);
action
let  val dt = Min(h,x_a)
  in (x_a-dt, x_b+dt)
end

input (d, x_b, x_c);
output (x’_b, x’_c);
action
let  val dt = Min(x_b, d)
  in (x_b-dt, x_c+dt)
end

p_ctrl

1

INT4

Figure 5. The Colored Petri Net corresponding to the speciﬁcation in Figure 4.

upper bound on the value of the token in the corresponding
place in CP. In particular, the ﬁll levels of
are the
at the end
values of the tokens in the places
of each execution step. The upper bound on the value of a
token in a place in a CPN can be checked by examining the
Best Upper Multi-set Bounds after running the state space
analysis routine on the CPN [9].

and

,

Given a pre-speciﬁed buffer size, from the computed
maximum buffer ﬁll level, it is possible to verify whether
the buffer might overﬂow. However, in this case, it is not re-
quired to compute the upper bound on the value of the token
in the place corresponding to the buffer in the CPN. Instead,
a more efﬁcient approach would be to add a new place into
the CPN to represent an error state. Whenever the value of
the token exceeds the speciﬁed buffer size, a token is put
in this new place. Hence, checking for buffer overﬂow can
now be formulated as reachability analysis problem instead
of resorting to a full state space exploration.

It is also possible to model buffers that implement block-
ing write. A PE writing into such a buffer stalls when the
buffer is full. To model such a buffer we extend the above
CPN with a new transition which is ﬁred after the CPN ﬁn-
ishes one execution step. This transition checks if the value
of the token in the place representing the buffer exceeds the
buffer size. If it does, then the value of this token is read-
justed to the maximum buffer size and the difference be-
tween the original value and this buffer size is added to the
downstream buffers. This process is then cascaded down-
stream.

Similarly, it is also possible to model PEs which adjust
their service depending on the state of the system, e.g. the
ﬁll levels of the buffers or the rate at which data items arrive
at the input. Finally, we would like to point out that so far
we have only been concerned with the processing of a single
stream. However, our framework can model the processing
of multiple streams in a straightforward manner, the details
of which may be found in [8].

4 Experimental Case Study

In this section we present a case study to illustrate the
practicality of the ECA model described so far. Towards
this, recall the MPEG-2 decoder application introduced in
Section 1 (see Figure 1). This application is partitioned
and mapped onto two processing elements (PEs). The in-
put to the ﬁrst PE is a constant bitrate (coded) bitstream,
which is processed by the VLD and IQ tasks. This results
in a stream of partially decoded macroblocks being writ-
ten into a buffer
. The second PE reads this buffer and
runs the IDCT and MC task on each of these partially de-
coded macroblocks. It then writes the resulting stream of
fully decoded macroblocks into the playout buffer which
is read by the output video device at a pre-speciﬁed con-
stant rate. Because of the variability in the execution times
of the VLD + IQ tasks and also the variability in the number
of bits constituting each partially decoded macroblock, the
stream being written into is highly bursty. We assume that
the timing properties of this stream is speciﬁed by an arrival
curve
(see Section 1). The execution requirements
of the IDCT + MC tasks running on the second PE is also

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

βl
1.70

βl
1.45
βl
1.25

αu

3
−

0
1
 
×

l

s
k
c
o
b
o
r
c
a
m

 
f
o
 
r
e
b
m
u
N

60

50

40

30

20

10

0

highly variable. We assume that this variability is captured
by a service curve
which denotes the minimum num-
ber of partially decoded macroblocks that can be processed
by the PE within any time interval of length
, when it is
run at a clock frequency . Further, we assume that this PE
implements a blocking write for the buffer
, i.e. it stalls
when

,

, the size of

and the rate
at which macroblocks are read out from by the output
device, we would like to compute the maximum ﬁll-level
(which is a measure of the minimum required size of
of
). Note that the effective service offered by the second PE
depends on

and the state (or ﬁll level) of

.

is full.
Now, given

4.1 Obtaining

and

In general, there are several ways in which

and
may be obtained. In many cases, it might be possi-
ble to analytically derive these functions (constraints) from
a formal speciﬁcation of the system and its environment.
In other cases a simulation- and trace-based analysis might
be easier. For our problem, program analysis techniques
along with an appropriate modeling of the PE' s microar-
chitecture [17] could have been used to derive these func-
tions. However, for simplicity, we adopted the latter (i.e.
simulation-based) approach. Towards this, we collected ex-
ecution traces of the different tasks by simulating their ex-
ecution using a model of the PE' s microarchitecture. We
then analyzed these traces to derive the functions
and

.

of the stream at the input of the buffer

To obtain the execution traces, we used a customized ver-
sion of the SimpleScalar instruction set simulator [5]. The
arrival curve
can be obtained by measuring the execution demands of the
VLD and IQ tasks for each macroblock in a video sequence
and by taking into account (i) the constant arrival rate of the
compressed bit stream at the input of the ﬁrst PE, and (ii) the
number of bits allocated to encode each macroblock in the
stream. Following this procedure, we ﬁrst obtained a func-
tion
denotes the number of macroblocks
arriving at
we
, following the deﬁnition of an arrival
then derived
curve in Section 1. Typically, a designer would use multi-
ple representative video clips to derive
, such that all
these clips satisfy the constraint imposed by

during the time interval

, where

. From

.

The function

can also be derived similarly. We
collected a trace of the execution demands for the pair of
tasks IDCT and MC executing on the second PE. For each
chosen processor frequency , we then analyzed this trace
to derive the function
using a method similar to the
one used for deriving
(see also the deﬁnition of a
service curve in Section 1).

The decoded macroblocks are read out from the play-
at a pre-speciﬁed constant rate, which can also
.

out buffer
be modeled by an arrival (or consumption) curve, say

0.1

0.2

0.3

0.4

0.6

0.7

0.8

0.9

1.0

0.5
Δ [s]

Figure 6. Arrival curve and service curves corresponding
to different processor frequencies.

However, we do not need to resort to simulation to obtain

, for obvious reasons.
Figure 6 shows the arrival curve

and the service

GHz and

for three different PE frequency values,

secs, the number of macroblocks arriving at

curves
GHz, for a Mbps MPEG-2 video
GHz,
clip. From this ﬁgure, note that over time intervals of length
less than
is larger than the minimum number of macroblocks that are
guaranteed to be processed within this time interval, for all
the three frequency values. However, for larger time in-
tervals (beyond
secs) the number of macroblocks that
are guaranteed to be processed is more than what may ar-
rive. This “switch-over” happens at different time inter-
val lengths for different processor frequencies. Clearly,
the smaller the value of
, the larger is the minimum re-
quired size of
GHz
is sufﬁcient to ensure that the required size of
is bounded.
The consumption rate of the decoded macroblocks from the
playout buffer was set to
macroblocks per second,
irrespective of the frequency of the PE.

. However, even a frequency of

4.2 Using ECAs

To represent the arrival and the service curves described
above, using ECAs, we ﬁrst need to ﬁx a suitable granular-
ity of time. This choice is primarily determined by two fac-
tors: (i) we would like to have a reasonably small number
of constraints
deﬁning the arrival (or
the service) curve, but at the same time (ii) we would like to
capture all the variability represented by these curves. For
our experiments, we deﬁned one time unit (i.e.
) to
be equal to
sec. We then represented the arrival and the
service curves (see Figure 6) using
constraints deﬁned
over time intervals of length

.

with

The resulting ECA consists of

,
count variables,
repre-
sents the number of items (partially decoded macroblocks

. At any integer point of time, each

the initial state, and also

states,

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

(0, x1+k,x2+k, x3+k,
x4+k, x5+k,x6+k, 
x7+k,x8+k, x9+k)

initNodeA

NODE_A

a0

(x1,x2,x3,
x4,x5,x6,x7,
x8,x9,x10)

initA

KX

genA

b

[ECAA(x1+k,x2+k,
x3+k,x4+k,x5+k,
x6+k,x7+k,x8+k,
x9+k,x10+k)
andalso
ECAB(y1+h,y2+h,
 y3+h,y4+h,y5+h, 
 y6+h,y7+h,y8+h,
y9+h,y10+h)]

(y1,y2,y3,y4,
y5, y6,y7,
y8,y9,y10)

A0

k

h

genB

KY

initB

1‘0

b_t

inbuf

b’

B’

B

0

outbuf

B_t

if (b’>bsize) 
then 1‘e 
else empty

error

E

input (k,h,b,B);
output (b’,B’);
action
let
 val m = Min(Min(h,b+k), 
               Bsize-B+Rc)
in (b+k-m, Max(B+m-Rc,0))
end

b0

NODE_B

initNodeB

(0,y1+h,y2+h,y3+h,
y4+h,y5+h, y6+h,
y7+h,y8+h,y9+h)

Figure 8. A CPN modeling the part of the architecture
enclosed within the rectangular box in Figure 1.

2500

2000

1500

1000

500

 
)
b
(
 
r
e

f
f

u
b

 
t

u
p
n

i
 

e
h

t
 
f

o

 
l

e
v
e

l
 
l
l
i

F

l

 
]
s
k
c
o
b
o
r
c
a
m

 
f

o
 
r
e
b
m
u
n

[

0

0

Maximum playout buffer size, B = 100

B = 400

B = 700

B = 1000

B = 1300

B = 1600

B = 1900

1.25

1.35

1.45

1.55

1.65

1.75

Processor frequency [GHz]

Figure 9. Fill levels of the input buffer for different max-
imum playout buffer sizes (in macroblocks) and different
processor clock frequencies.

the upper bound on the integer variable associated with the
place inbuf for different sizes of the playout buffer. These
results are shown in Figure 9.

This ﬁgure shows that for any ﬁxed playout buffer size,
as the processor frequency is increased, the ﬁll level of the
input buffer decreases. This is because the incoming data
items in the input buffer are now processed faster and are
written out into the playout buffer (which is read by the
output device at a constant rate). However, beyond a cer-
tain processor frequency, the maximum ﬁll level of the in-
put buffer stabilizes; this happens exactly when the play-
out buffer completely ﬁlls up (because the processor imple-
ments blocking write for this buffer). As a result, the max-
imum ﬁll level of the input buffer decreases as the playout
buffer size is increased. Note that all of these are a conse-
quence of the burstiness in the arrival pattern of the stream
and because its execution requirements are highly variable.

Figure 7. The CPN corresponding to the ECA specifying

in Figure 6.

and

between

constraints of the form

The ECA representing a service curve

in this case) that have arrived in the preceding time interval
of length , for some value of
. The
guards associated with each transition in the ECA is a con-
junction of
, where
. These constraints ensure that the
arrival pattern of the data items that arrived at the system till
. Finally, each state in the
the current time is bounded by
ECA is annotated with a range
, representing the
rate at which items can arrive when the ECA is in that state.
The CPN corresponding to this ECA is shown in Figure 7.
and the corre-
sponding CPN can be similarly obtained. We do not show
them here due to space constraints. Now, following the dis-
cussion in Section 3.1, the CPNs corresponding to these ar-
rival and service curves were composed into a single CPN
which is shown in Figure 8. Further, to simplify the repre-
sentation, the transitions in the two CPNs have been com-
bined into a single transition in this composed CPN. This
CPN models the part of the architecture enclosed within the
rectangular box in Figure 1. Since the playout buffer is read
out at a constant rate by the output device, this is not mod-
eled using a separate ECA. Instead this is directly encoded
in the composed CPN (where this constant rate is denoted
as Rc in the code region of the transition in the CPN). Note
that the places inbuf and outbuf model the input buffer
and the playout buffer respectively. These places are associ-
ated with two integer variables which denote the number of
data items in these buffers at any point in time. At each time
step, these variables are updated depending on the number
of items produced/consumed by genA, genB and the con-
stant rate of consumption by the output device. The fact
that the processor implements a blocking write for the play-
out buffer is also coded in the code region of the transition
in the CPN.

When the size of the input buffer is pre-speciﬁed, an item
is put in the place error whenever the value of the integer
variable associated with the place inbuf exceeds this pre-
speciﬁed size. Thus in this case, the problem of checking
whether the input buffer can ever overﬂow can be formu-
lated as a reachability analysis question, i.e. whether there
exists a reachable marking

at which

error

.

We used the CPN Tools tool kit [9] to specify the CPN
in Figure 8 and ran the state space analysis routine. From
the generated state space exploration result we computed

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

However, the “long-term” arrival rate of the stream, the
“long-term” rate at which macroblocks are processed by the
PE, and the “long-term” consumption rate from the play-
out buffer are all equal. The input and the playout buffers
only capture the burstiness in the stream, which our model
accurately captures. Had the arrival pattern of the stream
been modeled using periodic/sporadic event models with
constant execution time for every data item, then these ef-
fects could not be seen.

Based on these results it is possible to determine the opti-
mal processor frequency and sizes of the playout and the in-
put buffers, given the size of the available memory. Running
the processor at a frequency higher than this optimal fre-
quency reduces its utilization rate. Our results match well
with those obtained using simulation, which was based on a
transaction level model of the system architecture written in
SystemC and the PE modeled using a customized version of
the SimpleScalar instruction set simulator. We again wish to
point out that obtaining the results shown in Figure 9 using
a purely simulation-based approach is prohibitively expen-
sive even for video clips of very short duration. Further,
given that we are interested in an upper bound on the buffer
ﬁll level, results obtained from simulation can not provide
formal guarantees.

4.3 Efﬁciency Issues: State Space Representation

& Analysis Methods

The state spaces of the CPNs we extract from our ECA
networks will be very large for most practical problems.
Hence, an exhaustive exploration of such state spaces, as
we did in our case study, will not be a viable option. How-
ever, a variety of techniques are available for coping with
large state spaces. Since the emphasis of this paper has
been on introducing a new framework, it is not reasonable
to explore these techniques here in detail. Below we brieﬂy
discuss some such techniques that are particularly relevant
for our setting. Our aim is to convince the reader that the
framework we presented can be used for realistic problems
and that there are a number of reasonable implementation
options that would be interesting to study as a part of future
work.

Special Data Structures for Symbolic State Space Rep-
resentation: OBDDs [6] have turned out to be extremely
useful for representing large state spaces. Our state spaces
however are generated by ECAs and BDDs are not geared
towards taking advantage of the additional structure on offer
here. Tuples of integers (valuations) and constraints based
on these tuples are the speciﬁc features we need to han-
dle. We expect specialized forms of BDDs and in partic-
ular, the data structure called Interval Decision Diagrams
(IDDs) [24] to play a useful role in this context. This is so,
since IDDs are particularly suited for succinctly represent-

ing multi-valued functions whose domains consist of inter-
vals of integers and more importantly, where the effect of
the functions themselves can be described in terms of inte-
ger intervals. Hence IDDs -and the accompanying Interval
Mapping Diagrams [24]- hold considerable promise for ef-
ﬁciently representing the states of the behavioral automata
associated with ECAs as well networks of such automata
communicating via bounded buffers.

State Space Invariants: Many of the behavioral proper-
ties we wish to determine can be stated as invariant proper-
ties: For instance, is the number of items contained in the
for all reachable conﬁg-
buffer bounded by the constant
urations? There is a considerable body of work available for
efﬁciently generating invariants for the state spaces of hy-
brid automata; see for instance a recent work [21] and the
references therein. Simpliﬁed versions of these techniques
will be applicable for verifying a variety of important be-
havioral properties for ECAs too.

-invariants and

Structural Invariants: There is a also a large body of
work for computing the so called
-
invariants in the setting of CPNs [14]. The crucial fea-
ture of these invariants is that they are structural. In other
words, they depend on the way places and transitions are
connected to each other and the functions associated with
the transitions that manipulate the color sets. Consequently,
methods of linear algebra -and not state space exploration
techniques- can be used to compute these invariants. Ad-
mittedly not all the interesting invariant properties of the
state space can be caught by -invariants and -invariants.
Nevertheless, many of the properties of interest in our
setting -especially those concerning buffer overﬂows and
underﬂows- can be cast in the language of
-invariants.
Hence,
-invariant techniques specialized to CPNs that are
associated with ECA networks will be a powerful analysis
tool.

5 Concluding Remarks

In this paper we presented a state-based framework for
modeling and analyzing stream processing applications and
architectures. It is geared towards accurately modeling the
burstiness in data streams associated with applications such
as multimedia processing, as well as the variability in the
execution requirements associated with such streams. Be-
ing state-based, this framework allows for the modeling of
different protocols and scheduling policies in a straightfor-
ward way. This is not possible in some of the recently
proposed frameworks [18, 19, 27] which have inspired our
work.

There are several interesting threads that stem from this
work. First, it would be worthwhile to explore the state
space representation techniques outlined in Section 4.3 in
the context of our framework. Second, recall that we model

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

a multiprocessor system using a single global/composed
CPN, which we then use for analysis. This can blow up the
resulting state space that needs to be explored during the
analysis. To avoid this, it might be possible to use composi-
tion techniques similar to those in [18, 19, 27], but adapted
to our state-based setting. Given the arrival and the service
ECAs associated with a PE, the goal is to compute the ECA
representing the timing properties of the processed stream
and the ECA corresponding to the remaining service. These
then serve as inputs to subsequent processing of the stream
by the next PE, and the processing of a second stream by the
same PE. Third, we would also like to model the processing
of multiple streams, explore scheduling issues in more de-
tail and also model quality-of-service constraints (e.g. only
a certain fraction of data items belonging to a stream are
required to meet their deadlines). Finally, we can add ac-
tion labels to the transitions of an ECA. These labels can
be used to form synchronized products of ECAs to capture
stream processing components interacting with event-based
reactive components as suggested in [12].

References

[1] Y. Abdedda¨m, A. Kerbaa, and O. Maler.

Task graph

scheduling using timed automata. In IPDPS, 2003.

[2] Y. Abdedda¨m and O. Maler.
timed automata. In CAV, 2001.

Job-shop scheduling using

[3] R. Alur, C. Courcoubetis, T. A. Henzinger, and P.-H. Ho. Hy-
brid automata: An algorithmic approach to the speciﬁcation
and veriﬁcation of hybrid systems. In Hybrid Systems, LNCS
736, 1993.

[4] R. Alur and D. L. Dill. A theory of timed automata. Theo-

retical Computer Science, 126(2):183–235, 1994.

[5] T. Austin, E. Larson, and D. Ernst. SimpleScalar: An in-
frastructure for computer system modeling. IEEE Computer,
35(2):59–67, 2002.

[6] R. E. Bryant.

Symbolic boolean manipulation with or-
dered binary decision diagrams. ACM Computing Surveys,
24(3):293–318, 1992.

[7] S. Chakraborty, S. K¨unzli, and L. Thiele. A general frame-
work for analysing system properties in platform-based em-
bedded system designs. In 6th Design, Automation and Test
in Europe (DATE), Munich, Germany, February 2003.

[8] S. Chakraborty, L.T.X. Phan, and P.S. Thiagarajan. Event
count automata: A state-based model for stream processing
systems, 2005.
www.comp.nus.edu.sg/ samarjit/psﬁles/ecaTR.ps.

[9] CPN Tools: Computer

tool

for coloured petri nets.

http://wiki.daimi.au.dk/cpntools/cpntools.wiki.

[10] M.I. Gordon et al. A stream compiler for communication-
exposed architectures. In 10th Conf. on Architectural Sup-
port for Programming Languages and Operating Systems
(ASPLOS), pages 291–303, 2002.

[11] U.J. Kapasi et al. Programmable stream processors. IEEE

Computer, 36(8), 2003.

[12] M. Geilen and T. Basten. Reactive process networks.

In
ACM International Conference on Embedded Software (EM-
SOFT), 2004.

[13] T. A. Henzinger. The theory of hybrid automata. In LICS,

1996.

[14] K. Jensen. Coloured Petri Nets. Basic Concepts, Analysis
Methods and Practical Use, volume 1, 2 and 3 of Mono-
graphs in Theoretical Computer Science. Springer-Verlag,
1997.

[15] M. Jersak and R. Ernst. Enabling scheduling analysis of het-
erogeneous systems with multi-rate data dependencies and
rate intervals. In DAC, 2003.

[16] P. Krc´al and W. Yi. Decidable and undecidable problems
in schedulability analysis using timed automata. In TACAS,
2004.

[17] Y.-T.S. Li, S. Malik, and A. Wolfe. Performance estima-
tion of embedded software with instruction cache modeling.
ACM TODAES, 4(3):257–279, 1999.

[18] A. Maxiaguine, S. K¨unzli, S. Chakraborty, and L. Thiele.
Rate analysis for streaming applications with on-chip buffer
constraints. In ASP-DAC, 2004.

[19] A. Maxiaguine, S. K¨unzli, and L. Thiele. Workload charac-
terization model for tasks with variable execution demand.
In DATE, March 2004.

[20] C. Norstr¨om, A. Wall, and W. Yi. Timed automata as task

models for event-driven systems. In RTCSA, 1999.

[21] E. Rodr´guez-Carbonell and A. Tiwari. Generating polyno-

mial invariants for hybrid systems. In HSCC, 2005.

[22] M.J. Rutten, J.T.J. van Eijndhoven, E.G.T. Jaspers, P. van der
Wolf, O.P. Gangwal, and A. Timmer. A heterogeneous mul-
tiprocessor architecture for ﬂexible media processing. IEEE
Design & Test of Computers, 19(4):39–50, July-August
2002.

[23] J. Sermulins, W. Thies, R. Rabbah, and S. Amarasinghe.
Cache aware optimization of stream programs. In ACM Con-
ference on Languages, Compilers, and Tools for Embedded
Systems (LCTES), 2005.

[24] K. Strehl and L. Thiele.

Interval diagrams for efﬁcient
IEEE Trans.
symbolic veriﬁcation of process networks.
Computer-Aided Design of Integrated Circuits and Systems,
19(8), 2000.

[25] G. Varatkar and R. Marculescu. On-chip trafﬁc modeling
and synthesis for MPEG-2 video applications. IEEE Trans-
actions on VLSI, 12(1), January 2004.

[26] V.D. Zivkovi´c, P. van der Wolf, E.F. Deprettere, and E.A.
de Kock. Design space exploration of streaming multiproces-
sor architectures. In IEEE Workshop on Signal Processing
Systems (SIPS), San Diego, California, 2002.

[27] E. Wandeler, A. Maxiaguine, and L. Thiele. Quantitative
characterization of event streams in analysis of hard real-
time applications. In IEEE RTAS, 2004.

Proceedings of the 26th IEEE International Real-Time Systems Symposium (RTSS’05) 
0-7695-2490-7/05 $20.00 © 2005 IEEE 

