Optimal Top-K Query Evaluation for Weighted Business

Processes ∗

Daniel Deutch

Tova Milo

Tel Aviv University

Tel Aviv University

Neoklis Polyzotis
UC Santa Cruz

Tom Yam

Tel Aviv University

ABSTRACT
A Business Process (BP for short) consists of a set of ac-
tivities that achieve some business goal when combined in a
ﬂow. Among all the (maybe inﬁnitely many) possible execu-
tion ﬂows of a BP, analysts are often interested in identifying
ﬂows that are “most important”, according to some weight
metric. This paper studies the following problem: given a
speciﬁcation of such a BP, a weighting function over BP ex-
ecution ﬂows, a query, and a number k, identify the k ﬂows
with the highest weight among those satisfying the query.
We provide here, for the ﬁrst time, a provably optimal algo-
rithm for identifying the top-k weighted ﬂows of a given BP,
and use it for eﬃcient top-k query evaluation.

1.

INTRODUCTION

A Business Process (BP for short) consists of a set of activ-
ities which, when combined in a ﬂow, achieve some business
goal. BPs are typically designed via high-level speciﬁca-
tions (e.g. using the BPEL standard speciﬁcation language
[3]) which are compiled into executable code. As the BP
logic is captured by the speciﬁcation, tools for querying and
analyzing possible execution ﬂows (EX-ﬂows for short) of a
BP speciﬁcation are extremely valuable to companies [6].

A single BP typically induces a large (possibly inﬁnite,
for recursive BPs) set of possible EX-ﬂows. Among all these
EX-ﬂows, analysts are often interested only in a subset that
is relevant for their analysis. This subset is described via a
query. Since the number of query answers (qualifying EX-
ﬂows) may itself be extensively large (or even inﬁnite), it
is important to identify those that are “most important”,
where the notion of importance is captured by some weight-
ing metric that depends on the analysis goal. This paper
considers the problem of ﬁnding, given a BP speciﬁcation, a
weighting metric over EX-ﬂows, and a number k, the top-k
∗This research was partially supported by the Israeli Min-
istry of Science Eshkol Grant, the Israel Science Foundation,
the US-Israel Binational Science Foundation, a IBM faculty
development award and NSF grant IIS-0447966

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee. Articles from this volume were presented at The
36th International Conference on Very Large Data Bases, September 13-17,
2010, Singapore.
Proceedings of the VLDB Endowment, Vol. 3, No. 1
Copyright 2010 VLDB Endowment 2150-8097/10/09... $ 10.00.

weighted EX-ﬂows of the speciﬁcation. We provide here, for
the ﬁrst time, a provably optimal algorithm for identifying
the top-k weighted EX-ﬂows of a given BP; this algorithm
is utilized for eﬃcient top-k query evaluation.

For some intuition on the kind of BP analysis that one
may be interested in, and the corresponding queries and
weighting metrics, let us consider a simple example. Assume
we are given a BP of a Web-based shopping mall with virtual
shops of various vendors. A customer of the mall may be
interested in buying a Toshiba TV and a DVD player of low-
est overall price. Suppose that among the possible EX-ﬂows
containing a purchase of two such appliances [query], the
lowest-priced one [weighting] is achieved when the user ﬁrst
subscribes to the Toshiba customer club. Such a result may
suggest that subscription is beneﬁcial even if it entails some
registration fee. Alternatively, suppose that the same user
is interested in minimal shipping time [another weighting].
In this case, the preferred ﬂows may have both products
purchased at the same store.

As another example, the Web-site owner may be inter-

ested to identify the most proﬁtable/popular EX-ﬂows [weight-
ing] that lead to a TV purchase [query]. The answer here
may be used, for instance, to target relevant personalized
advertisements to users. Several weighting functions of in-
terest may be combined to form a single weighting metric.
To formally study top-k query evaluation, we ﬁrst propose
a generic model for weighted EX-ﬂows. To weigh EX-ﬂows,
we assume that each choice taken during the EX-ﬂow bears
some weight (denoted cW eight, for choice weight), and that
cW eights of choices throughout the EX-ﬂow are aggregated
to obtain the EX-ﬂow weight (denoted f W eight, for ﬂow
weight). For example, cW eight may be the price of the
product chosen at a given point of the EX-ﬂow, or the likeli-
hood of a user clicking on a given store link. In the ﬁrst case,
summation may be used for aggregation; for likelihoods we
may use multiplication. Following common practice [11], we
require the aggregation to be monotonic w.r.t. the progress
of the ﬂow. This captures most practical scenarios, e.g., the
total price of a shopping cart subset does not exceed the
price of the full cart, even in the presence of discount deals.
It is important to note that the cW eight of a given choice
may vary at diﬀerent points of the EX-ﬂow and may depend
on the course of the ﬂow so far and on previous choices. For
instance, the price of a given product may be reduced if the
user had previously subscribed to a customer club or bought
over two products from the same vendor; the likelihood of
clicking on a certain store link may depend on stores previ-
ously visited. Thus cW eight is modeled as a function whose

940input includes not only the choice itself but also informa-
tion about the history of the EX-ﬂow thus far. We derive
an equivalence relation equiv that captures how much the
cW eight of a given choice is aﬀected by preceding choices,
and provide a top-k algorithm whose worst-case complexity
is polynomial in the count of classes in equiv and the size of
the BP speciﬁcation, and linear in the size of the output.

We then study the optimality properties of top-k algo-
rithms in this setting. Following common practice [11], we
employ the notions of optimality and instance optimality,
that reﬂect how well a given algorithm performs compared
to all other possible algorithms in its class. We show that
the properties of the f W eight function dictate the optimal-
ity of top-k algorithms in this setting: for general monotone
f W eight function, we show that no algorithm is optimal or
even instance optimal. However, we further consider a class
of semi-strongly monotone functions that arise frequently in
practice. We show that still no optimal algorithm exists for
such functions, but we show instance optimality for our algo-
rithm. Finally, we show that for the further restricted class
of strongly monotone, our algorithm is in fact optimal.

We conclude with an experimental study of our algorithm
performance. Our experiments show that in all realistic sce-
narios, including when the conditions that guarantee opti-
mality are not met, our algorithm outperforms the worst-
case bound, as well as previously proposed algorithms, by
an order of magnitude.

Diﬃculties and novelty. A ﬁrst diﬃculty here is the in-
ﬁnite search space. While each individual EX-ﬂow is ﬁnite,
a single BP may have an inﬁnite number of possible EX-
ﬂows (analogous to how a grammar deﬁnes an inﬁnite set of
words), due to the possibly recursive nature of BPs. More-
over, even for non-recursive BPs, the size of a single EX-
ﬂow may be exponential in the speciﬁcation size. Indeed,
standard A∗-style [5] search algorithms may fail to halt in
this context and, moreover, become prohibitively ineﬃcient,
even for non-recursive BPs. Our previous work ([7]) has at-
tempted to overcome these diﬃculties. As we show in this
work, the performance of the solution proposed in [7] is un-
satisfactory for several realistic scenarios. In contrast, the
novel top-k algorithm presented here is provably optimal,
and outperforms the algorithm of [7] by over 90% in real-
life scenarios (see Section 5). Furthermore, the algorithm
of [7] was tailored to probabilistic BPs and thus has lim-
ited applicability comparing to the novel algorithm which is
generically applicable to any weight metric.

Paper organization Section 2 presents our model for weighted
BPs and EX-ﬂows. Section 3 presents our top-k algorithm,
and Section 4 discusses its optimality. Section 5 describes
our experiments. Section 6 concludes with related work. For
space constraints, proofs are deferred to the Appendix.

2. PRELIMINARIES

We start by recalling the standard basic model for BPs
and EX-ﬂows [6], then extend it to support weighted BPs.
As a running example, we will use the web-based Shopping
Mall BP from the Introduction.

2.1 BP Speciﬁcations

At a high-level, a BP speciﬁcation encodes a set of activ-
ities and the order in which they may occur. A BP spec-
iﬁcation is modeled as a set of node-labeled DAGs. Each

DAG has a unique start node with no incoming edges and a
unique end node with no outgoing edges. Nodes are labeled
by activity names and directed edges impose ordering con-
straints on the activities. Activities that are not linked via
a directed path are assumed to occur in parallel. The DAGs
are linked through implementation relationships; the idea is
that an activity a in one DAG is realized via the activities in
another DAG. We call such an activity compound to diﬀer-
entiate it from atomic activities having no implementations.
Compound activities may have multiple possible implemen-
tations, and the choice of implementation is controlled by a
condition referred to as the guarding formula.

We assume a domain A = Aatomic ∪ Acompound of activity

names and a domain F of formulas in predicate calculus.

Definition 2.1. A BP speciﬁcation s is a triple (S, s0, τ ),
where S is a ﬁnite set of node-labeled DAGs, s0 ∈ S is a
distinguished DAG consisting of a single activity, called the
root, τ : Acompound → 2S×F is the implementation func-
tion, mapping each compound activity name in S to a set of
pairs, each consisting of an implementation (a DAG in S)
and a guarding formula in F.

Example 2.2. Figure 1 shows an example BP speciﬁca-

tion. The root s0 has precisely one activity named ShoppingMall.
The latter has as its implementation the DAG S1, which de-
scribes a group of activities comprising user login, the in-
jection of an advertisement, the choice of a particular store,
and the user exit (possibly by paying). The directed edges
specify the order in which the activities may occur, e.g., a
user has to login ﬁrst before a store can be chosen. Some of
the activities are not in a particular order, e.g., the injection
of an advertisement and the choice of a store, which means
that they occur in parallel.

Within S1, we observe that Login and chooseStore are
compound activities; the Login activity has two possible im-
plementations S2 and S3 that are guarded by respective for-
mulas. The idea is that exactly one formula is satisﬁed at
run-time, e.g., the user either chooses to login with a Visa
or a Mastercard credit card, and thus Login is implemented
either by S2 or S3 respectively. A similar observation can
be made for chooseStore, which has several possible im-
plementations, but exactly one will be chosen at run-time
depending on which guarding formula is satisﬁed. Note that
the speciﬁcation is recursive as S4 may call S1.

We note that satisfaction of guarding formulas is deter-
mined by external factors, e.g. choices of the user or envi-
ronment parameters. We assume that exactly one guarding
formula can be satisﬁed when determining the implementa-
tion of a given compound activity occurrence. We observe
that satisfaction of guarding formulas can change if activi-
ties occur several times. For instance, a user may choose to
buy a “DVD” product the ﬁrst time she goes through the
activities of S4, and a “TV” product the second time.
2.2 EX-Flows

An EX-ﬂow is modeled as a nested DAG that represents
the execution of activities from a BP. We model each oc-
currence of an activity a by two a-labeled nodes, the ﬁrst
standing for the activity activation and the second for its
completion point. These two nodes are connected by an
edge. The edges in the DAG represent the ordering among
activities activation/completion and the implementation re-
lationships. To emphasize the nested nature of executions,

941Figure 1: Business Process Speciﬁcation

Figure 2: Example execution ﬂow

the implementation of each compound activity appears in-
between its activation and completion nodes. Of course, the
structure of an EX-ﬂow DAG must adhere to the structure
of the corresponding BP speciﬁcation, i.e., activities have to
occur in the same ordering and implementation relationships
must conform to function τ .

Definition 2.3. Given a BP speciﬁcation s = (S, s0, τ ),

e is an execution ﬂow (EX-ﬂow) of s if:

• Base EX-Flow: e consists only of the activation and
completion nodes of the root activity s0 of s, connected
by a single edge, or,

• Expansion Step: e(cid:48) is an EX-ﬂow of s, and e is ob-

tained from e(cid:48) by attaching to some activation-completion
pair (n1, n2) of an activity a in e(cid:48) some implementation
ea of a, through two new edges, called implementation
edges, (n1, start(ea)) and (end(ea), n2), and annotat-
ing the pair with the formula fa guarding ea.

We require that this (n1, n2) pair does not have any
implementation attached to it already in e(cid:48), whereas
all its ancestor compound activities in e(cid:48) do have one.
In the attached implementation ea, each activity node
is replaced by a corresponding pair of activation and
completion nodes, connected by an edge.
We call e an expansion of e(cid:48), denoted e(cid:48) → e.

Example 2.4. An example EX-ﬂow of the shopping mall
BP is given in Figure 2. Ordering edges (implementation
edges) are drawn by regular (resp. dashed) arrows. The EX-
ﬂow describes a sequence of activities that occur during the
BP execution. The user logins with a Visa Credit Card, then
chooses to shop at the BestBuy store. There, she chooses
to look for a DVD player and selects one by Toshiba, then
continues shopping at the same store, looking for a TV, and
selects one also by Toshiba (this last part is omitted from
the ﬁgure). Finally she exits and pays.

We use e(cid:48) →∗ e to denote that e was obtained from e(cid:48) by a
sequence of expansions. An activity pair a in an EX-ﬂow e
is unexpanded if it is not the source of any implementation
edge, implying that a can be used to further expand e. We
say that an EX-ﬂow is partial if it has unexpanded activities,

and full otherwise, and denote the set of all full ﬂows of a
BP speciﬁcation s by f lows(s). For a graph e, we say that
e is an EX-ﬂow if it is a (partial or full) ﬂow of some BP
speciﬁcation s.

To simplify the presentation, we impose a total order
among unexpanded activities of any given partial ﬂow, and
assume that the expansion of activities follows this order.
(This order can be achieved by a topological sort of the
EX-ﬂow DAG.) Thus, any partial EX-ﬂow corresponds to a
unique sequence of expansion steps from the base EX-ﬂow.
This assumption is made solely for presentation considerations–
all our results extend to a general context where multiple
expansion orders are possible (see Appendix B).

2.3 Weighted EX-ﬂows

We assume an ordered domain W of weights. We use
three functions: (1) cW eight that describes the weight of
each implementation choice, given a preceding sub-ﬂow, (2)
aggr that aggregates cW eight values, and (3) f W eight that
uses cW eight and aggr to compute ﬂow weight.

The cWeight function. Given a BP speciﬁcation s, cW eight
is a partial function that assigns a weight w ∈ W to each pair
(e, f ) where e is an EX-ﬂow of s and f guards the compound
activity node of e that is next to be expanded. Intuitively,
the value cW eight(e, f ) is the weight of the implementation
guarded by f , given that e is the ﬂow that preceded it.

Example 2.5. Re-consider the EX-ﬂow in Fig. 2, and a
cW eight function assigning, to each implementation choice,
the additional cost that it incurs to the customer. In this
case W is the set of all positive numbers. The cW eight
of the choice $brand = “T oshiba”, given that the preceding
ﬂow indicates that the product being purchased is a DVD, the
shop is BestBuy and the user has identiﬁed herself as a Visa
card holder, may be the Visa discounted price of a Toshiba
DVD at BestBuy. The cW eight of a Toshiba choice, given
that the product is a TV and that the preceding ﬂow already
includes a purchase of a Toshiba product (the DVD), may
reﬂect, e.g., a 20% discount for the second product. The
cW eight of other choices (like the store or the product type)
may be zero, as they incur no additional cost to the user.

The Aggregation function. The weights along the EX-
ﬂow are aggregated using an aggregation function aggr :
W × W → W. The ﬁrst input is intuitively the aggregated
weight computed so far, and the second is the new cW eight
to be aggregated with the previous value. For instance, when
computing purchase cost aggr = + and W = [0, ∞); when
computing likelihood, aggr = ∗ and W = [0, 1]. We consider
here aggregation functions that are associative, commuta-
tive, continuous and monotone, either increasing or decreas-
ing (For formal deﬁnition of these properties see Appendix
C). Observe that the aggregation functions + and ∗, for cost
and likelihood resp., satisfy the constraints.

The fWeight function. Finally, the f W eight of an EX-ﬂow
is obtained by aggregating the cW eights of all choices made
during the ﬂow, and is deﬁned recursively: if e is an EX-ﬂow
consisting only of the root s0, f W eight(e) = 1aggr. Other-
wise , if e(cid:48) → e for some EX-ﬂow e(cid:48) of s, then f W eight(e) =
aggr(f W eight(e(cid:48)), cW eight(e(cid:48), f )), where f is the formula
guarding the implementation that is added to e(cid:48) to form e.

942Example 2.6. Assume that a Toshiba TV and DVD, which

individually cost 250$ and 150$ resp., are sold together with
20% discount (i.e.
for 320$). The cW eight for the ﬁrst
choice of Toshiba TV (DVD) is 250$ (resp. 150$). The
cW eight for the next choice, of DVD (TV), is 70$ (170$),
computed as 320$ minus the cost already incurred for the
ﬁrst product. Using + for aggregation, cW eights along the
ﬂow are summed up, yielding the total 320$ deal price.

Observe that when aggr is monotonically increasing (de-
creasing), so is f W eight, in the sense that the weight of
an EX-ﬂow increases (resp. decreases) as the execution ad-
vances. Generally, when f W eight is increasing (as, e.g.,
for the overall price of purchases), we are interested in the
bottom-k full ﬂows (e.g. the cheapest overall price). When
f W eight is decreasing (as, e.g., for the likelihood of EX-
ﬂows), we are interested in top-k (e.g. the most likely) ones.
Since all deﬁnitions and algorithms presented below apply
symmetrically to both cases, we consider from now on only
monotonically decreasing functions and top-k EX-ﬂows.

Top-k EX-ﬂows. Given a BP speciﬁcation s, a monoton-
ically decreasing f W eight function for s and a number k,
we study the problem of identifying the top-k weighted EX-
ﬂows in f lows(s) 1. We refer to this problem as TOP-K-FLOWS.
One may further consider queries, that select EX-ﬂows of
interest and in this case we retrieve the top-k out of the
EX-ﬂows matching the query. The common practice in such
cases (see e.g. [7, 2]) is to employ a two-steps algorithm. In
the ﬁrst step we “intersect” the query q with s, obtaining
a new BP s(cid:48) whose ﬂows are exactly those ﬂows of s that
also match q. The second step is then to perform a top-
k analysis over s(cid:48). An eﬃcient algorithm for the ﬁrst step
was suggested in [6], and we thus focus here on the second
step, i.e. TOP-K-FLOWS. For completeness, we recall in the
Appendix D, (from [6]), the formal deﬁnition of queries and
the details of this two step algorithm.

3. OPTIMAL TOP-K ALGORITHM

When devising an algorithm for TOP-K-FLOWS, one encoun-
ters two main diﬃculties. First, recall that BPs may be re-
cursive, in which case the number of EX-ﬂows to consider
may be inﬁnite. Second, even without recursion, the size of
a single EX-ﬂow may be exponential in the BP size, as a
single graph may appear as the implementation of multiple
compound activities in the ﬂow. The conventional A∗ algo-
rithm [5] may traverse the entire search space in the worst
case, and thus fail to halt for recursive BPs. To observe
that, consider the following simple example.

Example 3.1. Consider the following BP speciﬁcation.
Its root activity A has two possible implementations:
the
ﬁrst, S1, guarded by a formula F 1, consists of a single
atomic activity a. The second, S2, guarded by F 2, con-
sists of a recursive invocation of A. The cW eight func-
for every two EX-ﬂows e, e(cid:48) cW eight(e, F 1) =
tion is s.t.
cW eight(e(cid:48), F 1) = 0.5 and cW eight(e, F 2) = cW eight(e(cid:48), F 2)
= 0; we use aggr = ∗. The algorithm will keep consider-
ing recursive expansions of A, each time obtaining EX-ﬂows
with decreasing weight, but nevertheless higher than 0, and
will never terminate. We note that while in this example

1Certain EX-ﬂows may have equal weights, which implies
that there may be several valid solutions to the problem, in
which case we pick one arbitrarily.

the cW eight values of some guarding formulas are 0, we
may also design a (more complicated) weight function, with
positive weights, for which the algorithm does not terminate.
Moreover, A∗ can be ineﬃcient (and incur EXPTIME in
the BP speciﬁcation size) even for non-recursive BPs, due
to the sizes of materialized EX-ﬂows (we provide such an
example in Appendix E). To overcome these problems, we
use the following two observations.
Observation 1. We ﬁrst observe that some distinct nodes
n, n(cid:48) may be in fact equivalent, in the sense that every sub-
ﬂow that may originate from n may also originate from n(cid:48),
having the same f W eight. In Example 3.1 above, all oc-
currences of nodes labeled by A are equivalent. As another
example, consider a weight function standing for product
prices. If no deals are proposed, every two nodes n, n(cid:48) stand-
ing for the purchase of the same product P , are equivalent. If
there are deals, then price of P may depend on the ﬂows his-
tories preceding n and n(cid:48). If these histories are the same in
terms of purchasing the same products speciﬁed in the com-
bined deal with P , then n and n(cid:48) are equivalent. Equivalence
is thus a relation between two pairs of (EX-ﬂow,next-to-
be-expanded-node). Before formally deﬁning this relation,
we introduce the auxiliary notion of (isomorphic) sub-ﬂows:
given an EX-ﬂow e and an activity n of e, the sub-ﬂow of
e rooted at n consists of all nodes and edges appearing on
some path in-between the activation and completion nodes
of n. An isomorphism between two (sub-)ﬂows e and e(cid:48) is a
one-to-one and onto matching between the nodes and edges
of e and e(cid:48), respecting node labels, guarding formulas and
the edge relation.

Definition 3.2. Given two pairs of (EX-ﬂow,next-to-be-
expanded-node), (e, n) and (e(cid:48), n(cid:48)), we say that (e, n),(e(cid:48), n(cid:48))
are equivalent if (1) n and n(cid:48) are labeled by the same activity
name, and (2) for all EX-ﬂows ˆe, ˆe(cid:48) s.t. e →∗ ˆe, e(cid:48) →∗ ˆe(cid:48),
and in which the sub-ﬂows rooted at n and at n(cid:48) (denoted ˆen
and ˆe(cid:48)

n(cid:48) ) are isomorphic, f W eight( ˆen) = f W eight( ˆe(cid:48)

n(cid:48) ).

We denote the set of equivalence classes, for the given BP
speciﬁcation, by equiv. We assume in the sequel that equiv
is known and ﬁnite, and explain below how to generate it.

Observation 2. We observe that existence of equivalence
classes in combination with the monotonicity of f W eight
facilitates incremental-style computation.

Lemma 3.3. For every equivalence class eq ∈ equiv and

a compound activity node n ∈ eq, the following hold:
(1) there exists a best ranked (top−1) EX-ﬂow originating
at n that contains no occurrence of any other node n(cid:48) ∈ eq.
(2) for j > 1, there exists a j’th ranked ﬂow originating at
n such that for any occurrence of a node n(cid:48) ∈ eq in it, the
sub-ﬂow rooted at n(cid:48) is one of its top j −1 ﬂows.

Let us illustrate the implications of these two observations.

Example 3.4. Re-consider example 3.1, and recall that
while trying to retrieve the top-1 EX-ﬂow rooted at A, the
A∗-like algorithm has encountered a recursive invocation of
A, and has examined possible EX-ﬂows of the latter, thus
resulting in an inﬁnite loop. Following Lemma 3.3, this is
redundant:
to compute the top-1 EX-ﬂow one may avoid
considering ﬂows that contain a recursive call to A (note
that all occurrences of A, regardless of the ﬂow preceding
them, are equivalent). The top-2 ﬂow may contain a recur-
sive invocation of A, but the only sub-ﬂow that needs to be

943considered as potential expansion for this occurrence of A is
the (already computed) top-1 ﬂow, and so on.

TOP-K Algorithm. Following the above observations, we de-
ﬁne an EX-ﬂows table, F T able, (compactly) maintaining the
top-k (sub)ﬂows for each equivalence class. It has rows cor-
responding to equivalence classes, and columns ranging from
1 to k. Each entry contains a pointer to the correspond-
ing sub-ﬂow. In turn, every implementation of a compound
activity node in this sub-ﬂow is not given explicitly, but
rather as a pointer to another entry in F T able, and so on.
This guarantees that the size of each ﬂow representation is
bounded by the table size, avoiding the blow-up of EX-ﬂow
sizes. In what follows, every EX-ﬂow is represented via a
single pointer to an entry at F T able (we discuss the explicit
construction of ﬂows below).

The algorithm then operates in two steps. First, it calls
a subroutine FindFlows which computes a compact repre-
sentation of the top-k EX-ﬂows within F T able, then it calls
EnumerateFlows that uses the table to explicitly enumerate
the EX-ﬂows from this compact representation. We next
explain the operation of these two subroutines.

FindFlows. The FindFlows procedure maintains two prior-
ity queues F rontier and Out of (partial) EX-ﬂows, ordered
by f W eight. At each step, F rontier contains all ﬂows that
still need to be examined. Upon termination, Out will con-
tain the top-k ﬂows. Initially, Out is empty and F rontier
contains a single partial EX-ﬂow, containing only the BP
root. At each step, we pop the highest weighted ﬂow e from
F rontier. If e is a full (partial) ﬂow, the algorithm invokes
HandleF ull (HandleP artial) to handle it.

Algorithm:HandlePartial

Input: e
v ← getN ext(e) ;
T ableRow = F T able.f indEquivClass([e, v]) ;
if T ableRow = N U LL then
insert [e, v] into F T able ;
Expansions ← AllExps(e) ;
foreach (e(cid:48), F (cid:48)) ∈ Expansions do
re(cid:48) ← aggr(re, cW eight(e, F (cid:48))) ;
insert (e(cid:48), re(cid:48) ) into F rontier;

U nhandledExp ← {e(cid:48)
chosen for (e, v)} ;
if U nhandledExp = N U LL then

v ∈ T ableRow | e(cid:48)

insert ((e, we), v) into OnHold ;

v was not

1
2

3

4

5
6

7

8

9

10

11
12

13

14

15
16

17

18

19
20

21

22

end

end
else

end
else

end

end

e, all of its expansions (i.e. all e(cid:48) s.t. e → e(cid:48)), along with
their weights. The algorithm ﬁrst retrieves the next-to-be-
expanded node v of e (line 1), and looks up its equivalence
class in F T able (line 2). If no entry is found, it means that
we haven’t encountered yet an equivalent node during the
computation. We thus create a new row in F T able for this
equivalence class (line 4). Entries in this row will be ﬁlled
later, when corresponding full ﬂows are found. Then, we ob-
tain all expansions of e (Line 5), and for each such expansion
we compute its f W eight value, and insert it to the F rontier
queue for processing in the following iterations (Lines 6-9).
Otherwise, if the appropriate row already exists in the table,
we consider the partial EX-ﬂows that appear in this row but
were not yet considered for expanding e (line 12). If no such
EX-ﬂow exists, (although the table entry exists), it means
that e was previously reached when expanding some other
node v(cid:48) (which appears in e as well). Following observation
2, we may compute the next best EX-ﬂow without further
expanding e. Thus, we put e on hold (line 14). It will be re-
leased upon ﬁnding a full ﬂow originating in v(cid:48) (see below).
If an unused EX-ﬂow exists, we take the highest ranked such
EX-ﬂow and “attach” it to v, that is, we make v point to
this ﬂow (lines 17-18). We now compute the weight of the
obtained EX-ﬂow (line 19) and add it to F rontier (line 20).

HandleFull. HandleFull is depicted in Algorithm 2. First,
the given full EX-ﬂow e is inserted into Out (line 1). If Out
already contains k ﬂows, then we terminate. Otherwise,
every node appearing in e, along with its preceding sub-
ﬂow (lines 7-9) deﬁne an equivalence class, used as entry at
F T able. The sub-ﬂow rooted at the node is then inserted
into the table at that entry, if it does not appear there al-
ready (lines 10-11). Last, all EX-ﬂows that were put by
HandlePartial “on hold” due to a node participating in e,
are returned to Frontier (lines 13-14).

Algorithm:HandleFull
Input: e, we
insert (e, we) into Out ;
if |Out| = k then

Output Out;

end
else

foreach node n ∈ e do

epre
n ← the sub-ﬂow of e preceding n ;
erooted
n
wrooted
if not (erooted

← the sub-ﬂow of e rooted at n;
← f W eight(f rooted

∈ F T able) then

) ;

n

n

n

F T able.update([n, epre

n ], erooted

n

) ;

end
foreach (e(cid:48), n) ∈ OnHold do

insert e(cid:48) into F rontier ;

1

2

3

4

5
6

7

8

9

10

11

12

13
14

15

16

17

e(cid:48)(cid:48)
v ← top(U nhandledExp) ;
e(cid:48) ← expand e by pointing v to e(cid:48)(cid:48)
v ;
we(cid:48) ← aggr(we, f W eight(e(cid:48)(cid:48)
insert (e(cid:48), we(cid:48) ) into F rontier;

v )) ;

end

end

end

Algorithm 1: HandlePartial

HandlePartial. HandlePartial, depicted in Algorithm 1,
is given a partial ﬂow e and considers all possible expan-
sions e(cid:48) of e. To that end, we assume the existence of an
AllExps function that allows to retrieve, given a partial ﬂow

Algorithm 2: HandleFull

Explicit enumeration. When F indF lows terminates, the
top-k ﬂows are compactly represented in Out via pointers to
entries in F T able; implementations of compound activities
within the graphs appearing in these entries are possibly rep-
resented by pointers to other entries, etc. EnumerateF lows
follow these pointers to materialize EX-ﬂows in Out. This

944pointer chasing terminates, following observation 2.

Theorem 4.1. For strongly monotone f W eight functions,

We may prove the following theorem.

TOP-K is optimal within A.

Theorem 3.5. Given a BP s (with cW eight and aggr)
and a number k, if |equiv| is ﬁnite, the time complexity of
Algorithm FindFlows is polynomial in |s|, k and |equiv|.
Generating equiv. Recall Def. 3.2, and observe that equiv
is dictated by the fragment of the partial ﬂow preceding a
given choice, that in fact aﬀects its cW eight. This fragment
is termed as memory. For instance, if cW eight stands for
product prices, then the memory for a given product choice
P includes the choice of shop, and the previous purchase
of products suggested in a combined deal with P . Thus, in
practice, equiv may be derived e.g. from a database of prod-
uct prices and proposed deals. |equiv|, and consequently the
complexity of TOP-K, is then polynomial in |s|, with the ex-
ponent depending on the required memory size. Using a
similar construction to that of [7], we may show the neces-
sity of the exponential dependency on memory size (unless
P = N P ), and that the problem becomes undecidable when
the memory size is unbounded (see Appendix A). In prac-
tice, the memory size for navigation choices in a web-site is
typically bounded and very small (approx. 4 [17]).

4. OPTIMALITY PROPERTIES

We next consider the optimality of TOP-K. We start by
deﬁning our optimality measures, then analyze TOP-K’s op-
timality for weight functions with diﬀerent properties.

4.1 Optimality Measures

We introduce the class of algorithms against which we
compare TOP-K, the cost metric used for comparison, and
the notions of optimality and instance-optimality.

Competing algorithms. We deﬁne the class A of all de-
terministic correct top-k algorithms operating on the same
input as TOP-K and having no additional information. An
algorithm in A may retrieve an EX-ﬂow by multiple calls
to AllExps. It may obtain the cW eight of each expansion
choice and can apply aggr to compute f W eight of EX-ﬂows,
but cannot use information not obtainable in this manner.

Cost metric. We consider the number of calls to AllExps
as the dominant computational factor, indicating the num-
ber of distinct (sub-)ﬂows examined. The cost of an algo-
rithm A executed over an input instance I (denoted cost(A, I))
is thus deﬁned as the number of calls it makes to AllExps.

Optimality and Instance Optimality. Following [11], we
use two notions of optimality (within the class A): A ∈ A is
optimal if for each algorithm A(cid:48) ∈ A and an input instance I
cost(A, I) ≤ cost(A(cid:48), I). A is instance-optimal if there exist
constants c, c(cid:48) such that for each A(cid:48) ∈ A and instance I,
cost(A, I) ≤ c ∗ cost(A(cid:48), I) + c(cid:48).

4.2 Optimality Results

We show next that the (instance) optimality of our algo-
rithm is inﬂuenced by properties of the f W eight function.

Strongly monotone fWeight. We say that f W eight is
strongly monotone if for every two distinct (partial or full)
ﬂows e, e(cid:48), we have f W eight(e) (cid:54)= f W eight(e(cid:48)). In partic-
ular, this implies that the weight strictly decreases as the
ﬂow advances. We prove the following.

Proof sketch. The proof works by contradiction and is

based on the following lemma (proved in the Appendix):

Lemma 4.2. Given some input I, let eterm be the worst
solution in Out upon termination. Whenever an e (cid:54)= eterm
is popped from F rontier, f W eight(e) > f W eight(eterm).

Now, if an algorithm A expands, on some input I, less
nodes than FindFlows, there exist a ﬂow e and a node v ∈ e
s.t. FindFlows expanded v but A has not expanded any node
equivalent to v (FindFlows expands at most a single node of
each equivalence class). Denote f W eight(eterm) by wterm.
f W eight(e) > wterm by the lemma. Consider some w∗ s.t.
aggr(f W eight(e), w∗) > wterm (such w∗ exists as aggr is
continuous), and design an input I (cid:48), similar to I but with a
new implementation of v’s activity with cW eight of w∗. A
is wrong on I (cid:48):
it acts on I (cid:48) as on I, never seeing v, thus
missing an EX-ﬂow having a better weight than wterm.

Semi-Strongly Monotone fWeight. In a realistic setting,
some choices do not incur any change to f W eight.
(For
instance, in our shopping mall example, the choice of store or
product type induce a zero added cost). Consequently, some
ﬂows may share the same f W eight value. Still, the number
of such ﬂows sharing any speciﬁc f W eight value, is typically
bounded. To model this we deﬁne, for each constant c, the
notion of c-strongly monotone f W eight:

Definition 4.3. For a constant c, an f W eight function
is c-strongly monotone for a BP speciﬁcation s, if for every
weight w, |{e ∈ f lows(s) | f W eight(e) = w}| ≤ c.

The following theorem holds.

Theorem 4.4. For every constant c, and every BP speci-
ﬁcation along with a c-strongly monotone f W eight function,
TOP-K is instance optimal within A.

The proof is similar to that of Theorem 4.1, and is given
in Appendix A. Note that no optimal algorithm is possible
here, as follows:

Theorem 4.5. No algorithm within A is optimal for all

c-strongly monotone f W eight functions.

Proof sketch. The proof assumes the existence of an
optimal algorithm A, then deﬁnes an algorithm A(cid:48) with a
diﬀerent order for the expansion of equally weighted EX-
ﬂows, and constructs an input for which the order chosen
by A(cid:48) yields less expansions before ﬁnding the top-1 ﬂow.
The full details are given in Appendix A.

Weakly monotone fWeight. Finally, we consider the (not
so common in practice) case of weakly monotone f W eight
functions. Here users may perform an unbounded number
of consecutive choices that incur no change to the EX-ﬂow
weight. Unfortunately, in this case our algorithm is not
(instance) optimal, but we can show that in this case no
(instance) optimal algorithm exists.

Theorem 4.6. No algorithm within the class A is (in-
stance) optimal for all weakly monotone f W eight functions.

9455. EXPERIMENTAL STUDY

We present an experimental study of our algorithm based
on synthetic and real-life data. The study evaluates the per-
formance of the algorithm in practice relative to the worst-
case bounds implied by our analysis, examining cases where
optimality is guaranteed as well as cases where it is not.

Note that TOP-K gradually ﬁlls in F T able, and halts once
it discovered the top-k ﬂows. We implemented a variant of
TOP-K, termed WC (for worst-case), that ﬁlls in all entries of
FTable before terminating, and compared the performance
of TOP-K to WC. Performance-wise, WC is similar to the algo-
rithm in [7] which also computes the top-k ﬂows rooted at
every activity. A comparison of TOP-K to WC thus provides
a comparison to [7], demonstrating the signiﬁcant perfor-
mance gains achieved by our new algorithm.

We have implemented the algorithm in C++ and ran our
experiments on a Lenovo T400 laptop, with Intel Core2 Duo
P8600 processor and 2GB RAM. We ran two series of exper-
iments. First, we used synthetic data to study the algorithm
performance and scalability. Second, we used real data, in
the context of the Yahoo! Shopping Web-site, to evaluate
the performance in a real life setting.
Experiments with Synthetic Data. We generated our syn-
thetic input by varying a number of diﬀerent parameters
that aﬀect the complexity of the TOP-K-FLOWS problem. The
ranges of parameter values were chosen based upon surveys
on the structure of typical Web Applications [13, 17]; to ex-
amine the scalability of our techniques, we favored values
that are on the higher end of the spectrum. In what follows,
we describe the parameters and the chosen value ranges.

BP Speciﬁcations size. We varied the total number of
activities in our BP speciﬁcations from 1000 to 40000; we
note that [13] states that a typical number of activities in a
given Web-site is 4000. To demonstrate scalability we have
studied here BP speciﬁcations whose size is up to 10 times
larger than that of a typical application.

History Bound. We considered bounded-history cW eight
functions with bounds ranging from 0 to 10. A previous
study [17] on the behavior of Web surfers concluded that a
typical history bound is 4.

Equivalence classes. Recall that the number of activi-
ties in the BP together with the size of the history bound
determine the number of equivalence classes, and thus also
the size of the F T able. The values above yielded BPs with
1K-260K diﬀerent equivalence classes.

Monotonicity strength. We varied the percentage of
cW eights that are equal to the neutral value of the aggrega-
tion function. This percentage determines how strongly/weakly
monotone is the f W eight function, and in turn, to what ex-
tent conditions that guarantee optimality hold (see Section
4). To further study the eﬀect of monotonicity strength on
the algorithm performance, we varied the standard devia-
tion of the distribution of cW eight values (we considered
uniform and normal distributions); high standard deviation
implies greater monotonicity strength.
Number of results. We varied k in the range 1 to 500.
Additional Parameters. As for the BP structure (i.e.
number of activities in each implementation graph and num-
ber of possible implementations for each activity), we tried
parameter values that are up to 5 times greater than ob-

served in the real-life case of Yahoo! Shopping Web-site: we
varied the number of implementation choices for each activ-
ity ranging from 2 to 1000, and the number of activities in
each implementation from 100 to 1000. But given a ﬁxed
number of equivalence classes, we noted no signiﬁcant eﬀect
of the BP structure on the algorithm performance, and con-
sequently, we show the results for a ﬁxed number (namely
50) of possible implementation choices (the number of ac-
tivities in each implementation is dictated by the overall BP
size and the number of possible implementation choices).

A representative sample of the experimental results is pre-
sented below. Figure 4(a) examines the execution times (in
seconds) of TOP-K and WC for increasing number (in thou-
sands) of equivalence classes. (The scale for the time axis
in all graphs is logarithmic). Since our experiments showed
that the shape of the BP graphs and the history bound do
not aﬀect the performance (given a ﬁxed number of equiva-
lence classes), we show here one representative sample where
the history bound is 5. The number k of requested results
here is 100. (We will consider varying k values below). The
ﬁgure shows the performance of TOP-K for cW eight values
in the range [0,1] with diﬀerent distributions. This includes
uniform and normal distributions with average value of 0.5
and varying standard deviation of 0.2, 0.1, and 0 (the lat-
ter corresponding to all-equal cW eight values). WC always
ﬁlls in all entries of the F T able, thus is not sensitive to the
cW eight distribution, and we show only one curve for it.

Compared to WC, TOP-K generally shows an improvement
of 90-99%, positively correlated with the variance of the dis-
tribution of cW eight values. This is because variance in
cW eights implies variance in the EX-ﬂows f W eight, ex-
ploited by the greedy nature of TOP-K which quickly sepa-
rates the top-k results from the rest. As we shall see below,
such variance of cW eights is indeed common in real-life BPs.
In the extreme (unrealistic) case where all cW eight values
are identical, i.e. standard deviation 0, the performance of
WC and TOP-K became the same (as the early stop condition
does not hold, and the ﬂows table must be fully ﬁlled), thus
we show only the WC curve.

Figure 4(b) examines the execution times of WC and TOP-K
for a growing number k of requested results (for the same
distributions of cW eights as above). The number of equiv-
alence classes here is 200K and the history bound is 5. We
can see that the running time increases only moderately as k
grows, with TOP-K steadily showing signiﬁcantly better per-
formance than WC and exhibiting similar behavior to what
have been described above. (The increase for WC is less visi-
ble in the graph due to the logarithmic time scale).

Figure 4(c) examines the eﬀect of the monotonicity strength

of the weight function, on TOP-K’s execution time. We ﬁx
k, the number of equivalence classes, and the history bound
(to 100, 40K, and 5, resp.), and vary the percentage of neu-
tral weights, with the non-neutral weights uniformly dis-
tributed. At the left-most end, there are no neutral weights
and TOP-K is guaranteed to be optimal; at the right-most
(very unlikely) case all weights are neutral, and TOP-K and
WC exhibit the same execution times (as the ﬂows table must
be fully ﬁlled). We see that the performance of TOP-K is sig-
niﬁcantly superior even when the conditions for optimality
do not necessarily hold. In particular, in all realistic scenar-
ios where less than 90% of the weights are neutral, TOP-K
improves over WC by more than 75%.

946Experiments with Real Data. Our second set of experi-
ments was performed using over (part of) the Yahoo! Shop-
ping Computer Store [20]. We used real data – products de-
tails, pricing information (including deals, reductions, etc.),
and more – obtained from the site through a Web interface
oﬀered by Yahoo!. The obtained BP speciﬁcation consists of
5976 activities with an average of 2.6 implementation choices
per compound activity and a history bound of 4, yielding ap-
prox. 840K equivalence classes. The variance in cW eight
values (costs) of choices for each compound activity (prod-
uct type) is high, e.g. the average RAM price is 192$, with
a standard deviation of 510$.

We considered increasingly large parts of the BP speciﬁ-
cation (corresponding to the outcome of evaluating decreas-
ingly selective queries in the evaluation process depicted at
the bottom of Section 2). Fig. 4(d) depicts results for 15
representative such subsets, involving increasing counts of
equivalence classes–the leading factor in the performance of
the TOP-K algorithm. At the extreme right, all equivalence
classes participate in the computation. Observe that TOP-K
outperforms WC by a factor of over 98%, demonstrating scal-
ability and good performance.

Note that this is also an example for a case where the
A∗-like top-k algorithm does not halt: the BP speciﬁcation
contains a mutual recursion that is due to the back button
facilitated by the web-site. As pressing the back button
incurs no cost, this recursive choice has a 0 weight, leading to
a case similar to that depicted in Example 3.1. In contrast,
our optimal top-k algorithm not only halts but shows an
extremely good performance.
6. CONCLUSION AND RELATED WORK

We considered in this paper top-k query evaluation in the
context of weighted BPs. We analyzed diﬀerent classes of
weight functions and their implications on the complexity of
query evaluation, and have given, for the ﬁrst time, a prov-
ably optimal algorithm for identifying the top-k EX-ﬂows
of BPs. We showed that our algorithm outperforms pre-
vious work [7] by an order of magnitude. The top-k algo-
rithm of [7] was used in [8] as a subroutine, for evaluation
of projection queries over probabilistic BPs. Replacing this
sub-component by the faster, optimal algorithm given in the
present work, will yield the same acceleration that we had
observed here, for the evaluation of projection queries.

Top-k queries were studied extensively for relational and
XML data [12]. Notably, [11] presented an instance-optimal
algorithm for top-k queries that aggregate individual scores
given to joining tuples.
In our context, one may think of
the cW eight as the equivalent of an individual score, and of
f W eight as the aggregation of cW eight values along a given
EX-ﬂow. Diﬃculties speciﬁc to our settings are that (1) the
size of a given ﬂow, thus the number of aggregated scores, is
unbounded (2) the particular properties of the cWeight func-
tions are unique to EX-ﬂows and (3) the number of items
(EX-ﬂows) that are ranked is inﬁnite. Note that while an
inﬁnite setting also appears in streamed data analysis [16],
such works aggregate over a bounded size sliding window,

whereas we study aggregation over ﬂows of unbounded size.
Ranking by likelihood was also studied in for Probabilis-
tic Databases (PDBs) [18] and Probabilistic XML [1, 15],
extending relational databases and XML, resp., to a proba-
bilistic setting. For example, [18] and [15] study top-k query
evaluation over PDBs and Probabilistic XML, resp. In con-
trast to relational data and XML, our model for BP ﬂows
allows representation of an inﬁnite number of items, out of
which the top-k are retrieved. Works on Probabilistic pro-
cess speciﬁcations (e.g.
[14, 10, 4]) either suﬀer from low
expressivity or incur infeasibility of query evaluation. Anal-
ysis of non-weighted processes in the context of veriﬁcation
(rather than top-k analysis) was discussed in e.g. [9].

Finally, we note a complementary line of works (e.g. [19])
on the optimization of ETL processes, that allow to con-
struct a repository of execution ﬂows that occurred in the
past (and consequently, to derive weight functions such as
choices likelihoods to be used within our model). This is
complementary to our analysis of possible future executions.
Extending our algorithms to more powerful models and
query features, including e.g. value-based joins, projection,
negation and non-monotone weight functions, while preserv-
ing low complexity is a challenging future research.
7. REFERENCES
[1] S. Abiteboul and P. Senellart. Querying and updating

probabilistic information in xml. In Proc. of EDBT, 2006.

[2] Active XML. http://activexml.net/.
[3] Business Process Execution Language for Web Services.
http://www.ibm.com/developerworks/library/ws-bpel/.

[4] B. Courcelle. The monadic second-order logic of graphs. Inf.

Comput., 85(1), 1990.

[5] R. Dechter and J. Pearl. Generalized best-ﬁrst search strategies

and the optimality of A*. JACM, 32(3), 1985.

[6] D. Deutch and T. Milo. Type inference and type checking for

queries on execution traces. In Proc. of VLDB, 2008.

[7] D. Deutch and T. Milo. Evaluating top-k queries over business

processes (short paper). In Proc. of ICDE, 2009.

[8] D. Deutch and T. Milo. Top-k projection queries for

probabilistic business processes. In Proc. of ICDT, 2009.

[9] A. Deutsch, L. Sui, V. Vianu, and D. Zhou. Veriﬁcation of
communicating data-driven web services. In PODS, 2006.

[10] K. Etessami and M. Yannakakis. Algorithmic veriﬁcation of

recursive probabilistic state machines. In TACAS, 2005.
[11] R. Fagin, A. Lotem, and M. Naor. Optimal aggregation

algorithms for middleware. JCSS, 66(4), 2003.

[12] I. F. Ilyas, G. Beskales, and M. A. Soliman. A survey of top-k

query processing techniques in relational database systems.
ACM Comput. Surv., 40(4), 2008.

[13] T. Jones. Estimating Software Costs. McGraw-Hill, 2007.
[14] J. Kemeny and J. Snell. Finite Markov Chains. Springer, 1976.
[15] B. Kimelfeld and Y. Sagiv. Matching twigs in probabilistic xml.

In Proc. of VLDB, 2007.

[16] N. Koudas and D. Srivastava. Data stream query processing: A

tutorial. In Proc. of VLDB, 2003.

[17] P. L. T. Pirolli and J. E. Pitkow. Distributions of surfers’ paths

through the world wide web: Empirical characterizations.
World Wide Web, 2(1-2), 1999.

[18] P. Sen and A. Deshpande. Representing and querying

correlated tuples in probabilistic databases. In ICDE, 2007.

[19] A. Simitsis, K. Wilkinson, M. Castellanos, and U. Dayal.
Qox-driven etl design: reducing the cost of etl consulting
engagements. In SIGMOD ’09, 2009.

[20] Yahoo! shopping. http://shopping.yahoo.com/.

947APPENDIX

A. ADDITIONAL PROOFS

Proof. (Lemma 3.3)

1. Let e be a top-1 ﬂow rooted at n ∈ eq. If e contains no
other node n(cid:48) ∈ eq, we are done. Otherwise, consider
the sub-ﬂow e(cid:48) of e that is the implementation of n(cid:48) (i.e.
e(cid:48) appears in between the activation and completion
nodes of n(cid:48)). Since n(cid:48) and n are equivalent, we may e(cid:48) is
also an implementation of n. Furthermore, the weights
appearing along e(cid:48) stay the same when e(cid:48) is rooted at
n(cid:48) intact (again, due to the equivalence of n and n(cid:48)).
Now, e(cid:48) is a sub-ﬂow of e, and thus f W eight(e(cid:48)) ≥
f W eight(e) due to monotonicity. Thus, e(cid:48) is also a top-
1 ﬂow rooted at e. If there are additional nodes n(cid:48)(cid:48) ∈ eq
still appearing in e(cid:48), we may repeat this process to omit
them.

2. As for part (2) of the theorem, assume by induction
that it holds for the i’th ranked ﬂow rooted at n, for
every i < j (part (1) is the base case for this induction).
Speciﬁcally it means that there exists some set of top-
(j-1) ﬂows rooted at n for which no node n(cid:48) ∈ eq in
it is the root of a sub-ﬂow that its j − 1-ranked ﬂow.
Now, if e is a j’th ranked ﬂow originating at n bearing
a node n(cid:48) ∈ eq in it, such that the sub-ﬂow rooted at
n(cid:48) is not one of its top j −1 ﬂows, we may replace the
sub-ﬂow rooted at n(cid:48) by by its j−1 ranked ﬂow, without
decreasing weight of e.

Proof. (Theorem 3.5)
The number of entries in F T able is k∗ | equiv |. Now,
for each ﬂow node v considered during the course of the
algorithm execution, either it already appears in F T able, or
it does’nt. The case where the sub-ﬂow requested for v does
not appear in the table may only happen k∗ | equiv | times,
while computing the top-k ﬂows rooted at v.
the cost of
computation for such cases is O(| equiv |) for searching the
table, (assuming that we have an index that allows, in O(1)
time, to get the last (worst ranked) entry for a given row;
otherwise there may be an additional factor of k) and then
O(1) of further computation - considering direct expansions
of v, a total of O(k∗ | equiv |2).

If the sub-ﬂow considered for v does already appear in
F T able, we only need to point the implementation of v to
the sub-ﬂow that were already computed (O(1)). We next
consider the number of times that this scenario may occur.
We start by considering the computation of top-1 ﬂows.
Now, consider some equivalence class e. Say that we’ve en-
countered some node n ∈ e, and then, before we are done
computing the top-1 ﬂow rooted at n, we have encountered,
at another point of the search tree, another node n(cid:48) ∈ e .
The course of the algorithm execution follows Observation 2
of Section 4: it suspends the computation for the top-1 ﬂow
of n(cid:48), until computation of the top-1 ﬂow of n is done (by
putting n(cid:48) “on hold”, line 14 of Algorithm HandlePartial.
The number of such suspensions, while computing the top-
1 ﬂow of n, is bounded by the size of the speciﬁcation s,
for each such n ∈ e and for each e. The number of such
equivalence classes is | equiv |. The same argument holds
for computation of the i’th highest weighted ﬂow, for each

i = 1, ...k, leading to a total bounded by | s |2 ∗ | equiv | ∗k
for this case. The total complexity is thus polynomial in
| equiv |, k, and | s |.

Undecidability. We may show that TOP-K-FLOWS is unde-
cidable in general (if |equiv| may be inﬁnite), as stated in
the text following Thm. 3.5.

Proof. The proof is by a reduction from the halting prob-
lem. Given a Turing Machine M, the idea is to “encode” M
using the BP speciﬁcation. The states of M are represented
by activity names; implementations model the transitions
between states, as well as changes to the tape and to the
head location; and the history of ﬂow is utilized to allow
“read” operations from the tape.

More formally, given a Turing Machine with a set of states
Q, an initial state q0 ∈ Q, an accepting state qF ∈ Q, a tape
alphabet Γ and a transition function delta, we generate a
BP speciﬁcation whose set of compound activity names is
Q, and additionally it contains an atomic activity a .The im-
plementation set of each compound activity corresponding
to a state s, contains a single-node implementation for each
activity name s(cid:48) (possibly = s) such that there is a transition
from s to s(cid:48) according to δ. The cWeight of such transition
is intuitively 1 if the transition is legitimate, according to δ
and to the current symbol under the head, and 0 otherwise.
As cW eight function is unbounded-history, it is allowed to
determine its value according to the entire preceding ﬂow:
this ﬂow determines uniquely the tape state and the head
location. For the accepting state, its single implementation
consist of the atomic activity a, with cW eight of 1. We use
multiplication for aggregation, and seek for full ﬂows with
cW eight higher than 0.

NP-hardness. We may further show that TOP-K-FLOWS is
NP-hard in the required memory size, may not be solved in
PTIME, as stated in the text following Thm. 3.5.

Proof. We use a reduction from Set Cover. For simplic-
ity, we consider here a monotonically increasing f W eight
function and bottom-k computation. (aggr is the + func-
tion, and W are positive numbers). But the proof works
symmetrically for monotonically decreasing f W eight and
top-k. (Simply take negative cW eights instead of the pos-
itive ones we use below). Given an instance of set cover,
namely a set X = {X1, ..., Xn} of items, a set of subsets
S = {S1, ..., Sm} and a bound B, we construct a BP as
follows:
its activity names are R (root), S1, ..., Sm (com-
pound) and a (atomic). Each Si (i = 1, ...m) bears 2 ∗ m+1
implementations: for each j = 1, ...m, Si has two implemen-
tations, each consisting of a single node whose activity is Sj:
the ﬁrst is guarded by a formula “$Si = chosen”, and the
second by “$Si = not chosen”; the last implementation of
Si, guarded by “$Si = done”, consists of a. The cW eight
of “$Si = chosen” and “$Si = not chosen” is 0, and that
of “$Si = done” depends on the last B choices:
it is 1 if
and only if the set of Si’s for which “$Si = chosen”, within
this set of B choices, covers X. Otherwise, its cW eight is 3.
We use addition for aggr. There exists a ﬂow of f W eight
smaller than 2 if and only if there exists a set cover of size
smaller than B.

948Proof of Theorem 4.1. We give here a full proof of Theo-
rem 4.1 (a sketch of which appears in the paper body).

In the following, we use we to denote the f W eight of a

Proof. (Theorem 4.1)
We start by showing an invariant satisﬁed by Algorithm

ﬂow e.

FindFlows.

Lemma 4.2. Given some input I, let eterm be the worst so-
lution that appears in Out upon termination. Whenever an
e (cid:54)= eterm is popped from F rontier (in Line 4 of Algorithm
refinedFindFlows), f W eight(e) > f W eight(eterm).

Proof. Denote f W eight(eterm) by wterm. Also, for a
ﬂow e (cid:54)= eterm, denote f W eight(e) by we. By the deﬁni-
tion of strong monotonicity, there exists a unique ﬂow eterm
with weight wterm. If this ﬂow eterm already appear in the
frontier when e is popped from it, then clearly we > wterm.
If it does not appear yet in F rontier, then F rontier must
contain at least some “preﬁx” e(cid:48) of eterm, (i.e. some ﬂow e(cid:48)
s.t. e(cid:48) →∗ eterm). Here too we > we(cid:48) , since e was popped
out and not e(cid:48), and by the strong monotonicity, we also have
we(cid:48) > wterm. Thus, we > we(cid:48) > wterm.

We next use the lemma to prove Theorem 4.1 assume that
there is a sample instance I and an algorithm A such that
cost(A, I) is less , i.e. A calls AllExps a smaller number
of times. Since A and our algorithm produce the correct
solution on input I, it must hold that they output the same
weight for the last (worst weighted) result in Out.

It is easy to show that for each equivalence class E, Algo-
rithm FindFlows calls AllExps at most once for any node
v ∈ E. As assumed, Algorithm A invokes AllExps less.
Thus, there exists at least one equivalence class E such that
Algorithm FindFlows expanded some node v ∈ E, but Algo-
rithm A did not expand v or any node equivalent to it. Say
that v ∈ e, where e is some speciﬁc ﬂow. As e was consid-
ered by Algorithm FindFlows, Lemma 4.2 guarantees that
we > wterm. Thus, there exists at least one partial ﬂow f
for which expansion of some of its nodes were considered by
Algorithm FindFlows and were not considered by Algorithm
A. Deﬁne w∗ such that aggr(we, w∗) > wterm.

As aggr is continuous, and we > wterm, there exists such
w∗. We construct another input instance I (cid:48) as follows. The
AllExps function is the same for all the nodes expanded
by A, as well as the cW eight function and the aggregation
function.

For a node v, the AllExps function returns a single imple-
mentation e(cid:48) consisting of a single atomic activity, and the
corresponding cW eight is w∗. As for the subsequent m com-
pound activities in e if exists, we design w1, ..., wm such that
given e as history, aggr(we, w∗, w1, ...wm) > wterm. Now
the corresponding ﬂow has a weight higher than wterm and
should have been added to Out. But Algorithm A did not,
and thus commits a mistake. This contradicts our assump-
tion that A is a correct algorithm, and thus it must hold that
Algorithm FindFlows is optimal for input I. Given that I
is an arbitrary input, it follows that Algorithm FindFlows
is optimal.

Proof. (Theorem 4.4)
The proof works by contradiction. Let c be the bound on
the number of consecutive expansions of any ﬂow e that

lead to a ﬂow e(cid:48) with f W eight(e) = f W eight(e(cid:48)). As-
sume that A is better than Algorithm FindFlows by a fac-
tor greater than c. Let wterm be as deﬁned in the proof
of Theorem 4.1 above. Note that for every ﬂow e consid-
ered by FindFlows, f W eight(e) ≥ wterm. There are at
most c ﬂows e such that f W eight(e) = wterm. Other than
these c ﬂows, for all other ﬂows e(cid:48) considered by FindFlows,
f W eight(e(cid:48)) > wterm. Consequently, there exists at least
one ﬂow e that was inserted by FindFlows to frontier, such
that f W eight(e) > wterm, and f was not considered by A.
The proof then proceeds similarly to the proof of Theorem
4.1 above.

Proof. (Theorem 4.5) By contradiction, let us assume
the existence of some optimal algorithm A. Given a number
n, we construct a BP speciﬁcation s as follows: its activities
are A1, ..., An (compound) and a (atomic). A1 is the root
activity.

Again, we construct the BP gradually, each time obtain-
ing an intermediate BP, executing A on it, and changing
the BP according to the prior execution of A. A1 has two
possible expansions, one containing only A2 and the second
containing only A3. We continue to construct the speciﬁca-
tion according to the behavior of A. If A chooses to expand
A2 (resp. A3), then A3 (resp. A2) will have as implemen-
tation the single activity A4. A3 (A2) and A4 have a single
implementation, consisting of A5; for i = 5, ..., n Ai a sin-
gle implementation, consisting of Ai+1, and An has a single
implementation consisting only of a.

We use multiplication for aggr, and a cW eight function
that assigns 1 to every guarding formula, apart from that
guarding the implementation of A4, which is weighted 0.5.
The induced f W eight is semi-strongly monotone. When
executed over s, A expands n − 1 nodes (it expands 3 nodes
out of the ﬁrst 4: A1, either A2 or A3, and A4, then the
rest n − 4 nodes).
In contrast, a diﬀerent algorithm that
chooses a diﬀerent order of expansion for this instance, will
only expand here n − 2 nodes (not going through A4) while
still being always correct.
Proof. (Theorem 4.6)
Given an algorithm A, we construct a BP s as follows: its
activities are r (root), A1, ..., An (compound) and a (atomic).
We use multiplication for aggr, and a cW eight function that
assigns 1 to every guarding formula. Clearly, aggr is weakly
monotone. We construct the BP gradually, each time ob-
taining an intermediate BP, executing A on it, and changing
the BP according to the prior execution of A.

The root activity r has two implementations, the ﬁrst con-
sisting of only A1 and the second of only A2. At ﬁrst, we
set the implementations of both A1 and A2 to be a, and
execute A on this (partial) BP. We then examine which ac-
tivity was expanded ﬁrst by A - A1 or A2. Since A ∈ A,
this choice does not depend on the implementations of A1
and A2. Thus, we change s as follows: if A chose to expand
A1 ﬁrst, we set the two implementations of A1 to consist of
A3 and A4 respectively, while the implementation of A2 still
consists of a. Next, A has three choices for the next expan-
sion: A2, A3, and A4. For the chosen activity, we set its two
implementations to consist of A5 and A6 respectively, while
these of A2 and A3 consist of a. We repeat this process until
obtaining a BP with n compound activities, then allow the
implementation of An to consist of a as well. We denote the
obtained BP by s.

Clearly, when A is executed over s, it expands n nodes,

949because each activity Ai that it chose, such that i < n,
only led to implementations containing further compound
activities. In contrast, we claim that there exists an opti-
mal algorithm A(cid:48) that, when executed over s, expands only
log(n) activities.

To observe that this is true, we show two lemmas, as fol-

lows:

Lemma A.1. There exists a ﬂow eshort in f lows(s) (with
f W eight = 1, same as the f W eight of any ﬂow of f lows(s)),
that is obtained by log(n) expansions.

Proof. Assume by contradiction that every ﬂow in f lows(s)

consists of more than log(n) expansions of activities. Since
every compound activity in s has two implementations, each
containing a distinct activity name, we obtain that there are
over 2log(n) = n distinct activities in s, in contradiction to
the way s was constructed.

C. CONSTRAINTS OVER THE
AGGREGATION FUNCTION

We provide the exact deﬁnition of the constraints imposed
over the aggregation function aggr, described intuitively in
section 2.

1. aggr is associative and commutative, namely for each
x, y, z ∈ W, aggr(aggr(x, y), z) = aggr(x, aggr(y, z)),
and aggr(x, y) = aggr(y, x)

2. aggr is continuous, that is for each x, y, z ∈ W,

if
aggr(x, y) < aggr(x, z) then there exists w ∈ W such
that aggr(x, y) < aggr(x, w) < aggr(x, z)

3. aggr has a neutral value, denoted 1aggr. Namely for

each x ∈ W, aggr(x, 1aggr) = aggr(1aggr, x) = x

4. aggr is monotonically increasing or decreasing over W.
Namely, either ∀s, x, y ∈ W x ≥ y =⇒ aggr(s, x) ≥
aggr(s, y) and aggr(s, x) ≥ s, or the same for ≤.

D. QUERIES

Lemma A.2. There exists a correct algorithm A(cid:48) that, when

executed on s ﬁnds eshort as the top-1 ﬂow, while expanding
exactly the activity nodes appearing in eshort.

We quote here the formal deﬁnitions for queries and their
matches. These deﬁnitions appear also in [6]. We then con-
sider top-k query evaluation.

Proof. First, note that all cW eight values within s are
identical; thus, for every order of expansion over the activi-
ties of s (that comply with the speciﬁcation), there exists a
correct algorithm A(cid:48) (that is, A(cid:48) is correct for every input)
that, when executed over s, follows this expansion order.
Speciﬁcally, there is a correct algorithm that expands ex-
actly the activities participating in eshort.

As a corollary of these two lemmas, when evaluated over s,
A(cid:48) expands at most log(n) nodes, while A expands n nodes.
A(cid:48) is thus better by a factor of
log(n) . n may be chosen as
we wish, and given a constant c we may choose n such that
log(n) > c + c(cid:48). Thus A(cid:48) is better than A by a non-constant
factor, and A is not instance optimal.

n

n

This concludes the proof of Theorem 4.6.

B. MULTIPLE EXPANSION SEQUENCES
We have assumed above (see the text following Example
2.4), for simplicity of presentation, the existence of a total
order over the expansion of activities. We next withdraw
this assumption, and explain the needed adjustments to our
deﬁnitions and algorithms.

• The cW eight function, previously deﬁned as cW eight(e, f )

for an EX-ﬂow e and a formula f should now be deﬁned
as cW eight(e, n, f ) with n being a node of e and f be-
ing a guarding formula of an implementation of λ(n).
cW eight(e, n, f ) is the weight of f , given that n was
chosen for expansion in e

• f W eight is now deﬁned as f W eight(e) =

maxe(cid:48)|e(cid:48)→e aggr(f W eight(e(cid:48)), cW eight(e(cid:48), n(cid:48), f )) where
n(cid:48) is the node of e(cid:48) expanded to form e and f is the
guarding formula on the corresponding expansion of n(cid:48)

• Given a partial ﬂow e, Algorithm TOP-K now examines
the expansions of each node of e, rather than just those
of a single node that is next-to-be-expanded in e.

Definition D.1. We say that a DAG e is an abstract
ﬂow if there exists some BP s(cid:48) s.t. e ∈ f lows(s(cid:48)). An exe-
cution pattern, abbr. EX-pattern, is a pair p = (ˆe, T ) where
ˆe is an abstract EX-ﬂow whose nodes are labeled by labels
from A ∪ {any} and may be annotated by guarding formu-
las. T is a distinguished set of activity pairs and edges in ˆe,
called transitive.

Example D.2. An example query (EX-pattern) is given
in Fig. 3. The double-lined edges (double-boxed nodes) are
transitive edges (activities). The query looks for EX-ﬂows
where the user chooses a DVD of brand Toshiba (possibly
after performing some other activities, corresponding to the
transitive edges), then chooses also a TV (of any brand).
The ShoppingMall activity is transitive indicating that its
implementation may appear in any nesting depth; chooseProduct
is not transitive, requiring the brand choice to appear in its
direct implementation.

Given a BP speciﬁcation s, a query (EX-pattern) p selects
the EX-ﬂows e ∈ f lows(s) that contain an occurrence of p.
Intuitively, nodes and edges of the EX-pattern are matched
to nodes and edges of EX-ﬂows, respecting activity names,
ordering and implementation edges. Formally,

Definition D.3. Let p = (ˆe, T ) be an execution pattern
and let e be an EX-ﬂow. An embedding of p into e is a
homomorphism ψ from the nodes and edges in p to nodes,
edges and paths in e s.t.

1. [nodes] activity pairs in p are mapped to activity pairs
in e. Node labels and formulas are preserved; a node la-
belled by any may be mapped to a node with any activity
name.

2. [edges] each (transitive) edge from node m to node n
in p is mapped to an edge (path) from ψ(m) to ψ(n) in
e. If the edge [n, m] belongs to a direct internal ﬂow of
a transitive activity, the edge (edges on the path) from
ψ(m) to ψ(n) can be of any type (ﬂow, or zoom-in) and
otherwise must have the same type as [n, m].

Our results all extend to the settings of multiple expansion
sequences.

An EX-ﬂow e belongs to the query result if there exists
some embedding of p into e. We then say that e satisﬁes p

950correspond exactly to a satisfying assignment - For every
variable whose corresponding compound activity has as im-
plementation the ’false’ (’true’) graph, assign ’false’ (’true’).
This is indeed an assignment, as every compound activity
can only have exactly one of the ’true’ or ’false’ graphs as
an implementation in e, and it is satisfying as every clause
node appears in e. The truth value assigned to the variable
corresponding to this compound activity thus satisﬁes this
clause.

Conversely, let A be a satisfying assignment. The EX-ﬂow
obtained by choosing as implementation for each compound
activity, its “true” graph if A assigns “true” to the corre-
sponding variable, and its “false” graph if A assigns “false”
to it. This is indeed an EX-ﬂow in f lows(s), since A is an
assignment. This EX-ﬂow satisﬁes q as every node clause
appears at least once. This is due to the fact that the as-
signment A is satisfying, thus for each clause, there is at
least one variable whose truth value causes the clause to be
true.

E. EXAMPLE FOR EXPTIME BEHAVIOR

OF THE A∗-LIKE ALGORITHM

We have suggested in Section 3 an algorithm based on the
idea of A∗ and noted that it has two pitfalls: the ﬁrst is non-
termination for recursive BPs, and the second is possibly
EXPTIME behavior, even for non-recursive BPs. Example
3.1 shows the ﬁrst pitfall (non-termination), and we next
provide an example for the second pitfall (EXPTIME for
non-recursive BP speciﬁcations).

Example E.1. Let n be an integer, and consider the fol-
lowing BP speciﬁcation, whose activity names are r (root),
A1, ...An (compound), a and b (atomic). We will use integer
weights addition for aggregating these weights. The root ac-
tivity bears two possible implementations: the ﬁrst (named
S1, guarded by a formula F 1) has a single activity node la-
beled a, and the second (named S2 guarded by a formula F 2)
has two activities, both labeled by A1; A1 bears an single im-
plementation, with two activities both labeled by A2, and so
on. I.e., Ai bears an single implementation, with two activ-
ities both labeled by Ai+1 for i = 1, ..., i = n − 1. The single
implementation of An bears a single atomic activity node a.
All cW eight values are dictated by the choice of implemen-
tation and independent of the preceding ﬂow. The cW eight
value of F 1 is n − 2, while the cW eight values of all other
formulas are 1.

When looking for the top-1 EX-ﬂow, the A∗-like algorithm
would generate the EX-ﬂows of size Θ(2n) obtained from
subsequent implementation choices of the implementations
containing Ai, before identifying that the top-1 ﬂow is in
fact obtained by choosing the S2 implementation of the root.
In contrast, our TOP-K Algorithm, presented in Section 3,
will compute the top sub-ﬂow rooted at each activity only
once (through its use of F T able, see algorithm description),
avoiding the exponential blow-up.

Figure 3:

Example query (EX-pattern)

D.1 Query Evaluation

We name TOP-K-ANSWERS as the problem of ﬁnding, given
a BP speciﬁcation s, weight function over its ﬂows, an EX-
pattern p, and a number k, the top-k ﬂows of s satisfying p.
The following theorem holds:

Theorem D.4. TOP-K-ANSWERS may be solved in time poly-

nomial in |s|,k, and |equiv| (with the exponent depending on
|p|) and linear in the output size.

Proof. We combine two algorithms, as follows:

1. The ﬁrst algorithm is the query evaluation algorithm of
[6] that, given a BP speciﬁcation s and an EX-pattern
p, constructs a BP speciﬁcation s(cid:48), including only those
EX-ﬂows of s that matches p. Intuitively, s(cid:48) is the “in-
tersection” of s with p, obtained by considering all pos-
sible splits of the query into sub-queries, then matching
these sub-queries to the DAGs in s.

2. The second algorithm is our TOP-K algorithm, that re-

trieves the top-k EX-ﬂows of the constructed s(cid:48).

The complexity of the ﬁrst algorithm is |s||p| [6], and so
is the maximal size of the resulting BP s(cid:48). The second step,
as shown above, is then polynomial in the size of its input
s(cid:48), and in k and |equiv|, and is linear in the output size.

To show that this exponential dependency on the size
of the query is inevitable, we deﬁne the decision problem
BEST-ANSWER, which tests, given a weighted BP speciﬁca-
tion s, a query q, some k > 0, and a threshold t, whether
the top-1 ﬂow in TOP-K-ANSWERS is of weight higher than t.
The following theorem holds.

Theorem D.5. BEST-ANSWER is NP-hard in |q|.

Proof. We prove the NP-hardness using a reduction from

3SAT, as follows.

Given a Conjunctive Normal Form formula F , with vari-
ables {X1, ...Xn} we generate a speciﬁcation and a query
(s, q), as follows: the idea is to create a compound activity
associated with each variable of the formula. This activity
has two diﬀerent implementations: for all i, the implemen-
tations of Xi are BPiT rue and BPiF alse. The former con-
tains all clauses that Xi satisﬁes, and the latter contains all
clauses that ¬Xi satisﬁes. The query requires all clauses of
the formula F to appear.

To formally prove that the reduction is valid, we give the

following lemma.

Lemma D.6. There exists an EX-ﬂow in f lows(s) satis-
fying the query q if and only if the formula F is satisﬁable.

Proof. Let e be an EX-ﬂow in f lows(s) satisfying q. e
was obtained by choosing a subset of compound activities
for which BPiT rue is chosen as implementation, and an-
other subset for which BPiF alse was chosen. These choices

951