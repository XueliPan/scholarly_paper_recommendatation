TOP-K Projection Queries for Probabilistic Business

Processes

Daniel Deutch

Tova Milo

{danielde,milo}@cs.tau.ac.il

ABSTRACT
A Business Process (BP) consists of some business activities
undertaken by one or more organizations in pursuit of some
business goal. Tools for querying and analyzing BP speciﬁ-
cations are extremely valuable for companies. In particular,
given a BP speciﬁcation, identifying the top-k ﬂows that are
most likely to occur in practice, out of those satisfying a
given query criteria, is crucial for various applications such
as personalized advertizement and BP web-site design.

This paper studies, for the ﬁrst time, top-k query evalua-
tion for queries with projection in this context. We analyze
the complexity of the problem for diﬀerent classes of distri-
bution functions for the ﬂows likelihood, and provide eﬃ-
cient (PTIME) algorithms whenever possible. Furthermore,
we show an interesting application of our algorithms to the
analysis of BP execution traces (logs), for recovering missing
information about the run-time process behavior, that has
not been recorded in the logs.

INTRODUCTION

1.
A Business Process (BP for short) is a collection of logically
related activities that, when combined in a ﬂow, achieve
a business goal. To simplify software development, it is a
common practice to provide a high level description of the
BP operational ﬂow (using a standard speciﬁcation language
such as BPEL [5]), and then have the software be automati-
cally generated from this speciﬁcation. Since the BP logic is
captured by the speciﬁcation, tools for querying and analyz-
ing BP speciﬁcations are extremely valuable for companies
[2]. They allow to optimize the BP, identify potential prob-
lems, and reduce operational costs.

A typical query engine is given as input a BP speciﬁcation
and an execution pattern of interest, and identiﬁes, among
the potential execution ﬂows of the BP, all those (sub)ﬂows
having the structure speciﬁed by the pattern ([2, 3, 13]).
Note, however, that among all possible ﬂows, some are typ-
ically more interesting than others. In particular, given a

Permission to copy without fee all or part of this material is granted pro-
vided that the copies are not made or distributed for direct commercial ad-
vantage, the ACM copyright notice and the title of the publication and its
date appear, and notice is given that copying is by permission of the ACM.
To copy otherwise, or to republish, to post on servers or to redistribute to
lists, requires a fee and/or special permissions from the publisher, ACM.
ICDT 2009, March 23–25, 2009, Saint Petersburg, Russia.
Copyright 2009 ACM 978-1-60558-423-2/09/0003 ...$5.00

BP speciﬁcation, identifying the top-k query answers (ﬂows)
that are most likely to occur in practice, is crucial for var-
ious applications.
It can be used, for instance, to adjust
the BP web-site design to the needs of certain user groups,
or to personalize on-line advertisements. The importance of
top-k query evaluation is enhanced by the fact that the num-
ber of answers (qualifying sub-ﬂows) to a simple query may
be extensively large, or even inﬁnite when the BP contains
recursion [2].

As a simple example, consider a BP of an on-line, Web-based
travel agency. An analyzer that wishes to examine the BP
execution ﬂows may issue queries such as “In what ways may
one reserve a travel package containing a ﬂight and an ho-
tel?”, or “How is this done for travellers of a particular airline
company, say British Airways?”. There may be many ways
to book such travel packages. But assume, for instance,
that we obtain that a popular scenario for British Airways
reservations is one where users ﬁrst search for a package con-
taining both ﬂights and hotels, but eventually book a British
Airways ﬂight without reserving an hotel. Such a result may
imply that the combined deals suggested for British Airways
ﬂiers are unappealing, (as users are speciﬁcally interested in
such deals, but refuse those presented to them), and can be
used to improve the Web site.

In a previous paper [14] we have suggested a model for rank-
ing of BP execution ﬂows based on their likelihood of occur-
rence, and presented an eﬃcient top-k query evaluation al-
gorithm for selection queries. Namely, queries that given an
execution pattern and a BP speciﬁcation, retrieve the top-
k full (start-to-end) possible execution ﬂows which contain
some occurrence of the pattern. In many cases, however, the
user may not be interested in the whole ﬂow (which may be
long and complex) but only in speciﬁc parts which are rel-
evant to her analysis (e.g. only the sub-ﬂow dealing with
hotel reservation, or only the activities issued when a pay-
ment request is rejected). To address this need we consider
in this paper projection queries, which retrieve the sub-ﬂows
of interest, out of the full qualifying ﬂows, and provide an
eﬃcient algorithm for top-k evaluation of such queries.

An important question that rises when considering projec-
tion queries is the choice of a ranking metric for the query
results. Utilizing the notion of ﬂow likelihood, we deﬁne
rank for projection results, as the maximal likelihood of a
ﬂow containing the projection as a sub-ﬂow. (Other pos-
sible rankings are considered in future work). We will see

239

that although there is a tight relationship between the se-
mantics of selection and projection queries (both searching
for ﬂows with maximal likelihoods), new techniques need to
be developed to provide eﬃcient (PTIME) query evaluation
for projection queries. Indeed, we show that the standard,
common, use of selection as an intermediate input for projec-
tion yields in this case an exponential blow-up. Instead, our
novel query evaluation algorithm constructs a direct, com-
pact representation of the top-k projections, avoiding mate-
rialization of the intermediate (full) qualifying ﬂows. This
algorithm is the ﬁrst contribution of the paper.

Interestingly, while our work was originally targeted to static
analysis of BP speciﬁcation, it turns out that our choice
of ranking metrics, and the corresponding query evaluation
technique, are also valuable for the analysis of run-time pro-
cesses. An instance of a BP speciﬁcation is an actual run-
ning process that follows the logic described in the speci-
ﬁcation. BP Management Systems allow to trace instance
executions and record the invoked activities. The execu-
tion traces recorded are typically selective and contain only
partial information on the activities that were performed at
run-time [6]. This may be due to performance concerns,
lack of storage space, conﬁdentiality, etc. However, given
such a partial log, users often wish to nevertheless under-
stand what had actually happened at run-time.
In other
words, they would like to identify the execution ﬂows that
are most likely to have been the origin of this log, typically
focusing of speciﬁc parts of the log that are of particular
interest [17, 4].
Intuitively, the recorded sub-ﬂow may be
viewed as a query, with the query result being the set of (rel-
evant parts of) ﬂows that are most likely to have occurred in
practice. We show that our query evaluation algorithms can
be adapted to retrieve the most likely origins of the given
(sub)trace. We ﬁrst consider the case where the names of
the BP activities that are masked/omitted from the trace
are known in advance, then the more diﬃcult case where
this information is not given. A challenge here is to avoid
considering all possible sets of potential omitted/masked op-
eration names (whose number is exponential in the size of
the BP). To overcome this we prove a small world theorem,
showing that only a polynomial number of representative
options need to be tested. This algorithm for computing the
top-k possible trace origins is the second contribution of the
paper.

The model that we use here for modeling BP speciﬁcations
and ﬂows likelihood is borrowed from [14] and is natural
abstraction of the BPEL standard (Business Process Exe-
cution Language [5]) for BP speciﬁcations. A BP is mod-
eled as a nested DAG consisting of activities (nodes), and
links (edges) between them, that detail the execution or-
der of the activities. The DAG shape allows to describe
parallel computations. Activities may be either atomic, or
compound. In the latter case their possible internal struc-
ture (called implementations) are also detailed as DAGs,
leading to the nested structure. A compound activity may
have diﬀerent possible implementations, corresponding to
diﬀerent user choices, variable values, servers availability,
etc. These are captured by logical formulas (over the user
choices, variable values, etc.) that guard each of the possi-
ble implementations. In practice, some user choices/variable
assignments/server states (and consequently truth values of

guarding formulas/implementation choices) are more likely
than others. This is captured by a c−likelihood (for choice
likelihood) function that describes the probability of each
implementation choice. This c−likelihood function is then
used to deﬁne a second likelihood function, this time over
possible execution ﬂows, denoted f−likelihood (ﬂow likeli-
hood). To simplify the presentation we ﬁrst assume inde-
pendence between implementation choices and present our
algorithms in this setting. Then we withdraw this assump-
tion and study the implications. In particular we show that
computation is still possible (although becomes EXPTIME)
if only a bounded level of dependency (to be deﬁned formally
in the paper) is allowed. This top-k query evaluation in the
presence of (bounded) dependencies is the third contribution
of this paper.

Paper organization. In Section 2 we formally deﬁne our
model and query language and the notion of (top-k) pro-
jection queries. In Section 3 we present our algorithm for
computing top-k query answers, assuming c−likelihood in-
dependence. Applications of our technique in the setting of
partial execution traces is considered in Section 4, and de-
pendencies between c−likelihood values are introduced in
Section 5. Section 6 provides an overview of related work.
We conclude in Section 7.

2. PRELIMINARIES
We start by presenting the formal deﬁnitions for our model
and query langauge.

BP speciﬁcation. As a running example, we consider a
web-based travel agency. The user, searching for a trip,
may choose between searching only for ﬂights and searching
for combined deals of ﬂights & hotels or ﬂights & hotels &
cars. Advertisements are injected in parallel to the search.
After viewing the search results, the user may select her
reservations. Then, she can either conﬁrm her selection,
reset and re-start the search, or cancel and leave the web-
site without ﬁnalizing any reservation.

The business logic of the travel agency BP is described
schematically in Figure 1. BP speciﬁcations are modeled
as nested Directed Acyclic Graphs (DAG). These are sets
of node-labeled DAGs, each intuitively corresponding to a
speciﬁc function or service. The graphs consist of activities
and the ﬂow thereof. Each activity is represented by a pair
of nodes, the ﬁrst (having darker background) standing as
the activity’s activation point and the second as its com-
pletion point. These notions of activation and completion
points will be utilized when considering execution ﬂows of a
BP. Edges represent execution ﬂow relations; multiple edges
going out of a single node stand for parallelism (hence the
DAG structure).

Activities may either be atomic (like the Login activity)
or compound (like chooseT ravel and F lights), in the latter
case their possible internal ﬂows (called implementation) are
also detailed (depicted as bubbles). A compound activity
may have diﬀerent possible implementations, corresponding
to diﬀerent user choices, variable values, etc. These are cap-
tured by logical formulas (over the user choices, variable
values, etc.) “guarding” each possible implementation. The
chooseT ravel activity has three possible implementations

240

Definition 2.2. A BP speciﬁcation s is a triple (S, s0, τ ),
where S is a ﬁnite set of act-comp DAGs, s0 ∈ S is a distin-
guished DAG consisting of a single activity pair, called the
root, τ : Acompound → 2F ×S is the implementation func-
tion, mapping each compound activity name in S to a set
of pairs, each containing a logical formula in F, called a
guarding formula, and an act-comp DAG from S.

At run-time, exactly one implementation is chosen for each
occurrence of a compound activity. Its corresponding guard-
ing formula is said to be satisﬁed, and we assume that no two
guarding formulas (guarding implementations) of the same
activity, may be satisﬁed concurrently.

For example, for the BP depicted in Figure 1, the set s of
act-comp DAGs consists of {F 1, F 2, F 3, F 4}, s0 = F 1 is
the speciﬁcation root, and the implementation function τ is
depicted by the “bubbles”, annotated by guarding formulas.

Execution Flows. An execution ﬂow is an actual running
instance of a Business Process. It may be abstractly viewed
as a nested DAG, containing node-pairs that represent the
activation and completion of activities, and edges that repre-
sent ﬂow and zoom-in (implementation) relationships among
activities, along with a record of guarding formulas corre-
sponding to chosen implementations of compound activity
nodes.

Example 2.1. Fig. 2 depicts two example execution ﬂows
of the travel agency process. Focus for instance on Fig. 2(a)
in which the user chooses a “ﬂights only” search, followed
by a choice of British Airways ﬂight, and then conﬁrms
her choice. Flow edges are marked by regular arrows, while
zoom-in edges, connecting activation and completion nodes
of compound activities to the start and end (resp.) nodes of
the chosen implementation, are marked by dashed arrows.
Fig. 2 (b) depicts a diﬀerent possible ﬂow, in which the user
chooses a “ﬂights+hotels” search, reserving a “British Air-
ways” ﬂight and a “Marriott” hotel. The fi’s next to some
nodes are identiﬁers, considered below.

Next, we formally deﬁne the notion of execution ﬂows for a
given BP speciﬁcation.

Definition 2.3. Given a BP speciﬁcation s = (S, s0, τ ),

g is an execution ﬂow (EX-ﬂow) of s if:

• g consists only of the root activity pair s0 of s, or,

• if g(cid:48) is an execution ﬂow of s, and g is obtained from g(cid:48)
by attaching to an activity pair (n1, n2) of g(cid:48), labeled by
some compound activity name a, and having no zoom-
in edge attached to it, some implementation ga of the
activity a, through two new edges, called zoom-in edges
(n1, start(ga)) and (end(ga), n2), and annotating the
pair with the formula fa guarding ga. We call g an
expansion of g(cid:48), and denote g(cid:48) → g.

Figure 1: Business Process

F 2, F 3, F 4, and their guarding formulas test the value of
the $searchT ype variable. This value may either be ”ﬂights
only”, ”ﬂights+hotels”, or ”ﬂights+hotels+cars”, depending
on the user’s choice. At run-time, exactly one implemen-
tation will be chosen, determined by the truth value of the
guarding formulas (determined, in turn, by the user choice).
Focusing on the F 2 implementation, the F lights activity has
a set of possible implementations, corresponding to choice
of $airline (“BA” stands for British airways, “AF” for Air
France, “AL” for Aer Lingus). Last, the Conf irm activity
has, as one of its implementations, the option of reset, recur-
sively going back to F 1. Other options here are conﬁrmation
and cancelation.

To formally deﬁne BP speciﬁcations, we assume the exis-
tence of three domains, N of nodes, A of activity names,
and F of guarding formulas1 . We distinguish two dis-
joint subsets of A, A = Aatomic ∪ Acompound, representing
atomic and compound activities, resp. We also use two dis-
tinguished symbols act, com, denoting, resp., activity acti-
vation and completion. We ﬁrst deﬁne the auxiliary notion
of activation-completion labeled DAGs, then use it to deﬁne
BP speciﬁcations.

Definition 2.1. An activities DAG is a tuple (N, E, λ)
in which N ⊂ N is a ﬁnite set of nodes, E is a set of directed
edges with endpoints in N , λ : N → A is a labeling function
for the nodes, labeling each node by an activity name. The
graph is required to be acyclic. An activation-completion
(act-comp) DAG g is obtained from an activities DAG by
replacing each node n, labelled by some label a, by a pair of
nodes, n(cid:48), n(cid:48)(cid:48), labelled (resp.) by (a, act) and (a, com). All
incoming edges of n are directed to n(cid:48) and all of the outgoing
edges of n now outgo n(cid:48)(cid:48). A single edge connects n(cid:48) to n(cid:48)(cid:48).

We assume g has a single start node without incoming
edges, and a single end node without outgoing edges, denoted
by start(g) and end(g), resp.

Next, we deﬁne the notion of BP speciﬁcations.

1Formulas are deﬁned in a standard manner using predicates
(e.g. (in)equality,<,>) on variables values and connectors
(and, or,not).

g is called a full ﬂow if it cannot be further expanded (that is,
it contains the internal ﬂow for each compound activity node

241

P ($searchT ype)

$airline

P ($airline)

$searchT ype
”'ights only”

”'ights+hotels”

”'ights+hotels+cars”

$hotel

”Marriott”

”HolidayInn”

”CrownePlaza”

0.5
0.25
0.25

0.6
0.3
0.1

P ($hotel)

P ($choice)

”BA”
”AF”
”AL”

$choice
”reset”

”con↓rm”

0.7
0.2
0.1

0.6
0.4

Table 1: c−likelihood function

Example 2.2. Consider Table 1 that depicts the proba-
bility of value assignments for the diﬀerent variables of the
travel agency BP, and consequently the c−likelihood func-
tion for the corresponding guarding formulas. According
to this c−likelihood function, the f−likelihood of each EX-
ﬂow may be computed. For instance, the
f−likelihood of
the EX-ﬂow in Fig.2(a) is computed as the multiplication
of the c−likelihood values of $searchT ype = “ﬂights only”,
$Airline = “British Airways”, and $choice = “conﬁrm”, that
is 0.5 ∗ 0.7 ∗ 0.4 = 0.14. The f−likelihood of the EX-ﬂow in
Fig.2(b) is computed as the multiplication of $searchT ype =
“f lights + hotels”, $airline = “BritishAirways”, $hotel =
“M arriott”, and $choice = “conf irm”, i.e. 0.25 ∗ 0.7 ∗ 0.6 ∗
0.4 = 0.0672.

Queries. We distinguish between selection and projection
queries. The former seeks for full execution ﬂows that con-
tain some given execution pattern, while the latter focuses
only on sub-ﬂows that are of interest to the user. We start by
deﬁning the auxiliary notions of execution patterns and their
embeddings within execution ﬂows. Then, we utilize these
deﬁnitions to deﬁne the syntax and semantics of selection
and projection queries.

Execution patterns are adaptations of the tree- and graph-
patterns oﬀered by existing query languages for XML and
graph-shaped data, to nested EX-ﬂow DAGs. Namely, such
patterns are similar in structure to EX-ﬂows, but contain
transitive edges that may match any execution ﬂow path,
and transitive nodes, for searching within indirect implemen-
tations, at any level, of the corresponding composite node.
Nodes in the pattern may be labeled by the wildcard any,
that may match any EX-ﬂow node.

Definition 2.3. An execution pattern, abbr. EX-pattern,
is a pair p = (ˆe, T ) where ˆe is an EX-ﬂow whose nodes are
labeled by labels from A ∪ {any} and may be annotated by a
formula. T is a distinguished set of activity pairs and edges
in ˆe, called transitive activities and edges, resp.

Example 2.4. Figure 3(a) depicts a simple execution pat-
tern describing ﬂows that contain some “British Airways”
(Abbr. “BA”) ﬂight search that resulted in a conﬁrmation
(ignore for now the rectangle surrounding a sub-graph of the
pattern). The double-lined edges are transitive edges. The
doubly bounded chooseT ravel nodes are transitive nodes.
The qi labels next to some nodes are identiﬁers, and will
be utilized below.

Intuitively, the transitive edge connected to the chooseT ravel
may match any sequence of searches and resets, and the
transitive edge connecting the F lights and Conf irm activi-
ties may match any sequence of search activities (for hotels

Figure 2: Execution Flow

in it), and a partial ﬂow otherwise. The set of all full EX-
ﬂows deﬁned by a BP s is denoted f lows(S). For a graph
e, we say that e is an EX-ﬂow if a (partial or full) ﬂow of
some BP speciﬁcation S.

Likelihood. Some user choices / variable values are more
common than others, and thus execution ﬂows vary in their
likelihood of occurring in practice. We deﬁne two kinds of
likelihood functions. The ﬁrst, named c−likelihood (choice
likelihood) function, associates a value with each guarding
formula (implementation choice). This value stands for the
probability that the formula holds. For now we assume
independence between holding formulas / implementation
choices made. We withdraw this assumption later on.

Using the c−likelihood function we may deﬁne a second like-
lihood function, this time over the possible execution ﬂows,
namely f−likelihood : recall that each execution ﬂow corre-
sponds to a sequence of implementation choices made during
the execution; the joint likelihood of their guarding formulas
thus stands as the ﬂow likelihood. Formally,

Definition 2.4. Given a BP s rooted at s0 and a c−likelihood

function δ for its guarding formulas, the f−likelihood ∆ of
an EX-ﬂow e of s (w.r.t. δ) is deﬁned as follows:

1. If e is an EX-ﬂow consisting only of the root activity

s0, ∆(e) = 1.

2. Else, if e(cid:48) → e for some EX-ﬂow e(cid:48) of s, then ∆(e) =
∆(e(cid:48)) × δ(f ), where f is the formula guarding the im-
plementation that is added to e(cid:48) to form e.

Note that the c−likelihood function δ considered here im-
plies independency between choices; that is, the likelihood of
any formula to hold is constant, regardless of its context in
the ﬂow and truth values of other formulas / implementation
choices taken. In general, choices may be dependent: for in-
stance, the choice of hotel may be dependent on the choice of
airline that preceded it, etc. In Section 5 we discuss exten-
sions of our results to a more general context where choices
are dependent.

242

Definition 2.7

(Projection Queries). A projection
query q = (p, P ) consists of an execution pattern p accom-
panied by a sub-graph P of the pattern, itself forming an
execution pattern, called the projected part of the pattern.

• For an EX-ﬂow e and an embedding h of p in e, the re-
sult of q on e, w.r.t. h, is denoted q↓(e, h) and contains
all nodes and edges of e to which nodes and edges of
P are mapped by h. For each activity pair participat-
ing in the embedding, the edge connecting its activation
and completion nodes is also included.

• For an EX-ﬂow e, the result of q on e, denoted q↓(e),
consists of the results of all possible embeddings of q
into e, i.e. q↓(e) = S

h q↓(e, h).

• Finally, for a BP s, the result of q on s, denoted q↓(s)
is the set of all possible results of q when applied on
the EX-ﬂows of s. Namely q↓(s) = S
e∈f lows(s) q↓(e).

It is easy to prove that q↓(s) is a set of EX-ﬂows. Note that
an EX-ﬂow e(cid:48) ∈ q↓(s) may originate from several EX-ﬂows of
s, namely there may be several e ∈ f lows(s) s.t. e(cid:48) ∈ q↓(e).
The score of e(cid:48) is the maximum likelihood of these ﬂows,
namely score(e(cid:48)) = max{∆(e) | e ∈ f lows(s) ∧ e(cid:48) ∈ q↓(e)},
where ∆ is the f−likelihood function for s.

Definition 2.8. The top-k result of a projection query q
over a BP speciﬁcation s, denoted top − k(q↓, s), is a set of
EX-ﬂows in q↓(s) having highest score values.

Example 2.9. Re-considering the pattern of Fig. 3(a)
and the EX-ﬂow of Fig. 2(a), a possible embedding h maps
q1 to f1, q2 to f2, and q3 to f3. The activation and com-
pletion nodes of f1, f2, f3 thus participate in the projection
result, along with their connecting edges. The transitive edge
from q1 to q2 is mapped to the path from f1 to f2 contain-
ing the zoom-in edge, the Login activity and the edge from
Login to F lights. The transitive edge from q2 to q3 is then
mapped to the implementation of F lights, along with the
zoom-in edges, and the edge connecting to Hotels. The pro-
jection result is depicted in Fig. 3(b).

Embedding the pattern in the EX-ﬂow of Fig. 2(b) is simi-
larly done, and the projection result is given in Fig. 3(c).

Evaluating the projection query on the BP speciﬁcation of
Fig. 1, the top-1 projection is depicted in Fig. 3(b), with
the maximal likelihood leading to it being the ﬂow of Fig.
2(a), with likelihood of 0.14 (which is thus the projection
score).

Technical Remark. We have required in Deﬁnition 2.2 above
that no two guarding formulas of the same activity may be
satisﬁed concurrently. Consequently, the sum of likelihoods
of guarding formulas for each activity name was 1. While
this assumption complies with an intuitive concept of BP
speciﬁcation, they are not necessary for our results. Indeed,
we use below, as a tool, relaxed BPs without this require-
ment.

Figure 3: Query And Answer

and/or cars). The transitivity of the chooseT ravel node al-
lows this matching to include indirect implementation of the
corresponding composite node, at any nesting level.

We next formally deﬁne the notion of embeddings, which are
matchings of execution patterns to execution ﬂows.

Definition 2.5. Let p = (ˆe, T ) be an execution pattern
and let e be an EX-ﬂow. An embedding of p into e is a
homomorphism ψ from the nodes and edges in p to nodes,
edges and paths in e s.t.

1. [nodes] activity pairs in p are mapped to activity pairs
in e. Node labels and formulas are preserved; a node
labeled by any may be mapped to nodes with any activ-
ity name.

2. [edges] each (transitive) edge from node m to node n
in p is mapped to an edge (path) from ψ(m) to ψ(n) in
e. If the edge [n, m] belongs to a direct internal trace of
a transitive activity, the edge (edges on the path) from
ψ(m) to ψ(n) can be of any type (ﬂow, or zoom-in)
and otherwise must have the same type as [n, m].

We next deﬁne queries. We consider two types of queries.
A selection query simply consists of an EX-pattern. When
applied on a BP speciﬁcation it selects all EX-ﬂows in which
the pattern may be embedded. Projection queries, on the
other hand, allows to focus on some speciﬁed part of the
selected ﬂows. Formally,

Definition 2.6

(Selection Queries). Given an exe-
cution pattern p = (ˆe, T ) and a BP speciﬁcation s (along
with a c−likelihood function δ) we deﬁne the result of eval-
uating p over s, denoted by p(s), as the set of all execution
ﬂows e of s such that there exists an embedding of p within
e. top − k(q, s) is a set of k execution ﬂows of p(s) having
highest

f−likelihood values 2.

Projection queries consists of an execution pattern along
with a sub-graph annotated as output. Only nodes and
edges matching this part are projected out and appear in
the query result.

2Since distinct EX-ﬂows may have the same likelihood this
set may not be unique and we choose one arbitrarily

243

3. QUERY EVALUATION
We describe in this section our evaluation algorithm for top-
k projection queries. We ﬁrst recall the algorithm for eval-
uating top-k selection queries, given in [14]. We show that
direct adaptations of this algorithm to projection queries fail
at achieving PTIME query evaluation, and ﬁnally describe
an alternative algorithm that overcomes this.

3.1 Evaluating Selection Queries
A main tool in the eﬃcient evaluation of top-k (selection
and projection) queries over a given BP, is a compact rep-
resentation of (intermediate) evaluation results via another
BP speciﬁcation. Thus, we start by deﬁning when a BP
speciﬁcation s captures a set of EX-ﬂows along with their
likelihoods.

Definition 3.1. A BP s(cid:48) along with a c−likelihood func-
tion δ(cid:48) (corresponding
f−likelihood function ∆(cid:48)) captures
a (possibly inﬁnite) set of EX-ﬂows T , with respect to a
f−likelihood function ∆ over T if (1) f lows(s(cid:48)) is identical
3, up to some renaming function ρ to its activity names, to
T and (2) ∀e∈f lows(s(cid:48))∆(cid:48)(e) = ∆(ρ(e)).

Given a BP speciﬁcation s and a query q, the TOP-K-
SELECTIONS algorithm, given in [14], ﬁnds a BP s(cid:48)(cid:48) along
with δ(cid:48)(cid:48) that captures top−k(q, s). The algorithm operates
in two steps:

• AllFlows: ﬁrst, the algorithm ﬁnds a BP speciﬁcation
s(cid:48), δ(cid:48) that captures all ﬂows corresponding to the query
(i.e. q(s)).

• Top-k: second, the algorithm analyzes the obtained
representation s(cid:48) to ﬁnd a representation s(cid:48)(cid:48), δ(cid:48)(cid:48) of only
the top-k most likely ﬂows of s(cid:48). s(cid:48)(cid:48), δ(cid:48)(cid:48) thus captures
top-k(q, s).

The algorithm bears two important features: ﬁrst, the exe-
cution time incurred by the construction of a BP that cap-
tures top-k(q, s) is polynomial in the size of the speciﬁcation;
second, explicit construction of any concrete ﬂow out of the
ﬂows in top-k(q, s) is possible in time which is polynomial in
the output size (i.e. the size of the ﬂow). Our goal is to de-
sign an evaluation algorithm for projection queries bearing
these two features.

The details of the above algorithm may be found in [14], but
are not important here, as we next show that its possible
direct adaptations to the setting of projection queries are
generally infeasible.

3.2 Adaptations of TOP-K-SELECTIONS
We next present two possible adaptations of
TOP-K-SELECTIONS for projection queries, and show that
they may incur exponential data complexity.

3We use isomorphism for equivalence between graphs

First attempt - Explicit Enumeration of EX-ﬂows. The
ﬁrst simple approach for evaluating projection queries is to
try and use the above mentioned algorithm that constructs
a compact representation s(cid:48)(cid:48), δ(cid:48)(cid:48) of top-k(q, s) 4, and then
to explicitly enumerate the ﬂows of s(cid:48), along with their
f−likelihood values. Next, for each obtained ﬂow, we may
compute its corresponding projections. Each projection re-
sult is ranked based on the maximal
f−likelihood of a ﬂow
leading to it.

Note, however, that this naive algorithm may incur time
that is exponential in the BP speciﬁcation size, as well as
in the output size, as the following theorem holds:

Theorem 3.2. There exists a ﬁxed-sized query q such that
for every n there exists a BP speciﬁcation sn whose size is
linear in n, such that even the smallest size of any EX-ﬂow
of q(sn) is exponential in n, while the size of the largest
q↓(sn) is bounded by a constant.

Proof. Consider a BP speciﬁcation in which each activ-
ity has a single implementation, as follows: the implementa-
tion of each activity ai (i = 1, ..., n−1) consists of two nodes
labeled ai+1, and the implementation of an consists of a sin-
gle atomic activity. Consider also a query that seeks for
the root activity, whose (indirect) implementation consists
of two any-labeled nodes, connected by a transitive edge.
The query then projects over the root node. It is easy to
observe that q(sn) = sn, and it has only a single possible
EX-ﬂow. The size of this ﬂow (containing two instances of
a2, 4 instances of a3, etc.) is exponential in n. Note that
in contrast, q↓(sn) consists of a single activity pair.

Second attempt - Computing a compact representation
of all projections. An alternative approach for adapting
the selection queries evaluation algorithm follows the idea of
generating a compact representation of all results, namely
q↓(s), and then retrieving the top-k out of these. Unfortu-
nately, this approach would also lead to infeasible algorithm,
as the following theorem holds:

Theorem 3.3. There exists a ﬁxed-sized query q such that
for every n there exists a BP speciﬁcation sn whose size is
linear in n, such that no s(cid:48)
n whose size is polynomial in the
size of sn captures q↓(sn).

Proof. For a number n, consider a BP speciﬁcation sn,
in which the start node branches into two diﬀerent activity
nodes, then joins with edges going into a single node, then
branches again, and so on, n times. Now consider a query q
that projects over the path from the start to the end node.
For a BP speciﬁcation s(cid:48)
n to capture q↓(sn), each possible
path in sn must appear as a direct implementation of the
root activity in a distinct EX-ﬂow of s(cid:48)
n. The number of such
paths in sn is 2n, and thus the root activity of s(cid:48)
n must bear
at least as much direct implementations. As a consequence,
the size of s(cid:48)
n is exponential in the size of sn (the size of the
latter is linear in n).
4If multiple ﬂows lead to the same projection result one may
need to generate the top-k’ ﬂows for some k(cid:48) > k.

244

Next, we show an alternative, PTIME, algorithm for evalu-
ating top-k projection queries.

3.3 Efﬁcient Evaluation of Top-k Projection

Queries

As shown above, it is infeasible to compute a compact rep-
resentation for all projection results and then retrieve the
top-k ones out of it. However, we may still perform a two-
steps algorithm, in the spirit of TOP-K-SELECTIONS. The
second step (top-k) stays intact. However, instead of a ﬁrst
step that generates a speciﬁcation capturing the entire set
of results q↓(s), the ﬁrst step of the reﬁned evaluation algo-
rithm generates a speciﬁcation that captures only a subset of
q↓(s), including in particular the top-k ranked projections.
We say that such BP k-captures q↓(s). Formally,

Definition 3.4. Given two BP speciﬁcations s(cid:48), s, a query
q, and a number k, we say that s(cid:48) k-captures q↓(s) if top−
k(q↓, s) ⊆ f lows(s(cid:48)) ⊆ q↓(s) (up to some renaming function
over the nodes), and the score of each projection f is the
same as the f−likelihood of the corresponding ﬂow of s(cid:48).

Theorem 3.5. Given a BP speciﬁcation s and a projec-
tion query q = (p, P ), we may compute a BP speciﬁcation
s(cid:48) that k-captures q↓(s) in time polynomial in s, with the
exponent determined by the query size.

Proof. We present an evaluation algorithm, K-CAPTURES,

computing s(cid:48) that k-captures q↓(s). Throughout the compu-
tation, our algorithm uses an EMBED function, to embed
(sub-)patterns into sub-graphs of implementations. When
invoked on a graph g and a pattern p, EMBED returns a
set of graphs em(g, p), each corresponding to a single em-
bedding: each g(cid:48) ∈ em(g, p) is isomorphic up to activities
names to some sub-graph of g. The activity labeling each
node encodes the identiﬁer and label of the original node in
g, as well as of all nodes (transitive edges) of p mapped to it.
EMBED may be implemented using extensions of sub-graph
homomorphism algorithms [9].

As the algorithm details are intricate, we explain it in 4
steps, gradually considering further complicated patterns.

“Flat" Patterns. We start by considering simple execution
patterns that consist of a root activity whose implementa-
tion contains only atomic activity nodes, or compound activ-
ity nodes having no implementation attached to them. Ad-
ditionally, the pattern contains no transitive nodes or edges.

The algorithm begins by embedding the pattern root r(cid:48) in
the BP root r, creating a new root [r, r(cid:48)]. Then, we use
EMBED to try embedding the implementation of r(cid:48) in each
direct implementation of r. Consider an implementation g
of r, guarded by f , s.t. em(g, p) (cid:54)= φ and let g(cid:48) ∈ em(g, p).
g(cid:48) is an implementation of the newly created [r, r(cid:48)], and its
guarding formula is denoted by f[r,r(cid:48)].

We then compute the c−likelihood value δ(cid:48) assigned to f[r,r(cid:48)],
as follows. Denote by N the set of all compound activity
nodes that appear in g. The implementations of N were not

matched and do not have counterparts in g(cid:48), as p contains
no implementation of any node other than the root. In con-
trast, recall that the score for each projection is computed
as the maximal likelihood of a ﬂow leading to it. The most
likely such ﬂow contains, as sub-ﬂows, the top-1 implemen-
tation for each node in N . We thus need to compute the
partial
f−likelihood induced by the top-1 implementation
of each n ∈ N , denoted by top-1-rank(n), then compensate
for it by setting δ(cid:48)(f[r,r(cid:48)]) = δ(f ) ∗ Πn∈N top-1-rank(n). To
compute the top-1-rank(n) we employ the Top-k algorithm
(described in Section 3.1, in the second step of the TOP-K-
SELECTIONS algorithm), with k = 1 and n being the BP
root activity.

Nested Patterns. We next consider execution patterns in
which some nodes in the root’s implementation may have
implementations attached to them by zoom-in edges (and
nodes in these implementations may bear implementations,
and so on).

In this case, to proceed with the embedding, and for each
matched compound activity of the pattern that bears an im-
plementation, we then match recursively its implementation
(in the pattern), to any implementation (in the BP) of its
matching node’s activity. These recursive calls end when
either the pattern contains no more nodes (in this case a
successful match was found), or when the pattern contains
nodes, but no embedding is found for them. In the latter
case we mark this matching as a failure. A ”garbage col-
lection” step follows, removing each activity for which all
implementations lead to failure (then activities that only
lead to these activities, etc.).

As for computation of
f−likelihood values, implementations
of some of the compound nodes of g were matched, and
are considered in further computation. Thus we only need
to compensate for those compound nodes that were not
matched; consequently, the set N contains only these nodes.

Patterns with transitive nodes. If the query pattern in-
cludes transitive nodes, their implementations may need to
be embedded in indirect implementations of the correspond-
ing BP nodes. Consequently we must consider all possible
splits of the patterns that appear as implementations of tran-
sitive nodes, into smaller sub-patterns. For each such split of
a pattern p into sub-patterns p1, ..., pk, we embed p1 within
a direct implementation I of the corresponding compound
node; as for p2, ..., pk, we “assign” each to a compound node
of I, generating a node with a new activity name [a, pi],
where a is the node’s original activity name and pi is the as-
signed sub-pattern. Intuitively, [a, pi] “guarantees” the em-
bedding of pi in its indirect implementation. We then recur-
sively construct the embedding of pi in an implementation
of a. A “garbage collection” step removes implementations
leading to failure.

The algorithm’s termination is guaranteed as each sub-pattern
of the query is matched only once against implementations
of each speciﬁcation node. If a match is found, the gener-
ated activity name guarantees the existence of a match, and
it does not need to be further veriﬁed.

Computation of f−likelihood values is again reﬁned, account-

245

ing for the case where upon matching a transitive node,
an entire implementation graph I of some node n is omit-
ted, while implementations of node within it are kept in-
tact. Thus, the “compensation” of likelihood is generalized:
the
c−likelihood of each newly generated formula guard-
ing an implementation g(cid:48)(cid:48), is multiplied by the top-1-rank
of all nodes co-appearing with nodes whose implementation
generated a sub-graph of g(cid:48)(cid:48), in implementations that were
eliminated.

Patterns with transitive edges. Finally, we consider tran-
sitive edges. The end-nodes of each edge are matched as
above to speciﬁcation nodes (denote these as n for the start
node of the edge and m for the end node), and it remains to
consider the paths in-between them. If the transitive edge
does not appear in the projection part, we only need to ver-
ify that a path exists. When the transitive edge does appear
in the projection part, then each projection result contains
a path, to which the edge is matched. It is infeasible to cre-
ate an implementation for each distinct projection (i.e. each
distinct path), as the number of paths between two nodes of
the speciﬁcation may be exponential in the speciﬁcation size.
Fortunately, we are only interested in the top-k projections,
in which only the top-k paths may appear.

We also assume in the sequel that the transitive edge appears
within an implementation of a transitive node. If not, then
any k 5 paths may be chosen, as they all co-appear in the
same implementation, thus share the same likelihood.

We design a Dynamic Programming algorithm, namely TOP-
K-PATHS, generating the top-k paths from n to m.

TOP-K-PATHS. First, we assign a unique identiﬁer to each
speciﬁcation node, then generate a new set of nodes [nj, i]
for each nj of the speciﬁcation and for each i = 1, .., k, and
initialize a table which keeps track of the i’th most likely
path from each nj to m, along with its likelihood. All entries
are initialized to an empty path and zero likelihood, except
for the entry for m itself, assigned a likelihood of 1. When
the table is full, it contains in particular the top-k paths
from n to m, which are explicitly generated.

To ﬁll in the table, we use the auxiliary notion of children,
as follows. We say that n2 is a child of n1 if there is an edge
from n1 to n2, or if n1 is a activation node of a compound
activity and n2 is a start node of its implementation, or if
n2 is an completion node of a compound activity and n1 is
an end-node of its implementation.

The computation of values in the table proceeds as follows,
computing the i’th paths for increasing values of i. When
computing the top-i path originating at some node l, we
consider all children of l in the speciﬁcation. For each such
child u, say that j is the greatest index of a path originating
in u that was used as a sub-path in some r < i ranked path
of l that was previously computed. Then we compute the
j + 1 path originated in u (if it was’nt already computed),
and obtain score(u), the score of u as a candidate for the
path being generated for l. In case the edge between l and u
is a zoom-in edge, score(u) is multiplied by the c−likelihood

5If there are only k(cid:48) < k paths, then all are matched

of f , where f is the formula guarding the implementation
rooted at u. The child of u with the maximal score, along
with its corresponding sub-path, is chosen for the top-i path
originating at l.

Each obtained path serves as a separate implementation of
the corresponding compound activity. The following lemma
holds.

Lemma 3.6. The partial speciﬁcation generated by TOP-
K-PATHS algorithm captures the k most likely paths from n
to m.

Complexity. The complexity of the above algorithm is poly-
nomial in the BP size s, with the exponent determined by
the query size q. The polynomial data complexity is ensured
by the polynomial data complexity of EMBED, as well as by
our treatment of transitive nodes (where each speciﬁcation
node is matched only once against each query sub-pattern)
and of transitive edges (generating only k paths rather than
all paths).

Corollary 3.7. We may compute a BP speciﬁcation s(cid:48)(cid:48)

that captures top − k(q↓, s) in PTIME (data complexity).

Proof. The TOP-K-PROJECTIONS algorithm ﬁrst ap-
plies K-CAPTURES, to obtain s(cid:48) that k-captures q↓(s). s(cid:48)
ﬂows capture all results of top−k(q↓, s), but possibly some
additional ﬂows. Thus, we apply the TOP-K algorithm,
which served as step (2) of the TOP-K-SELECTIONS algo-
rithm above. TOP-K is a dynamic programming algorithm,
similar to TOP-K-PATHS. Its details may be found in [14]
and are thus omitted here.

Note that the exponential dependency on the query size is
inevitable unless P (cid:54)= N P , as the following theorem holds.

Theorem 3.8. Given a BP speciﬁcation s , a query q and
a threshold t it is NP-complete with respect to the query size
to decide whether there exists a projection q↓(e) with score
greater than t.

NP-hardness may be proved by reduction from emptiness of
the results set, shown in [12] to be NP-hard. The NP algo-
rithm is based on a “Pumping Lemma”, guaranteeing that
it suﬃces to “guess” a small (polynomial) sized ﬂow, then
project it (details omitted for space constraints). Interest-
ingly, the problem remains NP-hard even when all speciﬁ-
cation and query graphs have a simple, almost tree-shaped
form.

246

4. EMPLOYING SELECTIVE TRACING
We have studied above projection queries as a tool for anal-
ysis of Business Process speciﬁcations.
In this section we
consider another application of our results.
It is a com-
mon practice to trace process executions. A naive tracing
keeps exact record of the activities occurring along the ﬂow,
and the obtained traces are thus equivalent, in this case,
to execution ﬂows. However, typical tracing is not naive.
First, the exact names of some activities are sometimes not
recorded. For instance, a generic name, say “Payment” may
be used to record a set of payment-related activities (e.g.
cash payment, credit card payment). Second, some activi-
ties may be omitted from traces altogether, due to lack of
storage space, conﬁdentiality, lack of interest, etc.

Given such a partial trace, the user may wish to identify
ﬂows that are most likely to have occurred in practice, and
moreover, focus on parts of these ﬂows that are of interest.
We ﬁrst describe our model for partial traces, then study
identiﬁcation of most likely ﬂows, given a partial trace.

4.1 Modeling Partial Traces
The omittance of activities and formulas from execution
traces, as well as the renaming of other activities, is captured
through the notion of selective tracing systems. Formally, a
selective tracing system σ = (A, F, π) for a BP speciﬁcation
s consists of a set A (F ) of activity names (guarding for-
mulas) in s to be omitted, and a renaming function π from
activities names in s to activities names in A. The obtained
traces are called selective traces, and to deﬁne them we recall
the deﬁnition of [13] 6:

Definition 4.1. [Selective EX-traces] Given a BP spec-

iﬁcation s and a selective tracing system σ = (A, F, π) sat-
isfying condition (*) below, the set of selective traces deﬁned
by s and σ, denoted traces(s, σ), consists of all graphs e ob-
tained from EX-ﬂows of s by deleting all activity pairs with
labels in A, 7, deleting all occurrences of guarding formulas
in F , and then replacing each label a of the remaining nodes
by π(a).

Condition (*): A does not include the root activity of s,
and for each activation-completion graph g in s, the graph g(cid:48)
obtained from g by removing the atomic activity pairs with
names in A is itself an activation-completion graph (as in
Deﬁnition 2.1), or is empty.

The intuition behind condition (*) is that from a practical
point of view, it is reasonable to assume that the result ob-
tained after each loss of information still bears the shape of
a ﬂow.

Consider, for example, a selective tracing system (A = Ho-
tel, F = $searchT ype = “ﬂights only”, $searchT ype =

6[13] did not consider formulas, but the adaptation is
straightforward.
7When an atomic activity pair (n1, n2) is deleted, the
edges incoming n1 are now connected to the nodes previ-
ously pointed by n2. For compound activities the incom-
ing(outgoing) edges of n1 (n2) are now being connected to
the start/end nodes of the implementation sub-graph.

“ﬂights+hotels”), with π being the identity function. Un-
der such tracing, it is impossible to distinct between a ﬂow
containing a search for airlines and hotels and one contain-
ing a search for only airlines, as all occurrences of the Hotels
activity, and of formulas dictating the search type are omit-
ted. Indeed, the same trace is obtained for the two diﬀerent
ﬂows of Fig. 2.

We next deﬁne the notion of origin ﬂows, which are ﬂows
that may have occurred given an observed trace, as follows:

Definition 4.1. An execution ﬂow e is a possible origin
of an execution trace t, w.r.t. a selective tracing system σ =
(A, F, π), denoted σ(e) = t, if deleting from e all occurrences
of activity names in A and of formula names in F , and
renaming all other activities according to π, results in t.

Given an execution trace t we wish to identify the top-k
ﬂows that are likely to have occurred in practice, or relevant
parts thereof. We consider a more generalized setting, where
the input consists of a query, and we seek for (relevant parts
of) the ex-ﬂows most likely to occur, out of the origins of
any trace conforming to the query. (This setting is indeed
more general: an observed trace t may be represented by the
pattern, with the projection part being the part of interest).

We next deﬁne top-k projections of origins, under selective
tracing. We say that e(cid:48) = e (e(cid:48) ⊆ e) if e(cid:48) is isomorphic to (a
sub-graph of) e.

Definition 4.2. Given a BP speciﬁcation s, a selective

tracing system σ = (A, F, π) and a query q, we deﬁne
origins(q↓, s, σ) = S
e∈f lows(s){e(cid:48) ⊆ e | σ(e(cid:48)) = q↓(σ(e))},
and say that e leads to e(cid:48). The score of each projection result
e(cid:48) is deﬁned as the maximal
f−likelihood of a ﬂow e leading
to it, and top − k(q↓, s, σ) consists of the k projections in
origins(q, s, σ) having the best scores.

Intuitively, the results set origins(q↓, s, σ) contains all sub-
ﬂows e(cid:48) of some ﬂow e of s (before renaming), such that
after renaming, σ(e(cid:48)) is the projection of σ(e) over q↓. It
thus captures the relevant parts of conforming ﬂows. As
before, each sub-ﬂow e(cid:48) is ranked by the maximal ranking
of a corresponding ﬂow e.

In the remainder of the section we discuss computation of
top−k(q↓, s, σ), in two diﬀerent settings. First, we assume
knowledge of σ, i.e. we know exactly which activities are
deleted / renamed. Then, we consider a more intricate sce-
nario where this information is unknown.

4.2 Known Selective Tracing
We start by showing that given q, s, σ, we may eﬃciently
capture top−k(q↓, s, σ).

Theorem 4.3. Given a BP speciﬁcation s, a selective trac-
ing system σ, and a query q, obtaining a BP speciﬁcation s(cid:48)
that captures top − k(q↓, s, σ), may be done in polynomial
time (data complexity).

247

Proof Sketch. Re-visiting the TOP-K-PROJECTIONS

algorithm of section 3, we adapt the ﬁrst step (K-CAPTURES)
to the selective setting, as follows:

1. Upon matching of nodes, we may match a query node
n(cid:48) to a speciﬁcation node n if the label of n, after
renaming is the same as the label of n(cid:48).

2. Upon matching of edges, we may also match a non-
transitive edge to a speciﬁcation path, given that the
path includes only nodes whose labels are in the dele-
tion set of the tracing system, and all zoom-in edges
along the path are guarded by formulas in the deletion
set.TOP-K-PATHS is adapted to support these newly
created edges, verifying that nodes and edges (in any
nesting level) along the matched path indeed conform
to the above requirement.

3. Each composite node is treated as transitive, and its
corresponding zoom-in edges are treated as transitive,
as in item (2).

This concludes the proof.

4.3 Unknown Selective Tracing
In the previous discussion we have assumed knowledge of
the information lost in the tracing process. Such knowledge
may generally be absent, for instance if we have no access
to the tracing system itself, but only to a sample of traces.

Obviously, assuming no information at all on the tracing sys-
tem, one cannot infer anything on the ﬂows shape. We thus
assume the tracing system follows some selective tracing,
that is, all occurrences of some subset of activity names are
deleted, and all occurrences of another subset are renamed.

We then say that an EX-ﬂow is an origin of an EX-trace if
it’s an origin of it under some selective tracing system, and
we correspondingly deﬁne top-k-uSelective(q↓, s), as follows:

Definition 4.4. Given a BP speciﬁcation s and a query
q, we deﬁne origins(q↓, s, uSelective) as S
σ origins(q↓, s, σ).
score(e(cid:48), uSelective) = maxσscore(e(cid:48), σ), and we denote top-
k-uSelective(q↓, s) as the k results with highest scores out of
these in origins(q↓, s, uSelective).

The following theorem holds:

Theorem 4.5. Given a BP speciﬁcation s, and a query q,
we may generate a BP speciﬁcation s(cid:48), that k-captures top−
k−uSelective(s, q↓), in polynomial time (data complexity).

Proof. We ﬁrst give a naive, exponential algorithm that
explicitly enumerates all possible tracing systems, then op-
timize it by considering only a subset of the possible tracing
systems. Finally, we prove that it is indeed suﬃcient to
consider only this subset.

Naive Algorithm. Given a BP speciﬁcation s and a query
q, a naive algorithm generates all possible systems σ =
(A, F, π) such that A contains activities names appearing
in s ,F contains guarding formulas appearing in s and π is
a mapping from activity names in s to activity names in q.

Then, for each such σ, the algorithm ﬁnds s(cid:48)(σ) that cap-
tures top−k(q↓, s, σ) (possible by Theorem 4.3). Last, the
algorithm constructs a BP speciﬁcation s(cid:48)(cid:48) whose root con-
tains as implementations all the s(cid:48)(σ) speciﬁcations, and
apply a top-k analysis over s(cid:48)(cid:48), to ﬁnd the top-k projections.

As the number of tracing systems tested is exponential in
the size of s, such algorithm is infeasible.

Optimized Version. We avoid explicit generation of all pos-
sible tracing system, and generate only a subset of these.
We ﬁrst generate all possible mappings from query nodes
(formulas) to BP activities names (formula names), ignor-
ing their original activities (formulas). Now, for each such
mapping L, we ﬁrst check L for consistency. That is, verify
that no two query nodes whose original activities (formula
names) were identical, are mapped to diﬀerent labels (for-
mula names). The algorithm generates a selective tracing
system, denoted σL, with its deletion set AL (FL) including
all activity names (formula names) except for those assigned
by L to some query node (formula name). The renaming
function πL matches each BP activity name to the original
activity name of a query node mapped by L to it (uniquely
deﬁned due to L’s consistency, all such nodes bear the same
activity name). For each consistent mapping L, σL is added
to a set of tracing systems, denoted Λ. The size of Λ is poly-
nomial in that of s. We claim that Λ captures all tracing
systems that need to be checked, namely:

Lemma 4.6. Given a BP speciﬁcation s and a query q,
and for any e, there exist σ, t s.t. e ∈ top − k(q↓, s) if and
only if there exist such σ(cid:48), t(cid:48), with σ(cid:48) ∈ Λ.

Proof. The ﬁrst direction is immediate. We thus assume
that there exists such σ, t, and denote by L the node embed-
ding of q in t, that is the assignment of labels to query nodes,
according to the embedding E of q in t. Denoting the result
of applying σL on e by t(cid:48), we construct the embedding E(cid:48) of
q in t(cid:48): it maps nodes to nodes exactly as E does (note that
no node of t to which E maps a node of q was removed by
σL). Edges are mapped to edges connecting corresponding
nodes; as for transitive edges, there still exists a path (possi-
bly containing one edge) in t(cid:48) connecting the corresponding
end-nodes, as edges are not removed unless their end-nodes
are removed.

As the number of tracing systems generated, as well as the
evaluation complexity for each tracing system, is polynomial
in the BP speciﬁcation size, we obtain a polynomial data
complexity algorithm.

This concludes the proof of Theorem 4.5.

248

5. DEPENDENCIES
In the above discussion, we have assumed full independency
between the likelihood of choices dictating the execution
ﬂow. In practice, such independency is rare, as user choices,
variables values, etc. tend to be correlated with each other.
To conclude, we withdraw the assumption of independency
and show that under plausible assumptions, query evalua-
tion is feasible under dependency.

To deﬁne dependency, we ﬁrst extend the deﬁnition of the
c−likelihood function to consider not only a given guarding
formula, but also an EX-ﬂow representing the history oc-
curring before the formula evaluation. Namely, δ is now a
function of both e(cid:48) and f , where e(cid:48) is a partial ﬂow and f
is a formula guarding an activity name of a node that is
next to be expanded 8. Intuitively, prediction of the next
user choice / variable value is dependent on the history of
the ﬂow thus far; for instance, if British Airways and Mar-
riott oﬀer combined deals, we expect to observe that typical
British Airways customers stay at the Marriott.

We have shown in [14] that for general c−likelihood func-
tions with dependency, even emptiness of selection queries
is undecidable. However, in realistic cases, the likelihood of
each formula depends on the execution history, but only in
a bounded manner. One way [22] to deﬁne such bound is
to consider a “sliding window”, that is allow dependency of
each choice on, at most, the m last choices; however, this
approach yields, in our setting, a class that is too restric-
tive. To observe that, consider a recursive BP, and a choice
f1 (f2) that precedes (follows) the recursive loop. We would
still like to allow dependency between f1 and f2, even for
executions in which the number of choices within the loop
exceeds our bound. Thus, for each formula f , we bound the
number of implementation choices previously made for each
activity a, that aﬀect the likelihood of f . We next deﬁne the
bounded-memory class, capturing such functions, as follows:

Definition 5.1. Given a BP s, we say that δ is bounded-
for each
memory if there exists some ﬁnite bound n, s.t.
guarding formula f , for each activity name ai ∈ s and for
all pairs of EX-ﬂows e, e(cid:48) that agree on the implementations
chosen for each activity name ai, in its last n expansion
steps, δ(e, f ) = δ(e(cid:48), f ). If n = 0, δ is memory-less.

Continuing with our running example, assume that the choice
of hotel is dependent on the last choice of search type, and
on the last choice of airline; the memory bound for the hotels
activities, in this case, is 1. In contrast, if the likelihood of
choosing BritishAirways depends, for example, on exactly
how many times “reset” was chosen, then we have an un-
bounded memory.

We claim that we may extend all of our algorithms to the
setting of a bounded-memory likelihood function, though
this may incur exponential time in the speciﬁcation size.

Theorem 5.2. Given a BP speciﬁcation s along with a
bounded-memory c−likelihood function δ, (a selective trac-
8For clarity of presentation, we assume a total order on the
expansions order. This assumption may be relaxed [14].

ing system σ), and a query q, generating a BP speciﬁca-
tion s(cid:48), that captures top − k(q↓, s) (top − k(q↓, s, σ), top −
k−uSelective(q↓, s)) may be done in exponential time (data
complexity).

Proof Sketch. We use the algorithm from [14] that,

given a BP speciﬁcation s and a bounded-memory c−likelihood
function δ, generates a BP speciﬁcation s(cid:48) and a memory-
less c−likelihood function δ(cid:48) that captures f lows(s). The
activity names of s(cid:48) encodes suﬃcient amount of history re-
quired for computation of likelihood for guarding formulas,
and thus the size of s(cid:48) may be exponential in the size of s.
A renaming function ρ maps the new names into names of
s.

The algorithms presented in previous sections may now be
applied over s(cid:48), generating a new s(cid:48)(cid:48) capturing top−k(q↓, s)
(top − k(q↓, s, σ), top − k − uSelective(q↓, s)). During this
algorithm, a second renaming function ρ(cid:48) is generated, as
explained above. The ﬁnal renaming function over activity
names is obtained as ρ(cid:48) ◦ ρ.

Unless P=NP, the exponential time of evaluation in pres-
ence of dependency may not be improved, as the following
theorem holds (proof omitted for space constraints):

Theorem 5.3. Given a BP speciﬁcation s, with a bounded-
memory c−likelihood function, a query q and a threshold t it
is NP-complete with respect to the size of s to decide whether
there exists a projection q↓(e) with score greater than t.

6. RELATED WORK
We next give a brief review of related work, highlighting our
results relative contributions.

The query language and data model that we consider here
were originally introduced in [2, 3], and extended to a prob-
abilistic setting in [14]. The work in [14] focused only on
selection queries and assumed naive tracing, i.e. that ex-
ecution traces accurately and exactly represent the ﬂows
that had occurred in practice. In contrast, our work here
is the ﬁrst, to the best of our knowledge, to study projection
queries and partial tracing for Probabilistic Business Pro-
cesses. The model for partial tracing used here was intro-
duced, for a non-probabilistic setting, in [13]. It was shown
to be realistic enough to capture real-life tracing systems
such as [6].

Probabilistic XML [1, 20, 19, 8] extends XML to a prob-
abilistic setting, by introducing distributional nodes. For
such node, a subset of its children is randomly chosen to ap-
pear in the concrete XML documents. [20] has shown that
evaluation of projection queries over probabilistic XML is
possible in polynomial time (data complexity). This result
by itself, however, does not imply PTIME algorithm for our
setting, which is more complex: ﬁrst, our model allows rep-
resentation of nested DAG structures, rather than trees. For
projection queries, this entails another level of complexity

249

in ﬁnding matches serving as implementations, and project-
ing them over relevant nodes; second, an inﬁnite number of
ﬂows may be represented by our probabilistic BP (serving
as schema), due to possible recursive calls. Upon projec-
tion, the results set may be inﬁnite as well, posing a further
challenge.

In an XML setting, evaluation of projection queries with the
maximum aggregation function may be done by a straight-
forward adaptation of selection queries evaluation algorithms.
Thus, studies focused on the sum aggregation function. In
contrast, we have shown that, in the settings of probabilis-
tic BP, there are inherent diﬃculties in adaptation of algo-
rithms for support of projection queries, even for maximum
aggregation. The sum aggregation function is considered as
future work.

Probabilistic Databases (PDBs) [11, 26] allow representation
of uncertain relational information. They extend relational
algebra to a probabilistic setting, and analyze the complex-
ity of query evaluation in this setting. They show that ﬁnd-
ing the exact probabilities for query results is (cid:93)P -hard [11]
(though top-k query evaluation is PTIME, by approximat-
ing results probabilities [24]). The hardness, however, stems
from combination of projections (again using the sum ag-
gregation function) with joins, absent in our context, and
thus does not hold in our settings. In contrast, diﬀerent dif-
ﬁculties rise in our setting, with the representation of the
dynamic nature of ﬂow and the possibly unbounded number
of recursive (possibly dependent) activity invocations.
In
terms of the possible worlds semantics [11], the number of
worlds in our model is inﬁnite (rather than large, yet ﬁnite,
in PDBs).

A variety of formalisms for probabilistic process speciﬁca-
tions exist in the literature, such as Markov Chains [18],
Probabilistic Recursive State Machines (PRSMs) [16], and
Stochastic Context Free (Graph) Grammars (SCFG, SCFGG)
[23]. To the best of our knowledge, projection queries over
these models were not studied. As for selection queries, anal-
ysis of SCFGGs generally extends the theoretical analysis of
Courcelle [10] on regular (non-stochastic) CFGGs, consider-
ing strongly expressive logics such as MSO (Monadic Sec-
ond Order Logic). The complexity bounds obtained there
are thus practically infeasible. For PRSMs, evaluation of
strongly expressive query languages such as P CT L∗[25] is
undecidable in general, and EXPTIME-hard [7] for some
fragment. Other works consider linear-time formulas [21,
15], allowing to express only string-like properties. In con-
trast, our query language suggests a reasonable tradeoﬀ be-
tween expressibility and feasibility [12].

Another advantage of using the query language studied here
is its graphical and intuitive nature. Being similar to the
graph-based view of processes used by commercial vendors
for the speciﬁcation of BPs [3], it is claimed to be more
intuitive for BP developers than other query formalisms such
as temporal logics and process algebras [2, 3].

7. CONCLUSION
We have studied in this paper, for the ﬁrst time, top-k query
evaluation for projection queries over probabilistic BP spec-
iﬁcations. We have shown a PTIME (data complexity) al-

gorithm for query evaluation in presence of independency
between events dictating the BP ﬂow, and studied the prob-
lem complexity in presence of dependency.

Furthermore, we have considered an application of our re-
sults to the analysis of BP execution traces, for recovering
information missing from the traces.

We have limited the discussion in this paper to the max
aggregation function, computing the rank of any given pro-
jection as the maximal likelihood of ﬂows leading to it. Var-
ious other aggregation functions, and in particular the sum
aggregation function, will be considered as future research.

8. REFERENCES
[1] S. Abiteboul and P. Senellart. Querying and updating

probabilistic information in xml. In Proc. of EDBT,
2006.

[2] C. Beeri, A. Eyal, S. Kamenkovich, and T. Milo.

Querying business processes. In Proc. of VLDB, 2006.
[3] C. Beeri, A. Eyal, T. Milo, and A. Pilberg. Monitoring

business processes with queries. In Proc. of VLDB,
2007.

[4] S. Bhiri, W. Gaaloul, and C. Godart. Mining and

improving composite web services recovery
mechanisms. Int. J. Web Service Res., 5(2), 2008.

[5] Business Process Execution Language for Web

Services.
http://www.ibm.com/developerworks/library/ws-
bpel/.

[6] Oracle bpel process manager administrator’s guide -

conﬁguring and viewing bpel process logs.
http://download.oracle.com/docs/cd/E11036-01
/integrate.1013/b28982/logging.htm.

[7] T. Brazdil, A. Kucera, and O. Strazovsky. On the
decidability of temporal properties of probabilistic
pushdown automata. In Proc. of STACS, 2005.

[8] S. Cohen, B. Kimelfeld, and Y. Sagiv. Incorporating

constraints in probabilistic xml. In Proc. of PODS,
2008.

[9] M. Consens and A. Mendelzon. The g+/graphlog
visual query system. In Proc. of SIGMOD, 1990.
[10] B. Courcelle. The monadic second-order logic of

graphs. Inf. Comput., 85(1), 1990.

[11] N. Dalvi and D. Suciu. Eﬃcient query evaluation on

probabilistic databases. In Proc. of VLDB, 2004.
[12] D. Deutch and T. Milo. Querying structural and

behavioral properties of business processes. In Proc. of
DBPL, 2007.

[13] D. Deutch and T. Milo. Type inference and type

checking for queries on execution traces. In Proc. of
VLDB, 2008.

[14] D. Deutch and T. Milo. Evaluating top-k queries over

business processes. In Proc. of ICDE, 2009.

[15] K. Etessami and M. Yannakakis. Algorithmic

veriﬁcation of recursive probabilistic state machines.
In Proc. of TACAS, 2005.

[16] N. Friedman, L. Getoor, D. Koller, and A.Pfeﬀer.

Learning probabilistic relational models. In Proc. of
IJCAI, 1999.

[17] W. Gaaloul and C. Godart. Mining workﬂow recovery

250

from event based logs. In Business Process
Management, 2005.

[18] J. G. Kemeny and J. L. Snell. Finite Markov Chains.

Springer, 1976.

[19] B. Kimelfeld, Y. Kosharovsky, and Y. Sagiv. Query

eﬃciency in probabilistic xml models. In Proc. of
SIGMOD, 2008.

[20] B. Kimelfeld and Y. Sagiv. Matching twigs in

probabilistic xml. In Proc. of VLDB, 2007.

[21] Z. Manna and A. Pnueli. The temporal logic of reactive

and concurrent systems. Springer-Verlag, 1992.

[22] S. P. Meyn and R. L. Tweedie. Markov Chains and

Stochastic Stability. Springer-Verlag, 1993.

[23] T. Oates, S. Doshi, and F. Huang. Estimating
maximum likelihood parameters for stochastic
context-free graph grammars. In Proc. of ILP, 2003.

[24] C. Re, N. N. Dalvi, and D. Suciu. Eﬃcient top-k

query evaluation on probabilistic data. In Proc. of
ICDE, 2007.

[25] M. Reynolds. An axiomatization of pctl. Inf. Comput.,

201(1), 2005.

[26] P. Sen and A. Deshpande. Representing and querying
correlated tuples in probabilistic databases. In Proc. of
ICDE, 2007.

251

