On Models and Query Languages for Probabilistic

Processes ∗

Daniel Deutch

Tova Milo

Tel Aviv University

danielde@post.tau.ac.il milo@post.tau.ac.il

ABSTRACT
Probabilistic processes appear naturally in various con-
texts, with applications to Business Processes, XML data
management and more. Many models for specifying
and querying such processes exist in the literature; a
main goal of research in this area is to design models
that are expressive enough to capture real-life processes
and analysis tasks, but at the same time allow for ef-
ﬁcient query evaluation. We depict the model estab-
lished in [13, 16, 17, 18], and claim that it achieves a
good balance between expressivity and query evaluation
complexity. We compare and contrast the model with
other common models for probabilistic processes, high-
lighting the different choices made in models design and
their effect on expressivity and incurred complexity.

1.

INTRODUCTION

Probabilistic processes, i.e. processes with some
probability distribution over their possible execu-
tions, appear naturally in various contexts. For in-
stance, the possible behaviors of web-site users may
be captured by such processes, where the proba-
bilities are derived from the popularity of actions
among previous users; a recent paper [6] explains
how to capture probabilistic XML data via a prob-
abilistic process speciﬁcation; and there are many
additional applications e.g. in areas such as Natural
Language Processing [29] or computational biology
[35]. Probabilistic processes occurring in such cases
typically have intricate structures, and may induce
a large (or even inﬁnite, in presence of recursion)
number of possible executions [6, 15].

The importance of probabilistic processes along
with their complex nature call for the use of a query
language, that will allow to analyze the processes
and their possible executions. The results of such
analysis are then applied for debugging the process,
optimizing it, or identifying optimal ways to use
∗Database Principles Column. Column editor: Leonid
Libkin, School of Informatics, University of Edinburgh,
Edinburgh, EH8 9AB, UK. E-mail: libkin@inf.ed.ac.uk

it. Examples for analysis tasks include termination
analysis (i.e. ﬁnding the probability that the pro-
cess terminates), identifying likely execution ﬂows
(or parts thereof), identifying the probability that
the execution reaches a given point, and so on.

To allow for an analysis of the above ﬂavor, three
components are required. First, one should de-
sign a formal model for probabilistic processes and
their executions. Second, the model should be ac-
companied by a corresponding query language that
will allow to specify analysis tasks over such pro-
cesses and executions; the model and query lan-
guage should be expressive enough to capture real-
life processes and analysis tasks, and simple enough
to allow for eﬀective formulation of process speciﬁ-
cation and queries. Third, the model and query lan-
guage must be supported by eﬃcient query evalua-
tion algorithms. Clearly, there exists a tradeoﬀ be-
tween the expressive power of the model and query
language, and the complexity of query evaluation.
An important goal of research in this area is to ﬁnd
a good balance between the two.

Many models and query languages for probabilis-
tic processes (e.g.
[4, 6, 9, 17, 25, 30, 34]) appear
in the literature, and vary in their expressive power
and the query evaluation complexity they admit.
Speciﬁcally, in [5, 16, 17] we have suggested a model
and query language for Probabilistic Business Pro-
cesses (BPs), which are used to depict the logical
structure of business activities that are common e.g.
in e-commerce and in Web Applications [5, 19]. The
model is an abstraction of the BPEL [8] standard
and allows for an intuitive, graphical representation
of the process. The query language is then based
on the same graph-based view and allows users to
query processes visually,
in an intuitive manner,
very analogous to how the processes are typically
speciﬁed. We then studied query evaluation, and
provided eﬃcient algorithms, for diﬀerent fragments
of the query language [13, 16, 17].

We claim that our proposed model is successful in

SIGMOD Record, June 2010 (Vol. 39, No. 2)

27

achieving a good balance between the expressivity
and the complexity of query evaluation. To sub-
stantiate this claim, we ﬁrst informally depict the
model and the complexity results achieved for query
evaluation. Then, we review other common models
and compare their properties. Via this comparison,
we highlight the diﬀerent choices that are made in
the models design, and their eﬀects on expressivity
and query evaluation complexity.

We next provide a brief overview of the Business

Process model and query language.

A Business Process (BP) speciﬁcation is ab-
stractly modeled as a nested DAG consisting of ac-
tivities (nodes), and links (edges) between them,
that detail the execution order of the activities [15,
23]. For example, consider a BP of an on-line travel
agency. The BP speciﬁcation may include activities
(nodes) for ﬂight and hotel reservation, car rental,
payment and conﬁrmation services, and edges that
describe their execution order. The DAG shape
allows to describe parallel computations. For in-
stance, advertisements may be injected in parallel
to the search. BP activities may be either atomic,
or compound. In the latter case their possible in-
ternal structures, called implementations, are also
detailed as DAGs, leading to the nested DAG struc-
ture. A compound activity may have diﬀerent possi-
ble implementations, corresponding to diﬀerent user
choices, variable values, servers availability, etc. An
Execution Flow (abbr. EX-ﬂow) is then an actual
running instance of a BP, obtained by choosing a
single implementation for each compound activity.
A BP speciﬁcation induces a set of such possible
EX-ﬂows; this set may be large, or even inﬁnite
when the BP speciﬁcation contains recursion.

In practice, some EX-ﬂows are more common
than others. This is modeled by a probability dis-
tribution over the possible implementations of com-
pound activities [16, 17]. A BP speciﬁcation along
with a description of such distribution is called a
Probabilistic BP. We note that the probabilities of
choices dictating the execution course are, in typical
cases, inter-dependent; for instance a user making a
reservation for a ﬂight to Paris is more likely to also
reserve an hotel in Paris. We allow to model such
dependencies in a straightforward manner.

We also deﬁned a query language for analyzing
BPs. Queries are used to deﬁne EX-ﬂows or parts
of them, that are of interest to the analyst. For
our travel agency example, an analyst may wish
to ﬁnd out how is one likely to book a travel pack-
age containing a ﬂight reservation?, or how is this
likely to be done for travelers of a particular air-
line company, say British Airways?. There may be

many diﬀerent ways for users to book such travel
packages. But assume, for instance, that we obtain
that a likely scenario for British Airways reserva-
tions is one where users ﬁrst search for a package
containing both ﬂights and hotels, but eventually
do not reserve an hotel. Such a result may im-
ply that the combined deals suggested for British
Airways ﬂiers are unappealing, (as users are specif-
ically interested in such deals, but refuse those pre-
sented to them), and can be used to improve the
Web site. Queries are deﬁned using execution pat-
terns (abbr. EX-patterns), generalizing EX-ﬂows
similarly to the way tree patterns, used in query
languages for XML, generalize XML trees [10]. In
more details, EX-patterns bear the structure of an
EX-ﬂow, where activity names are either speciﬁed,
or left open using a special any symbol and then may
match any node. Edges in a pattern are either regu-
lar, interpreted over edges, or transitive, interpreted
over paths. Similarly, activities may be regular or
transitive, for searching only in their direct internal
ﬂow or for searching in any nesting depth, respec-
tively. A match of the query is captured via the
notion of an embedding, which is a homomorphism
from an EX-pattern to an EX-ﬂow, respecting node
labels and edge relation. We then note that given
a BP speciﬁcation s and a query q, the number of
possible EX-ﬂows of s that qualify according to q
may be extensively large, or even inﬁnite when s is
recursive. In practice, analysts are only interested
in the possible EX-ﬂows of s that are most likely to
occur in practice. This is in fact a ﬂavor of top-k
analysis.

In many cases, analysts are further interested
only in some part of the possible EX-ﬂows. For that,
we deﬁne top-k projection queries, whose output
consists of the likely sub-ﬂows. An important ques-
tion that rises when considering projection queries
is the choice of a ranking metric for the query re-
sults. Recall that our model associates a likelihood
value with every possible EX-ﬂow of the BP speci-
ﬁcation; with projection queries, a single projection
results may originate from multiple EX-ﬂows.
In
this case, the likelihoods of all such EX-ﬂows should
then be aggregated, to form the result score. Evi-
dently, diﬀerent choices of such aggregation func-
tions require diﬀerent query evaluation mechanisms
and incur diﬀerent complexity of query evaluation.
We consider the max and sum aggregation func-
tions, explain their intuitive meaning and depict the
complexity of query evaluation for each choice of
function.

28

SIGMOD Record, June 2010 (Vol. 39, No. 2)

Paper Organization. In Section 2 we recall our
model of probabilistic BPs and queries over such
BPs; in Section 3 we overview the complexity of
query evaluation for such queries.
In Section 4
we overview other common models for probabilis-
tic models, comparing them to our BP model. We
conclude in Section 5.

2. MODEL

We (informally) depict in this section the model
of probabilistic Business Processes (BPs), and a
query language over such processes, originally de-
ﬁned and used in [5, 16, 17, 18]. Additional process
models and their connection to this model are dis-
cussed in Section 4.

2.1 Business Processes

We start by depicting the model for Business Pro-
cesses (without probabilities), then introduce prob-
abilities. At a high-level, a BP speciﬁcation encodes
a set of activities and the order in which they may
occur. A BP speciﬁcation is modeled as a set of
node-labeled DAGs. Each DAG has a unique start
node with no incoming edges and a unique end node
with no outgoing edges. Nodes are labeled by activ-
ity names and directed edges impose ordering con-
straints on the activities. Activities that are not
linked via a directed path are assumed to occur in
parallel. The DAGs are linked through implemen-
tation relationships; the idea is that an activity a
in one DAG is realized via the activities in another
DAG. We call such an activity compound to dif-
ferentiate it from atomic activities which have no
implementations. Compound activities may have
multiple possible implementations, and the choice
of implementation is controlled by a a condition re-
ferred to as a guarding formula.

Example 2.1. Fig. 1 depicts a partial BP spec-
iﬁcation. Its root DAG consists of a single activity
chooseTravel. chooseTravel is a compound ac-
tivity having 3 possible implementations F2, F3, F4.
These correspond to diﬀerent choices of
travel
search (ﬂights only, ﬂights + hotels, or ﬂights +
hotels + cars) and are guarded by corresponding
formulas. The idea is that exactly one formula is
satisﬁed at run-time (the user chooses one of the
three search types) and thus chooseTravel is im-
plemented either by F2, F3 or F4. Consider for
example F1; it describes a group of activities com-
prising user login, the injection of an advertise-
ment, the Flights activity, and the Confirm ac-
tivity. Directed edges specify the order of activities
occurrence, e.g. users must login before choosing
a ﬂight. Some of the activities (e.g. Advertise

and Flights) are not in a particular order, and
thus may occur in parallel. Login and Advertise
are atomic whereas Flights and Confirm are com-
pound. Note that the speciﬁcation is recursive as
e.g. F2 may call F1.

We note that satisfaction of guarding formulas is
determined by external factors, such as user choices.
We assume that exactly one guarding formula can
be satisﬁed when determining the implementation
of a given compound activity occurrence, but satis-
faction of guarding formulas can change if activities
occur several times. For instance, a user may choose
to search for ﬂights and hotels the ﬁrst time she goes
through F1 and for ﬂights only the second time.

Execution Flows. An Execution Flow (EX-ﬂow) is
modeled as a nested DAG that represents the ex-
ecution of activities from a BP. Since, in real-life,
activities are not instantaneous, we model each oc-
currence of an activity a by two a-labeled nodes,
the ﬁrst standing for the activity activation and
the second for its completion point. These two
nodes are connected by an edge. The edges in the
DAG represent the ordering among activities ac-
tivation/completion and the implementation rela-
tionships. To emphasize the nested nature of exe-
cutions, the implementation of each compound ac-
tivity appears in-between its activation and comple-
tion nodes. An EX-ﬂow structure must adhere to
the structure of the BP speciﬁcation, i.e., activities
must occur in the same order and implementation
relationships must conform to τ .

of

the

Example 2.2. Two EX-ﬂows

travel
agency BP are given in Fig. 2. Ordering edges
(implementation edges) are drawn by regular (resp.
dashed) arrows. Each EX-ﬂow describes a sequence
of activities that occurred during the BP execution.
In Fig. 2(a) the user chooses a “ﬂights+hotels”
search, reserving a “British Airways” ﬂight and a
“Marriott” hotel, then conﬁrms. Fig. 2 (b) depicts
another possible EX-ﬂow, where the user chooses a
“ﬂights only” search, followed by a choice of British
Airways ﬂight, but then resets and makes other
choices (omitted from the ﬁgure).

Likelihood. We note that the EX-ﬂow occurring
at run-time is dictated by the truth values of guard-
ing formulas, which in turn dictate the choice of
implementation for compound activities (out of the
possibly multiple implementations associated with
each such activity in the BP speciﬁcation).
In a
probabilistic process, each such guarding formula is
associated with a probability of being satisﬁed at
run-time, and this probability may be dependant

SIGMOD Record, June 2010 (Vol. 39, No. 2)

29

Figure 1: Business Process Speciﬁcation

Figure 2: Execution Flows

on the EX-ﬂow thus far and formulas previously
satisﬁed.

To model this we use two likelihood functions.
The ﬁrst, named c−likelihood (choice likelihood),
associates a probability value with each guard-
ing formula (implementation choice), describing the
probability that the formula holds, given the par-
tial EX-ﬂow that preceded it. The second, named
f−likelihood (ﬂow likelihood) reﬂects the joint likeli-
hood of satisfaction of guarding formulas occurring
along the ﬂow and is deﬁned as the multiplication of
c−likelihood values. A BP speciﬁcation along with
a likelihood function over the guarding formulas oc-
curring in the speciﬁcation is called a Probabilistic
Business Process.

Note that the c−likelihood function δ receives two
inputs: a guarding formula f in hand, and the par-
tial EX-ﬂow e(cid:3) that preceded the implementation
choices guarded by f . This allows us to capture
dependencies among likelihood values. We distin-
c−likelihood func-
guish between three classes of
tions, according to their sensitivity to e(cid:3) (referred
to as “history”).

the more

common scenario where

History independence: History-independent func-
tions imply probabilistic independence between the
choices of implementation in diﬀerent activities oc-
currences throughout the ﬂow. More formally,
a c−likelihood function is history-independent for
c−likelihood (e,f) =
every guarding formula f ,
c−likelihood (e’,f) for each two EX-ﬂows e, e(cid:3).
Bounded-history: Bounded-history functions cap-
ture
the
c−likelihood value does depend on the history e of
the EX-ﬂow, but only in a bounded manner. That
is, to determine the c−likelihood of any implemen-
tation choice at an activity node n, it suﬃces to
consider only the implementation choices of the last
b preceding compound activities, for some bound b.
By “preceding” we refer here to activity nodes ˆn
that are ancestors of n in e (in contrast to nodes
that occur in parallel and thus in general may or
may not precede n). By “choice” we refer to the
formula guarding the implementation selected for
the activity.
Unbounded-history: Unbounded-history functions
may use an unbounded portion of the ﬂow history

30

SIGMOD Record, June 2010 (Vol. 39, No. 2)

e to compute the next choice’s likelihood. For in-
stance, if the price of a given product depends on
the exact full sequence of searches that the user per-
formed prior to the purchase, then the correspond-
ing c−likelihood function is unbounded-history.
Observation. Note that, by deﬁnition, for non-
c−likelihood functions are always
recursive BPs,
bounded-history, with the bound being, at most,
the BP nesting depth. Recursive BPs, on the other
c−likelihood
hand, may have unbounded-history
c−likelihood func-
functions.
tions are bounded-history, and moreover the bound
is typically small [36].

In practice, typical

2.2 Query Language

We next consider a query language for Probabilis-
tic Business Processes, originally deﬁned in [5] and
further reﬁned in [17, 18]. We start by considering
selection queries, whose output is the (representa-
tion of the) set of all EX-ﬂows of the original BP
speciﬁcation, that also match the query. We then
introduce projection queries, that further allow to
focus on some sub-ﬂows that are of interest.

Queries are deﬁned using execution patterns, an
adaptation of the tree-patterns of existing XML
query languages, to nested EX-ﬂow DAGs. Such
patterns are similar in structure to EX-ﬂows, but
contain transitive edges that match any EX-ﬂow
path, and transitive activity nodes, for searching
deep within the implementation subgraph, of the
corresponding compound activities, at any level of
nesting. Nodes/ formulas in the pattern may be la-
beled by the wildcard any and then may match any
EX-ﬂow node/formula.

Example 2.3. The query in Fig. 3 (a) (ignore
for now the rectangle surrounding a sub-graph of the
pattern) describes EX-ﬂows that contain a choice of
some British Airways (abbr. “BA”) ﬂight followed
by a conﬁrmation. The double-lined edges are tran-
sitive edges, and may match any sequence of activ-
ities. The doubly bounded chooseTravel activity is
a transitive activity. Its implementation nodes may
be embedded anywhere inside the implementation of
the corresponding EX-ﬂow activity, at any nesting
level.

The matching of an EX-pattern p to an EX-ﬂow
e is called an embedding. An embedding of p into
e is a homomorphism ψ from nodes and edges in
p to nodes,edges and paths in e such that the root
of p is mapped to the root of e; activity pairs in p
are mapped to activity pairs in e, preserving node
labels and formulas; a node labeled by any may be
mapped to nodes with any activity name. For non-

transitive compound activity pairs in p, nodes in
their direct implementation are mapped to nodes
in the direct implementation of the corresponding
activity pair in e. As for edges, each (transitive)
edge from node m to n in p is mapped to an edge
(path) from ψ(m) to ψ(n) in e.

We then distinguish between selection and pro-

jection queries, as follows.

Selection Queries. A selection query is represented
by an EX-pattern. An EX-ﬂow e belongs to the
query result if there exists some embedding of p
into e. We then say that e satisﬁes p. When eval-
uated against a Business Process s, the output of p
consists of all full EX-ﬂows of s that also satisfy p;
the set of top-k most likely out of these EX-ﬂows
are denoted top-k(s,p).

Projection Queries. In many cases, analysts are not
interested in full execution ﬂows of the process, but
rather in focusing on some part of them. To that
end, we deﬁne projection queries over probabilis-
tic processes. For selection queries, the query re-
sult consisted of the full EX-ﬂow in which the EX-
pattern was embedded. We generalize the deﬁnition
of such queries and allow a speciﬁc part of the pat-
tern to be speciﬁed as the projected part. The rest
of the pattern serves for selecting EX-ﬂows of inter-
est. Namely, only EX-ﬂows in which an embedding
of the entire pattern are considered; within these
ﬂows, only nodes and edges matching the projected
part are in fact projected out and appear in the
query result.

(cid:2)

Given an embedding ψ of a query q in an EX-ﬂow
e, the embedding result is then deﬁned as the nodes
and edges of e to which ψ maps the nodes and edges
of the projected part of q. For an EX-ﬂow e, the
result of q on e, denoted q↓(e), consists of the results
of all possible embeddings of q into e; ﬁnally, for a
BP s, the result of q on s, denoted q↓(s) is the union
of all possible results of q when applied on the EX-
ﬂows of s. Namely q↓(s) =
e∈f lows(s) q↓(e) where
ﬂows(s) is the set of possible EX-ﬂows of s.

Note that an EX-ﬂow e(cid:3) ∈ q↓(s) may originate
from several EX-ﬂows of s, namely there may be
several e ∈ f lows(s) s.t. e(cid:3) ∈ q↓(e). Before deﬁn-
ing the top-k projection results, we should ﬁrst
decide on how to aggregate the weights of these
individual EX-ﬂows, to form the score of projec-
tion result. We consider two possible aggregation
functions (and consequently, semantics of queries),
max and sum. Under max semantics, the score of
e(cid:3) is deﬁned as score(e(cid:3)) = max{f-likelihood(e) |
e ∈ f lows(s) ∧ e(cid:3) ∈ q↓(e)}. Under sum semantics,

SIGMOD Record, June 2010 (Vol. 39, No. 2)

31

Figure 3: Query

score(e(cid:3)) =

(cid:3)

e∈f lows(s)∧e(cid:2)∈q↓(e) f-likelihood(e).

The top-k results of a projection query q over
a BP speciﬁcation s, with respect to max (sum)
semantics, are then denoted top-kmax(q↓, s) (top-
ksum(q↓, s)). When the semantics used is clear from
context, we omit it from notation and simply write
top-k(q↓, s).

Example 2.4. Let us consider again the EX-
pattern in Figure 3(a), this time as a query, with the
rectangle denoting its projected part. Note that the
projection focuses on the execution sub-ﬂows that
may occur between the point where a user chooses a
“BritishAirways” ﬂight and the ﬁnal conﬁrmation
of her reservation. Note that, due to recursive na-
ture of the BP, there are in general an inﬁnite num-
ber of such possible sub-ﬂows (query answers) - a
user may reset and restart the search an unbounded
number of times. Two possible answers to the query
appear in Fig. 3 (b) and (c). The ﬁrst answer corre-
sponds to users that choose at some point a “ﬂight-
sOnly” search, pick a “BA” ﬂight and then imme-
diately conﬁrm. The second answer corresponds to
users that choose at some point a “ﬂights+hotels”
search, pick “BA” as airline and Marriott as hotel,
and conﬁrm.

Observe that each of these answers (sub-ﬂow)
have potentially an inﬁnite number of possible origin
EX-ﬂows, diﬀering in what the user had done prior
to/after the reservation. The likelihood of each an-
swer is the max / sum of likelihoods of all these
origins, according to the semantics in hand.

To illustrate the diﬀerence between the two se-
mantics (max and sum), consider the above query
and a case where one particular deal D, consist-
ing of a speciﬁc ﬂight, hotel and car rental reserva-
tion, is very popular, but where packages consisting
of only ﬂight and hotel reservations (with no car
rental) are overall more common (even though each
given oﬀer is individually less popular than the spe-
ciﬁc ﬂight+hotel+car deal D). With sum seman-
tics, the result corresponding to the ﬂight+hotel op-

tion is ranked highest, as it appears in most EX-
ﬂows. But with max semantics, ﬂight+hotel+car
will be ranked highest, as there exists one very pop-
ular EX-ﬂow in which it appears.

3. QUERY EVALUATION

We next review the main results on query evalua-
tion over probabilistic Business Processes. We omit
the proofs and algorithms and refer the reader to
prior publications for the full details.

There are three axes that determine the complex-
ity of query evaluation: whether the BP speciﬁca-
tion is recursive or not, the class of the c−likelihood
function used in the process description (i.e.
its
level of dependency over the history), and the query
semantics (selection vs. projection). Interestingly,
when considering projection queries, the choice of
aggregation function also bears a signiﬁcant eﬀect
on the complexity of query evaluation. The com-
plexity results are summarized in Table 1.

We start the discussion with selection queries,

then proceed to projection queries.

3.1 Selection Queries

Given a BP speciﬁcation s, a selection query q,
and a number k, the top-k results of q with re-
spect to s (denoted top−k(q, s)) are deﬁned as the
k most likely ﬂows of s, out of those in which an
embedding of q exists. 1. We refer to the problem
of identifying top-k(q,s) (given the above input) as
TOP-K-ANSWERS.

We next discuss the problem complexity for the

diﬀerent classes of c−likelihood functions.

History-independent c−likelihood function. When
c−likelihood function is history-independent,
the
we can design an eﬃcient algorithm for top-k se-
lection query evaluation, as the following theorem

1Certain EX-ﬂows may have equal weights, which im-
plies that there may be several valid solutions to the
problem, in which case we pick one arbitrarily.

32

SIGMOD Record, June 2010 (Vol. 39, No. 2)

BP

Weight Function

(Non-)Recursive History-independent

Queries

Selection /

Data Complexity

PTIME [16, 17, 18]

Projection (max)

(Non-)Recursive

Bounded-History

Selection /

PTIME in BP,

Projection (max)

EXPTIME (NP-hard)

Recursive

Unbounded-History

Selection /
Projection

in bound [16, 17]

Undecidable [16, 17]

(Non-)Recursive History-independent
Non-Recursive
History-independent

Projection (sum)
Projection (sum)

EXPTIME, NP-hard [13]

PTIME

restricted

(unit-cost rat. arithmetic) [13]

(Non-)Recursive

Bounded-History

Projection (sum)

EXPTIME in BP,

EXPTIME

2-EXPTIME in bound [13]

Table 1: Complexity of query evaluation for Business Processes

Query Complexity

EXPTIME,
NP-hard [14]
EXPTIME

Undecidable

EXPTIME
EXPTIME

holds (the algorithm proving the theorem correct-
ness originally appeared in [16] and was improved
in [18]).

a query q, we may solve TOP-K-ANSWERS in time
polynomial in the size of s and in the output size,
and exponential in b and in the query size.

Theorem 3.1. [16, 18] Given a probabilistic BP
s with a history-independent c−likelihood function,
and a query q, we may solve TOP-K-ANSWERS in time
polynomial in the size of s and in the output size,
and exponential in the query size.

The algorithm solving TOP-K-ANSWERS works by
“intersecting” the BP speciﬁcation s with the query
q, outputting a BP speciﬁcation s(cid:3) whose EX-ﬂows
are exactly the EX-ﬂows of s in which there exists
an embedding of q. The algorithm then employs
a sophisticated A*-style analysis that explores the
space of possible EX-ﬂows of s(cid:3), by repeatedly test-
ing possible expansions of activities and avoiding
inﬁnite loops by maintaining a table of the previ-
ously computed sub-ﬂows in a dynamic program-
ming style.

We can also show that a PTIME algorithm
w.r.t. query size is not possible, unless P=NP. For
that, we deﬁne the corresponding decision problem
BEST-ANSWER, which tests, whether the top-1 EX-
ﬂow of a given BP speciﬁcation is more likely than
some threshold t. The following theorem holds (the
proof appears in [17], following a construction from
[14], using reduction from 3-SAT):

Theorem 3.2. [14, 17] BEST-ANSWER is NP-hard
when the input size is considered to be the query
size (and the BP speciﬁcation size is considered a
constant).

Bounded-History c−likelihood function. Bounded-
History c−likelihood functions pose further chal-
lenges, as the c−likelihood of each choice may de-
pend on a number of other choices. The following
theorem was shown in [17]:

Theorem 3.3. [17] Given a BP s, a bounded-
history c−likelihood function δ with bound b, and

The general idea of the algorithm is to create,
a new BP s(cid:3), with a new, history-independent,
c−likelihood function δ(cid:3), such that s and s(cid:3) have
essentially the same set of ﬂows with the same
f−likelihood . Then, we apply the algorithm from
the proof of Theorem 3.1. To obtain s(cid:3) and δ(cid:3)
we annotate the activity names in the speciﬁca-
tion, “factoring” within the names all information
required for the computation of c−likelihood of for-
mulas, namely a pre-condition vector, including the
m last choices for all activities. Additionally, the
new activities names also contain post-condition
vectors, necessary to assure consistencies between
pre-conditions assumed by activities and what has
happened in their predecessors.

It was further shown in [17] that the added ex-
ponential dependency on the history-bound b is in-
evitable, as the following theorem holds (proof by
reduction from Set Cover):

For

Theorem 3.4. [17]

bounded-history
c−likelihood functions with bound b, BEST-ANSWER
is NP-hard when the number of activities in the BP
speciﬁcation and in the query are considred to be
constants, and b is considered to be the input size.

Unbounded-History c−likelihood functions. Last,
for unbounded-history c−likelihood functions, we
showed in [16] that TOP-K-ANSWERS becomes impos-
sible to solve, as the following theorem holds:

Theorem 3.5. [16] If the c−likelihood function
then

given as input may be unbounded-history,
BEST-ANSWER is undecidable.

The proof is by reduction from the halting prob-
lem, where we encode a Turing Machine as a BP
speciﬁcation with unbounded-history c−likelihood
function; the latter is used to model the TM tape.

SIGMOD Record, June 2010 (Vol. 39, No. 2)

33

3.2 Projection Queries

We next turn to projection queries. It is easy to
observe that all hardness results presented above for
selection queries, also hold for projection queries.
However, it turns out that the upper bounds depend
upon the aggregation function in use. Speciﬁcally,
for the max semantics:

Theorem 3.6. [17] Theorems 3.1 and 3.3 hold

for projection queries with max semantics.

To prove Theorem 3.6 we adapt the algorithms
that were designed for selection queries to account
for projection queries with max semantics. A naive
attempt for such adaptation involves selection fol-
lowed by projection, namely the generation of a BP
speciﬁcation whose EX-ﬂows are the top-k selected
EX-ﬂows, then projecting these EX-ﬂows to ﬁnd the
top-k projections. However the size of the selected
EX-ﬂows, and consequently the algorithm complex-
ity is exponential in the size of the input BP speciﬁ-
cation, even when the projection results themselves
are of small size. Moreover, we may show that it
is infeasible to compute a BP speciﬁcation whose
EX-ﬂows correspond to all projection results and
then retrieve the top-k results out of them, intu-
itively because projection over transitive edges may
result in exponentially many paths which cannot be
compactly represented together. However, we may
still perform a two-steps algorithm, similar to the
one employed for selection queries: he ﬁrst step of
the reﬁned evaluation algorithm generates a speciﬁ-
cation that captures only a subset of the projection
results, where for each transitive edges only the top-
k matching paths are kept; this subset includes in
particular the top-k projections. We can then ﬁnd
the top-k EX-ﬂows of this speciﬁcation, which are
the top-k projection results with respect to max se-
mantics.

When the sum aggregation function is used,
query evaluation becomes much more diﬃcult.
Speciﬁcally, we can show the following:

Theorem 3.7. [13] For projection queries with
sum semantics, BEST-ANSWER is NP-hard (under
Turing computation model) in the BP size, even for
non-recursive speciﬁcations and for queries with no
transitive nodes.

The proof is by reduction from 3-SAT. Interest-
ingly, the problem is hard even for non-recursive
BPs. This is because the hardness is due to the
DAG structure of the BP graphs, that may lead
to exponentially many paths being projected over
the query transitive edges; consequently the sum
of likelihoods of exponentially many EX-ﬂows must

be computed. See the comparison in Section 5 to
Probabilistic XML.

On the other hand, under certain plausible as-
sumptions over the BP speciﬁcation structure, we
can design an algorithm whose complexity is EXP-
TIME in the BP speciﬁcation size. We say that a
projection query q w.r.t. a BP speciﬁcation s has
separated likelihoods, if for every two query answers,
either they have equal likelihoods or the diﬀerence
of their likelihoods is greater than some ﬁxed con-
stant (cid:6). The following theorem then holds:

Theorem 3.8. [13] For projection queries with
sum semantics and BP speciﬁcations with history-
independent c−likelihood function:, TOP-K-ANSWERS
may be solved in EXPTIME, for: (1) non-recursive
BP speciﬁcations, and (2) recursive BP speciﬁca-
tions, when the query has separated likelihoods w.r.t.
the speciﬁcation.

The algorithm uses a small world theorem, show-
ing that among the inﬁnitely many paths that may
match the query transitive edges, it is suﬃcient to
examine paths whose length is bounded by the size
of the BP speciﬁcation multiplied by k (the num-
ber of required results); consequently only exponen-
tially (in the above quantity) many paths are exam-
ined. Then, the algorithm reduces TOP-K-ANSWERS
to the computation of likelihoods for a set of ex-
ponentially many candidate answers that are rep-
resented as boolean queries, i.e. queries for which
we ask only for the likelihood of a match; ﬁnally,
techniques from [25] are adapted to approximate
the likelihood values of these boolean queries up to
a point allowing to separate the diﬀerent candidate
answers (this is why separated likelihoods are re-
quired). Exact computation of likelihood values for
boolean queries is impossible here since they may
in general be irrational [13], thus we must resort to
their approximation.

Note that the proof for NP-hardness (Theorem
3.7) used queries with transitive edges. When no
transitive edges are allowed in the query, our algo-
rithm is more eﬃcient, for non-recursive BP speciﬁ-
cations. Speciﬁcally, consider the unit-cost rational
arithmetic model [7]: in this model, when comput-
ing the complexity, we assume that each arithmetic
operation on rational numbers may be done in O(1),
regardless of the numbers size. The following theo-
rem then holds:

Theorem 3.9. [13] When the query projected
part does not include transitive edges, and the BP
speciﬁcation is non-recursive, TOP-K-ANSWERS for
projection queries with sum semantics may be solved

34

SIGMOD Record, June 2010 (Vol. 39, No. 2)

in PTIME under the unit-cost rational arithmetic
model.

The assumption of unit-cost rational arithmetic
is necessary here, as there are examples where even
non-recursive BP speciﬁcations and queries without
transitive edges yield projection results with prob-
abilities whose encoding is exponential in the BP
speciﬁcation size.

When the

c−likelihood is bounded-history, we
may ﬁrst use the construction depicted above for
proving Theorem 3.3 to obtain a new BP speci-
ﬁcation s(cid:3) with history-independent
c−likelihood
function, then apply the above algorithm. Note
that since the size of s(cid:3) may be exponential in the
history-bound, and the algorithm that ﬁnds the top-
k projections may incur exponential time in the
size of its input, the overall complexity is double-
exponential in the size of the bound. The following
theorem holds:

Theorem 3.10. [13] For projection queries with
sum semantics and BP speciﬁcations with bounded-
c−likelihood function with bound b,
history
TOP-K-ANSWERS may be solved in time exponential
in the size of the BP speciﬁcation and double ex-
ponential in b, for: (1) non-recursive BP speciﬁca-
tions, and (2) recursive BP speciﬁcations, when the
query has separated likelihoods w.r.t. the speciﬁca-
tion.

4. ADDITIONAL MODELS

We have depicted above our model for probabilis-
tic Business Processes. The literature contains a
variety of formalisms for probabilistic process spec-
iﬁcations. We next discuss a representative sub-
set of these models; for each model we review the
query languages used for its analysis, and the cor-
responding complexity results for query evaluation.
A summary of the models and results reviewed in
this Section appears in Table 2. We also compare
and contrast these models with the model of prob-
abilistic BP.

4.1 Markov Chains

The probabilistic counterpart of Finite State Ma-
chines (FSMs) is called Markov Chains (MCs) [30].
MCs are in fact FSMs, but with transitions as-
sociated with probabilities; these state machines
bear the Markovian property [30], meaning that the
choice of transition is independent of the previous
states that were traversed, given the current state.
The common approach in analysis of such processes
is to use a query language based on temporal logic
[33], e.g. LTL, CT L∗ or μ-calculus (these diﬀer

from each other in terms of expressive power, see
e.g.
[33]). Query evaluation for such logics then
correspond to computing the probability that the
property deﬁned by the given query, holds for a ran-
dom walk over the Markov Chain. It is known that
query evaluation of such temporal logic queries over
a Markov Chain may be performed in time polyno-
mial in the size of the Markov Chain, and exponen-
tial in the query size [11].

Comparison to the BP model and query language.
Finite State Machines (and consequently, Markov
Chains) lack the expressive power to capture the
possibly recursive processes allowed in the BP
model here (we shell see in the sequel that BPs
are equivalent to “stronger” models). The deﬁni-
tion of history-unbounded c−likelihood functions
resembles (and is inspired by) the Markovian Prop-
erty.

As for the query language, a ﬁrst observation is
that temporal logic allows only for boolean queries
(i.e. computing the probability that a given boolean
property holds), while selection and projection
queries of the kind depicted in Section 2 were not
studied in the context of Markov Chains (to the
best of our knowledge). But even when considering
just boolean queries, there are queries expressible
in our language but not in temporal logic. To that
end, note that temporal
logics are bisimulation-
invariant, intuitively meaning that they can query
only the process “behavior” rather than its struc-
ture (see [14] for exact notions).
In contrast, our
query language takes a database approach and al-
lows to further query the structure of the process
as well as the structure of its possible executions.
Indeed, we have shown in [14] that some queries ex-
pressible in our query language are not expressible
in temporal logic (and vice versa).

4.2 Introducing Function Calls

As stated above, Markov Chains are the proba-
bilistic counterpart of Finite State Machines. Sim-
ilarly,
there exist probabilistic counterparts to
stronger model; these models allow for function
calls, and in their full-ﬂedged version, also for
recursion. Speciﬁcally, Recursive Markov Chains
(RMCs) [25] extend Markov Chains to allow for re-
cursive invocations of procedures. An RMC con-
sists of a collection of ﬁnite state components, each
of which is a Markov chain, that can call each other
in a potentially recursive manner. The authors of
[25] further show that RMCs generalize (and can ex-
press) previous important models for probabilistic
processes such as probabilistic Pushdown Automata
[9], and Stochastic Context Free Grammars [32].

SIGMOD Record, June 2010 (Vol. 39, No. 2)

35

Model

MC
RMC

HMC

Query

Temporal

MSO

MSO

MSO

Data Complexity

PTIME

EXPTIME,

at least as hard as SQRT-SUM

(with unit-cost relational arithmetic)

PTIME

PTIME
PTIME

Query Complexity

EXPTIME

Non-elementary

Non-elementary

Non-elementary

(cid:2)P -complete

Tree-like HMC

Prob. XML [31, 37] (non-recursive)

Selection / Projection

Table 2: Complexity of query evaluation for diﬀerent models

Query evaluation over RMCs was ﬁrst studied in
[25] for approximating the probabilities of reacha-
bility and termination.
In a recent work, [6] has
extended the analysis for a very strong query lan-
guage, namely the Monadic Second Order (MSO)
Logic. Denote as MSO-EVAL the problem of com-
puting the probability that a given MSO query is
satisﬁed in a random execution of an RMC; the fol-
lowing theorem then holds:

Theorem 4.1. [24] MSO-EVAL can be per-
formed in EXPTIME Data Complexity and non-
elementary query complexity.

(cid:3)

It is highly unlikely that query evaluation for
RMCs may be solved in PTIME, as [25] showed
that this problem is at least as hard as SQRT-SUM.
SQRT-SUM is the problem of deciding, given natu-
ral numbers (d1, ..., dn) and a natural number k,
di ≤ k, strongly believed not
whether
be solvable in PTIME under Turing Computation
Model [27]. Interestingly, this hardness result holds
even for very simple reachability and termination
analysis, and even when we are only interested in
approximating the probabilities.

i=1,...,n

√

Also note in this context the non-elementary
query complexity of the evaluation problem. This
complexity is entailed by the use of the highly ex-
pressive MSO logic as a query language, and is un-
avoidable even for weaker process models due to
[38].

Several restricted variants of RMCs were studied
in [6, 25]; speciﬁcally, HMCs (Hierarchical Markov
Chains) is a restricted version that does not allow
for recursive calls.
Interestingly, query evaluation
here is still harder than for non-hierarchical MCs.
This is due to the fact that the probability of a
given property may be so small that exponentially
many bits are required to represent it. This, in
turn is due to the function-like structure of HMCs
that allow several functions to call a single function;
in this way, exponentially many call paths may be
represented compactly.

Thus, for the Turing computational model there
is no hope for a PTIME data complexity algorithm.
However, if we use the unit-cost rational arithmetic

model [7], we do not have to care about the size of
numbers. The following theorem then holds:

Theorem 4.2. [6] MSO-EVAL for HMC can be
performed in PTIME Data Complexity (and non-
elementary query complexity), under the unit-cost
rational arithmetic model.

If the HMC possible calls graph has a tree-shape,
then the above problem is avoided and we obtain
a PTIME data complexity under the conventional
Turing Computational Model

Theorem 4.3. [6] MSO-EVAL for Tree-Like
HMCs ([6]) can be performed in PTIME Data Com-
plexity (and non-elementary query complexity), un-
der the Turing Computational Model

Comparison to the BP model and query lan-
guage. Our Business Process model with history-
independent likelihood functions may be shown to
be equivalent to a restricted version of RMCs,
namely 1-exit RMCs (the proof is an adaptation
of Theorem 3 in [14] to a probabilistic context),
and similarly non-recursive Business Processes are
equivalent to 1-exit HMCs. To our knowledge, no
extended model for RMCs that allows for depen-
dencies in-between probabilistic choices was stud-
ied. As for the query language, our language (when
queries are considered as boolean) is contained in
MSO in terms of expressive power. But note that
the use of MSO is very costly:
it incurs non-
elementary query complexity, with respect to the
EXPTIME obtained for our language. Our query
language is restricted, but is expressive enough
to express interesting and practical properties as
shown in [5], while allowing for a practically eﬃ-
cient evaluation. Furthermore, as the case for MCs,
selection and projection queries were not studied in
the context of RMCs (to our knowledge).

4.3 Probabilistic XML

It turns out that there are intricate connections
between Probabilistic XML and probabilistic pro-
cesses. Speciﬁcally, the recent work of [6] mentioned

36

SIGMOD Record, June 2010 (Vol. 39, No. 2)

above establishes a model for Probabilistic XML
that is based on Recursive State Machines. Then,
in addition to their study of MSO queries, they
study more restricted languages which are com-
mon for XML querying such as (boolean) Tree Pat-
tern Queries and XPath, and show that they incur
lower query complexity: F P (cid:2)P (the class of compu-
tation problems that can be solved in polynomial
time using a (cid:7)P oracle) for tree pattern queries and
PSPACE for XPath.

Previous works on Probabilistic XML documents
[2, 3, 31, 37] used non-recursive models for express-
ing distributions over a ﬁnite collection of possible
documents. In [31], a p-document is an XML tree
with two types of nodes: ordinary nodes which are
just regular XML nodes, and distributional nodes
that deﬁne some probabilistic distribution over sub-
sets of their children. A random XML document
may then be generated by making probabilistic
choices that follow these distributions. The authors
of [31] then study query evaluation over p-document
and use a language that allows for selection and
projection; the semantics used there for projection
is the counterpart of our sum semantics, and they
show that query evaluation is feasible, as follows:

Theorem 4.4. [31] Query Evaluation over p-
documents may be done in time complexity that is
polynomial in the p-document size, and exponential
in the query size.

They also show that the exponential dependency

on the query size is inevitable, unless P = (cid:7)P .

Comparison to the BP model and query language.
An important distinction between the model of [31]
and our BP model is that BP graphs are DAG-
shaped while XML graphs are tree-shaped. Evi-
dently, this diﬀerence causes an unavoidable (unless
P=NP) exponential overhead in query evaluation,
and also complicates the algorithmic construction
(see [13] and the discussion in Section 3). While [6]
considers XML with sharing, a model that does al-
low for DAG-shape graphs in the speciﬁcation, the
weaker query languages (tree patterns and XPath)
studied in this cannot capture the DAG-shaped pat-
terns expressible in our query language; also, [6]
only studies boolean queries in contrast to the selec-
tion and projection queries allowed in our language.

5. CONCLUSION

We have reviewed in this paper several impor-
tant models for specifying and querying probabilis-
tic processes and compared them in terms of ex-
pressive power and complexity of query evaluation.

We further depicted our proposed model for Busi-
ness Process and our query language that allows for
top-k selection and projection queries. We then ex-
plained how our proposed model achieves a reason-
able balance between expressivity and evaluation
complexity.

Clearly, more work has to be done to capture
real-life probabilistic processes and analysis tasks.
In particular, while the models consider, to some
extent, the data manipulated in the process execu-
tion, more work is required for modeling and query-
ing such manipulated data in real-life settings. The
modeling (and analysis) of the data manipulated
by processes was studied in e.g.
[12, 20, 21, 22,
26, 28], but the processes studied there were not
probabilistic; combining these two lines of research
into a uniﬁed framework for probabilistic processes
along with the data they manipulate. Additionally,
we have discussed selection and projection queries,
the latter with two particular aggregation functions
(sum and max);
in [1] the authors study aggre-
gate queries for “monoid” aggregate functions (in-
cluding sum, count, min, max) for Probabilistic
XML. Studying further operations such as value-
based joins and projection with diﬀerent aggrega-
tion functions, in the context of the diﬀerent models
presented here is an intriguing challenge.

Acknowledgments
This research was partially supported by the Is-
raeli Science Foundation (ISF), the US-Israel Bina-
tional Science Foundation (BSF), the EU Project
Mancoosi and the Israel Ministry of Science Eshkol
grant.

6. REFERENCES

[1] S. Abiteboul, T.H. Hubert Chan,

E. Kharlamov, W. Nutt, and P. Senellart.
Aggregate queries for discrete and continuous
probabilistic XML. In ICDT, 2010.

[2] S. Abiteboul, B. Kimelfeld, Y. Sagiv, and

P. Senellart. On the expressiveness of
probabilistic XML models. VLDB J., 18(5),
2009.

[3] S. Abiteboul and P. Senellart. Querying and
updating probabilistic information in XML.
In Proc. of EDBT, 2006.

[4] R. Alur, M. Benedikt, K. Etessami,

P. Godefroid, T. Reps, and M. Yannakakis.
Analysis of recursive state machines. ACM
Trans. Program. Lang. Syst., 27(4), 2005.

[5] C. Beeri, A. Eyal, S. Kamenkovich, and

T. Milo. Querying business processes. In Proc.
of VLDB, 2006.

SIGMOD Record, June 2010 (Vol. 39, No. 2)

37

[6] M. Benedikt, E. Kharlamov, D. Olteanu, and

P. Senellart. Probabilistic XML via Markov
chains. PVLDB, 3(1), 2010.

[7] L. Blum, F. Cucker, M. Shub, and S. Smale.

Complexity and real computation.
Springer-Verlag, 1998.

[8] Business Process Execution Language for Web

Services.
http://www.ibm.com/developerworks/library/ws-
bpel/.

[9] T. Brazdil, A. Kucera, and O. Strazovsky. On

the decidability of temporal properties of
probabilistic pushdown automata. In Proc. of
STACS, 2005.

[10] D. Chamberlin. Xquery: a query language for

XML. In Proc. of SIGMOD, 2003.

[11] C. Courcoubetis and M. Yannakakis. The
complexity of probabilistic veriﬁcation. J.
ACM, 42(4), 1995.

[12] T. Deng, W. Fan, L. Libkin, and Y. Wu. On
the aggregation problem for synthesized web
services. In Proc. of ICDT, 2010.

[13] D. Deutch. Querying Web Applications Under

Models of Uncertainty. PhD thesis, Tel Aviv
University, 2010.
http://www.cs.tau.ac.il/ danielde/PhdThesis.pdf.

[14] D. Deutch and T. Milo. Querying structural

and behavioral properties of business
processes. In Proc. of DBPL, 2007.

[15] D. Deutch and T. Milo. Type inference and

type checking for queries on execution traces.
In Proc. of VLDB, 2008.

[16] D. Deutch and T. Milo. Evaluating top-k

queries over business processes. In Proc. of
ICDE, 2009.

[17] D. Deutch and T. Milo. Top-k projection

queries for probabilistic business processes. In
Proc. of ICDT, 2009.

safety analysis of pointer-based codes. In
LCPC, 2003.

[24] K. Etessami and M. Yannakakis. Algorithmic

veriﬁcation of recursive probabilistic state
machines. In Proc. of TACAS, 2005.

[25] K. Etessami and M. Yannakakis. Recursive
Markov Chains, stochastic grammars, and
monotone systems of nonlinear equations.
JACM, 56(1), 2009.

[26] C. Fritz, R. Hull, and J. Su. Automatic

construction of simple artifact-based business
processes. In Proc. of ICDT, 2009.

[27] M. R. Garey, R. L. Graham, and D. S.
Johnson. Some np-complete geometric
problems. In Proc. of STOC, 1976.

[28] R. Hull and J. Su. Tools for composite web
services: a short overview. SIGMOD Rec.,
34(2), 2005.

[29] D. Jurafsky, C. Wooters, J. Segal, A. Stolcke,
E. Fosler G. Tajchman, and N. Morgan. Using
a stochastic context-free grammar as a
language model for speech recognition. In
Proc. of ICASSP, 1995.

[30] J. G. Kemeny and J. L. Snell. Finite Markov

Chains. Springer, 1976.

[31] B. Kimelfeld and Y. Sagiv. Matching twigs in

probabilistic XML. In Proc. of VLDB, 2007.
[32] K. Lary and S. J. Young. The estimation of
stochastic context-free grammars using the
inside-outside algrithm. Computer, Speech and
Language, 4:35–56, 1990.

[33] Z. Manna and A. Pnueli. The temporal logic

of reactive and concurrent systems.
Springer-Verlag, 1992.

[34] T. Oates, S. Doshi, and F. Huang. Estimating
maximum likelihood parameters for stochastic
context-free graph grammars. In Proc. of ILP,
2003.

[18] D. Deutch, T. Milo, N. Polyzotis, and T. Yam.

[35] T. Pavlidis. Linear and context-free graph

Optimal top-k query evaluation for weighted
business processes. In Proc. of VLDB, 2010.

grammars. J. ACM, 19(1), 1972.
[36] P. L. T. Pirolli and J. E. Pitkow.

[19] D. Deutch, T. Milo, and T. Yam.

Goal-oriented web-site navigation for on-line
shoppers. In Proc. of VLDB, 2009.

[20] A. Deutsch, M. Marcus, L. Sui, V. Vianu, and
D. Zhou. A veriﬁer for interactive, data-driven
web applications. In Proc. of SIGMOD, 2005.

Distributions of surfers’ paths through the
world wide web: Empirical characterizations.
World Wide Web, 2(1-2), 1999.

[37] P. Senellart and S. Abiteboul. On the

complexity of managing probabilistic XML
data. In Proc. of PODS, 2007.

[21] A. Deutsch, L. Sui, V. Vianu, and D. Zhou.

[38] L. Stockmeyer. The Complexity of Decision

Veriﬁcation of communicating data-driven
web services. In Proc. of PODS, 2006.

[22] A. Deutsch and V. Vianu. Wave: Automatic
veriﬁcation of data-driven web services. Data
Eng. Bull., 31(3), 2008.

[23] P. Diniz. Increasing the accuracy of shape and

Problems in Automata Theory and Logic.
PhD thesis, Massachusetts Institute of
Technology, 1974.

38

SIGMOD Record, June 2010 (Vol. 39, No. 2)

