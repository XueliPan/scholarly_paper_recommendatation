Querying Web-Based Applications Under Models of

Uncertainty

Daniel Deutch

Supervised by Prof. Tova Milo

Tel Aviv University

ABSTRACT
Many businesses oﬀer their services to customers via Web-
based application interfaces. Reasoning about execution
ﬂows of such applications is extremely valuable for compa-
nies. Such reasoning must often operate under terms of
uncertainty and partial information, due to partial tracing,
eﬀects of unknown external parameters, and more. The ob-
jectives of this research are (1) to deﬁne models for cap-
turing Web application executions, with partial information
and uncertainly of various ﬂavors, (2) to design algorithms
that allow for eﬃcient reasoning over applications/execution
traces under these models, and (3) to provide practical im-
plementations that exploit these sound theoretical founda-
tions for eﬀective optimization of Web applications. We
identify a restricted class of models that capture realistic
scenarios, while allowing for an eﬃcient query-based appli-
cations analysis. Hardness results indicate the necessity of
such restricted models. We describe these results, highlight
open problems, and consider directions for future research.

1.

INTRODUCTION

A Business Process (BP for short) consists of some busi-
ness activities undertaken by one or more organizations in
pursuit of some particular goal. Customers (and other busi-
nesses) often interact with such BPs via Web-based appli-
cation interfaces, which are extremely popular nowadays.
The ﬂow of such applications depends on many variables
whose values are known only at run-time. Among them
one may ﬁnd user choices, servers availability, response time
and more. To allow for applications analysis, it is a common
practice to trace the execution ﬂow, logging the performed
activities along with their relative order and causality re-
lationship. Reasoning about execution traces of such ap-
plications is extremely valuable for companies:
it can be
used to optimize business processes, employ targeted adver-
tisements, reduce operational costs, and ultimately increase
competitiveness. Such reasoning often operates in an envi-
ronment that induces partial information and uncertainty

Permission to make digital or hard copies of portions of this work for 
personal or classroom use is granted without fee provided that copies 
Permission to copy without fee all or part of this material is granted provided
are not  made or distributed for  profit or commercial advantage and 
that the copies are not made or distributed for direct commercial advantage,
 
that copies bear this notice and the full citation on the first page.
the VLDB copyright notice and the title of the publication and its date appear,
Copyright for components of this wor k owned by  others than VLDB 
and notice is given that copying is by permission of the Very Large Data
Endowment must be honored. 
Base Endowment. To copy otherwise, or to republish, to post on servers
Abstracting with c redit is permitted. To copy otherwise, to republish, 
or to redistribute to lists, requires a fee and/or special permission from the
to post on servers or  to redistribute to lists requires  prior specific 
publisher, ACM.
permission and/or a fee. Request permission to republish from: 
VLDB ‘08, August 24-30, 2008, Auckland, New Zealand
Publications Dept., ACM, Inc. Fax +1 (212)869-0481 or  
Copyright 2008 VLDB Endowment, ACM 000-0-00000-000-0/00/00.
permissions@acm.org. 
 
PVLDB '08, August 23-28, 2008, Auckland, New Zealand 
Copyright 2008 VLDB Endowment, ACM 978-1-60558-306-8/08/08 

of various ﬂavors. First, the execution traces recorded for
a Web application often contain only partial information
on the activities that were performed at run time. This
may be due to conﬁdentiality, lack of storage space, etc.
Second, even in the presence of fully detailed traces of the
past executions, prediction of the behavior of future execu-
tions should naturally consider uncertainty. This is because
executions often depend on unknown external parameters,
such as users behavior, interaction with other applications,
servers response time, etc. To enable such reasoning, the
possible/typical execution ﬂows of applications must be ﬁrst
characterized and then eﬀectively analyzed. We focus on two
complementing sorts of characterization, detailed below.

Traces structure. Schema and type information has proved
to be extremely useful for the management of semi-structured
and XML data. Knowledge about the typical structure
(shape) of data items allows for intuitive query formulation,
optimized query processing, minimization of run time errors,
and more [19, 4]. Such knowledge is commonly referred to as
type information. Process execution traces can be abstractly
viewed as a particular class of semi-structured data having
the shape of Directed Acyclic Graphs (DAGs), which de-
scribe the execution ﬂow. [3] showed that type information
is also critical for (optimized) analysis of execution traces.
While formal process speciﬁcations (e.g. in the style dic-
tated by the BPEL standard [5]) provide knowledge about
the possible shape of execution traces, it turns out that a
much more careful characterization of the traces shape is re-
quired in practice. First, as mentioned above, the execution
traces recorded for Web applications often contain only par-
tial information on the activities that were performed at run
time (namely only part of what is given in the formal process
speciﬁcation is actually recorded). Second, when execution
traces are queried, the process speciﬁcations provide type
information only about the input traces, but not about the
output sub-traces selected by queries. To address this, we
study, for the ﬁrst time, the management of type informa-
tion for process execution traces. Speciﬁcally, we consider
here type inference and type checking for queries over BP
execution traces. The queries that we consider select por-
tions of the traces that are of interest to the user; the types
describe the possible shape of the execution traces in the
input/output of the query. We formally deﬁne and charac-
terize here three common classes of BP execution tracing
systems that vary in the amount of information that they
record on the run, and consider their respective notions of
type inference and type checking. We study the complex-

1659

ity of the two problems for query languages of varying ex-
pressive power and present eﬃcient type inference/checking
algorithms where possible. Our analysis aims to provide
a complete picture of which combinations of trace classes
and query features lead to PTIME eﬀective algorithms and
which to NP-complete/undecidable problems.

Traces likelihood. A second characterization of interest
is by likelihood. The execution course of a BP depends
on many variables, such as users behavior, interaction with
other applications and servers response time, whose actual
value is known only at run time. However, examining a set
of execution traces, one will often observe that some execu-
tion traces (or patterns thereof) are more likely than others.
Identifying the top-k most likely traces (satisfying certain
query criteria), is crucial for various applications, such as
adjustments of Web-sites design to ﬁt the needs of certain
user groups, personalization of on-line advertisements, en-
hancements to business logic etc. To allow for top-k traces
selection, one ﬁrst needs a model describing all the possi-
ble executions of the BP, as well as their likelihood. Sec-
ond, given such a model and a query describing a family
of execution traces (usage patterns) of interest, an eﬃcient
mechanism to identify the top-k qualifying traces is required.
Much eﬀorts have been directed recently to addressing the
ﬁrst issue, namely the inference of a proper BP model out a
given set of execution traces, using a variety of data mining
techniques (see related work). The second issue, namely ef-
ﬁcient querying and analysis of the BP model, has been less
successfully addressed so far. Our work aims at providing a
set of algorithms that address this problem, under various
settings. These algorithms will be a basis for practical im-
plementations that exploit the sound theoretical foundations
for eﬀective optimization of Web applications.

In the following sections we give an intuitive, informal de-
scription of our models and the results obtained so far. The
formal deﬁnitions and the detailed theorems and algorithms
appear in [9, 11].

2. PRELIMINARIES

We start by reviewing (informally) the main concepts that
stand at the center of our research. In this section, we intro-
duce a basic form of each concept; their extended variants
that capture uncertainty are discussed in section 3. While
the models that we use for describing BP speciﬁcations and
queries are an abstraction of those considered in [2, 3], they
are abstract, conforming to various formalisms.

Business Processes. We use below the term Business Process
(BP) to describe the essence of the (Web) applications that
we consider here. The recent BPEL standard (Business
Process Execution Language [5]) allows to describe the full
operational logic and execution ﬂow of BPs. A BPEL speciﬁ-
cation describes a process as a nested DAG (Directed Acyclic
Graph) consisting of activities (nodes), and links (edges) be-
tween them. Links detail the execution order of the activ-
ities. Activities may be either atomic or compound. In the
latter case, each of their possible internal structures (called
implementation) is also detailed as a DAG, leading to the
nested structure. In each DAG, a unique node is marked as
start (end) node.

Example 2.1. A schematic graphical example for a BP

1660

Figure 1: Business Process

speciﬁcation of a Web-based travel agency is depicted in Fig-
ure 1. Each activity is represented here by a pair of nodes,
the ﬁrst (having darker background) standing as the activ-
ity’s activation point and the second as its completion point.
The BP starts at the compound Trip activity. Then, the user
may choose between reserving a regular trip and a luxurious
one. The ﬁrst choice leads to the implementation whose ﬂow
is depicted in the leftmost big bubble. The second choice leads
to the Luxury compound activity, whose internal ﬂow (im-
plementation) is depicted in the rightmost big bubble. In the
two implementations, the user may search, in parallel (e.g.
by opening new browser windows), for hotels and ﬂights (reg-
ular or luxury). In each implementation, the user is directed
to a billing system, represented by the Credit1 and Credit2
activities (for regular and luxury reservations, respectively).

Execution Traces. An instance of a BPEL speciﬁcation is
an actual running process that follows the logic described in
the speciﬁcation. BP Management Systems allow to trace
instance executions. An execution trace can be abstractly
viewed as a (nested) DAG that contains nodes represent-
ing the activation (start) and completion (end) events of
activities, and edges that describe their ﬂow. For a com-
pound activity, the events corresponding to its internal ﬂow
are recorded between its activation and completion events,
and are connected to them using distinctly marked zoom-in
edges. The nesting of DAGs in the trace follows naturally
from the BP nested structure.

Example 2.2. Consider the trace depicted in Figure 2(a).
zoom-in edges are depicted as dashed arrows, and follow-
ing them reveals internal traces of the corresponding com-
pound activities. For example, zooming into Trip reveals
that a Search was performed, then the corresponding ho-
tel and ﬂight were reserved (in parallel), by the Hotel and
Flight activities, resp., and a conﬁrmation was printed.
Queries. We use an abstraction of the query language sug-
gested in [3], where queries are deﬁned using execution pat-
terns, whose structure is similar to that of execution traces.
Some of the pattern’s edges may be marked as transitive,
seeking for a path connecting the edge end-nodes, rather
than a single edge; similarly, composite nodes may be marked
as transitive, seeking for possibly indirect implementations.
To evaluate a query, we search for occurrences of the ex-
ecution pattern in the execution traces, represented by em-
beddings. An embedding is a homomorphism from all nodes

the BP are recorded. More general cases, where only partial
information is recorded, will be considered in the following
section. For queries over BP execution traces we will con-
sider both the input type, for which the BP speciﬁcation is
readily available, as well as the output type that captures
sub-traces selected by queries, and for which type informa-
tion will be inferred.

3. MODELS OF UNCERTAINTY

We next extend our model to account for uncertainty
caused by partial tracing, as well as uncertainty caused by
external events. We present the corresponding problems,
our proposed solutions, and their practical implications.

3.1 Partial Tracing

We present a model for partial tracing, then list our ini-
tial results for Type Inference and Type Checking in these
settings.

Model Loggers that generate execution traces of BPs
may vary in the amount of information that they record
on runs. To account for that, we distinguish three fami-
lies of execution trace types, with increasing ﬂexibility (and
decreasing amount of guaranteed information), as follows:
Naive tracing provides a complete record of tracing provides
a complete record of the activation/completion events of all
activities, along with the corresponding activities names;
Semi-Naive tracing provides a record of all activation/ com-
pletion events, but possibly with only partial information
about their corresponding activities names; and Selective
tracing provides only a record of some subset of the activa-
tion/completion events, possibly reported with only partial
information about their corresponding activities names.

Next, we present examples for the diﬀerent sorts of tracing

systems, and the obtained traces.

Example 3.1. Figures 2 (a) and (b), described above,
present examples for naive traces of the BP in Figure 1.
Note that these traces disclose that a diﬀerent billing system
is invoked for luxury and regular reservations. To avoid such
disclosure, we may rename the logged activities, so that the
traces contain a generic activity name such as Credit, in-
stead of the Credit1 and Credit2 names. This is captured
by the notion of semi-naive tracing system, represented by a
renaming function over the activities names. Figures 2 (c)
and (d) present semi-naive traces of our BP, obtained from
the executions that led to Figures 2 (a) and (b) resp.

In some cases, a more selective tracing is used, where the
occurrence of some activities is not recorded at all, due to
conﬁdentiality, storage constraints etc. A selective tracing
system is represented by a renaming function and a deletion
set; the record of all occurrences of activities names that ap-
pear in the deletion set is omitted. For instance, if our travel
agency wishes to keep as a secret the fact that reservations of
diﬀerent types are treated diﬀerently, then not only the credit
checks activities need to be re-labeled, but also the LuxHotel
and the LuxFlight activities, and the record of the Luxury
activity should be omitted altogether. Figure 2(e) is the se-
lective trace obtained from the naive trace in Figure 2 (b),
as well as by (a), by applying such renaming and deletion
operations. Thus, the goal of secrecy is achieved.

Types Revisited We have mentioned above that a type
for a set T of traces consists of (a) a Business Process spec-
iﬁcation and (b) a tracing system, such that T is exactly

Figure 2: Execution traces

Figure 3: A query and its results

and edges of the pattern to some nodes and edges of the
trace, such that for matched nodes, their activity names co-
incide, and composite (atomic) nodes are mapped to com-
posite (atomic) nodes. Non-transitive edges (both regular
and zoom-in) of the query are mapped to corresponding
edges of the trace, such that the end-points in the pattern
are mapped to the corresponding end-points in the trace.
Transitive edges may be mapped to paths (containing ﬂow
or zoom-in edges), and implementations of transitive query
nodes may be mapped to indirect implementations of the
corresponding nodes in the speciﬁcation.

Example 2.3. An example execution pattern is depicted
in Fig. 3 (a). It zooms-in transitively into Trip, searching
for a Credit1 activity. Double-bounded nodes (double-lined
edges) denote transitive nodes (resp. edges). Fig. 3(b) and
(c) depict its two possible matches in the trace of Fig. 2(a).

Types. A family of BP execution traces is captured by the
notion of type. A type consists of (1) a BP speciﬁcation
and (2) a tracing system, that records activities of the BP
execution. In the simplest case, all activities performed by

1661

the set of traces logged for all possible executions of the
process. We have already deﬁned the notion of business
processes, and we may now formally formulate the notion
of a tracing system:
it consists of (1) a renaming function
over the activities names and (2) a deletion set, which is
a subset of the activities names set. The semantics is that
run-time occurrences of activities are recorded as their image
under the renaming function; and occurrences of activities
whose names appear in the deletion set are omitted from
the execution log altogether. If the renaming function is the
identify function and the deletion set is empty, the tracing
system is naive; if only the latter holds, the tracing system
is semi-naive; otherwise selective.

Our results We study the problems of Type Checking
and Type Inference for queries over execution traces, for all
cases of tracing systems. The two problems are practically
well-motivated, as querying execution traces repositories is
often done in two steps: the repository is ﬁrst queried to
select portions of the traces that are of particular interest.
Then, these serve as input to a ﬁner analysis that further
queries and mines the sub-traces to derive critical business
information [22]. Not surprisingly, type information, i.e.,
knowledge about the possible structure of the queried (sub-
)traces, is valuable for query optimization [3].
Its role is
analogous to that of XML schema for XML query optimiza-
tion:
it allows to eliminate redundant computations and
simplify query evaluation. Such type information is readily
available, as the BPEL speciﬁcation, for the original traces.
However, this information is not available for the sub-traces
selected by queries. We develop eﬃcient algorithms for de-
riving this type information. At another level, when the
analysis tool expects data of particular type, we would like
to guarantee that the sub-traces selected by the queries con-
form to the required type. Such type checking is a second
problem that we study. We examine the two problems in
presence of naive, semi-naive and selective tracing systems,
for both the input and output types. Our results follow. For
space constraints, we may not give here the exact proofs for
our results, but rather explain the intuition behind them;
the exact theorems and proofs appear in [11].

Type Inference. In the type inference problem we are given
an input type and a query over its traces, and our goal is to
infer an output type that represents only the (sub-) traces
that conform to the query. The problem is naturally para-
meterized by the tracing systems of the input and output
type. We consider all possible variants:

• If the output type is restricted to a naive tracing sys-
tem, we show that type inference may not be possible.

• If the output type is restricted to a semi-naive trac-
ing system, we give an algorithm for type inference.
However, we show that, inevitably, the size of the out-
put type may be exponential in the size of the input
type and query. This holds even if the input type is
restricted to a naive tracing system.

• If a further more ﬂexible, selective tracing system is
allowed for the output type, we provide an algorithm
that performs type inference, whose time complexity
is polynomial in the size of the input type, with the ex-
ponent determined by the query size. This holds even
if the input type contains a selective tracing system.

Intuition

• To observe that naive tracing system may be insuﬃ-
cient for capturing exactly the traces set selected by
a query, consider a BP speciﬁcation s whose ﬂow con-
tains two consecutive nodes labeled by the compound
activity name a. a bears two diﬀerent implementa-
tions, one containing an activity name b, and the sec-
ond containing c. Obviously, the set of possible exe-
cution traces corresponds to all combinations of b / c
followed by b / c. Now consider a query that requires a
choice of b for the ﬁrst a-labeled activity, and a choice
of c for the second b-labeled activity. It is easy to see
that no BP speciﬁcation may have the unique trace
corresponding to the query as its only naive trace

• In contrast, if the output type may use a semi-naive
tracing system, type inference is possible. For the
above example, the new BP will contain two activ-
ity names a1 and a2, the ﬁrst having b as its single
implementation and the second having c as its single
implementation. The renaming function will then map
both a1 and a2 to a.

In general, the type inference algorithm follows the
lines of the query evaluation algorithm in [10]. The al-
gorithm generates an “intersection” between the origi-
nal BP speciﬁcation and the query. The pattern spec-
iﬁed in the query is embedded within the speciﬁcation
in a top-down manner; start by mapping the query
root to the speciﬁcation root, and then map recursively
each implementation of a mapped query node, to some
implementation within the speciﬁcation. As for tran-
sitive nodes, the corresponding implementation in the
speciﬁcation does not have to be a direct one, thus we
consider all splits of the query, allocating a sub-query
to each compound activity name in the newly created
speciﬁcation. This allocation is done by renaming the
activity names into pairs of [activity name, sub-query],
and thus the semi-naive tracing is required.

The exponential blow-up in the query size is due to
the need of considering all query splits. The blow-up
in the speciﬁcation size is due to transitive edges, as
the number of possible paths matching to such edge
may be exponential in the speciﬁcation size.

• Selective tracing allows to avoid the exponential blow-
up in the speciﬁcation size caused by matchings tran-
sitive edges. The selective tracing is exploited to form
a regular grammar, succinctly capturing all paths to
which the transitive edge was matched. The overall
complexity is thus polynomial in the speciﬁcation size,
with the exponent determined by the query size (all
splits of the query still need to be considered).

Type Checking. In the type checking problem we are also
given, in addition to the input type and query, a target type.
Our goal is to verify whether the (sub-) traces that conform
to the query, out of those of the input type, also conform
to the target type. Again, we consider several variants, as
follows:

• If the input and target types are restricted to naive
or semi-naive tracing systems, we give an EXPTIME

1662

algorithm for type checking, and show NP-hardness of
the problem.

• We show that type checking is generally undecidable if
the input and target types may use selective tracing.

Intuition

• The EXPTIME algorithm is rather complex, and is
derived from the algorithm for intersecting parenthe-
sis string grammars [18]. The general idea is to deﬁne
an auxiliary class of deterministic business processes,
where every logged execution trace uniquely deﬁnes
the execution that occurred in practice; then we show
that intersection of such processes is possible, and ﬁ-
nally we show that every business process may be trans-
formed to a deterministic one. The details may be
found in [11].

• The undecidability proof is by reduction from the prob-
lem of testing containment of context free (string) lan-
guages, known to be undecidable.

Practical Implications. Our results on type analysis have
two main practical implications. First, concerning type in-
ference, we signal the class of selective trace types as an
“ideal” type system for BP traces, allowing both ﬂexible de-
scription of the BP traces as well as eﬃcient type inference.
Second, we have shown the hardness of type checking, which
motivates identifying further practical restrictions that al-
low eﬃcient type checking.

3.2 Traces Likelihood

We start by explaining our model for external events that

aﬀect the course of execution, then proceed to the results.

Model We ﬁrst extend the deﬁnition of BP speciﬁcations
to support external events and likelihood. Then we deﬁne
a ranking over traces, based on their likelihood, and ﬁnally
adjust the query language to account for TOP-K queries.
Speciﬁcation. Recall that each compound activity may have
diﬀerent possible implementations, corresponding to diﬀer-
ent user choices, variable values, server availability etc. To
capture these notions, we attach logical formulas (over user
choices, variable values, etc.) guarding each implementation.
Probabilities. In practice, some guarding formulas truth
values are more likely than others. Moreover, the likelihood
of any particular choice varies at diﬀerent points of the run
and may depend on the course of the run so far and on pre-
viously made choices. To account for that, we use a proba-
bility distribution function δ that, given a description of an
execution course up to a given point, and a guarding formula
f , determines the probability that f holds. The likelihood
of each execution trace is deﬁned based on this distribution
function. We focus on three common classes of distribution
functions, as follows: memory-less where all formulas are
independent, ﬁxed-choice, where the truth value of each for-
mula stays constant over time, and bounded-memory, where
the truth value of each formula f at any point of execution
depends (at most) on truth values assigned to the k most
recent occurrences of each formula, for some constant k.

1663

Figure 4: Probabilistic BP

$searchT ype
”flights only”
”flights + hotels”
”flights + hotels + cars”

P($searchT ype)

0.65
0.25
0.1

P ($Airline |
$searchT ype)

”flights
only”

”flights
+hotels”

”flights

+hotels+cars”

”BA”
”AF”
”AL”

0.7
0.1
0.2

0.1
0.7
0.2

P ($Hotel | $Airline)

”BA”

”AF”

”AL”

”Marriott”

”HolidayInn”

”CrownePlaza”

”reset”

”confirm”

0.7
0.05
0.25

0.5
0.5

0.6
0.1
0.3

0.4
0.6

P ($choice | $AirLine)

”BA”

”AF”

”AL”

Table 1: Formulas Distribution

0.6
0.3
0.1

0.1
0.7
0.2

0.8
0.2

corresponds to a Web-page in the application.
Implemen-
tations of compound activities are now guarded by guard-
ing formulas, which are boolean formulas over parameters
such as user choices (e.g.
the choice of $searchT ype, or
of $airline, where ”BA” stands for British airways, ”AF”
for Air France, ”AL” for Aer Lingus). At run-time, one
implementation will be chosen for each compound activity
occurrence, determined by the formulas’ truth values. Ta-
ble 1 depicts a bounded-memory distribution over these for-
mulas. The conditional probability of each formula is given
succinctly, where each formula is conditioned only on a sub-
set of other formulas; this subset is suﬃcient for compu-
tation of the formula’s probability, independently of other
formulas. Here, the top-3 most typical execution ﬂows are
the following: the ﬁrst is the one obtained where the user
searches only for ﬂights, booking a BA ﬂight (its likelihood
is 0.2275). The second is one where the user chooses to
search for ﬂights and hotels, booking an AF ﬂight and a
Marriott hotel (0.063). Finally, the third is one where the
user searches only for ﬂights, choosing BA as airline, but is
not satisﬁed and retries, this time reserving only a BA ﬂight
(0.05175625). Note that the speciﬁcation structure dictates
the sequence of guarding formulas values that correspond to
each trace, and thus aﬀects the computation of likelihood.

The analysis in the above example suggests that hotel
deals presented to British Airways ﬂyers are not appealing
enough and need to be improved. We next explain how
Top-k querying can assist with that.

Example 3.2. Figure 4 provides a schematic description
of the Travelocity [24] application. Each activity roughly

Query Language. We adjust the query language presented
in section 2, to support queries retrieving only the TOP-

Integration. So far, we have considered separately our two
models for uncertainty. Thus, the likelihood analysis algo-
rithms assumed that the tracing system is Naive, revealing
all information on logged execution traces. Naturally, we
intend to extend TOP-K-TRACES and TOP-K-MATCHES
to settings of semi-naive and selective tracing.

Open Problems. Clearly, there exist related problems that
currently remain open. We list some of these next.

• Eﬃcient Type Checking. We have given EXP-
TIME algorithm for type checking in presence of semi-
naive tracing systems, and have shown undecidability
for selective tracing systems. We are interested in iden-
tifying restrictions, either over the tracing systems or
over the speciﬁcation, allowing PTIME algorithms.

• Models for Distribution. Our algorithms are all
generic, and use an oracle that allows computation of
probabilities and (conditional) independencies. We in-
tend to examine appropriate implementations for this
oracle; preliminary results indicate that dynamic bayesian
networks, of varying expressivity, may serve as appro-
priate models for this need.

• Speciﬁcation Inference. In practice, there are many
cases in which the distribution over the speciﬁcation
guarding formulas, or even the speciﬁcation structure
itself, are unknown, and should be mined from a given
set of sampled traces. Incorporation of such inference
engine is one of our challenges for future research.

• Optimizations. We intend to enhance our optimiza-

tions that allow practically eﬃcient run-time.

Practical Applications. We intend to construct a system
that demonstrates practical applications of our algorithms
in the context of real-life commercial Web-sites. Web sites
design may be adjusted to ﬁt navigation patterns of speciﬁc
classes of users, either statically or dynamically; On-line ad-
vertisements may be injected according to common patterns
of co-occurring choices. Given the structural nature of the
analysis, we may point out not only the content of person-
alized advertisements, but also speciﬁc locations within the
Web-sites, where advertisements will yield optimal proﬁt;
and more.
5. RELATED WORK

We give in this section a review of related work, highlight-
ing the relative contributions of our results. Due to space
constraints we give here only a limited subset of the related
results. See [11, 9] for further review.
Types. Type checking and type inference are well studied
problems in functional programming languages [20]; as pointed
out in [6], this analysis is valuable for database queries as
well. Type inference and type checking were also consid-
ered extensively in the context of XML. [19] showed that for
XML selection queries, type checking can be performed in
time complexity equal to or lower than type inference (de-
pending on the XML types/queries being considered). Com-
pare to our setting (baring the obvious distinction of having
nested DAGs instead of ﬂat trees), where type checking may
be harder than type inference.

Probabilistic data. Probabilistic Databases (PDBs) [8],
Probabilistic XML [1] and Probabilistic Relational Models
(PRMs) [15] allow representation of uncertain information.
Many works on PDBs assume independencies between the

Figure 5: (a) Query 1

(b) Query 2

K most likely matched traces. Examples for such queries
follow.

Example 3.3. The query depicted in Figure 5(a) focuses
on British Airways ﬂiers that also reserved some hotel, and
retrieves the top-k hotel-related activity ﬂows of such traces.
The top-1 match for the query indicates that British Airways
travelers prefer the Marriott, which should thus be further
promoted. Fig. 5(b) depicts a query that focuses on execu-
tions where the search ended unsuccessfully, with the users
“resetting” and (recursively) restarting the search. Identi-
fying the most common such ﬂows may provide insight on
main reasons for users dissatisfaction.

Our results Finding the TOP-K traces is called the TOP-
K-TRACES problem (BEST-TRACE, for the decision prob-
lem), and its variant that considers also a query is called
TOP-K-MATCHES (BEST-MATCH).

• Given a speciﬁcation s, accompanied by a memory-less
or ﬁxed-choice distribution, we present and implement
an algorithm that computes TOP-K-TRACES in time
polynomial in | s |. Our algorithm computes a type
representing only the TOP-K (relevant) traces. Given
also a query q, we may compute TOP-K-MATCHES in
time polynomial in | s | with the exponent determined
by | q |. We also show that BEST-MATCH is NP-
complete in | q |.

• For bounded-memory distributions, BEST-TRACE (and

thus also BEST-MATCH) is NP-complete in the speci-
ﬁcation size. However, we present and implement algo-
rithms for TOP-K-TRACES and TOP-K-MATCHES
that perform well on practical cases.

• We show that these results may not be extended to
general distributions, as for such distributions, BEST-
TRACE (BEST-MATCH) is undecidable.

Practical Implications. We have implemented our algo-
rithms, and tested their performance on synthetic data. Our
results so far indicate that analysis of fairly large speciﬁca-
tions, with thousands of activities, may be performed within
seconds. As a further goal, we intend to apply our results
to real-life objectives, as described below.

4. FUTURE WORK

We have summarized above our main results. In this sec-

tion, we review our main goals for further research.

1664

data elements. Dependencies are considered in PRMs and
in extensions of PDBs [23], however they do not capture the
dynamic nature of ﬂow and the possibly unbounded num-
ber of recursive (possibly dependent) activity invocations.
In terms of possible worlds semantics, the number of worlds
in our model is inﬁnite, and thus materializing all worlds is
not only costly (as in PDBs), but impossible. Extensions
of PRMs to a dynamic setting [21] do not allow for eﬃcient
query evaluation.
Grammars. There is a tight connection between the classes
of traces studied here and corresponding classical classes of
string languages, represented by bracketed, parenthesis and
context-free grammars [16]. There is also a close connec-
tion between selective trace types and context free graph
languages [7]. However, to the best of our knowledge, no
model equivalent to naive and semi-naive tracing was stud-
ied in this context.
In terms of query languages, most of
the work on context free graph grammars is concerned with
formal logic, and speciﬁcally First and (Monadic) Second
Order Logic (MSO). Our query language is expressible in
MSO, but is restricted enough to allow eﬃcient evaluation,
absent from [7].

Veriﬁcation. A variety of formalisms for (probabilistic) process
speciﬁcations exist in the literature. Among these, we men-
tion Hidden Markov Models (HMMs) [13], (Probabilistic)
Recursive State Machines (PRSMs) [15], and Stochastic Con-
text Free (Graph) Grammars (SCFG, SCFGG). While HMMs
extend Finite State Machines, PRSMs and SCFGGs de-
scribe nested structures similar to our model. However,
they assume independencies between probabilistic events.
As noted in [10], our query language allows representation
of properties inexpressible in temporal logics typically con-
sidered in veriﬁcation, as it is not bisimulation-invariant.
Also note the unique concepts of trace types deﬁned here,
and the eﬃciency of TOP-K query evaluation, both absent
from veriﬁcation works on probabilistic processes.

Data Mining. Finally, we mention a complementary line
of tools that use data mining techniques to autonomously
(that is, without queries, and generally without knowledge
of the speciﬁcation structure itself) analyze a set of traces.
Typically, these works aim at ﬁnding, autonomously, “in-
teresting” patterns within the given logs, or inferring an
approximation of the speciﬁcation. Among these we men-
tion Web mining [14], Business Process Mining [17], and
OLAP-style tools [12].

6. CONCLUSION

The research described in this paper focuses on Web appli-
cations, aiming to develop tools for their analysis, in settings
of partial information and uncertainty. Initial results indi-
cate that our models are suitable for reasoning over such
speciﬁcations, being concise, intuitive, and allowing eﬃcient
analysis. Based on these models, we provide eﬃcient and
practical methods for analyzing and querying speciﬁcations
under terms of uncertainty; experimental results, as well as
theoretical analysis, indicate the eﬃciency of our methods.
We believe that our models and results stand as ﬁrm foun-
dations for further research; we intend to enhance and op-
timize our methods, solve problems that remain open, and
ﬁnally implement our algorithms to allow a representation
and querying of real-life Web applications, under realistic
settings.

7. REFERENCES
[1] S. Abiteboul and P. Senellart. Querying and updating

probabilistic information in xml. In Proc. of EDBT,
2006.

[2] C. Beeri, A. Eyal, S. Kamenkovich, and T. Milo.

Querying business processes. In Proc. of VLDB, 2006.
[3] C. Beeri, A. Eyal, T. Milo, and A. Pilberg. Monitoring

business processes with queries. In Proc. of VLDB,
2007.

[4] V. Benzaken, G. Castagna, D. Colazzo, and

K. Nguyen. Type-based xml projection. In Proc. of
VLDB, 2006.

[5] Business Process Execution Language for Web

Services.
http://www.ibm.com/developerworks/library/ws-
bpel/.

[6] J. Bussche, D. Gucht, and S. Vansummeren. A crash
course on database queries. In Proc. of PODS, 2007.

[7] B. Courcelle. The monadic second-order logic of

graphs. Inf. Comput., 85(1), 1990.

[8] N. Dalvi and D. Suciu. Eﬃcient query evaluation on

probabilistic databases. In Proc. of VLDB, 2004.

[9] D. Deutch and T. Milo. Querying probabilistic

execution traces.
http://www.cs.tau.ac.il/˜danielde/ProbTracesFull.pdf.

[10] D. Deutch and T. Milo. Querying structural and

behavioral properties of business processes. In Proc. of
DBPL, 2007.

[11] D. Deutch and T. Milo. Type inference and type

checking for queries on execution traces. In Proc. of
VLDB, 2008.

[12] J. Eder, G. E. Olivotto, and W. Gruber. A data

warehouse for workﬂow logs. In Proc. of EDCIS, 2002.
[13] Y. Ephraim and N. Merhav. Hidden markov processes.

IEEE Trans. Inf. Theory, 48(6), 2002.

[14] F. M. Facca and P. L. Lanzi. Mining interesting

knowledge from weblogs: a survey. Data Knowl. Eng.,
53(3), 2005.

[15] N. Friedman, L. Getoor, D. Koller, and A.Pfeﬀer.

Learning probabilistic relational models. In Proc. of
IJCAI, 1999.

[16] S. Ginsburg and M. Harrison. Bracketed context-free

languages. J. Computer and System Sciences, 1, 1967.

[17] D. Grigori, Fabio Casati, M. Castellanos, M.Sayal

U .Dayal, and M. Shan. Business process intelligence.
Computers in Industry, 53, 2004.

[18] R. McNaughton. Parenthesis grammars. J. ACM,

14(3), 1967.

[19] T. Milo and D. Suciu. Type inference for queries on

semistructured data. In Proc. of PODS, 1999.
[20] J. C. Mitchell. Foundations for Programming

Languages. MIT Press, 1996.

[21] S. Sanghai, P. Domingos, and D. Weld. Dynamic

probabilistic relational models. In IJCAI, 2003.
[22] D. M. Sayal, F. Casati, U. Dayal, and M. Shan.

Business Process Cockpit. In Proc. of VLDB, 2002.

[23] P. Sen and A. Deshpande. Representing and querying

correlated tuples in probabilistic databases. In Proc.
of ICDE, 2007.

[24] Travelocity web-site. http://www.travelocity.com.

1665

