P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11

BrowserShield: Vulnerability-Driven Filtering
of Dynamic HTML

CHARLES REIS
University of Washington
JOHN DUNAGAN, HELEN J. WANG, and OPHER DUBROVSKY
Microsoft
and
SAHER ESMEIR
Technion

Vulnerability-driven ﬁltering of network data can offer a fast and easy-to-deploy alternative or
intermediary to software patching, as exempliﬁed in Shield [Wang et al. 2004]. In this article,
we take Shield’s vision to a new domain, inspecting and cleansing not just static content, but
also dynamic content. The dynamic content we target is the dynamic HTML in Web pages, which
have become a popular vector for attacks. The key challenge in ﬁltering dynamic HTML is that
it is undecidable to statically determine whether an embedded script will exploit the browser at
runtime. We avoid this undecidability problem by rewriting web pages and any embedded scripts
into safe equivalents, inserting checks so that the ﬁltering is done at runtime. The rewritten pages
contain logic for recursively applying runtime checks to dynamically generated or modiﬁed web
content, based on known vulnerabilities. We have built and evaluated BrowserShield, a general
framework that performs this dynamic instrumentation of embedded scripts, and that admits
policies for customized runtime actions like vulnerability-driven ﬁltering. We also explore other
applications on top of BrowserShield.

Categories and Subject Descriptors: D.4.6 [Operating Systems]: Security and Protection; D.3.4
[Programming Languages]: Processors—Translator writing systems and compiler generators

General Terms: Languages, Security

Additional Key Words and Phrases: Web browser, vulnerability, JavaScript, code rewriting

A subset of the material in this article ﬁrst appeared in the Proceedings of the 2006 Usenix Sym-
posium on Operating Systems Design and Implementation (OSDI).
Authors’ addresses: C. Reis, CSE Department, University of Washington, Seattle, WA; email:
creis@cs.washington.edu; J. Dunagan, H. J. Wang, O. Dubrovsky, Microsoft, Redmond, WA; email:
{judnagam,helenw,opherd}@microsoft.com; S. Esmeir, CS Department, Technion; email: eashaer@
cs.technion.ac.il.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is
granted without fee provided that copies are not made or distributed for proﬁt or direct commercial
advantage and that copies show this notice on the ﬁrst page or initial screen of a display along
with the full citation. Copyrights for components of this work owned by others than ACM must be
honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers,
to redistribute to lists, or to use any component of this work in other works requires prior speciﬁc
permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn
Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212) 869-0481, or permission@acm.org.
C(cid:2) 2007 ACM 1559-1131/2007/09-ART11 $5.00 DOI 10.1145/1281480.1281481 http://doi.acm.org/
10.1145/1281480.1281481

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:2

•

C. Reis et al.

ACM Reference Format:

Reis, C., Dunagan, J., Wang, H. J., Dubrovsky, O., and Esmeir, S. 2007. BrowserShield:
Vulnerability-driven ﬁltering of dynamic HTML. ACM Trans. Web 1, 3, Article 11 (September
2007), 32 pages. DOI = 10.1145/1281480.1281481 http://doi.acm.org/10.1145/1281480.1281481

1. INTRODUCTION

Web browsers have become an important interface between users and many
electronic services such as information access, personal communications, ofﬁce
tasks, and e-commerce. The importance of web browsers is accompanied by rich
functionality and extensibility, which arguably have also contributed to their
popularity as a vector of attack. During the year 2005, 8 out of 29 critical Mi-
crosoft security bulletins, corresponding to 19 vulnerabilities, are due to ﬂaws
in Internet Explorer (IE) or its extensions such as ActiveX controls [Microsoft
2005]. There were also 7 critical security bulletins for Firefox [Mozilla 2005],
corresponding to 16 vulnerabilities over the same period of time.

To date, the primary way to defend browser vulnerabilities is through soft-
ware patching. However, studies have shown that the deployment of software
patches is often delayed after the patches become available. Services such as
Windows Update download patches automatically, but they typically delay en-
actment if the patch requires a reboot or application restart. This delay helps
both home and corporate users save work and schedule downtime. An addi-
tional delay in the corporate setting is that patches are typically tested prior
to deployment, to avoid the potentially high costs for recovering from a faulty
patch [Beattie et al. 2002].

As a result, there is a dangerous time window between patch release and
patch application during which attackers often reverse-engineer patches to gain
vulnerability knowledge and then launch attacks. One study showed that a
large majority of existing attacks target known vulnerabilities [Arbaugh et al.
2000].

For vulnerabilities that are exploitable through application level protocols
(e.g., HTTP, RPC), previous work, Shield [Wang et al. 2004], addresses the patch
deployment problem by ﬁltering malicious trafﬁc according to vulnerability sig-
natures at a ﬁrewall above the transport layer. The vulnerability signatures
consist of a vulnerability state machine that characterizes all possible message
sequences that may lead to attacks, along with the message formats that can
trigger the exploitation of the application (e.g., an overly long ﬁeld of a message
that triggers a buffer overrun). The key characteristic of this approach is that it
cleanses the network data without modifying the code of the vulnerable appli-
cation. This data-driven approach makes signature deployment (and removal
if needed) easier than it is for patches. Vulnerability signature deployment can
be automatic rather than user-driven and use the same deployment model as
antivirus signatures.

These desirable features of vulnerability-driven ﬁltering motivated us to ex-
plore its potential for exploit removal in web pages. The Shield approach is
able to ﬁlter static HTML pages by treating HTML as another protocol layer

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:3

Fig. 1. The BrowserShield system.

over HTTP. However, the challenge lies in dynamic HTML, where pages can be
dynamically generated or modiﬁed by scripts embedded in the page—attackers
could easily evade Shield ﬁlters by using scripts to generate malicious Web con-
tent at runtime, possibly with additional obfuscation. Determining whether a
script will eventually exploit a vulnerability is undecidable. Our approach to
cleansing dynamic content is to rewrite HTML pages and any embedded scripts
into safe equivalents before they are rendered by the browser. The safe equiva-
lent pages contain logic for recursively applying run-time checks to dynamically
generated or modiﬁed web content, based on known vulnerabilities. To this end,
we have designed BrowserShield, a system that performs dynamic instrumen-
tation of embedded scripts and that admits policies for changing Web page be-
havior. A vulnerability signature is one such policy, which sanitizes Web pages
according to a known vulnerability. Figure 1 gives an overview of the Browser-
Shield system, showing how it transforms HTML and JavaScript using a set of
policies. Our system focuses on JavaScript because it is the predominant script-
ing language used on the Web; a full-ﬂedged system would require additionally
rewriting or disabling VBScript and any other script languages used by Web
browsers that BrowserShield protects.

Our general approach of code rewriting for interposition has been used in
other contexts. Code rewriting has been used to isolate faults of software ex-
tensions [Wahbe et al. 1993]. Java bytecode rewriting has been used to enable
security polices [Erlingsson and Schneider 2000a; Sirer et al. 1999], such as
stack inspection policies for access control. However, rewriting script code for
web browsers poses additional challenges: JavaScript is a prototype-based lan-
guage, and the combination of this with JavaScript’s scoping rules, implicit
garbage collection and pervasive reﬂection required a number of techniques
not needed by previous rewriting work in other contexts.

We have designed BrowserShield to adhere to well established principles for
protection systems: complete interposition of the underlying resource (i.e., the
HTML document tree), tamper-proofness and transparency [Anderson 1972;
Erlingsson and Schneider 2000a; Saltzer and Schroeder 1973]. In addition,
BrowserShield is a general framework that supports applications other than
vulnerability-driven ﬁltering. For example, we have authored policies that add
UI invariants to prevent certain phishing attempts.

Because BrowserShield protects Web browsers by transforming their inputs,
not the browser itself, the BrowserShield logic injector can be deployed at client

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:4

•

C. Reis et al.

or edge ﬁrewalls, browser extensions, or Web publishers that republish third-
party content such as ads.

We have implemented a prototype of the BrowserShield system, in which
the rewriting logic is injected into a Web page at an enterprise ﬁrewall and
executed by the browser at rendering time. Our prototype can transparently
render many familiar Web sites that contain JavaScript (e.g., www.google.com,
www.cs.washington.edu, www.mit.edu). We also successfully translated and ran
a large intranet portal application (Microsoft SharePoint) that uses 549 KB of
JavaScript libraries.

We chose the ﬁrewall deployment scenario because it offers the greatest man-
ageability beneﬁt, as BrowserShield updates can be centralized at the ﬁrewall,
immediately protecting all client machines in the organization without any
BrowserShield–related installation at either clients or web servers. The main
disadvantage of this deployment scenario is that ﬁrewalls have no visibility into
end-to-end encrypted trafﬁc. Nevertheless, commercial products [Secure Com-
puting 2006] already exist that force trafﬁc crossing the organization boundary
to use the ﬁrewall (instead of a client within the organization) as the encryption
endpoint, trading client privacy for aggregate organization security.

In scenarios where end-to-end encryption is critical, the browser extension
and web publisher deployment scenarios can transparently handle encrypted
trafﬁc. While a client-side deployment of BrowserShield will require policy up-
dates for every client, this approach still offers advantages over relying on
software patches. In particular, BrowserShield policies do not require applica-
tion restarts, and they are easy to roll back if they prove to be faulty. Thus, the
policies can be automatically distributed much like antivirus signatures.

Our evaluation focuses on the effectiveness of the BrowserShield design and
the performance of our implementation. Our analysis of recent IE vulnerabili-
ties shows that BrowserShield signiﬁcantly advances the state of the art; exist-
ing ﬁrewall and antivirus techniques alone can only provide patch-equivalent
protection for 1 of the 8 IE patches from 2005, but combining these two with
BrowserShield is sufﬁcient to cover all 8. We evaluated BrowserShield’s perfor-
mance on real-world pages containing over 125 KB of JavaScript. Our evalua-
tion shows a 22% relative increase in ﬁrewall CPU utilization, and client render-
ing latencies that are comparable to the original page latencies for most pages.
The rest of the article is organized as follows: In Section 2 we describe a typ-
ical browser vulnerability that we would like to ﬁlter. We discuss the design of
BrowserShield in Section 3, and we give BrowserShield’s JavaScript rewriting
approach in detail in Section 4. We discuss how to author and register policy
functions in Section 5. We describe our implementation in Section 6, and in
Section 7 we give our evaluation of BrowserShield. We survey additional po-
tential applications in Section 8. We then discuss related work in Section 9 and
conclude in Section 10.

2. A MOTIVATING EXAMPLE

As a motivating example of vulnerability-driven ﬁltering, we consider MS04-
040: the HTML Elements Vulnerability [Microsoft 2004] of IE from December,

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:5

Fig. 2. JavaScript code snippet to identify exploits of the MS04-040 vulnerability.

2004. In this vulnerability, IE had a vulnerable buffer that was overrun if both
the name and the src attributes were too long in an iframe, frame, or embed
HTML element.

Figure 2 shows a corresponding snippet of JavaScript code that can be used
to identify and to remove exploits of this vulnerability. As input, the function
takes an object representing an HTML tag, including an associative array of its
attributes. When invoked on an <iframe>, <frame>, or <embed> tag, the function
determines whether the relevant attributes exceed the size of the vulnerable
buffer. If so, it removes the attributes to defeat the exploit.

The goal of BrowserShield is to take such vulnerability-speciﬁc ﬁltering func-
tions as policies and apply them to all occurrences of vulnerable content whether
they are in static HTML pages or dynamically generated by scripts. The frame-
work could react in many ways to detected exploits; our current system simply
removes the exploit from the HTML before rendering. Vulnerability driven ﬁl-
tering, used as a patch alternative or intermediary, should prevent all exploits of
the vulnerability (i.e., zero false negatives), and should not disrupt any exploit-
free pages (i.e., zero false positives). We design BrowserShield to meet these
requirements.

3. OVERVIEW

The BrowserShield system consists of a JavaScript library that translates Web
pages into safe equivalents and a logic injector (such as a ﬁrewall) that modiﬁes
Web pages to use this library.

BrowserShield uses two separate translations along with policies that are
enforced at runtime. The ﬁrst translation, THTML, translates the HTML: It to-
kenizes an HTML page, modiﬁes the page according to its policies (such as the
one depicted in Figure 2), and wraps the script elements so that the work of
the second translation, Tscript, will be deferred to page rendering at the browser.
THTML is depicted in Figure 3 using bshield.translateScript(...) to invoke
Tscript. Tscript, as depicted in Figure 4, parses and rewrites JavaScript to access
the HTML document tree through an interposition layer. This layer regulates
all accesses and manipulations of the underlying document tree, recursively
applies THTML to any dynamically generated HTML, and recursively applies
Tscript to any dynamically generated script code. Additionally, the interposition
layer enforces policies, such as ﬁltering exploits of known vulnerabilities.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:6

•

C. Reis et al.

Fig. 3. THTML translation.

Fig. 4. Tscript translation.

Since users can choose to disable scripting in their Web browsers, we must
ensure that BrowserShield protects such users even without the JavaScript
library. We handle such clients by applying THTML at the logic injector, indepen-
dent of the user’s browser. Any modiﬁcations due to Tscript are still in place, but
disabling scripts has made them irrelevant, along with the original script code.
Browser extensions, such as ActiveX controls, can also manipulate the doc-
ument tree. The security model for such extensions is that they have the same
privileges as the browser, and thus we focus on interposing between script and
the extensions, not between the extensions and the document tree. This allows
BrowserShield to prevent malicious script from exploiting known vulnerabili-
ties in trusted browser extensions.

We have designed BrowserShield to adhere to Well-established principles for
protection systems [Anderson 1972; Erlingsson and Schneider 2000a; Saltzer
and Schroeder 1973]:

—Complete interposition. All script access to the HTML document tree must

be mediated by the BrowserShield framework.

—Tamper-proof. Web pages must not be able to modify or tamper with the

BrowserShield framework in unintended ways.

—Transparency. Apart from timing considerations and reasonable increases
in resource usage, web pages should not be able to detect any changes in
behavior due to the BrowserShield framework. The sole exception is for pol-
icy enforcement (e.g., the behavior of a page containing an exploit is visibly
modiﬁed).

—Flexibility. We desire the BrowserShield framework to have a good separa-
tion between mechanism and policy, to make the system ﬂexible for many
applications.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:7

4. DESIGN

We now give a detailed discussion of the BrowserShield script library. While
much previous work uses code rewriting for interposition [Erlingsson and
Schneider 2000a; Erlingsson and Schneider 2000b; Evans and Twyman 1999;
Wahbe et al. 1993], our approach is heavily inﬂuenced by the fact that our
code lives in the same name space as the code it is managing, and also by
several subtleties of JavaScript. First, JavaScript is a prototype-based lan-
guage [Ungar and Smith 1987], not a class-based language like Java. In
prototype-based languages, objects are created using other objects as proto-
types. They can then be modiﬁed to have a different set of member variables
and methods. A consequence of this is that JavaScript has no static typing:
Different data types can be assigned to the same variable, even for references
to functions and object methods. Second, scoping issues must be dealt with
carefully, as assigning a method to a new object causes any use of the this
keyword in the method to bind to the new object. Thus, any interposition mech-
anisms must ensure that this is always evaluated in the intended context.
Third, JavaScript uses a garbage collector that is not exposed to the language.
Fourth, the language has pervasive reﬂection features that let a script explore
its own code and object properties.

As a result of these subtleties, BrowserShield must use a series of interposi-
tion mechanisms: method wrappers, new invocation syntax, and name resolu-
tion management. We justify and describe these mechanisms in the following
subsections, organized by our goals for the framework.

4.1 Complete Interposition

To provide complete interposition, BrowserShield must mediate all possible
accesses and manipulations allowed by the Document Object Model (DOM)
over the HTML document trees (including script elements). In this subsection,
we detail how we achieve this using script rewriting to interpose on function
calls, object method calls, object property accesses, object creation, and control
constructs. These interposition points are sufﬁcient to mediate script access to
the DOM. We summarize our rewriting rules in Table I.

Function and Object Method Calls. JavaScript supports the deﬁnition of
global functions and methods on objects. Both functions and methods can be
passed by reference and aliased, so that multiple names could refer to the same
executable code. The sole difference between functions and methods is that
the this keyword will be bound to the enclosing object for methods. All other
references are bound at the time the function or method is created.

There are two techniques to rewrite function or method calls for interposition:
callee rewriting or caller rewriting. Below, we evaluate each and ﬁnd that both
techniques are necessary.

In callee rewriting, the original function or method deﬁnition is ﬁrst saved
under a different name, and then the original function or method is redeﬁned to
allow interception before calling the saved original. We call the redeﬁned func-
tion the wrapper. For example, a foo method on an object could be renamed to

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

Table I. Sample Code for BrowserShield Rewrite Rules

11:8

•

C. Reis et al.

Construct
Function Calls
Method Calls

Original Code

foo(x);
document.write(s);

Object Properties

obj.x = obj.y;

with Construct

with (obj) { x = 3; }
// x refers to obj.x

Variable Names
in Construct

bshield = x;
for (i in obj) {...}

Rewritten Code

bshield.invokeFunc(foo, x);
bshield.invokeMeth(document,

"write", s);

bshield.propWrite(obj, "x",

bshield.propRead(obj, "y"));

("MyClass",[x]);

(bshield.undefined(obj.x) ?
x = 3 : bshield.propWrite (obj,

"x", 3));

bshield = x;
for (i in obj) {

if (i=="bshieldProp")
continue; ... }

Object Creation

var obj = new MyClass(x);

var obj = bshield.createObj

fooOriginal, and a new foo method could check the arguments to the method
before invoking fooOriginal. The beneﬁt of callee rewriting is that the rewrit-
ten code is localized—only the functions or methods of interest are modiﬁed,
and not their invocations throughout the code. However, callee rewriting does
not work in cases where functions or methods cannot be redeﬁned.

In caller rewriting, the invocation is rewritten to call an interposition func-
tion without changing the original function’s deﬁnition. The interposition func-
tion looks up the appropriate interposition logic based on the identity of
the target function or method. For example, foo(3) could be rewritten as
invokeFoo(3), which ﬁrst checks the arguments before invoking foo. Although
caller rewriting causes more pervasive code changes, it can interpose on those
functions or methods that cannot be overwritten.

In BrowserShield, we have to use a hybrid of both approaches to accommo-

date the previously mentioned JavaScript subtleties.

Speciﬁcally, JavaScript contains some native functions that cannot be re-
deﬁned (e.g., alert in Internet Explorer), which necessitates caller rewriting.
The ﬁrst row of Table I shows how BrowserShield indirectly invokes a function
with its list of parameter values by passing it to bshield.invokeFunc(func,
paramList), where bshield is a global object that we introduce to contain
BrowserShield library code.

However, using caller rewriting alone for interposing on method calls re-
quires maintaining references to state otherwise eligible for garbage collection.
That is, caller rewriting requires maintaining a map from functions and meth-
ods of interest to their associated interposition logic. Storing this map in a global
table would require maintaining a reference to methods of interest on every
object ever created. This is because each object may correspond to a distinct
prototype requiring distinct interposition logic. These global table references
would prevent reclamation of objects otherwise eligible for garbage collection,
possibly causing pages that render normally without BrowserShield to require
unbounded memory. To avoid this, BrowserShield uses callee rewriting to main-
tain the necessary interposition logic on a wrapper for each method, allowing
unused state to be reclaimed.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:9

It might seem tempting to maintain this interposition logic as a property on
the object, rather than using wrappers. Unfortunately, aliases to the interposed
method can be created, and these aliases provide no reference to the object con-
taining the interposition logic. For example, after “f = document.write,” any
interposition logic associated with document.write is not associated with f;
ﬁnding the logic would require a global scan of JavaScript objects. This justi-
ﬁes using wrappers for methods that require interposition logic. The wrappers
are installed by replacing the original method with the wrapper and saving
the original method as a property on the wrapper (which is itself an object).
Because we interpose on object property accesses, object creation, and method
invocations, we can install wrappers when an object is ﬁrst created or used.

Thus far we have justiﬁed caller rewriting for functions and callee rewriting
for methods. Because JavaScript allows functions to be aliased as methods on
objects (e.g., “obj.m = eval”), we also must perform caller rewriting for method
calls. The rewritten method invocations can then check for potential aliased
functions.

JavaScript scoping introduces additional complexity in method interposition.
The original method cannot simply be called from the method wrapper. This is
because the original method is now a property of the wrapper, so the this key-
word binds to the wrapper instead of the intended object. To avoid this problem,
we use a swapping technique: The wrapper temporarily restores the original
method during the wrapper execution, and then reinstalls the wrapper for the
object method before the wrapper returns.

The ﬁrst step in swapping is to restore the original method. One challenge
here is that the method name may not be the same as when the method wrap-
per was installed, so we may not know where to place the original method.
This is because methods can be reassigned to different names. For exam-
ple, document.write may be aliased to otherObject.foo. The document.write
wrapper needs to be informed of the method name being called. We solve this
problem again with caller rewriting. In the rewritten method invocation syn-
tax invokeMeth(obj, methName, paramList), we pass the name of the method
to the method wrapper, which performs the swap. Continuing the example,
the rewritten method call is invokeMeth(otherObject, "foo",...), allowing
document.write to swap to otherObject.foo.

The swapping process requires an additional check to handle recursive
methods. As described above, a recursive call to a method would bypass the
method’s wrapper, which is swapped out after the ﬁrst call. Instead, the
bshield.invokeMeth method ﬁrst checks to see if the method being called has
a wrapper that has already been swapped out. If so, invokeMeth invokes the
wrapper again, ignoring any swapping logic until the original recursive call
completes. Because JavaScript is single threaded, we have not needed to han-
dle concurrency during this process.

Object Properties. The HTML document tree can be accessed and modiﬁed
through object property reads and writes in JavaScript. For example, the HTML
in a page can be modiﬁed by assigning values to document.body.innerHTML, or
an individual script tag can be changed by modifying its text property. To

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:10

•

C. Reis et al.

interpose on such actions, BrowserShield replaces any attempts to read or
write object properties with calls to bshield’s propRead(obj, propName) and
propWrite(obj, propName, val) methods, as shown in Table I. We apply this
rewriting rule to all object property reads and writes, because it is not possible
to know statically whether a given read or write will require interposition logic.
Instead, we use the object’s identity at runtime to check whether an assignment
will create new HTML or script code. If so, propWrite applies THTML or Tscript to
the new code as needed. As part of the identity check, we can determine if an
object is part of the HTML document tree by calling certain JavaScript library
functions. Note that we ensure BrowserShield uses the authentic JavaScript
library functions (and not malicious replacements) by creating private aliases
of the functions before any script code begins to run.

Interposing on property accesses is necessary for two additional reasons.
First, it is required for installing wrappers when an object is ﬁrst accessed.
Using this technique, we avoid installing wrappers on DOM objects unless
the particular method requiring virtualization is about to be accessed. Sec-
ond, while wrappers are swapped out during method execution, propRead must
ensure that any attempts to access the original method are redirected to the
swapped-out wrapper.

Object Creation. For some objects, BrowserShield must ensure that method
wrappers are initialized on each object as it is created. For example, it is
straightforward to check the type of DOM objects at any point during their
lifetime, making it easy to then decide on an appropriate interposition policy.
In contrast, determining the appropriate interposition policy for the output of
the ActiveXObject constructor is best done at creation time, since otherwise
important context will be lost. To achieve this, we rewrite the instantiation
of new objects to use bshield’s createObj(className, paramList) method.
The createObj method is also responsible for interposing on the JavaScript
Function constructor, which can create new executable functions from its pa-
rameters as follows:
f = new Function("x", "return x+1;");
In this case, createObj applies Tscript to the arguments before instantiating the
function.

Control Constructs. For control constructs (e.g., if-then blocks, loops, etc.),
the bodies of the constructs are translated by Tscript. The bodies of traditional
function constructors (e.g., function foo() {...}) are translated by Tscript as
well.

JavaScript’s with construct presents a special case, as it has the ability to
modify scope. As shown in Table I, free variables within a with block are as-
sumed to refer to properties on the designated object, unless such properties
are undeﬁned. This construct is purely “syntactic sugar” for JavaScript, and
thus we handle this case with a syntactic transformation.

4.2 Tamper-Proof

Preventing scripts from tampering with BrowserShield is challenging because
BrowserShield logic lives in the same name space as the code it is managing. To

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:11

address this, we use name resolution management to ensure that all Browser-
Shield logic is inaccessible. This entails renaming certain variables and modi-
fying the output of reﬂection in some cases.

Variable Names.

In the common case, variable names in a script can re-
main unchanged. However, we make the bshield name inaccessible to scripts
to prevent tampering with the global BrowserShield data structure.

To do this, we rename any variable references to bshield by appending an
underscore to the end of the name. We also append an underscore to any name
that matches the bshield( *) regular expression (i.e., that begins with bshield
and is optionally followed by any number of underscores). Note that JavaScript
places no limit on variable name length, so appending characters will not cause
a conﬂict.

Reﬂection. Reﬂection in JavaScript allows script code to explore the proper-
ties of objects as well as its own code, using two pervasive language features: the
syntax for accessing object properties (such as myScript.text or myScript[i]),
and the JavaScript in construct.

In the ﬁrst case, BrowserShield must hide some object properties, because it
maintains per-object interposition state (details given in Section 4.3) on some
objects. Such state is stored on a bshieldProp property of the object, which we
hide using property access interposition. Speciﬁcally, if a call to propRead or
propWrite attempts to access a property name beginning with bshieldProp, we
simply append an underscore to the name, thus returning the property value
that the original script would have seen. Since array indices can also be used
to access object properties, we must return the appropriate value for the given
index.

In the second case, the in construct allows iteration through all of an object’s
properties by name. For example, for (i in obj) sets up a loop that iterates
through each property name in obj. The bshieldProp property of an object must
be hidden during the iteration if it is present. Thus, BrowserShield inserts a
check as the ﬁrst line of the iteration loop, jumping to the next item if the
property name is bshieldProp. This is accomplished using the rewrite rule
shown in Table I.

4.3 Transparency

The BrowserShield framework must also ensure that its presence is transpar-
ent to the original script’s semantics. The techniques for preventing tampering
described in Section 4.2 contribute to this goal by making BrowserShield in-
accessible. Transparency additionally requires that we present to scripts the
context they would have in the absence of BrowserShield.

For example, JavaScript supports additional reﬂective features, such as the
typeof or instanceof keywords, which can reveal information about a variable.
BrowserShield can rewrite or virtualize such features to ensure they do not
expose the presence of the BrowserShield framework.

We next discuss two speciﬁc mechanisms that are necessary for preserving

this transparency in general.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:12

•

C. Reis et al.

Shadow Copies. Scripts can access both their own script code and HTML,
which BrowserShield modiﬁes for interposition. To preserve the intended se-
mantics of such scripts, BrowserShield retains a “shadow copy” of all original
code before rewriting it. The shadow copy is stored on a bshieldProp property
of the object. Interposition on property reads and writes allows the shadow copy
to be exposed to scripts for access and modiﬁcation.

Shadowing translated HTML requires additional care. During THTML trans-
formation, a policy may rewrite static HTML elements. We must similarly cre-
ate shadow copies for such translated HTML elements, but we cannot directly
create a JavaScript object in HTML to store the shadow copy. Thus, we persist
the shadow copy to a bshieldProp HTML tag attribute during THTML, which
is later used by the BrowserShield library. For example, a policy function that
rewrites link URLs may modify the href attribute of <a> tags during the THTML
transformation. Then, the persisted shadow copy looks like this:

<a href="http://translatedLink"

bshieldProp="{href:’http://originalLink’}">

When BrowserShield looks for the bshieldProp property of the DOM object
corresponding to this tag, it interprets this string into an actual bshieldProp
property with a shadow copy for the href attribute.

Because scripts can interact only with shadow copies of their code and not
modiﬁed copies, they are not exposed to changes such as renamed variables.
This also implies that our transformations are not required to be idempotent.
That is, we will never apply THTML or Tscript to code that has already been
transformed.

Preserving Context. The JavaScript eval function evaluates a string as
script code in the current scope, and any occurrence of the this keyword in the
string is bound to the current enclosing object. Thus, if eval were to be called
from within bshield.invokeFunc, the this keyword might evaluate differently
than in the original context.

For this reason, the rewriting rule for functions is actually more complex
than shown in Table I. Instead, the rewritten code ﬁrst checks if the function
being invoked is eval. If so, the parameter is translated using Tscript and then
evaluated in the correct context; otherwise, invokeFunc is called as described
before. Thus, the code is rewritten as follows:

bshield.isEval(bshield.func = foo) ?

eval(bshield.translate(x)) :
bshield.invokeFunc(bshield.func, x);

Note that the function expression foo is assigned to a temporary state variable
on the bshield object, so that the expression is not evaluated a second time in
the call to invokeFunc.

This check is a special case that is only needed for eval, because eval is the
only native function in JavaScript that accesses this. Other native functions,
such as alert or parseInt, do not access this, and can be evaluated within
invokeFunc.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:13

4.4 Flexibility

The ﬁnal goal of BrowserShield is to support ﬂexible policy enforcement. This
can be achieved by separating mechanism from policy: Our mechanism con-
sists of the rewrite rules for translating HTML and script code, and our
policy consists of the runtime checks invoked by the rewritten code. Some
runtime checks are critical for complete interposition, such as applying Tscript
to any string passed to eval or the Function constructor, or applying THTML to
any string passed to document.write or assigned to document.body.innerHTML.
These checks are always applied, regardless of what policy is in place.

Because the interposition logic itself is policy-driven, our system can be made
incrementally complete. For example, if an undocumented API is discovered
that can manipulate the document tree, we simply add a new policy to interpose
on this API.

The remaining runtime checks are used for enforcing ﬂexible policies, such
as the MS04-040 vulnerability ﬁlter in Figure 2. Such policy functions are sep-
arate from the remainder of the BrowserShield code, and they can be updated
and customized based on the intended application. We provide a more detailed
discussion of policy functions in the next section.

5. POLICIES

BrowserShield policies are functions that can be registered at any interposition
point in the framework. These functions are given the chance to inspect and
modify script behavior during execution, allowing them to enforce invariants on
script behavior in a comprehensive way. In this section, we discuss how policy
functions are written, how to register them with the BrowserShield framework,
and how they can be distributed.

5.1 Writing Policies

Policies are implemented as JavaScript functions. Each policy function takes in
arguments relevant to the interposition point at which it is registered, such as
the arguments to a JavaScript function or a representation of an HTML tag. The
policy function inspects these arguments and determines whether they should
be modiﬁed before the page’s logic is allowed to proceed. The policy function has
access to the entire state of the page and the BrowserShield framework itself, in
case additional context is required beyond the arguments. We also allow policy
writers to introduce new global state and functions as part of the global bshield
object, or local state and methods for speciﬁc objects.

Policy functions are the only code outside the BrowserShield framework that
runs without being translated, and thus they have access to the BrowserShield
framework itself. Because these policy functions are given control over the page
and are responsible for protecting the browser from exploits, they are part of the
trusted computing base. Thus, we have not established mechanisms to prevent
the policies from interfering with the framework itself.

For vulnerability ﬁltering policies, there are many reasonable reactions
to ﬁnding an exploit attempt. Our current prototype is conﬁgured to strip
the offending code from the page, preventing the exploit. Alternatively,

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:14

•

C. Reis et al.

Fig. 5. JavaScript code to register policy function for the MS04-040 vulnerability.

BrowserShield could redirect to a page with an error message, or it could notify
an administrator of the attempted exploit.

Examples of speciﬁc vulnerability ﬁltering policies are discussed in Section 2

and Section 7.2.

5.2 Policy Registration

The BrowserShield framework exposes several “hook” functions for registering
policies at interposition points. These interposition points include when new
HTML tags are passed to the browser, when functions and methods are called,
and when object properties are read and written. By registering policy functions
at these points using the hooks, policy authors can comprehensively restrict or
modify the behavior of any HTML or script code in a web document.

We describe the API for registering policy functions in the following. The
registration functions are deﬁned on the global bshield object and are invoked
as part of BrowserShield’s initialization logic. In general, the registration func-
tions take in a representation of the interposition point, such as the name of an
HTML tag, along with a reference to the policy function itself. As BrowserShield
encounters each interposition point at runtime, it invokes the policy functions
registered at that point.

—addHTMLTagPolicy(tagName, policy). This hook allows a policy function to
be registered for a given HTML tag name. Whenever BrowserShield encoun-
ters a tag with the given name on a page, it passes a JavaScript object rep-
resenting the tag and its attributes to the policy function. This occurs before
the tag is rendered by the browser, allowing the policy to change the tag if
necessary.

For example, the code in Figure 5 would register the MS04-040 policy

function from Figure 2.

The tags are presented as part of a token stream of tags and text, with-
out a full parse tree. Policy functions are free to reconstruct a subset of the
parse tree to gain additional context if necessary, although we have not yet
encountered a need for this in the policies we have authored.

—addJSConstructorPolicy(className, policy). This hook causes Browser-
Shield to invoke the given policy function each time an instance of the class
with the given name is constructed. BrowserShield passes the list of construc-
tor arguments to the policy function, allowing it to alter them if necessary.
The policy function is expected to return the newly constructed object. This
allows the policy function to wrap methods on the object if necessary (e.g., to
alter the behavior of method calls).

An example use of this hook is restricting the creation of particular
ActiveX objects. This can be accomplished by registering a policy on the
ActiveXObject constructor.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:15

—addJSFunctionPolicy(function, policy). This hook causes BrowserShield
to invoke the given policy function each time a particular function is invoked.
This registration function takes in a pointer to the function of interest rather
than its name, to eliminate the need for an additional mechanism to track
function aliasing. This approach avoids the difﬁculties mentioned in Sec-
tion 4.1 with aliasing.

Each time the function is called, BrowserShield passes the arguments to
the policy function. The policy function is expected to call the function and
return a result, altering the arguments and return value as it desires.

Registering policies on function calls can be used to support simple type
checking, to prevent improper arguments from being passed to particular
functions. Such type checking can prevent exploits of vulnerabilities in the
JavaScript engine, as we discuss in Section 7.2.

—addJSMethodPolicy(obj, methodName, policy). This hook causes Browser-
Shield to invoke the given policy function each time a method with the
given name on the given object is invoked. Because BrowserShield wraps
the method on its ﬁrst access, subsequent aliasing of the method is not a
concern (as mentioned in Section 4.1). As in addJSFunctionPolicy, the policy
function takes in the arguments for the method and returns the result of
calling the method, altering them if necessary.

An example use of this policy is restricting the number of windows that a
page is allowed to open, to prevent a page from ﬂooding the user with new
windows. This can be accomplished by registering a policy on the window.open
method.

—addJSPropWritePolicy(obj, policy). This hook causes BrowserShield to in-
voke the given policy function on any write to a property of the given object.
The policy function takes in the name of the property and the value to write.
It can then apply the change, alter it, or block it as necessary. The policy
function returns no value in this case.

An example use of this policy is comprehensively translating links. Links
on a Web page may be present as <a href...> tags, but JavaScript code
can also navigate to a link by changing the window.location property. This
hook can be used to intercept any change to window.location to modify the
intended destination. We discuss link translation further in Section 8.

—addJSDOMPropWritePolicy(nodeName, policy) This hook is similar to the
object property write hook above, except that it applies to all DOM objects of
a particular type. Rather than taking in a pointer to the object of interest,
it takes in the name of a DOM node. This acts as an analog of a class name,
allowing policies to be applied to any instance of a given type of DOM node.
As an example, policy authors can intercept any changes to script tags on
a page. This is difﬁcult to accomplish with addJSPropWritePolicy, since all
instances of such tags may not be known in advance. Instead, this hook can
be used to register a policy on all tags that have a nodeName of “script.”

The BrowserShield framework is architected so that additional registration
functions (e.g., addJSPropReadPolicy) are straightforward, but we have not yet
encountered a need for them in practice.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:16

•

C. Reis et al.

Finally, we note that multiple policy functions can be registered for the same
function, HTML tag, or other hook. The BrowserShield framework simply calls
the policy functions in the order that they were registered.

5.3 Policy Distribution

Policy functions are downloaded separately from the remainder of the Browser-
Shield framework, and they can be updated and customized based on the in-
tended application. In the ﬁrewall deployment scenario, policy functions are
downloaded to the ﬁrewall, and clients fetch them in a ﬁle separate from the
BrowserShield framework. This allows the BrowserShield framework to be
cached on the client, with a longer cache expiry time than the policy functions.
We envision that a centralized service provider or vendor could provide
BrowserShield policy ﬁles. If multiple vendors provided policy ﬁles, a ﬁrewall
administrator could act as an integrator for the ﬁles. Policy vendors would be re-
sponsible for keeping vulnerability policies up to date and notifying subscribers
when new updates are available. This scenario is analogous to the current model
of distributing virus signatures for antivirus products.

6. IMPLEMENTATION

We have implemented a prototype of BrowserShield as a service deployed at
a ﬁrewall and proxy cache. Our prototype consists of a standard plugin to
Microsoft’s Internet Security and Acceleration (ISA) Server 2004 [Microsoft ISA
2004], and a JavaScript library that is sent to the client with transformed web
documents. The ISA plugin plays the role of the BrowserShield logic injector.

We implemented our ISA plugin in C++ with 2,679 lines of code. Our
JavaScript library has 3,493 lines (including comments). Most of the ISA plugin
code is devoted to parsing HTML, while about half of the JavaScript library is
devoted to parsing HTML or JavaScript. This is a signiﬁcantly smaller amount
of code than in a modern Web browser, which implies that our trusted comput-
ing base is small compared to the code base we are protecting.

The ISA plugin is responsible for applying the THTML transformation to static
HTML. The ISA plugin ﬁrst inserts a reference to the BrowserShield JavaScript
library into the Web document. Because this library is distributed in a separate
ﬁle, clients automatically cache it, reducing network trafﬁc on later requests.
THTML then rewrites all script elements such that they will be transformed using
Tscript at the client before they are executed. Figure 3 depicts this transforma-
tion; note that it does not require translating the JavaScript at the ﬁrewall.

In our implementation, the ﬁrewall component applies THTML using a stream-
ing model, such that the ISA Server can begin sending transformed data to the
client before the entire page is received. This streaming model also means that
we do not expect the ﬁlter to be vulnerable to state-holding DoS attacks by
malicious Web pages.

One complexity is that BrowserShield’s HTML parsing and JavaScript pars-
ing must be consistent with that of the underlying browser. Any inconsistency
will cause false positives and false negatives in BrowserShield runtime checks.
For our prototype, we have sought to match IE’s behavior through testing and

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:17

Table II. BrowserShield Vulnerability Coverage

Protected by

BrowserShield HTTP Filter

Antivirus

12

2∗

0

0

3∗

0

0

0

4

Vulnerability

Type
HTML, script,

#
12

ActiveX

HTTP

images and
other ﬁles

3

4

∗Two of the HTTP vulnerabilities required both BrowserShield and an HTTP ﬁlter
to provide patch-equivalent protection.

reﬁnement. If future versions of browsers exposed this logic to other programs,
it would make this problem trivial.

When the browser starts to run the script in the page, the library applies
Tscript to each piece of script code, translating it to call into the BrowserShield
interposition layer. This may sometimes require decoding scripts, a procedure
that is implemented in publicly available libraries [Virtual Conspiracy 2005]
and which does not require cryptanalysis, though we have not yet incorporated
it in our implementation.

A ﬁnal issue in Tscript is translating scripts that originate in source ﬁles
linked to from a <script src=...> tag. THTML rewrites such source URLs so
that they are fetched through a proxy. The proxy wraps the scripts in the same
way that script code embedded directly in the page is wrapped. For exam-
ple, a script source URL of http://foo.com/script.js would be translated
to http://rewritingProxy/ translateJS.pl?url=http://foo.com/ script.js.
Tscript is then applied at the client after the script source ﬁle is downloaded.

7. EVALUATION

Our evaluation focuses on measuring BrowserShield’s vulnerability coverage,
the complexity of authoring vulnerability ﬁlters, the overhead of applying the
BrowserShield transformations at ﬁrewalls, and the overhead of running the
BrowserShield interposition layer and vulnerability ﬁlters at end hosts.

7.1 Vulnerability Coverage

We evaluated BrowserShield’s ability to protect IE against all critical vulnera-
bilities for which Microsoft released patches in 2005 [Microsoft 2005]. Of the 29
critical patches that year, 8 are for IE, corresponding to 19 IE vulnerabilities.
These vulnerabilities fall into three classes: IE’s handling of (i) HTML, script,
or ActiveX components, (ii) HTTP, and (iii) images or other ﬁles. Table II shows
how many vulnerabilities there were in each area, and whether BrowserShield
or another technology could provide patch-equivalent protection. The Browser-
Shield design is focused on HTML, script, and ActiveX controls, and it can
successfully handle all 12 of these vulnerabilities. This includes vulnerabilities
where the underlying programmer error is at a higher layer of abstraction than
a buffer overrun, for example, a cross-domain scripting vulnerability. Handling
HTTP accounted for 3 of the 19 vulnerabilities. Perhaps surprisingly, 2 out of

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:18

•

C. Reis et al.

Fig. 6. BrowserShield policy to prevent exploits of the MS05-037 vulnerability.

3 of these vulnerabilities required BrowserShield in addition to an existing
HTTP ﬁlter, such as Snort [Snort 2005] or Shield [Wang et al. 2004]. This is
because malformed URLs could trigger the HTTP layer vulnerabilities regard-
less of whether the URL came over the network or was generated internally
by the browser. BrowserShield is able to prevent the HTML/script layer from
triggering the generation of these bad HTTP requests. Processing images or
other ﬁles accounted for the remaining 4 vulnerabilities. Patch-equivalent pro-
tection for these vulnerabilities is already available using existing antivirus
solutions [Seltzer 2005].

Because management and deployment costs are often incurred on a per-
patch basis, we also analyze the vulnerabilities in Table II in terms of the
corresponding patches. For the 8 IE patches released in 2005, combining
BrowserShield with standard antivirus and HTTP ﬁltering would have pro-
vided patch-equivalent protection in every case, greatly reducing the costs as-
sociated with multiple patch deployments. In the absence of BrowserShield,
antivirus and HTTP ﬁltering would have provided patch-equivalent protection
for only 1 of the IE patches.

7.2 Authoring Vulnerability Filters

To evaluate the complexity of vulnerability ﬁltering, we choose three vulnerabil-
ities from three different classes: HTML Elements Vulnerability (MS04-040),
COM Object Memory Corruption (MS05-037), and Mismatched DOM Object
Memory Corruption (MS05-054). We ﬁltered for the MS04-040 vulnerability
using the function shown in Figure 2, registered as shown in Figure 5.

COM object vulnerabilities typically result from IE instantiating COM ob-
jects that have memory errors in their constructors. The IE patch blacklists
particular COM objects (identiﬁed by their clsid). Implementing an equiv-
alent blacklist in BrowserShield requires adding checks for an HTML tag
(the OBJECT tag) and sometimes a JavaScript function (the ActiveXObject
constructor, which can be used to instantiate a subset of the COM objects
accessible through the OBJECT tag). In the case of MS05-037, it does not
appear to be possible to instantiate the vulnerable COM object using the
ActiveXObject constructor. The code for the OBJECT tag ﬁlter we use is shown in
Figure 6.

The MS05-054 vulnerability results when the window object, which is not
a function, is called as a function in the outermost scope. Our interposition

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:19

Fig. 7. BrowserShield policy to prevent treating the window object as a function.

layer itself prevents window from being called as a function in the outermost
scope since all function calls are mediated by BrowserShield with invokeFunc.
Hence there is no need for a ﬁlter. Nevertheless, if this vulnerability had not
depended on such a scoping constraint, we could simply have added a ﬁlter to
prevent calling the object as a function. Figure 7 shows how such a ﬁlter could
be written.

To test the correctness of our vulnerability ﬁlters, we installed an unpatched
image of Windows XP Pro within a virtual machine, and created Web pages
for each of the vulnerabilities that caused IE to crash. Applying BrowserShield
with the ﬁlters caused IE to not crash upon viewing the malicious Web pages.
We tested the ﬁdelity of our ﬁlters using the same set of URLs that we used in
our evaluation of BrowserShield’s overhead (details are in Section 7.3). Under
side-by-side visual comparisons, we found that the ﬁlters had not changed the
behavior of any of the Web pages, as desired.

7.3 Firewall Performance

We evaluated BrowserShield’s performance by scripting multiple IE clients to
download web pages (and all their embedded objects) through an ISA server
running the BrowserShield ﬁrewall plugin. The ISA ﬁrewall ran on a Compaq
Evo PC containing a 1.7GHz Pentium 4 microprocessor and 1 GB RAM. Because
we are within a corporate intranet, our ISA server connected to another HTTP
proxy, not directly to web sites over the internet. We disabled caching at our
ISA proxy, and we ﬁxed our IE client cache to contain only the BrowserShield
JavaScript library, consistent with the scenario of a ﬁrewall translating all web
sites to contain a reference to this library.

We ran 10 IE processes concurrently using 10 pages that IE could render
quickly (so as to increase the load on the ﬁrewall), and repeatedly initiated
each page visit every 5 seconds. We used manual observation to determine
when the load on the ISA server had reached a steady state.

We chose these 10 pages out of a set of 70 URLs that are the basis for our
client performance macrobenchmarks. This set is based on a sample of 250 of
the top 1 million URLs clicked on after being returned as MSN Search results
in Spring 2005, weighted by click-through count. Speciﬁcally, the 70 URLs are
those that BrowserShield can currently render correctly; the remaining URLs
in the sample encountered problems due to incomplete aspects of our imple-
mentation, such as JavaScript parsing bugs.

We measured CPU and memory usage at the ﬁrewall, as shown in Table III.
We observed a 3.3% absolute increase in CPU usage when introducing Browser-
Shield, from 15% to 18.3%. This corresponds to a relative increase of 22%. If
the ﬁrewall is CPU bound, then the throughput is inversely proportional to the

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:20

•

C. Reis et al.

Table III. BrowserShield Firewall Overhead (“Virtual
memory” measures the total virtual memory allocated
to the process; “working set” measures memory pages
that are referenced regularly; “private bytes” measures

memory pages that are not sharable.)

Resource
cpu utilization
virtual memory
working set
private bytes

Unmodiﬁed

Browsershield

15.0%
317 MB
45.5 MB
26.3 MB

18.3%
319 MB
46.6 MB
27.3 MB

Table IV. BrowserShield Microbenchmarks (Slowdown is the ratio of the execution

time of BrowserShield translated code and that of the original code.)

Operation

Slowdown

1
2
3
4
5
6
7
8
9
10
11
12

i++
a = b + c
if
string concat (‘+’)
string concat (‘concat’)
string split (‘split’)
no-op function call
x.a = b (property write)
eval of minimal syntactic structure
eval of moderate syntactic structure, minimal computation
eval of moderate syntactic structure, signiﬁcant computation
image swap

1.00
1.00
1.07
1.00

61.9
21.9
44.8
342
47.3
136

1.34
1.07

CPU utilization. Thus, we compute the throughput degradation to be 18%, as
shown in Equation (1).

Throughputbrowsershield

− Throughputunmodiﬁed

Throughputunmodiﬁed

1

18.3

− 1
15

=

1
15

= −18.0%.

(1)

All aspects of memory usage we measured increased by negligible amounts.
We also found that network usage increased only slightly (more detail in
Section 7.4.2).

7.4 Client Performance

We evaluated the client component of our BrowserShield implementation
through microbenchmarks on the JavaScript interposition layer and mac-
robenchmarks on network load, client memory usage, and the latency of page
rendering.

7.4.1 Microbenchmarks. We designed microbenchmarks to measure the
overhead of individual JavaScript operations after translation. Table IV lists
our microbenchmarks and their respective BrowserShield slowdown. Our re-
sults are averages over 10 trials, where each trial evaluated its microbenchmark
repeatedly, and lasted over half a second. For the ﬁrst 11 microbenchmarks,
the standard deviation over the 10 trials was less than 2%. In the last case it
was less than 8%. The slowdown ratio was computed using the average time

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:21

required per microbenchmark evaluation with and without the interposition
framework.

Microbenchmarks 1–4 measure operations for which we expect no changes
during rewriting, and hence no slowdown. The only slowdown we measure is in
the case of the if statement. Further examination showed that the Browser-
Shield translation inserted a semi-colon (e.g., var a = 1 (linebreak) changed
to var a = 1; (linebreak)). This results in a 7% slowdown.

Microbenchmarks 5–8 measure operations we expect to incur a slowdown
comparable to an interpreter’s slowdown. As detailed in Section 4, Browser-
Shield translation introduces additional logic around method calls, function
calls, and property writes, leading to a slowdown in the range of 20x–400x. This
slowdown is in line with good interpreters [Romer et al. 1996], but worse than
what is achieved by rewriting systems targeting other languages, for exam-
ple, Java bytecode [Erlingsson and Schneider 2000a]. BrowserShield is paying
a price for the JavaScript subtleties that previous rewriting systems did not
have to deal with. We were curious about the difference in slowdown between
the two string methods; an additional experiment showed that the difference
can be attributed to the JavaScript built-in concat method requiring about 3
times as much CPU as the built-in split method. Also, it is not surprising
that property writes have a greater slowdown than function or method calls
because property writes need to both guard the BrowserShield namespace and
interpose on writes to DOM elements (such as the text property of scripts).

Microbenchmarks 9–11 explore the overhead of translating JavaScript code
of various complexity. The “eval of minimal syntactic structure” microbench-
mark measures the cost of translating and then evaluating a simple assign-
ment. The cause of the large slowdown is the additional work done by eval
in the BrowserShield framework: parsing, constructing an AST, modifying the
AST, and outputting the new AST as a JavaScript program. The two subse-
quent “eval of moderate syntactic structure” microbenchmarks measure the
cost of translating and evaluating a simple for(;;) loop. This simply demon-
strates that as the cost of the computation inside the simple loop increases,
the cost of translating the code can decrease to a small fraction of the overall
computational cost.

The last microbenchmark measures the overhead of performing a simple ma-
nipulation of the DOM—swapping two 35 KB images. This microbenchmark is
designed to measure the relative importance of overheads in the JavaScript
engine when the JavaScript is manipulating the layout of the HTML page.
The JavaScript code to swap these two images requires two property writes
(i.e., img.src = ’newLink’), and we have already described how BrowserShield
translation adds signiﬁcant overhead to property writes. Nonetheless, the over-
all slowdown is less than 8%. In particular, the raw time to swap the image
only increases from 26.7 milliseconds to 28.5 milliseconds. This suggests that
even the large overheads that BrowserShield translation adds to some lan-
guage constructs may still be quite small in the context of a complete web
page.

In summary, BrowserShield incurs a signiﬁcant overhead on the language
constructs where it must add interpreter-like logic, but these overheads can be

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:22

•

C. Reis et al.

Fig. 8. Latency CDF with and without BrowserShield.

quite small within the context of the larger DOM manipulations in embedded
scripts.

7.4.2 Macrobenchmarks. We designed macrobenchmarks to measure the
overall client experience when the BrowserShield framework is in place. In par-
ticular, the macrobenchmarks include all the dynamic parsing and translation
that occurs before the page is rendered, while the microbenchmarks primarily
evaluated the performance of the translated code accomplishing a task relative
to the untranslated code accomplishing that same task. To this end, we scripted
an instance of IE to download each of the 70 web pages in our workload 10 times.
For the same reasons given in our evaluation of the BrowserShield ISA compo-
nent, we maintained that the only object in the IE cache was the BrowserShield
JavaScript library. These caching policies represent a worst case for client la-
tency, because all pages and objects must be fetched from the network. (The
BrowserShield library itself must be fetched only once.) The macrobenchmarks
include the overhead of the three ﬁlters that we discussed in Section 7.2. We
then repeated these measurements without the BrowserShield framework and
translation.

We set a 30-second upper limit on the time to render the web page, includ-
ing launching secondary (popup) windows and displaying embedded objects,
but not waiting for secondary windows to render. We visually veriﬁed that the
programmatic signal that rendering had completed indeed corresponded to the
user’s perception that the page had rendered. IE hit the 30-second timeout sev-
eral times in these trials, and it hit the timeouts both when the BrowserShield
framework and translation were present and when the framework and transla-
tion were absent. We did not discern any pattern in these timeouts, and because
our experiments include factors outside our control, such as the wide-area net-
work and the servers originating the content, we do not expect page download
times to be constant over our trials. We reran the trials that experienced the
timeouts.

Figure 8 shows the CDF of page rendering with and without BrowserShield.
On average BrowserShield added 1.7 seconds to page rendering time. By way
of contrast, the standard deviation in rendering time without BrowserShield
was 1.0 seconds.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:23

Fig. 9. Breakdown of latency for slowest 10 pages under BrowserShield.

Fig. 10. Latency of JavaScript parsing.

In Figure 9, we further break down the latency for the 10 pages that took
the most time to render under BrowserShield. They experienced an average
increase in latency of 6.3 seconds, requiring 3.9 seconds on average with-
out BrowserShield and 10.2 seconds on average with BrowserShield. Of this
6.3 seconds of increased latency, we found that 2.8 seconds (45%) could be
attributed to the overhead of dynamically translating JavaScript and HTML
within IE. We attribute the remaining overhead to effects such as the overhead
of evaluating the translated code, and the time to modify the HTML at the
ﬁrewall.

We broke down the latency of dynamic translation for both HTML and
JavaScript into 2 parts each: time to parse the JavaScript/HTML into an AST
and convert the modiﬁed AST back to a string, and the time to modify the AST.
We found that the time to parse the JavaScript to and from a string was always
more than 70% of the overall latency of dynamic translation, and it averaged
80% of the overall latency. Figure 10 shows the JavaScript parsing time versus
the number of kilobytes. Fitting a least-squares line to this data yields an av-
erage parse rate of 4.1 KB of JavaScript per second, but there was signiﬁcant
variation; the slowest parse rate we observed was 1.3 KB/second.

Figure 11 shows the memory usage of page rendering with and with-
out BrowserShield. We found that private bytes (memory pages that are
not sharable) was the client memory metric that increased the most when

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:24

•

C. Reis et al.

Fig. 11. Memory usage at client.

rendering the transformed page. Private memory usage increased on average
by 11.8%, from 19.8 MB to 22.1 MB. This increase was quite consistent; no page
caused memory usage to increase by more than 3 MB.

We also measured the increased network load over a single run through the
pages both with and without BrowserShield. We measured an average increase
of 9 KB, less than the standard deviation in the network load over any in-
dividual trial due to background trafﬁc during our measurements. We expect
BrowserShield rewriting to only slightly increase the network load, because the
ﬁrewall just adds script wrappers, while the translation itself happens at the
client.

8. APPLICATIONS

Our motivating application for BrowserShield is to prevent exploits of known
browser vulnerabilities. The BrowserShield framework is general, however, and
it can be useful for a wide variety of applications, related to browser security
or not. In this section, we explore how the framework can be used to compre-
hensively translate links, aid in script debugging, sandbox scripts, and enable
certain antiphishing measures.

Comprehensive Link Translation. One application of BrowserShield out-
side security involves comprehensive link translation. URL rewriting is offered
by some web proxies (e.g., EZproxy [Useful Utilities 2007]) and web servers
(e.g., Apache [Apache Foundation 2007]), but in these cases rewriting can only
be applied to links that appear in the HTML page as it is transferred over
the network. Any links that are generated by script code on the page will not
be rewritten. In contrast, BrowserShield policies can intercept any link on a
page that a user attempts to visit, whether it appears in the original source of
the page or not.

Comprehensive link translation can be useful in many contexts. For exam-
ple, corporate intranet sites, such as Microsoft’s SharePoint product [Microsoft
SharePoint 2007], often contain links that are accessible only within the in-
tranet. Providing remote authenticated access to employees may be desirable,
but in such cases, links must be translated to use a proxy server. Using Browser-
Shield, all links and redirects in a page can be comprehensively identiﬁed and

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:25

translated, whether they exist in the original HTML or are generated by scripts.
This would allow sites such as SharePoint to easily export a view for remote
authenticated access.

Similarly, a link translation policy may be useful for search engines that
provide cached results, such as Google and MSN. Currently, users visit the
cached copies of a search result when the original server is unavailable, but
any embedded links and images continue to point to the unavailable server.
A BrowserShield policy could translate HTML and script-generated links in
cached pages to redirect into the search engine’s cache, allowing users to browse
entirely within the cache. If deployed at a search engine and combined with the
vulnerability policies discussed in this paper, this search engine cache could
provide a safer search and browsing experience as well.

The Coral content distribution network [Freedman et al. 2004] could also
beneﬁt from such link translation. Any URL can be fetched through the Coral
CDN by appending “nyud.net:8090” to its domain name. A BrowserShield pol-
icy could easily perform this “Coralization” for all links on a given page, allowing
users to transparently use Coral while navigating a web site.

Script Debugging. As another application outside the realm of security,
BrowserShield policies can be used to provide extensible JavaScript debug-
ging or proﬁling functionality. Many browsers have integrated JavaScript de-
buggers, but these debuggers have interfaces that vary across browsers and
cannot always be extended with new features. Debugging using BrowserShield
policies could offer a browser agnostic interface and the opportunity to easily
register custom hooks or logging functionality within a page’s code. Perhaps
even more importantly, BrowserShield allows JavaScript developers to debug
JavaScript code running on the client without requiring any trust from the
client. BrowserShield debugging policies could easily include call traces, condi-
tional breakpoints, and proﬁling information.

We are currently investigating how to use BrowserShield policies to instru-
ment and analyze web applications [Kiciman and Wang 2007]. This would al-
low debugging, proﬁling, and maintaining web applications as they are used in
practice.

Script Sandboxing. BrowserShield policies can be useful for security-
related tasks beyond browser exploit prevention, as well. For example, many
Web sites today host user-contributed content, such as wikis, blogs, and social
networking sites. These sites currently attempt to prevent any scripts from
appearing in user-contributed content, because such scripts could leak private
information to an attacker. Identifying and removing scripts can be challeng-
ing, however, often leaving these sites vulnerable to “cross-site scripting” at-
tacks [CERT 2000].

To address this, BrowserShield policies could be created to sandbox the user-
contributed content on such sites. Such policies might prevent any scripts from
running in certain areas of a page, as proposed by Jim et al. [2007]. Alterna-
tively, the authors of these community-driven sites might want to allow certain
kinds of user-contributed dynamic content, such as simple scripts or function

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:26

•

C. Reis et al.

calls approved by the site authors. BrowserShield polices could enforce a corre-
sponding sandbox or otherwise restrict the actions that scripts on a page may
take. Content Restrictions [Markham 2006] is an example of a proposed set of
restrictions on script actions.

Anti-Phishing Aids. Finally, BrowserShield policies can be used to enforce
invariants on the user interface of the browser, which can be useful to pre-
vent deceptive behavior employed by some phishing sites. For example, some
phishing sites use JavaScript to change the text in the status bar to hide the
true destination of links, and some open new windows without location bars.
BrowserShield policies can be used to prevent such behavior, ensuring that the
status bar and location bar always display authentic information. This can aid
users in determining whether they are actually visiting the site they expect.

Overall, BrowserShield’s comprehensive interposition makes it useful for
security policies such as exploit prevention, but its general design supports a
wide range of additional applications as well.

9. RELATED WORK

We ﬁrst compare BrowserShield with other protection systems in Section 9.1.
We then discuss BrowserShield’s relation to the extensive work on code rewrit-
ing and interposition in Section 9.2.

9.1 Remote Exploit Defense

In our prior work on Shield [Wang et al. 2004], we proposed using vulnerability-
speciﬁc ﬁlters to identify and block network trafﬁc that would exploit known
software vulnerabilities. Shield maintains protocol-speciﬁc state machines in
an end-host’s network stack, allowing it to recognize when a packet will trigger
a vulnerability. However, the Shield approach does not address dynamic content
such as scripts in web documents, since it is undecidable whether script code
in a document will eventually exploit a vulnerability. BrowserShield shares
Shield’s focus on vulnerability-speciﬁc ﬁlters, but in contrast to Shield, its use
of runtime interposition allows it to handle exploits in dynamic HTML.

Like BrowserShield and Shield, IntroVirt also employs vulnerability-speciﬁc
predicates, speciﬁcally to detect past and present intrusions using virtual ma-
chine introspection and replay [Joshi et al. 2005]. As a result, IntroVirt allows
“just in time” patch application: postponing the application of a patch while an
exploit has not occurred, and rolling back system state to apply a patch if an
exploit does occur. BrowserShield instead offers protection while a patch is be-
ing tested (or otherwise delayed) by the administrator of a vulnerable system,
buying time even in cases where exploits are immediately attempted. Addition-
ally, BrowserShield supports more ﬂexible deployment scenarios. For example,
it does not require the client’s browser to run inside an instrumented virtual
machine.

Opus [Altekar et al. 2005] seeks to address the problem of patching by al-
lowing patches to be applied without restarting the application. Opus provides
tools for developers to increase the reliability of such “dynamic” patches during

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:27

development. However, these tools reduce, but do not eliminate, the program-
mer’s burden to produce a correct dynamic patch.

Vigilante [Costa et al. 2004] focuses on worm containment, automatically
detecting and preventing the spread of worm trafﬁc. Vigilante combines rapid
distribution of self-certifying alerts and automatic ﬁlter generation, along with
vulnerability detection techniques such as nonexecutable pages [PaX 2007] and
dynamic dataﬂow analysis [Newsome and Song 2005]. These techniques, even
with the Vigilante improvements, admit false negatives. BrowserShield does
not share the speed constraint of Vigilante, since browser exploits require hu-
man involvement and therefore do not spread on the same time scales as worms.
Therefore, we are able to trade off the speed of automatically generated vulner-
ability ﬁlters for the accuracy of hand-coded ﬁlters.

EarlyBird [Singh et al. 2004] and Autograph [Kim and Karp 2004] are two
exemplary systems that use pattern matching to block network trafﬁc contain-
ing exploits. Pattern matching scales to high data rates, crucial to the authors’
goal of stopping worm outbreaks at network choke points. The HTML scripts
that are BrowserShield’s focus seem difﬁcult to detect consistently with pattern
matching, as they can trivially modify themselves at the client.

HoneyMonkey [Wang et al. 2006] aims to discover Web servers that dis-
tribute malicious code. In HoneyMonkey, virtual machines automatically fetch
content from the Web and use black-box techniques to discover exploits. Exploit
discovery is complimentary to BrowserShield’s approach of providing patch-
equivalent protection to clients.

Finally, a number of techniques have aimed to sandbox the browser or other
applications, in effect protecting the operating system from the impact of an
exploit. These techniques include system call interposition [Garﬁnkel et al.
2004; Goldberg et al. 1996; Jones 1993] and Microsoft’s “protected mode” for
IE in Windows Vista [Friedman 2006]. These may limit damage to a user’s
computing environment, but they do not protect the browser itself, allowing
attacks such as keylogging to easily be conducted from exploited browsers.
Tahoma [Cox et al. 2006] takes the conﬁnement approach one step further,
sandboxing browsers in virtual machines and using site-speciﬁc manifests to
restrict browser trafﬁc to known servers. While this could help to mitigate
many browser related problems, the difﬁculty of getting such manifests widely
adopted is unclear.

9.2 Interposition Techniques

Interposition techniques such as code rewriting have been used in previous
work to achieve additional safety properties or otherwise modify the behavior
of existing code. Code rewriting is only one of several alternatives for backward
compatible modiﬁcations, and the choice of technique is inﬂuenced by tradeoffs
in deployability and performance. Directly modifying the execution environ-
ment, such as the Java Virtual Machine, has the highest deployment barriers.
Some work instead uses a level of indirection, such as emulation (e.g., Bochs
[2006]), easing deployment but incurring a high performance overhead. Thus,
BrowserShield and others [Erlingsson and Schneider 2000a; Wahbe et al. 1993;

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:28

•

C. Reis et al.

Waldspurger 2002] employ code rewriting, with its low barriers to deployment
and smaller performance overhead than that required by an emulator.

We characterize interposition techniques by the target of interposition, since
the technical differences between targets require different solutions. Compared
to approaches for other interposition targets, BrowserShield must address a
new combination of technical challenges presented by JavaScript: its scoping
rules, an implicit garbage collector, pervasive reﬂection, and its prototype-based
object model (which implies a lack of static typing).

Machine Code. Many approaches focus on the machine code interface,
whether rewriting binary instructions or emulating them at runtime. Soft-
ware Fault Isolation (SFI) [Wahbe et al. 1993] rewrites binary code to in-
sert runtime checks, creating sandboxes that prevent code from writing or
jumping to addresses outside its fault domain. This creates process-like mem-
ory boundaries between units of code within a process. The more recent XFI
[Erlingsson et al. 2006] uses binary rewriting to provide ﬂexible access con-
trol and additional integrity guarantees. VMware ESX Server [Waldspurger
2002] also rewrites machine code, in its case to allow programs to be virtual-
ized on x86 hardware. Etch [Romer et al. 1997] rewrites machine code with the
goals of proﬁling and measurement. Valgrind [2007] and Program Shepherd-
ing [Kiriansky et al. 2002] are dynamic binary instrumentation tools. Valgrind’s
goal is to offer debugging and proﬁling support, while Program Shepherding’s
goal is to monitor control ﬂow, preventing the transfer of control to data regions
which might include malicious code.

The techniques used for rewriting at the machine code interface do not need
to address any of the four challenges of JavaScript rewriting that have in-
ﬂuenced BrowserShield: scoping, reﬂection, garbage collection, or typing. Most
work interposing at the machine code interface only adds semantics that can be
deﬁned in terms of low level operations, such as enforcing a process-like memory
boundary, as in SFI. Indeed, Erlingsson and Schneider [2000b] note the difﬁ-
culty of extending rewriting at the machine code interface to enforce policies
on the abstractions internal to an application. BrowserShield’s interposition
target (the HTML document tree) is such an application-internal abstraction.

System Call Interface. Much previous work has modiﬁed user level program
behavior by interposing on the system call interface. Jones [1993] introduces a
toolkit for system call interposition agents that simpliﬁes tasks such as tracing,
emulation, and sandboxing. Goldberg et al. [1996] use system call interposition
in Janus to conﬁne untrusted applications to a secure sandbox environment.
Garﬁnkel [2003] notes difﬁculties in trying to interpose on the system call in-
terface, such as violating OS semantics, side effects, and overlooking indirect
paths. Garﬁnkel et al. [2004] discuss a delegation-based architecture to ad-
dress some of these problems. Naccio describes an approach to provide similar
guarantees by rewriting x86 code that links against the Win32 system call
interface [Evans and Twyman 1999]. Naccio can also rewrite Java bytecode.

Work on the system call interface differs from BrowserShield both in goal
and in technique. System call interposition can guard external resources from

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:29

an application, while the goal of BrowserShield is to guard an application-
internal resource, the HTML document tree. Naccio’s use of rewriting as a
technique to interpose on the system call interface does not present any of
the four technical challenges (scoping, reﬂection, garbage collection, or typing)
relevant to JavaScript rewriting. For example, Naccio also wraps methods to
accomplish interposition, but Naccio’s method wrappers do not need to handle
JavaScript’s scoping rules, and so do not need to implement swapping.

Java Bytecode. Several pieces of previous work [Erlingsson and Schneider
2000a; Erlingsson and Schneider 2000b; Sirer et al. 1999], including the pre-
viously mentioned Naccio [Evans and Twyman 1999], have used rewriting at
the Java Virtual Machine bytecode interface [Lindholm and Yellin 1999]. This
interface is type-safe, and provides good support for reasoning about
application-internal abstractions. In the most similar of these works to Browser-
Shield, Erlingsson’s PoET mechanism rewrites Java bytecode to enforce se-
curity policies expressed in the PSLang language [Erlingsson and Schneider
2000a].

JavaScript’s pervasive reﬂection, scoping rules, and prototype-based object
model forced us to develop several techniques not needed for Java bytecode
rewriting. For example, where Java bytecode rewriting can interpose on Java’s
reﬂection API, BrowserShield must interpose on all property reads and writes,
as well as some for loops, to achieve similar control over reﬂection. Additionally,
Java bytecode rewriting can achieve complete interposition by only modifying
callees (using method wrappers) and without maintaining state, though some
previous work allowed modifying callers or adding state to simplify policy con-
struction [Erlingsson and Schneider 2000a]. In contrast, BrowserShield must
modify both callers and callees to appropriately handle scoping and the pos-
sibility of functions aliased as methods (and vice versa). Also, BrowserShield
must maintain state, requiring careful attention to its interaction with the
JavaScript garbage collector.

Web Scripting Languages. Yu et al. [2007] independently proposed a policy-
driven JavaScript rewriting approach to improve browser security. They pro-
vide formal semantics for a subset of the JavaScript language, and they prove
that their rewriting process is both sound (i.e., rewritten code respects the poli-
cies) and transparent (i.e., rewriting will not affect the behavior of code that
respects the policy). These goals match those of BrowserShield. However, their
technique and evaluation are very different from BrowserShield. For example,
their policies use edit automata, while BrowserShield’s policies are written in
JavaScript. Yu et al. present two example policies, but they do not explore how
rewriting can protect against the critical browser vulnerabilities that we fo-
cus most of our attention on. Yu et al. rely on modiﬁcations to client browsers
for deployment. Finally, their performance evaluation does not cover as many
aspects as ours.

Other JavaScript rewriting techniques have not offered full interposition.
The SafeWeb anonymity service used a JavaScript rewriting engine that failed
to provide either interposition or transparency [Martin and Schulman 2002].

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:30

•

C. Reis et al.

The Greasemonkey [Greasemonkey 2007] extension to the Firefox browser al-
lows users to run additional site-speciﬁc scripts when a document is loaded,
but it does not provide complete interposition between the existing script code
and the HTML document tree.

10. CONCLUSION

Web browser vulnerabilities have become a popular vector of attacks. Filter-
ing exploits of these vulnerabilities is made challenging by the dynamic nature
of Web content. We have presented BrowserShield, a general framework that
rewrites HTML pages and any embedded scripts to enforce policies on runtime
behavior. We have designed BrowserShield to provide complete interposition
over the underlying resource (the HTML document tree) and to be transpar-
ent and tamper-proof. Because BrowserShield transforms content rather than
browsers, it supports deployment at clients, ﬁrewalls, or web publishers. Our
evaluation shows that adding this approach to existing ﬁrewall and antivirus
techniques increases the fraction of IE patches from 2005 that can be protected
at the network level from 12.5% to 100%, and that this protection can be done
with only moderate overhead. Though we have focused on the application of
vulnerability-driven ﬁltering in this paper, BrowserShield can also serve as a
platform for other new functionality on the Web, such as comprehensive link
translation, script sandboxing, and script debugging.

ACKNOWLEDGMENTS

We would like to thank Ulfar Erlingsson, Steve Gribble, Bill Weihl, Geoff
Voelker, and Alec Wolman for feedback on this paper. Also, we would like to
thank the anonymous reviewers for their helpful comments.

REFERENCES

ALTEKAR, G., BAGRAK, I., BURSTEIN, P., AND SCHULTZ, A. 2005. OPUS: Online patches and updates

for security. Usenix Security Sumposium.

ANDERSON, J. P. 1972. Computer Security Technology Planning Study. Vol. II ESD-TR-73-51,
Vol. II, Electronic Systems Division, Air Force Systems Command, Hanscom Field, Bedford, MA.

APACHE FOUNDATION 2007. The Apache HTTP server project. http://httpd.apache.org.
ARBAUGH, W. A., FITHEN, W. L., AND MCHUGH, J. 2000. Windows of vulnerability: A case study

analysis. IEEE Comput.

BEATTIE, S., ARNOLD, S., COWAN, C., WAGLE, P., AND WRIGHT, C. 2002. Timing the Application of
Security Patches for Optimal Uptime. In Large Installation System Administration Conference.

BOCHS 2006. Bochs: The Open Source IA-32 emulation project. http://bochs.sourceforge.net/.
CERT. 2000. CERT advisory CA-2000-02 malicious HTML tags embedded in client Web re-

quests. http://www.cert.org/advisories/CA-2000-02.html.

COSTA, M., CROWCROFT, J., CASTRO, M., ROWSTRON, A., ZHOU, L., ZHANG, L., AND BARHAM, P. 2004. Vigi-
lante: End-to-end containment of Internet worms. In Proceedings of the Symposium on Operating
Systems Principles.

COX, R. S., HANSEN, J. G., GRIBBLE, S. D., AND LEVY, H. M. 2006. A safety-oriented platform for Web

applications. In Proceedings of the IEEE Symposium on Security and Privacy.

ERLINGSSON, ´U., ABADI, M., VRABLE, M., BUDIU, M., AND NECULA, G. C. 2006. XFI: Software guards
for system address spaces. In Proceedings of the Symposium on Operating Systems Design and
Implementation.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

BrowserShield: Vulnerability-Driven Filtering of Dynamic HTML

•

11:31

ERLINGSSON, ´U. AND SCHNEIDER, F. B. 2000a.

IRM Enforcement of Java stack inspection. In Pro-

ceeding of the IEEE Symposium on Security and Privacy.

ERLINGSSON, ´U. AND SCHNEIDER, F. B. 2000b. SASI enforcement of security policies: A retrospective.

EVANS, D. AND TWYMAN, A. 1999. Flexible policy-directed code safety. In Proceedings of the IEEE

New Security Paradigms Workshop.

Symposium on Security and Privacy.

FREEDMAN, M. J., FREUDENTHAL, E., AND MAZIRES, D. 2004. Democratizing content publication with

Coral. In Proceedings of the Symposiumon Network Systems Design and Implementation.

FRIEDMAN, M. 2006. Protected mode in Vista IE7. http://blogs.msdn.com/ie/archive/2006/02/

09/528963.aspx.

GARFINKEL, T. 2003. Traps and pitfalls: Practical problems in system call interposition based

security tools. In Proceedings of the Network and Distributed System Security Conference.

GARFINKEL, T., PFAFF, B., AND ROSENBLUM, M. 2004. Ostia: A delegating architecture for secure
system call interposition. In Proceedings of the Network and Distributed System Security Con-
ference.

GOLDBERG, I., WAGNER, D., THOMAS, R., AND BREWER, E. A. 1996. A secure environment for untrusted

helper applications. In Usenix Security Symposium.

GREASEMONKEY. 2007. Greasemonkey. http://greasemonkey.mozdev.org/.
JIM, T., SWAMY, N., AND HICKS, M. 2007. Defeating script injection attacks with browser-enforced

embedded policies. In Proceedings of the World Wide Web Conference.

JONES, M. B. 1993.

Interposition agents: Transparently interposing user code at the system

interface. In Proceedings of the Symposiums on Operating System Principles.

JOSHI, A., KING, S. T., DUNLAP, G. W., AND CHEN, P. M. 2005. Detecting past and present intrusions
through vulnerability-speciﬁc predicates. In Proceedings of the Symposium on Operating System
Principles.

KICIMAN, E. AND WANG, H. J. 2007. Live monitoring: Using adaptive intstrumentation and analysis

to debug and maintain Web applications. In HotOS XI.

KIM, H.-A. AND KARP, B. 2004. Autograph: Toward automated, distributed worm signature detec-

KIRIANSKY, V., BRUENING, D., AND AMARASINGHE, S. 2002. Secure execution via program shepherding.

LINDHOLM, T. AND YELLIN, F. 1999. The Java Virtual Machine Speciﬁcation, 2nd ED. Sun Microsys-

MARKHAM, G. 2006. Content restrictions. http://www.gerv.net/security/content-restrictions/.
MARTIN, D. AND SCHULMAN, A. 2002. Deanonymizing users of the safeWeb anonymizing service.

MICROSOFT. 2004. Microsoft security bulletin MS04-040. http://www.microsoft.com/technet/

tion. Usenix Security Symposium.

Usenix Security Symposium.

tem.

In USENIX Security Symposium.

security/Bulletin/MS04-040.mspx.

MICROSOFT. 2005. Microsoft security bulletin summaries and webcasts. http://www.microsoft.

com/technet/security/bulletin/summary.mspx.

MICROSOFT ISA. 2004.

Internet security and acceleration server. http://www.microsoft.com/

MICROSOFT SHAREPOINT. 2007. SharePoint. http://www.microsoft.com/sharepoint.
MOZILLA. 2005. Mozilla Foundation security advisories. http://www.mozilla.org/security/

isaserver/default.mspx.

announce.

NEWSOME, J. AND SONG, D. 2005. Dynamic taint analysis for automatic detection, analysis, and
signature generation of exploits on commodity software. In Proceedings of the Network and Dis-
tributed System Security Conference.

PAX. 2007. Homepage of PaX. http://pax.grsecurity.net/.
ROMER, T., VOELKER, G., LEE, D., WOLMAN, A., WONG, W., LEVY, H., AND BERSHAD, B. 1997.
Instrumentation and optimization of Win32/Intel executables using Etch. Usenix NT
Workshop.

ROMER, T. H., LEE, D., VOELKER, G. M., WOLMAN, A., WONG, W. A., BAER, J.-L., BERSHAD, B. N., AND

LEVY, H. M. 1996. The structure and performance of interpreters. In ASPLOS.

SALTZER, J. H. AND SCHROEDER, M. D. 1973. The protection of information in computer systems. In

Proceedings of the Symposium on Operating Systems Principles.

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

P1: OJL

ACMJ321-01

ACM-TRANSACTION

September 19, 2007

23:47

11:32

•

C. Reis et al.

SECURE COMPUTING. 2006. Webwasher SSL Scanner. http://www.securecomputing.com/pdf/WW-

SSLscan-PO.pdf.

SELTZER, L. 2005. Eweek. Anti-virus protection for WMF ﬂaw still inconsistent. http://www.

eweek.com/article2/0,1895,1907102,00.asp.

SINGH, S., ESTAN, C., VARGHESE, G., AND SAVAGE, S. 2004. Automated worm ﬁngerprinting. In Pro-

ceedings of the Symposium on Operating Systems Design and Implementation.

SIRER, E. G., GRIMM, R., GREGORY, A. J., AND BERSHAD, B. N. 1999. Design and implementation
of a distributed virtual machine for networked computers. In Proceedings of the Symposium on
Operating Systems Principles.

SNORT. 2005. The Open Source Network intrusion detection system. http://www.snort.org/.
UNGAR, D. AND SMITH, R. B. 1987. Self: The power of simplicity. In Proceedings of the Conference

on Object-Oriented Programming Systems, Languages, and Applications.

USEFUL UTILITIES. 2007. Ezproxy by useful utilities. http://www.usefulutilities.com.
VALGRIND. 2007. Valgrind. http://www.valgrind.org/.
VIRTUAL CONSPIRACY. 2005. Windows script decoder. http://www.virtualconspiracy.com.
WAHBE, R., LUCCO, S., ANDERSON, T., AND GRAHAM, S. 1993. Efﬁcient software-based fault isolation.

In Proceedings of the Symposium on Operating Systems Principles.

WALDSPURGER, C. A. 2002. Memory resource management in VMware ESX server. In Proceedings

of the Symposium on Operating Systems Design and Implementation.

WANG, H. J., GUO, C., SIMON, D. R., AND ZUGENMAIER, A. 2004. Shield: Vulnerability-driven network

ﬁlters for preventing known vulnerability exploits. In Proceedings of the SIGCOMM.

WANG, Y.-M., BECK, D., JIANG, X., ROUSSEV, R., VERBOWSKI, C., CHEN, S., AND KING, S. 2006. Auto-
mated Web patrol with Strider HoneyMonkeys: Finding Web sites that exploit browser vulnera-
bilities. In Proceedings of the Network and Distributed Systems Security Conference.

YU, D., CHANDER, A., ISLAM, N., AND SERIKOV, I. 2007.

JavaScript instrumentation for browser

security. In Proceedings of the Symposium on Principles of Programming Language.

Received February 2007; revised June 2007; accepted July 2007

ACM Transactions on the Web, Vol. 1, No. 3, Article 11, Publication date: September 2007.

