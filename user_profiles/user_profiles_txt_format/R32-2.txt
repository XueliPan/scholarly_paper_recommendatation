On the Integration of Context-based Heterogeneous 

Middleware for Ubiquitous Computing 

Frederico Lopes, Flavia 

Delicato 

DIMAp - UFRN 
Natal (RN), Brazil 

[fred.lopes, 

fdelicato]@gmail.com 

Thais Batista 
DIMAp - UFRN 
Natal (RN), Brazil 
thais@ufrnet.br 

Computing Departament – Lancaster 

Nelio Cacho 

University 

Lancaster, UK 

n.cacho@lancaster.ac.uk 

ABSTRACT 
The use of context provision middleware is a promising approach 
for  dealing  with  the  low-level  functions  involved  in  handling 
contextual  events  when  building  ubiquitous  applications.  Several 
middleware platforms are currently available that provide support 
for  context  handling,  each  one  adopting  different  models  for 
interacting with applications and representing contextual data, and 
aiming at handling different types of context. There are ubiquitous 
applications 
that  need  dealing  with  a  high  degree  of 
heterogeneous  context  sources  and  detection  of  complex  event 
patterns  thus  requiring  support  of  different  and  often  non-
interoperable middleware platforms.  For  this kind of  application, 
developers  must  handle 
thus 
increasing the complexity of the application code. To address this 
issue,  we  propose  OpenCOPI 
(Open  COntext  Platform 
Integration),  a  context  platform  that  integrates  several  context 
provision middleware and provides common services for handling 
the  composition  of  contextual  events  in  order  to  offer  a  unified 
context platform. This paper introduces OpenCOPI and details its 
composition  event  service,  CES,  showing  the  integrating  of  two 
context middleware. The paper also describes a case study, based 
on a Meeting Detection System, to illustrate the use of CES. 

the  platform  heterogeneity, 

Categories and Subject Descriptors 
C.2.4 
Systems – Distributed application; 

[Computer-Communication  Networks]:  Distributed 

General Terms 
Design, Algorithms. 

Keywords 
Ubiquitous  applications,  pervasive  computing,  context-based 
middleware, context heterogeneity 

1.  INTRODUCTION 
Ubiquitous  computing 
[1]  consists  of  sensor-instrumented 
environments, often endowed with wireless network interfaces, in 
which  devices,  software  agents  and  services  are  integrated  in  a 
seamless  and  transparent  way  and  cooperate  to  meet  high  level 

 

Permission to make digital or hard copies of all or part of this work for 
personal or classroom use is granted without fee provided that copies are 
not  made  or  distributed  for  profit  or  commercial  advantage  and  that 
copies  bear  this  notice  and  the  full  citation  on  the  first  page.  To  copy 
otherwise,  to  republish,  to  post  on  servers  or  to  redistribute  to  lists, 
requires prior specific permission and/or a fee. 

MPAC’08, December 1-5, 2008 Leuven, Belgium 

Copyright 2008 ACM 978-1-60558-364-8/08/12... $5.00 

 
 

goals of user applications. These environments typically present a 
high degree of dynamism regarding different characteristics of the 
execution  state.  Mobile  devices  frequently  move,  entering  and 
leaving  the  range  of  a  given  network;  wireless  connectivity  is 
subject  to  disruptions  and  oscillations  in  the  strength  of  the 
transmitted  signal,  physical  parameters  such  as  temperature  and 
light  frequently  changes  and  so  on.  Applications  that  run  in 
ubiquitous  environments  must  cope  with  their  dynamic  features 
and  preferably  exploit  such  characteristics  to  provide  services  of 
better quality to the final user. Therefore, ubiquitous applications 
must  encompass  mechanisms  to  provide  awareness  of  the 
surrounding context and adaptive behavior in function of changes 
in  this  context.  Context  is  "any  information  that  can  be  used  to 
characterize the situation of an entity (person, local or object) that 
is  considered  important  for  the  interaction  between  the  user  and 
the  application,  including  the  own  user  and  the  application  itself 
[2]".  Context  awareness  refers  to  the  ability  of  an  application  to 
perceive  characteristics  of  its  environment,  to  detect  changes  in 
those  characteristics  and  to  trigger  adaptations  according  to 
different execution conditions. 

Changes  in  the  execution  context  are  detected  by  ubiquitous 
applications as events originating from the underlying distributed 
infrastructure.  Such  events  often  occur  concurrently  and  come 
from different sources. Individual, low-level events are less useful 
to applications than aggregated events, representing a higher level 
view of the changing environment. The high heterogeneity and the 
distributed  nature  of  event  sources  along  with  the  need  of 
composing individual events in higher level data of interest to the 
application hinder the handling of contextual information.  

Instead  of  incorporating  functionalities  for  handling  contextual 
events  into  the  application  business  code,  a  more  promising 
approach is to delegate them to underlying infrastructures such as 
platforms or middleware for context provision. Such  middleware 
support  most  of  the  tasks  involved  in  dealing  with  contextual 
events  thus  unburdening  applications  from  explicit  dealing  with 
the involved complexities. 

information 

for  handling  and 

Several  context  provision  middleware  are  currently  available  [2, 
3,  4,  5],  each  one  addressing  different  types  of  context  and 
adopting  different  models 
representing 
contextual 
(known  as  context  model).  Each 
middleware  is  often  more  suitable  to  meet  different  application 
requirements. Such trend in designing specific middleware creates 
a  problem  to  developers  of  applications  that  require  handling  a 
wide  range  of  contextual  events.  Typical  examples  are  Health 
Care  and  Vehicular  applications.  In  a  Health  Care  Mobile 
application,  patients  are  monitored  at  home  from  multiple 

31physical  sensors  measuring  their  vital  signs,  for  example,  heart 
beats  per  minute,  blood  pressure,  temperature,  etc.  Whenever  an 
emergency  situation  occurs  that  needs  further  medical  attention, 
the application looks for the nearest ambulance to help the patient. 
So, the application uses a middleware to receive information from 
sensors  that  monitors  the  patient  vital  signs  and  another 
middleware  that  offers  location  services  (through  GPS,  RFID, 
GSM,  or  other  technology)  to  find  out  which  ambulance  can 
attend  the  patient  as  soon  as  possible.  A  vehicular  ubiquitous 
application offers information about the traffic (via GPS) and user 
preferences  to  decide  the  best  routes  to  be  followed.  Moreover, 
this  type  of  application  monitors  and  tries  to  avoid  accidents 
occurring  with 
the  vehicle  by  using 
environmental  sensors.  Therefore,  the  vehicle  is  equipped  with 
sensors to adjust its braking configuration according to the type of 
road, weather conditions, current calibration of tires, etc. Another 
example  is  a  Meeting  Detecting  application,  which  is  used  as  a 
case  study  in  our  work.  Developers  of  such  kind  of  applications 
must know in details different platforms for context provision and 
to programmatically handle the integration among them. For this 
kind  of  applications,  instead  of  dealing  with  specificities  of 
context developers have to deal with specificities of middleware, 
meaning  that  the  complexity  remains,  it  was  only  moved  to  a 
higher level. 

the  occupants  of 

that 

To  address  the  requirements  of  such  ubiquitous  applications,  we 
propose  OpenCOPI  (Open  COntext  Platform  Integration),  a 
context  platform 
integrates  several  context  provision 
middleware  in  order  to  provide  a  unified  service  for  handling 
contextual  events.  OpenCOPI  provides  a  unified  context  model, 
converting  the  several  representations  adopted  by  different 
middleware  so  that  applications  only  need  to  deal  with  the 
OpenCOPI  model.    Besides  integrating  different  middleware, 
OpenCOPI offers additional and generic functionalities related to 
context handling in order to complement the services provided by 
these middleware. For instance, most of current context platforms 
do  not  provide  mechanisms  to  deal  with  composite  events  and 
event  patterns, 
the 
application.  Therefore,  OpenCOPI  includes  CES  (Composite 
Event Service), a component that provides event composition thus 
unburdening  applications 
functionality. 
Mechanisms  for  event  composition  [6,  7]  have  the  goal  of 
receiving  primitive,  low  level  events  and  aggregate  them  in  a 
composite event. 

leaving  such  processing 

in  charge  of 

implement 

this 

to 

OpenCOPI can be used along with different platforms of context 
provision,  providing  an  additional  layer,  aiming  at  supplying 
information  of  value  added  to  the  applications  in  their  adaptive 
decisions. It takes advantage of the specific features of individual 
middleware and abstracts out their differences to the application. 
Although  the  additional  layer  added  by  OpenCOPI  can  bring  a 
small  overhead,  the  latest  mobile  devices  (PDAs,  smartphones, 
etc.) have been increasing the capacity for processing and storage 
of data, making this additional processing insignificant. With this 
new  layer,  OpenCOPI  give  the  possibility  to  several  context 
provision middleware to collaborate for the same purpose: deliver 
any necessary context data for the applications. 

This paper briefly sketches the main design features and goals of 
OpenCOPI but its main focus is to detail the component for event 
composition,  CES.  We  show  the  integration  of  OpenCOPI  with 
MoCA [3, 8] and Context Toolkit [2] as well as a case study that 
consists  of  a  Meeting  Detection  application  to  illustrate  such 

integration.  Section  II  presents  some  background  in  middleware 
for  context  provision  and  briefly  describes  MoCA  and  Context 
Toolkit.  Section  III  introduces  OpenCOPI  and  describes  CES. 
Section  IV  presents  the  case  study.  Section  V  discusses  related 
work. Section VI contains the final remarks. 

is  often  based  on 

2.  MIDDLEWARE FOR CONTEXT 
PROVISION 
Middleware  for  context provision  acquire contextual  information 
from  various  context  sources,  processing  such  information  and 
notifying  the  application  about  the  occurrences  of  relevant 
changes  in  the  execution  environment.  The  mechanism  used  to 
notify  applications 
the  asynchronous 
communication  paradigm  (publish-subscribe).  This  paradigm  is 
suitable to support  the  ubiquitous computing goal of  providing a 
representation  of  the  real  world  as  near  as  possible  of  the  user's 
perception.  Such  representation  is  essentially  reactive.  However, 
to  provide  this  integrated  and  near-to-reality  perception  of  the 
ubiquitous  environment,  the  use  of  multiple  and  heterogeneous 
sources  of  context  is  needed.  Examples  of  such  sources  are 
physical  sensors,  applications  and  intelligent  interfaces.  Once 
acquired,  the  source  provided  data  should  be  aggregated  to 
achieve an overview of the current context. 

the 

The  complexity  of  handling 
information  provided  by 
heterogeneous  sources  often  requests  the  use  of  different  and 
context-specific middleware  platforms that  capture the  semantics 
of the received contextual information. For instance, the location 
of a device can be inferred by comparing the pattern of the current 
radio signal of the device with the previously measured signal in 
reference  points  over  a  region.  To  accomplish  such  inference, 
some middleware [3, 8] supply services that receive the low level 
information  (radio  frequency)  and  transform  it  in  higher  level 
information  (location).  In  the  same  way,  other  middleware 
platforms  for  context  provision  are  specialized  in  accomplishing 
users' identification [2], light sensing, etc. 

contextual 

information  produced  by 

The growing use of specific middleware to handle each different 
type  of 
complex 
environments composed of several infrastructures, which often do 
not interact to each other, in order to build a more complete and 
integrated  perception  of  the  ubiquitous  environment.    In  these 
scenarios,  application  developers  are  compelled  to  individually 
handle each information and to provide their own mechanisms to 
build the desired high level contextual vision. In order to illustrate 
the  complexity  of  aggregating  information  from  several  context 
middleware, 
two 
middleware (MoCA and  Context Toolkit) commonly used  in the 
development  of  ubiquitous  applications  and  the  hardness  of 
managing the differences between them (Section II.C). 

this  section  describes 

the  remaining  of 

2.1  MoCA 
MoCA (Mobile Collaboration Architecture) [3,8] is a middleware 
that  provides  an  environment  for  developing  context  aware 
collaborative applications for mobile users, supplying services of 
collection, aggregation and access to different types of contextual 
information.  In  MoCA  architecture,  CIS  (Context  Information 
Service) 
that  provides  contextual 
information.  The  ECI  (Event-based  Communication  Interface) 
API supports publish/subscribe (pub/sub) communication without 
requiring any further infrastructure [9]. CIS uses ECI to (i) receive 
requests of notifications containing expressions that represent the 
interest of applications on contextual information and, (ii) deliver 

is  a  centralized  service 

32notifications  whenever  an  interest  is  fulfilled.  ECI  supports 
subscriptions containing conditional constraints through the use of 
filters,  when  each  filter  is  composed  of  a  set  of  attribute-value 
pairs representing context information, plus a comparison operator 
(=,  <,  <=,  >,  >=).  Filters  can  be  combined  though  the  use  of 
operators And, Or and Not. LIS (Location Inference Service) is a 
MoCA’s  component  which  is  responsible  for  make  inferences 
about  the  localization  of  mobile  devices  through  of  RF  signals 
patterns.  The  context  model  adopted  by  MoCA  is  a  variation  of 
the Attribute-Value model [10] where contextual information has 
a name, a type and a value. Additionally, MoCA permits that Java 
Objects can be passed along with notifications to clients. 

2.2  Context Toolkit 
Context Toolkit (CT) is a framework that aims at simplifying the 
design and implementation of context aware systems. It defines an 
architecture,  offers  a  set  of  services,  and  provides  a  component 
library that can be customized for building such systems.  

The architecture of systems built by using CT components is fully 
distributed.  The  key  goal  is  allowing  developers  to  design 
application  in  terms  of  building  blocks  in  which  objects  that 
acquire,  gather, processes  and deliver context  data are separately 
implemented.  BaseObject  is  the  component  that  implements  the 
communication  mechanisms  supported  by  CT,  including  the 
pub/sub communication. All other components use BaseObject for 
communicating. Widgets are software components responsible for 
receiving  contextual  information  issued  by  sensors  or  other 
context  sources.  Aggregators  gather  contextual  information  of 
several  Widgets.  Both  Widgets  and  Aggregators  can  receive 
subscriptions  for  contextual  events  from  multiple  applications, 
through the BaseObject. 

The  pub/sub  communication  implemented  by  BaseObject  also 
supports  conditional  restrictions  through  the  use  of  filters 
(similarly  to  restrictions  supported  by  MoCA).  Those  filters  can 
be  further  combined  through  operators  And,  Or  or  Not.  The 
context  model  used  by  CT  is  also  a  variation  of  the  Attribute-
Value  model.  The  supported  types  are:  Integer,  Long,  Float, 
Double, Boolean, String and Struct, which is a data structure that 
allows  the  storage  of  several  contextual  information  of  the  other 
types (including Structs). 

2.3  Comparing MoCA and CT 
As previously described, these two middleware presents different 
features,  thus  hindering  the  task  of  integrating  them  when 
developing a single application that demands different contextual 
data.    For  instance,  in  MoCA  there  is  a  centralized  point  of  the 
contextual information (CIS), responsible for receiving customers' 
subscriptions  and  information  from  context  sources  and  for 
notifying customers when subscriptions are fulfilled. On the other 
hand,  CT  architecture  is  distributed:  each  component  that 
implements  BaseObject  (mostly  Widgets  and  Aggregators) 
implements  the  pub/sub  interface  and  sends  the  contextual 
information directly to subscribers, without a centralized element. 
Both  middleware  adopted  as  context  model  a  variation  of  the 
Attribute-Value model. However, CT supports an additional type 
(struct) of contextual information while in MoCA objects (derived 
from  Java  Object  class)  can  be  sent  to  subscribers  attached  to 
notifications.  Both  middleware 
synchronous  and 
asynchronous  communications  and  allow  the  combination  of 
filters in subscriptions through connectors. 

support 

The  different  characteristics  of  middleware  for  context  provision 
stimulate  developers  of  more  complex  ubiquitous  applications  to 
use, in a same application, the best resources of each middleware. 
Since MoCA  has  a  centralized architecture, it supports a simpler 
and  faster  development  of  context  aware  applications, 
in 
comparison  to  CT.  In  CT,  application  development  is  more  time 
consuming since it is necessary to create several components and 
each  component  has  to  be  previously  configured  with  the 
contextual  information  that  it  will  handle.  Moreover,  the  MoCA 
has a service exclusively to infer the location of users in specific 
environments  and  CT  doesn’t  provide  similar  service.  On  the 
other  hand,  CT  decentralization  avoids  the  problem  of  a  single 
point  of  failure,  meaning  that  CT’s  context  service  is  less 
susceptible  to  faults.  Additionally,  different  communication 
interfaces  and  different  forms  of  context  storage  used  by  each 
middleware,  among  other  differences  on  their  implementations, 
hinder the integration of their contextual information. 

3.  OPENCOPI and CES 
OpenCOPI (Open COntext Platform Integration) is a platform for 
context handling built to support the developing and execution of 
complex  context-aware  applications.  OpenCOPI  works 
in 
conjunction  with  several  middleware  for  context  provision  in 
order to allow handling highly heterogeneous context data. CES is 
the  OpenCOPI  component  responsible  for  performing  event 
composition, a key requirement in processing complex contextual 
events. CES works along with pub-sub interfaces provided by the 
respective  middleware  integrated  with  OpenCOPI.  To  support 
different  levels  of  abstraction  in  which  event  data  may  be 
represented, CES offers a service for composing individual events 
in higher level and for identifying event patterns of interest to the 
application.  Thus,  OpenCOPI  applications  are  seamlessly 
provided  with  high-level  contextual  information  achieved  from 
different context sources and middleware platforms.  

CES supports six composite event types with specific connectors. 
The  AND  connector  defines  that  all  events  involved  in  a 
composition  should  happen,  independently  on  the  notifications 
reception  order.  The  OR  connector  requires  that  one  of  the 
primitive events involved in a composition should happen to meet 
the  composed  subscription.  The  SEQUENTIAL  connector 
requires that events should occur in a pre-established order in the 
subscription, from the left to the right. The ITERATOR connector 
defines  how  many 
times  an  event  should  happen.  The 
INTERVAL connector defines that events should happen inside a 
pre-established  time  interval,  independently  on  the  occurrence 
order. The elapsed interval is counted from the moment that any 
involved  event  is  notified.  The  PARALLEL  connector  requires 
that the events involved in a composition happen at the same time. 
Figure  1  depicts  examples  of 
the  OpenCOPI  connectors. 
OpenCOPI  also  have  the  special  connector  ‘internalAnd’  that 
enables  the  use  of  filters  (similar  to  those  supported  by  context 
middleware) at the same primitive subscription. 

Figure 1. CES connectors [11] 

As CES receives notifications from several middleware and each 
one  can  use  distinct  timestamp  policies  for  handling  contextual 

 

33data, CES abstracts these differences and considers the moment of 
the notification of middleware to CES as the event’s timestamps. 

sharing, 

information 

supports  context 

independent  CES 

In  order  to  avoid  the  centralization  of  an  event  composition 
service  and  the  consequent  problem  of  a  single  point  of  failure, 
each  application  has  an 
instance.  The 
application dynamically  configures its CES instance and informs 
which  context  middleware  will  interact  with  CES.  In  addition, 
CES 
i.e.,  context 
information received  in a  notification can be shared  and used by 
others  primitive  subscriptions  involved  at  the  same  composite 
subscription.  This  feature  allows  that  a  context  information 
received in a notification is used to determine the own expression 
of  events  composition.  To  support  this  feature,  the  keyword 
‘Event’ 
expression 
Event(“<eventname>”){<contextual 
conditions>}.  Figure  2 
illustrates  the  contextual  information  sharing  in  the  subscription 
Event(“ev1”){temp>35}  &  ((region  =  ev1.region)  internalAnd 
(humidity  <  30)).  This  subscription  is  an  example  of  event 
composition using contextual information sharing where only the 
first part (Event(“ev1”){temp>35}) is subscribed to the respective 
middleware  when  OpenCOPI  receives  a  composite  subscription.  
When  CES  receives  the  notification  of  the  first  part,  it  uses 
contextual  information  enclosed  in  the  notification  to  sign  the 
second part ((region = ev1.region) internalAnd (humidity < 30)). 

pattern 

used 

the 

in 

is 

representation  according  to  the  application  needs,  thus  reducing 
the overload to the limited devices of ubiquitous environments. A 
detailed  description  of  the  OpenCOPI  context  model  is  out  of 
scope  of  this  paper.  However,  it  is  worthwhile  mentioning  that, 
besides the OWL files describing OpenCOPI ontology, there is a 
set  of  modules  in  charge  of  mapping  from  each  middleware 
context model to the elements of the ontology. Furthermore, since 
OpenCOPI  assumes  ontology  as 
its  canonical  model  for 
representing  contextual  data,  we  hope  that  in  the  future,  new 
context  middleware  platforms  wishing  to integrate  to  OpenCOPI 
would adopt such model. Therefore, OpenCOPI provides a tool to 
validate  OWL  documents  describing  context  models  of  such 
middleware  thus  guaranteeing  the  consistency  of  the  adopted 
ontology. 

3.1  Integration Architecture 
To  support  the  integration  between  several  context  provision 
middleware, CES offers three  interfaces:  LookUpIn, LookUpOut 
and  Admin.  The  two  last  interfaces  are  used  to  allow  the 
interaction  between  an  application  (subscriber)  and  CES. 
LookUpIn  interface  is  used  to  support  the  communication 
between  CES  and  the  pub-sub  interface  of  the  underlying 
middleware [11]. Figure 3 illustrates those interfaces.  

Figure 2. Context information sharing 

Each  middleware  defines  a  context  model  and  CES  defines  a 
unified  context  model  to  aggregate  all  contextual  information 
received.  This  means  that  CES  should  convert  the  context 
information  received  from  the  different  middleware  to  its  own 
context  model.  There  are  often  two  different  approaches  for 
modeling  contextual  information:  formal  and  informal.  Informal 
context  models  adopt  representations  based  on  proprietary 
schemes  with  no  facilities  to  share  information  among  different 
application  entities  interested  in  contextual  events.  The  context 
models of both CT and MoCA, based on attribute-value pairs are 
examples of informal  models. On  the other hand,  formal context 
models  often  use  formal  representation  such  as  based  on  Entity-
Relationship  and  UML  models.  Another  formal  approach  for 
modeling  contextual  data  is  based  on  the  use  of  first-order 
predicates.  However,  none  of  these  approaches  addresses  the 
contextual data sharing. Since one major goal of OpenCOPI is to 
achieve  a  high  level  of  contextual  data  sharing  from/to  different 
sources,  we  have  adopted  an  ontology-based  formal  context 
model  particularly  to  address  the  needs  of  context  sharing  and 
logical  reasoning.  In  the  OpenCOPI  ontology-based  approach, 
context  is  represented  by  predicates  written  in  OWL  [12],  a 
markup  language  that  is  part  of  the  suite  of  Web  Semantic 
technologies.  There  are  currently 
for 
representing  contextual  data 
the  domain  of  ubiquitous 
computing. We have chosen the ontology proposed in [13] to use 
in OpenCOPI, since it encompasses a broad range of concepts and 
at  the  same  time,  it  is  sub-divided  in  several  sub-domains.  Such 
division  allows 
the  context 

loading  only  a  sub-part  of 

several  ontology 

in 

 

Figure 3. CES interfaces 

is 

responsible 

Admin  interface  allows  an  application  to  configure  OpenCOPI, 
i.e., it specifies which middleware will be used and which context 
information  will  be  handled  by  each  middleware.  LookUpOut 
interface 
receiving  client’s  composite 
subscriptions  and  for  notifying  them  when  a  composed  event 
occurrence is detected. LookUpIn interface is provided by CES to 
(i)  support  subscriptions  of  primitive  events,  each  one  to  the 
respective  pub/sub  interface  of  each  middleware  involved  in  the 
composite  subscription  and  (ii)  to  receive  notifications  about  the 
primitive events. 

for 

 

 

Figure 4. LookUpIn Interface 

The  LookUpIn  interface  (Figure  4)  is  the  main  interface  of  CES 
since  it  is  responsible  for  the  communication  with  the  several 
middleware.  It  defines  CES  subscribe  and  unsubscribe  methods, 
being used in CES primitive event subscriptions to the underlying 
middleware. Classes that implement LookUpIn are listeners used 
by CES in its own subscriptions. Due to the particularities of each 
middleware pub/sub interface, the methods called for notifications 
are  distinct,  as  it  can  be  seen  in  EventListenerToContextToolkit 
and  EventListenerToMoca  classes.  In  EventListenerToMoca,  the 
notify method is onReceiveData() and it receives a MoCA Event 
object. This object brings all contextual information associated to 

34the notification. In the second class, the method called is handle().  
It receives the subscription identifier and a CT DataObject object 
with all contextual information associated to the notification. 

To subscribe for an event, an application creates a ListenerClient 
object  to  be  used  to  perform  a  new  CES  subscription  and  this 
object  is  sent  to  CES  along  with  a  composite  subscription 
expression.  When  CES  instance  receives  a  new  subscription,  it 
creates  a  subscription  object  and  an  automata  that  controls  the 
events occurrence that are included in a composite event. For each 
primitive  event  involved  in  the  composite  event,  CES  creates  a 
listener  to  the  respective  middleware.  Each  middleware  uses  the 
respective primitive event listener to send a notification message 
to  the  object  that  created  it  (i.e.,  the  subscription  object).  When 
the  Subscription  object  receives  a  notification  message,  the 
automata  that  represents  the  subscription  is  updated.  If  the 
automata  reaches  its  final  state,  the  subscription  object  calls  the 
onReceiveData()  method  -  application  listener  -  to  notify  the 
application that a composite event happened.  

3.2  Implementation 
This section describes the implementation aspects of CES. When 
CES  starts,  the  application  should  configure  the  environment 
before  performing 
illustrates  a 
configuration using MoCA and CT. 

subscriptions.  Figure  5 

1  //config CES host 
2  ces.configurator.setIp("200.19.162.16"); 
3  //config pubsub MoCA  
4  ComponentInformation moca = new  

MocaComponentInformation("moca","sagui.natal 
net.br","200.19.162.12", 55000, 50001); 

5  ces.setPS("moca", moca, true); 
6  //config pubsub Context Toolkit 
7  ComponentInformation ct = new  

CTComponentInformation("ct","Wid 
get_papagaio_6001","papagaio. 
natalnet.br", "200.19.162.56",6001, 50002); 

8  ces.setPS("ct",ct,false);  
9 //config OpenCOPS attributes 
10 ces.setAttribute("moca","temperature"); 
11 ces.setAttribute("moca","humidity"); 
12 ces.setAttribute("ct","velocity"); 
13 ces.setAttribute("ct","weight"); 
14 ces.setAttribute("ct","height"); 

Figure 5. OpenCOPI configuration source code 

Initially,  the  application  informs  the  computer  host  and  IP  (lines 
2-3)  and  configures  the  middleware  (lines  4-9).  For  each 
middleware,  the  ComponentInformation  class  is  specialized.  At 
line  8,  the  CTComponentInformation  constructor  has  an  extra 
parameter in comparison with the MocaComponente-Information  
constructor  since  CT  requests  the  component  name  that  will 
receive the subscription and not necessary for MoCA since CIS is 
centralized. The application configures (lines 11-15) the attributes 
that will be handled by each middleware. 

CES  listeners  used  to  perform  the  subscriptions  to  several 
middleware are also dependent on the different pub-sub interface 
and need different implementation, one to each middleware used. 
The listener  implements  the  LookUpIn  interface  and  the  specific 
middleware  interface.  Whenever  a  listener  receives  an  event 
notification, it should transform the event contextual information 
from middleware-specific format to the CES format. 

4.  CASE STUDY 
The selected case study was inspired in the pervasive environment 
application  known  as  Meeting  Detection  (MD)  [14].  In  the 
original  Meeting  Detection,  motion  and/or  pressure  sensors 
deployed in the chairs are used to detect the number of people in a 
meeting  room.  The  application  is  able  to  detect  if  a  meeting  is 
happening  or  not  (meeting’s  status).  With  this  information,  MD 
application  automatically  configures  the  room  devices.  An 
example  of  this  kind  of  configuration  is  when  a  meeting  is 
detected  the  phone  should  be  configured  to  automatically  send 
received calls to an answering machine. 

In  our  MD  variant  we  consider  that  only  context  information  of 
chairs sensors is not enough to correctly detect the occurrence of a 
meeting.  Several  examples  of  distortions  on  detections  can  be 
mentioned,  as 
the  existence  of  objects  on  chairs  or  a 
videoconference  where  only  a  person  is  at  the  room.  Therefore, 
further information on the environment is needed beyond the use 
of chairs, thus increasing the complexity degree of the application. 
In our study, beyond  motion and pressure sensors at chairs there 
are others context information sources, such as: luminosity sensor, 
videoconference and air conditioner systems.  

In  this  MD  variant  there  are  many  possible  configurations  in 
which  the  application  assumes  that  a  meeting  is  in  place. 
Therefore,  we  can  demonstrate  the  use  of  event  composition 
involving  contextual  information  from  different  context  sources 
and  middleware.  Experiments  were  performed  with 
the 
application,  OpenCOPI  (with  CES)  and  MoCA  executing  at  a 
same host and CT widgets executing at a different host. Figure 6 
shows  the  components  of  the  case  study.  All  sensors  were 
simulated. 
the 
application and has an OpenCOPI instance.  

  Meeting  Detection  component 

represents 

 

 

Figure 6. Components of Meeting Detection application 

The  following  scenarios  represent  a  meeting  in  progress:  (i) 
Videoconference system active and detection of use of at least one 
chair;  (ii)  detection  of  at  least  two  chairs  in  use  and  minimum 
illumination above 120 lux or projector in use; among others.  

Initially,  the  application sends  to  CES  subscriptions  that  identify 
the  occurrence  of  a  meeting  or  not.  According  to  the  received 
subscriptions,  CES  sends  subscriptions  to  MoCA  and/or  to  CT 
widgets.    MoCA  receives  luminosity  sensor’s  information  and 
chair sensors’ information. CT receives subscriptions to Wvideo, 
Warcond and Wprojetor widgets (videoconference, air conditioner 
and  projector  equipments,  respectively).  Each  widget  receives 
state  change  notifications  (ON  or  OFF)  of  the  monitored 
equipment. A composite subscription example of sceneries (ii) is 
(amountOfChairInUse  >  1)  &  ((luminosity  >  120)  ||  (projector  = 
true))  where  a  contextual  information  related  to  videoconference 
in use is subscripted to CT and the contextual information related 
to luminosity and chair in use are subscripted to MoCA.  

When the subscription is made, the sensors begin to be simulated 
to trigger events and the respective middleware sends the notified 

35events  to  CES.  When  OpenCOPI  detects  the  occurrence  of  any 
subscribed  scenario,  it  notifies  the  application.  By  receiving  this 
notification,  the  application  change  meeting’s  status  to  “meeting 
happening”. Tests were applied to evaluate CES and in all cases it 
was  effective,  notifying  the  application  always  when  one  of  the 
meeting sceneries was identified. No "false detections" happened. 

5.  RELATED WORK 
In  this  section,  we  present  works  that  are  directly  related  to  our 
own. For simplicity, we place related work in two categories: (i) 
composite event mechanisms and (ii) context-aware middleware. 

Composite Event Mechanisms: There are some mechanisms that 
aim  to  extend  the  expressiveness  of  the  composite  event 
languages, such as EPS [6], HERMES [15], and PADRES [7]. In 
general, these mechanisms support the main connectors described 
in  section  II,  such  as  And,  Or,  Sequential,  Iterator,  Interval  and 
Parallel.  In  addition,  PADRES  supports  the  information  sharing 
among primitive subscriptions.  Our approach builds upon most of 
these  works  but,  to  the  best  of  our  knowledge,  it  is  the  first  one 
that  integrates  a  plethora  of  middleware  in  order  to  provide  a 
unified  service  for  handling  contextual  events.    In  this  way, 
developers  can 
implementation  or 
execution,  specific  composite  events  whose  sources  are 
middleware  with  different  context  models,  allowing  use  the  best 
resources  of  each  middleware,  simplifying  the  application  code 
and consequently contribute to reduce its size    

indicate,  during  system 

Context-aware  middleware:  Several  middleware  have  emerged 
over  the  last  years  to  assist  the  development  of  context-aware 
systems by supporting the management of contextual information. 
Context-aware  framework  is  one  of  them  and  has  reached 
maturity. It is a class library that provides the foundation basis for 
designing context-aware systems. For instance, WildCAT[4]  is a 
framework  which  offers  a  simple  API  to  encompass  most  of  the 
context-aware  capabilities.  Likewise  MoCA,  WildCAT  supports 
contextual adaptation by following the pub/sub pattern to combine 
events and implement non-blocking communication.  

On the other hand, context-aware middleware focus on providing 
different  abstractions  to  hide  low-level  sensing  details  and  to 
manage  contextual  information.  For  instance,  Huebscher  and 
McCann  [16]  present  an  adaptive  middleware  for  context-aware 
applications which encompasses a 4-tier architecture. The bottom 
layer consists of sensors. In the next layer, context providers apply 
sensor  logic  to  produce  context  types  as  services.  Context 
composition  occurs  on  the  third  layer  where  context  services 
retrieve  context  information  from  the  context  providers  and 
deliver this information to the applications. 

CARISMA  [5]  is  a  middleware  that  exploits  computational 
reflection  to  enhance  the  built  of  adaptive  and  context-aware 
mobile applications. This middleware provides software engineers 
with composite events to describe how context changes should be 
handled  using  policies.  However,  CARISMA  and  the  other 
middleware  previously  mentioned  do  not  support  context 
information  sharing  and  a  fully  set  of  composite  connectors,  as 
supported by our approach. In addition, they are not aware of the 
semantic  of  events,  whereas  CES  can  match  events  with 
subscriptions  based  on  both  the  semantic  and  the  structure  of 
events. Hence, in CES, the domain concepts involved in all events 
are integrated together through predicates written in OWL[12] to 
form  a  conceptual  model  which  allows  matching  events  with 
subscriptions both semantically and syntactically. 

6.  CONCLUSION 
We  introduced  OpenCOPI,  a  context  platform  that  integrates 
several  middleware  for  context  provision  and  details  one  of  its 
main  component,  CES,  a  service  for  event  composition.    CES 
abstracts  away  the  differences  among  various  middleware  and 
complements 
the 
development  of  context-aware  applications.  To  illustrate  our 
proposal  we  presented  the  use  of  CES  integrated  with  two 
context-based  middleware  platforms  in  a  case  study  based  on  a 
meeting detection application. We hope that the use of OpenCOPI 
leverages the widespread adoption of ubiquitous computing. 

their  provided  services, 

thus  facilitating 

7.  REFERENCES 

[1]  Weiser,  M.  1991  The  Computer  for  the  Twenty-First 

Century. In Scientific American, 94-10 (Sept, 1991). 

[2]  Dey,  A.  and  Abowd,  G.  2000  The  Context  Toolkit:  Aiding 
In 
the  Development  of  Context-Aware  Applications. 
Workshop  on  Software  Engineering  for  Wearable  and 
Pervasive Computing, Limerick, Ireland. 

[3]  Sacramento  V.,  et  al.  2004  An  Architecture  supporting  the 
development of Collaborative Applications for Mobile Users. 
In  2nd.  International  Workshop  on  Distributed  and  Mobile 
Collaboration, IEEE WETICE-2004, Modena, Italy. 

[4]  David,  P.  C.  and  Ledoux,  T.  2005  Wildcat:  a  generic 
framework for context-aware applications. In MPAC ’05, 1–
7, USA. 

[5]  Capra, L., et al, 2003 CARISMA: Context-Aware Reflective 
Middleware  System  for  Mobile  Applications.  In  IEEE 
Transactions on Software Engineering, 29(10). 

[6]  Moreto,  D.  and  Endler,  M.  2001  Evaluating  Composite 
Events using Shared Trees. In IEEE Proceedings – Software, 
Vol. 148, 1-10. 

[7]  Li,  G.  and  Jacobsen,  H.  2005  Composite  Subscriptions  in 
Content-based  Publish/Subscribe  Systems.  In  International 
Middleware Conference. Grenoble, France. 

[8]  Rubinsztejn,  H.,  et  al,  2004  Support  for  Context-Aware 
and 

Technologies 

Collaboration.Mobility 
Applications. In LNCS Vol 3284, 37-47. 

Aware 

[9]  Baptista, G., et al, 2007 Uma API Pub/Sub para Aplicações 
Móveis  Sensíveis  ao  Contexto.  In  1st  Worskhop  on 
Pervasive  and  Ubiquitous  Computing,  Gramado,  RS  (in 
portuguese). 

[10] Baldauf,  M., Dustdar,  S.  and  Rosemberg, F. 2007  A survey 
on context-aware systems. In Int. J. Ad Hoc and Ubiquitous 
Computing, 2(4). 

[11] Lopes, F., Cacho, N. and Batista, T. 2007 Um Mecanismo de 
Composição  de  Eventos  para  Resolução  de  Exceções 
Sensíveis  ao  Contexto.  In  Proc.  Software  Engineering 
Brazilian Symposium, João Pessoa/PB, (in portuguese). 

[12] Harmelen,  F.,  et  al.  2002  Owl  Web  Ontology  Language 

Reference. http://www.w3.org/TR/owl-ref/. 

[13] Wang,  X.  H.  et.  al.  2004  Ontology  based  context  modeling 
and  reasoning  using  OWL.  In  Procs.  of  the  Second  IEEE 
Annual  Conference 
and 
Communications Workshops. 

on  Pervasive  Computing 

[14] Wang,  J.  et  al.  2004  A  sensor-fusion  approach  for  meeting 

detection In Workshop on Context Awareness, Boston. 

[15] Pietzuch, P., Shand, B. and Bacon, J. 2003 A Framework for 
In  4th 

Event  Composition 
ACM/IFIP/USENIX Middleware, Rio de Janeiro, Brazil. 

in  Distributed  Systems. 

36