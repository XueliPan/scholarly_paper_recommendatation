Operating System Transactions

Donald E. Porter, Owen S. Hofmann, Christopher J. Rossbach,

Alexander Benn, and Emmett Witchel

Department of Computer Sciences, The University of Texas at Austin

{porterde,osh,rossbach,abenn1,witchel}@cs.utexas.edu

ABSTRACT
Applications must be able to synchronize accesses to operating sys-
tem resources in order to ensure correctness in the face of concur-
rency and system failures. System transactions allow the program-
mer to specify updates to heterogeneous system resources with the
OS guaranteeing atomicity, consistency, isolation, and durability
(ACID). System transactions efﬁciently and cleanly solve persis-
tent concurrency problems that are difﬁcult to address with other
techniques. For example, system transactions eliminate security
vulnerabilities in the ﬁle system that are caused by time-of-check-
to-time-of-use (TOCTTOU) race conditions. System transactions
enable an unsuccessful software installation to roll back without
disturbing concurrent, independent updates to the ﬁle system.

This paper describes TxOS, a variant of Linux 2.6.22 that imple-
ments system transactions. TxOS uses new implementation tech-
niques to provide fast, serializable transactions with strong isola-
tion and fairness between system transactions and non-transactional
activity. The prototype demonstrates that a mature OS running on
commodity hardware can provide system transactions at a reason-
able performance cost. For instance, a transactional installation of
OpenSSH incurs only 10% overhead, and a non-transactional com-
pilation of Linux incurs negligible overhead on TxOS. By making
transactions a central OS abstraction, TxOS enables new transac-
tional services. For example, one developer prototyped a transac-
tional ext3 ﬁle system in less than one month.

Categories and Subject Descriptors
D.4.1 [Operating Systems]: Process Management—synchroniza-
tion; D.1.3 [Programming Techniques]: Concurrent Programming;
D.4.7 [Operating Systems]: Organization and Design

General Terms
Design, Performance, Security

Keywords
Transactions, Operating Systems, TxOS, Race Conditions, Trans-
actional Memory

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SOSP’09, October 11–14, 2009, Big Sky, Montana, USA.
Copyright 2009 ACM 978-1-60558-752-3/09/10 ...$10.00.

1.

INTRODUCTION

Applications often need to group accesses to operating system
resources (such as ﬁles and signals) into logical units, just as mul-
tithreaded applications must group accesses to shared data struc-
tures into critical regions. For example, local user and group ac-
counts on Linux and similar operating systems are stored across
three ﬁles that need to be mutually consistent: /etc/passwd,
/etc/shadow, and /etc/group.

Applications currently struggle to make consistent updates to
system resources. In current operating systems, individual system
calls are generally atomic and isolated from the rest of the system,
but it is difﬁcult, if not impossible, to condense complex opera-
tions into a single system call. In simple cases, programmers can
use a powerful, single system call like rename, which atomically
replaces the contents of a ﬁle. For more complex updates, options
like ﬁle locking are clumsy and difﬁcult to program. In the presence
of concurrency, the problem is exacerbated because existing inter-
faces are often insufﬁcient to protect a series of system calls from
interference by buggy or malicious applications. With the current
proliferation of multi-core processors, concurrent processing is be-
coming ubiquitous, exposing the inability of the traditional system
call interface to ensure consistent accesses.

In the example of managing local user accounts, developers spend
substantial effort creating tools that minimize, but fail to eliminate
consistency problems. The vipw and useradd utilities help en-
sure that user account databases are formatted correctly and mutu-
ally consistent. To address concurrency in the system, these tools
create lock ﬁles for mutual exclusion. A careless administrator,
however, can corrupt the ﬁles by simply editing them directly. The
tools also use the sync() and rename commands to ensure that
an individual ﬁle is not corrupted if the system crashes, but can-
not ensure that an update to multiple ﬁles is consistently prop-
agated. For instance, suppose a system crashes after useradd
writes /etc/passwd but before it writes /etc/shadow. After
rebooting the system, the new user will not be able to log on, yet
useradd will fail because it thinks the user already exists, leaving
the system administrator to manually repair the database ﬁles. The
proliferation of tools to mitigate such a simple problem, as well
as the tools’ incompleteness, indicate that developers need a better
API for consistent system accesses.

In practice, OS maintainers address the lack of concurrency con-
trol in the system call API in an ad hoc manner: new system calls
and complex interfaces are added to solve new problems as they
arise. The critical problem of eliminating ﬁle system race con-
ditions has motivated Solaris and Linux developers to add over a
dozen new system calls, such as openat, over the last seven years.
Linux maintainers added a close-on-exec ﬂag to ﬁfteen system calls
in a recent version of Linux [13] to eliminate a race condition be-

161tween calls to open and fcntl. Individual ﬁle systems have in-
troduced new operations to address consistency needs: the Google
File System supports atomic append operations [16], while Win-
dows recently adopted support for transactions in NTFS and the
Windows registry [44]. Users should not be required to lobby OS
developers for new system calls and ﬁle system features to meet
their concurrent programming needs. Why not allow users to solve
their own problems by supporting composition of multiple system
calls into arbitrary atomic and isolated units?

This paper proposes system transactions to allow programmers
to group accesses to system resources into logical units, which ex-
ecute with atomicity, consistency, isolation, and durability (ACID).
System transactions are easy to use: code regions with consistency
constraints are enclosed within the system calls, sys_xbegin()
and sys_xend(). The user can abort an in-progress transaction
with sys_xabort(). Placing system calls within a transaction
alters the semantics of when and how their results are published to
the rest of the system. Outside of a transaction, actions on system
resources are visible as soon as the relevant internal kernel locks are
released. Within a transaction, all accesses are kept isolated until
commit time, when they are atomically published to the rest of the
system. System transactions provide a simple and powerful way
for applications to express consistency requirements for concurrent
operations to the OS.

This paper describes an implementation of system transactions
on Linux called TxOS, which provides transactional semantics for
OS resources, including the ﬁle system, memory management, sig-
nals, and process creation. To efﬁciently provide strong guarantees,
the TxOS implementation redesigns several key OS data structures
and internal subsystem interfaces. By making transactions a core
OS abstraction, TxOS enables user and OS developers to create
powerful applications and services. For example, given an initial
implementation of TxOS, a single developer needed less than a
month to prototype a transactional ext3 ﬁle system.

This paper makes two primary contributions. First, it describes a
new approach to OS implementation that supports efﬁcient transac-
tions on commodity hardware with strong atomicity and isolation
guarantees. Secondly, it demonstrates a prototype implementation
of system transactions (TxOS) whose strong guarantees and good
performance enable new solutions to systems problems such as:

1. Eliminating security vulnerabilities exploited by ﬁle system

race conditions.

2. Rolling back an unsuccessful software install or upgrade with-
out disturbing concurrent, unrelated updates. A transactional
dpkg install adds only 10% overhead for this increase in
safety.

3. Providing a lightweight alternative to a database for con-
currency management and crash consistency, yielding sim-
pler application code and system administration. Replacing
Berkeley DB with ﬂat ﬁles and system transactions as the
storage back-end for the OpenLDAP directory service im-
proves performance on write-mostly workloads by 2–4×.

4. Allowing user-level transactional programs to make system

calls during a transaction.

The remainder of the paper is structured as follows. Section 2
provides motivating use-cases for system transactions and Section 3
describes programming with system transactions and their imple-
mentation in TxOS. Section 4 describes the design of TxOS, Sec-
tion 5 provides kernel implementation details, and Section 6 de-
scribes how certain key subsystems provide transactional seman-
tics. Section 7 measures the performance overhead of system trans-
actions and evaluates TxOS in a number of application case studies.
Section 8 positions TxOS in related work and Section 9 concludes.

2. MOTIVATING EXAMPLES

A range of seemingly unrelated application limitations share a
root cause—the lack of a general mechanism to ensure consistent
access to system resources. This section reviews two common ap-
plication consistency problems and how system transactions rem-
edy those problems. System transactions allow software installa-
tions to recover from failures without disrupting concurrent, inde-
pendent updates to the ﬁle system. System transactions also elim-
inate race conditions inherent in the ﬁle system API, which can be
exploited to undermine security.

2.1 Software installation or upgrade

Installing new software or software patches is an increasingly
common system activity as time to market pressures and good net-
work connectivity combine to make software updates frequent for
users. Yet software upgrade remains a dangerous activity. For
example, Microsoft recalled a prerequisite patch for Vista service
pack 1 because it caused an endless cycle of boots and reboots [28].
More generally, a partial upgrade can leave a system in an unusable
state.

Current systems are adopting solutions that mitigate these prob-
lems, but each has its own drawbacks. Microsoft Windows and
other systems provide a checkpoint-based solution to the software
update problem. Users can take a checkpoint of disk state before
they install software: if something goes wrong, they roll back to
the checkpoint. Windows checkpoints certain key structures, like
the registry and some system ﬁles [30]. Other systems, like ZFS’s
apt-clone, checkpoint the entire ﬁle system. If the software in-
stallation fails, the system restores the pre-installation ﬁle system
image, erasing ﬁle system updates that are concurrent but indepen-
dent from the software installation. Partial checkpointing mitigates
this problem, but loses the ability to recover from application in-
stallations that corrupt ﬁles not checkpointed by the system. More-
over, the user or the system must create and manage the disk-based
checkpoints to make sure a valid image is always available. Finally,
if a bad installation affects volatile system state, errant programs
can corrupt ﬁles unrelated to the failed installation. Collectively,
these problems severely decrease the usability of checkpoint-based
solutions.

System transactions provide a simple interface to address these
software installation problems. A user executes the software instal-
lation or update within a transaction, which isolates the rest of the
system until the installation successfully completes. If the installa-
tion or upgrade needs to be rolled back, independent updates made
concurrently remain undisturbed.

2.2 Eliminating races for security

Figure 1 depicts a scenario in which an application wants to
make a single, consistent update to the ﬁle system by checking
the access permissions of a ﬁle and conditionally writing it. Com-
mon in setuid programs, this pattern is the source of a major and
persistent security problem in modern operating systems. An at-
tacker can change the ﬁle system name space using symbolic links
between the victim’s access control check and the ﬁle open,
perhaps tricking a setuid program into overwriting a sensitive
system ﬁle, like the password database. The OS API provides no
way for the application to tell the operating system that it needs a
consistent view of the ﬁle system’s name space.

Although most common in the ﬁle system, system API races, or
time-of-check-to-time-of-use (TOCTTOU) races, can be exploited
in other OS resources. Local sockets used for IPC are vulnera-
ble to a similar race between creation and connection. Versions of
OpenSSH before 1.2.17 suffered from a socket race exploit that al-

162Victim

if(access(’foo’)){

Attacker

symlink(’secret’,’foo’);

Victim

Attacker

symlink(’secret’,’foo’);

fd=open(’foo’);
write(fd,...);
...

}

sys_xbegin();
if(access(’foo’)){

fd=open(’foo’);
write(fd,...);
...

}
sys_xend();

symlink(’secret’,’foo’);

Figure 1: An example of a TOCTTOU attack, followed by an example
that eliminates the race using system transactions. The attacker’s sym-
link is serialized (ordered) either before or after the transaction, and
the attacker cannot see partial updates from the victim’s transaction,
such as changes to atime.

lowed a user to steal another’s credentials [1]; the Plash sandboxing
system suffers a similar vulnerability [2]. Zalewski demonstrates
how races in signal handlers can be used to crack applications, in-
cluding sendmail, screen, and wu-ftpd [57].

While TOCTTOU vulnerabilities are conceptually simple, they
pervade deployed software and are difﬁcult to eliminate. At the
time of writing, a search of the U.S. national vulnerability database
for the term “symlink attack” yields over 600 hits [37]. Further,
recent work by Cai et al. [7] exploits fundamental ﬂaws to defeat
two major classes of TOCTTOU countermeasures: dynamic race
detectors in the kernel [53] and probabilistic user-space race detec-
tors [52]. This continuous arms race of measure and countermea-
sure suggests that TOCTTOU attacks can be eliminated only by
changing the API.

In practice, such races are addressed with ad hoc extension of
the system API. Linux has added a new close-on-exec ﬂag to ﬁf-
teen different system calls to eliminate a race condition between
calls to open and fcntl. Tsafrir et al. [51] demonstrate how
programmers can use the openat() family of system calls to con-
struct deterministic countermeasures for many races by traversing
the directory tree and checking user permissions in the application.
However, these techniques cannot protect against all races with-
out even more API extensions. In particular, they are incompatible
with the O_CREAT ﬂag to open that is used to prevent exploits on
temporary ﬁle creation [9].

Fixing race conditions as they arise is not an effective long-term
strategy. Complicating the API in the name of security is risky:
code complexity is often the enemy of code security [4]. Because
system transactions provide deterministic safety guarantees and a
natural programming model, they are an easy-to-use, general mech-
anism that eliminates API race conditions.

3. OVERVIEW

System transactions are designed to provide programmers with
a natural abstraction for ensuring consistent access to system re-
sources. This section describes the API, semantics, and behavior
of system transactions, followed by an overview of how system
transactions are supported in TxOS, our prototype implementation
of system transactions within Linux.

3.1 System transactions

System transactions provide ACID semantics for updates to OS
resources, such as ﬁles, pipes, and signals. In this programming
model, both transactional and non-transactional system calls may
access the same system state; the OS is responsible for ensuring
that these accesses are correctly serialized and contention is ar-
bitrated fairly. The interface for system transactions is intuitive
and simple, allowing a programmer to wrap a block of unmodi-
ﬁed code in a transaction simply by adding sys_xbegin()and
sys_xend().

3.1.1

System transaction semantics

System transactions share several properties developers are likely
familiar with from database transactions. System transactions are
serializable and recoverable. Reads are only allowed to committed
data and are repeatable, which corresponds to the highest database
isolation level (level 3 [18]). Transactions are atomic (the system
can always roll back to a pre-transaction state) and durable (trans-
action results, once committed, survive system crashes).

To ensure isolation, the kernel enforces the invariant that a ker-
nel object may only have one writer at a time, excepting containers,
which allow multiple writers to disjoint entries. Two concurrent
system transactions cannot both successfully commit if they access
the same kernel objects and at least one of the accesses is a write.
Such transactions are said to conﬂict and the system will detect the
conﬂict and abort one of the transactions. Non-transactional up-
dates to objects read or written by an active system transaction are
also prevented by the system. Either the system suspends the non-
transactional work before the update, or it aborts the transaction.
By preventing conﬂicting accesses to the same kernel object, the
system provides conﬂict serializability, which is commonly used to
enforce serializability efﬁciently.

System transactions make durability optional because durabil-
ity often increases transaction commit latency and the programmer
does not always need it. The increased commit latency comes from
ﬂushing data to a slow block storage device, like a disk. Eliminat-
ing the TOCTTOU race in the ﬁle system namespace is an example
of a system transaction that does not require durability. Durability
for system transactions in TxOS is under the control of the pro-
grammer, using a ﬂag to sys_xbegin()(Table 2).

Each kernel thread may execute a system transaction. Transac-
tional updates are isolated from all other kernel threads, including
threads in different processes. We call a kernel thread executing a
system transaction a transactional kernel thread.

3.1.2

Interaction of transactional and
non-transactional threads

The OS serializes system transactions and non-transactional sys-
tem calls, providing the strongest guarantees and most intuitive
semantics [18] to the programmer. The serialization of transac-
tional and non-transactional updates to the same resources is called
strong isolation [5]. Previous OS transaction designs have left the
interaction of transactions with non-transactional activity semanti-
cally murky. Intuitive semantics for mixing transactional and non-
transactional access to the same resources is crucial to maintaining
a simple interface to system resources. Strong isolation prevents
unexpected behavior due to non-transactional and transactional ap-
plications accessing the same system resources.

The presence of system transactions does not change the behav-
ior of non-transactional activity in the underlying operating sys-
tem. While most system calls are already isolated and atomic,
there are important exceptions. For example, Linux does not seri-
alize read with write. On an OS with system transactions, non-

163transactional system calls can still exhibit non-serializable behavior
with respect to each other, but non-transactional system calls serial-
ize with transactions. For example, one or more calls to read in a
system transaction will correctly serialize with a non-transactional
write.

3.1.3 System transaction progress

The operating system guarantees that system transactions do not
livelock with other system transactions. When two transactions, A
and B, cannot both commit, the system selects one to restart (let’s
say B in this example), and ensures its decision remains consistent.
If A continues and B restarts and again conﬂicts with A, the OS
will again restart B. See § 5.2.1 for details.

Guaranteeing progress for transactional threads in the presence
of non-transactional threads requires support from the OS. If an OS
supports preemption of kernel threads (present in Linux 2.4 and 2.6
since 2004), then it can guarantee progress for long running trans-
actions by preempting non-transactional threads that would impede
progress of the transaction.

The OS has several mechanisms to regulate the progress of trans-
actions, but the use of these mechanisms is a matter of policy. For
instance, allowing a long running transaction to isolate all system
resources indeﬁnitely is undesirable, so the OS may want a policy
that limits the size of a transaction. Limiting a transaction that over-
consumes system resources is analogous to controlling any process
that abuses system resources, such as memory, disk space, or kernel
threads.

3.1.4 System transactions for system state

Although system transactions provide ACID semantics for sys-
tem state, they do not provide these semantics for application state.
System state includes OS data structures and device state stored in
the operating system’s address space, whereas application state in-
cludes only the data structures stored in the application’s address
space. When a system transaction aborts, the OS restores the ker-
nel state to its pre-transaction state, but it does not revert application
state.

For most applications, we expect programmers will use a library
or runtime system that transparently manages application state as
well as system transactions. In simple cases, such as the TOCT-
TOU example, the developer could manage application state her-
self. TxOS provides single-threaded applications with an auto-
matic checkpoint and restore mechanism for the application’s ad-
dress space that marks the pages copy-on-write (similar to Specu-
lator [35]), which can be enabled with a ﬂag to sys_xbegin()
(Table 2). In Section 4.3, we describe how system transactions inte-
grate with hardware and software transactional memory, providing
a complete transactional programming model for multi-threaded
applications.

3.1.5 Communication model

Code that communicates outside of a transaction and requires a
response cannot be encapsulated into a single transaction. Com-
munication outside of a transaction violates isolation. For exam-
ple, a transaction may send a message to a non-transactional thread
over an IPC channel and the system might buffer the message until
commit. If the transaction waits for a reply on the same channel,
the application will deadlock. The programmer is responsible for
avoiding this send/reply idiom within a transaction.

Communication among threads within the same transaction is
unrestricted. This paper only considers system transactions on a
single machine, but future work could allow system transactions to
span multiple machines.

Subsystem
Credentials
Processes

Tot.
34
13

Part.
1
3

Communication
Filesystem

Other

Totals

15
61

13

0
4

6

Examples
getuid, getcpu, setrlimit (partial)
fork, vfork, clone, exit, exec (par-
tial)
rt_sigaction, rt_sigprocmask, pipe
link, access, stat, chroot, dup,
open, close, write, lseek
time, nanosleep,
mmap2 (partial)

ioctl (partial),

136

14 Grand total: 150

Unsupported

Processes
Memory
Filesystem
File Descriptors
Communication
Timers/Signals
Administration
Misc
Total

nice, uselib, iopl, sched_yield, capget
brk, mprotect, mremap, madvise

33
15
31 mount, sync, ﬂock, setxattr, io_setup, inotify
14
8
12
22
18
153

splice, tee, sendﬁle, select, poll
socket, ipc, mq_open, mq_unlink
alarm, sigaltstack, timer_create
swapon, reboot, init_module, settimeofday
ptrace, futex, times, vm86, newuname

Table 1: Summary of system calls that TxOS completely supports
(Tot.) and partially supports (Part.) in transactions, followed by system
calls with no transaction support. Partial support indicates that some
(but not all) execution paths for the system call have full transactional
semantics. Linux 2.6.22.6 on the i386 architecture has 303 total system
calls.

3.2 TxOS overview

TxOS implements system transactions by isolating data read and
written in a transaction using existing kernel memory buffers and
data structures. When an application writes data to a ﬁle system or
device, the updates generally go into an OS buffer ﬁrst, allowing
the OS to optimize device accesses. By making these buffers copy-
on-write for transactions, TxOS isolates transactional data accesses
until commit. In TxOS, transactions must ﬁt into main memory,
although this limit could be raised in future work by swapping un-
committed transaction state to disk.

TxOS isolates updates to kernel data structures using recent im-
plementation techniques from object-based software transactional
memory systems. These techniques are a departure from the log-
ging and two-phase locking approaches of databases and historic
transactional operating systems (§4.2). TxOS’s isolation mecha-
nisms are optimistic, allowing concurrent transactions on the as-
sumption that conﬂicts are rare.

Table 1 summarizes the system calls and resources for which
TxOS supports transactional semantics, including the ﬁle system,
process and credential management, signals, and pipes. A partially
supported system call means that some processing paths are fully
transactional, and some are not. For example, ioctl is essentially
a large switch statement, and TxOS does not support transactional
semantics for every case. When a partially supported call cannot
support transactional semantics, or an unsupported call is issued,
the system logs a warning or aborts the transaction, depending on
the ﬂags passed to sys_xbegin().

Ideal support for system transactions would include every rea-
sonable system call. TxOS supports a subset of Linux system calls
as shown in Table 1. The count of 150 supported system calls
shows the relative maturity of the prototype, but also indicates that
it is incomplete. The count of unsupported system calls does not
proportionately represent the importance or challenge of the re-

164Function Name
int sys_xbegin
(int ﬂags)

int sys_xend()

void sys_xabort
(int no_restart)

Description
Begin a transaction. The ﬂags specify trans-
actional behavior,
including automatically
restarting the transaction after an abort, ensur-
ing that committed results are on stable stor-
age (durable), and aborting if an unsupported
system call is issued. Returns status code.
End of transaction. Returns whether commit
succeeded.
Aborts a transaction.
If the transaction was
started with restart, setting no_restart over-
rides that ﬂag and does not restart the trans-
action.

Table 2: TxOS API

maining work because many resources, such as network sockets,
IPC, etc., primarily use the common ﬁle system interfaces. For
instance, extending transactions to include networking (a real chal-
lenge) would increase the count of supported calls by 5, whereas
transaction support for extended ﬁle attributes (a fairly straight-
forward extension) would add 12 supported system calls. The re-
maining count of system calls falls into three categories: substan-
tial extensions (memory management, communication), straight-
forward, but perhaps less common or important (process manage-
ment, timers, most remaining ﬁle interfaces), and operations that
are highly unlikely to be useful inside a transaction (e.g., reboot,
mount, init_module, etc.). TxOS supports transactional se-
mantics for enough kernel subsystems to demonstrate the power
and utility of system transactions.

4. TXOS DESIGN

System transactions guarantee strong isolation for transactions,
while retaining good performance and simple interfaces. This sec-
tion outlines how the TxOS design achieves these goals.

4.1 Interoperability and fairness

TxOS allows ﬂexible interaction between transactional and non-
transaction kernel threads. TxOS efﬁciently provides strong iso-
lation inside the kernel by requiring all system calls to follow the
same locking discipline, and by requiring that transactions anno-
tate accessed kernel objects. When a thread, transactional or non-
transactional, accesses a kernel object for the ﬁrst time, it must
check for a conﬂicting annotation. The scheduler arbitrates con-
ﬂicts when they are detected.
In many cases, this check is per-
formed at the same time as a thread acquires a lock for the object.
Interoperability is a weak spot for previous transactional sys-
tems.
In most transactional systems, a conﬂict between a trans-
action and a non-transactional thread (called an asymmetric con-
ﬂict [41]) must be resolved by aborting the transaction. This ap-
proach undermines fairness. In TxOS, because asymmetric con-
ﬂicts are often detected before a non-transactional thread enters a
critical region, the scheduler has the option of suspending the non-
transactional thread, allowing for fairness between transactions and
non-transactional threads.

4.2 Managing transactional state

Databases and historical transactional operating systems typi-
cally update data in place and maintain an undo log. This approach
is called eager version management [25]. These systems isolate
transactions by locking data when it is accessed and holding the
lock until commit. This technique is called two-phase locking, and
it usually employs locks that distinguish read and write accesses.

Because applications generally do not have a globally consistent
order for data accesses, these systems can deadlock. For example,
one thread might read ﬁle A then write ﬁle B, while a different
thread might read ﬁle B, then write ﬁle A.

The possibility of deadlock complicates the programming model
of eager versioning transactional systems. Deadlock is commonly
addressed by exposing a timeout parameter to users. Setting the
timeout properly is a challenge. If it is too short, it can starve long-
running transactions.
If it is too long, it can destroy the perfor-
mance of the system.

Eager version management degrades responsiveness in ways that
are not acceptable for an operating system.
If an interrupt han-
dler, high priority thread, or real-time thread aborts a transaction,
it must wait for the transaction to process its undo log (to restore
the pre-transaction state) before it can safely proceed. This wait
jeopardizes the system’s ability to meet its timing requirements.

TxOS, in contrast, uses lazy version management, where trans-
actions operate on private copies of a data structure. Applications
never hold kernel locks across system calls. Lazy versioning re-
quires TxOS to hold locks only long enough to make a private copy
of the relevant data structure. By enforcing a global ordering for
kernel locks, TxOS avoids deadlock. TxOS can abort transactions
instantly—the winner of a conﬂict does not incur latency for the
aborted transaction to process its undo log.

The primary disadvantage of lazy versioning is the commit la-
tency due to copying transactional updates from the speculative
version to the stable version of the data structures. As we discuss
in Section 5, TxOS minimizes this overhead by splitting objects,
turning a memcpy of the entire object into a pointer copy.

4.3 Integration with transactional memory

System transactions protect system state, not application state.
For multi-threaded programs, the OS has no efﬁcient mechanism
to save and restore the memory state of an individual thread. User-
level transactional memory (TM) systems, however, are designed to
provide efﬁcient transactional semantics to memory modiﬁcations
by a thread, but cannot isolate or roll back system calls. Integrating
user and system transactions creates a simple and complete trans-
actional programming model.

System transactions ﬁx one of the most troublesome limitations
of transactional memory systems—that system calls are disallowed
during user transactions because they violate transactional seman-
tics. System calls on traditional operating system are not isolated,
and they cannot be rolled back if a transaction fails. For exam-
ple, a ﬁle append performed inside a hardware or software user
transaction can occur an arbitrary number of times. Each time the
user-level transaction aborts and retries, it repeats the append.

On a TM system integrated with TxOS, when a TM application
makes a system call, the runtime begins a system transaction. The
user-level transactional memory system handles buffering and pos-
sibly rolling back the application’s memory state, and the system
transaction buffers updates to system state. The updates to sys-
tem state are committed or aborted by the kernel atomically with
the commit or abort of the user-level transaction. The programmer
sees the simple abstraction of an atomic block that can contain up-
dates to user data structures and system calls. See Section 5.6 for
implementation details and Sections 7.8 and 7.9 for evaluation.

5. TxOS KERNEL IMPLEMENTATION

This section describes how system transactions are implemented
in the TxOS kernel. TxOS provides transactional semantics for
150 of 303 system calls in Linux, presented in Table 1. The sup-
ported system calls include process creation and termination, cre-

165struct inode_header {

i_count; // Reference count
i_lock;
*data;

atomic_t
spinlock_t
inode_data
// Other objects
address_space i_data; // Cached pages
tx_data xobj;
list i_sb_list; // kernel bookkeeping

// for conflict detection

// Data object

};

};

struct inode_data {

inode_header *header;
// Common inode data fields
unsigned long i_ino;
loff_t

i_size; // etc.

Figure 2: A simpliﬁed inode structure, decomposed into header and
data objects in TxOS. The header contains the reference count, locks,
kernel bookkeeping data, and the objects that are managed transac-
tionally. The inode_data object contains the ﬁelds commonly ac-
cessed by system calls, such as stat, and can be updated by a transac-
tion by replacing the pointer in the header.

dential management operations, sending and receiving signals, and
ﬁle system operations.

System transactions in TxOS add roughly 3,300 lines of code for
transaction management, and 5,300 lines for object management.
TxOS also requires about 14,000 lines of minor changes to convert
kernel code to use the new object type system and to insert checks
for asymmetric conﬂicts when executing non-transactionally.

5.1 Versioning data

TxOS maintains multiple versions of kernel data structures so
that system transactions can isolate the effects of system calls until
transactions commit, and in order to undo the effects of transac-
tions if they cannot complete. Data structures private to a process,
such as the current user id or the ﬁle descriptor table, are versioned
with a simple checkpoint and restore scheme. For shared kernel
data structures, however, TxOS implements a versioning system
that borrows techniques from software transactional memory sys-
tems [21] and other recent concurrent programming systems [24].
When a transaction accesses a shared kernel object, such as an
inode, it acquires a private copy of the object, called a shadow
object. All system calls within the transaction use this shadow ob-
ject in place of the stable object until the transaction commits or
aborts. The use of shadow objects ensures that transactions always
have a consistent view of the system state. When the transaction
commits, the shadow objects replace their stable counterparts. If a
transaction cannot complete, it simply discards its shadow objects.
Any given kernel object may be the target of pointers from sev-
eral other objects, presenting a challenge to replacing a stable ob-
ject with a newly-committed shadow object. A naïve system might
update the pointers to an object when that object is committed. Un-
fortunately, updating the pointers means writing the objects that
contain those pointers. By writing to the pointing objects, the trans-
action may create conﬂicting accesses and abort otherwise non-
conﬂicting transactions. For two concurrent transactions to suc-
cessfully commit in TxOS, they must write disjoint objects.

Splitting objects into header and data.

In order to allow efﬁcient commit of lazy versioned data, TxOS
decomposes objects into a stable header component and a volatile,
transactional data component. Figure 2 provides an example of this

decomposition for an inode. The object header contains a pointer
to the object’s data; transactions commit changes to an object by
replacing this pointer in the header to a modiﬁed copy of the data
object. The header itself is never replaced by a transaction, which
eliminates the need to update pointers in other objects; pointers
point to headers. The header can also contain data that is not ac-
cessed by transactions. For instance, the kernel garbage collection
thread (kswapd) periodically scans the inode and dentry (di-
rectory entry) caches looking for cached ﬁle system data to reuse.
By keeping the data for kernel bookkeeping, such as the reference
count and the superblock list (i_sb_list in Figure 2), in the
header, these scans never access the associated inode_data ob-
jects and avoid restarting active transactions.

Decomposing objects into headers and data also provides the
advantage of the type system ensuring that transactional code al-
ways has a speculative object. For instance, in Linux, the vir-
tual ﬁle system function vfs_link takes pointers to inodes
and dentries, but in TxOS these pointers are converted to the
shadow types inode_data and dentry_data. When modify-
ing Linux, using the type system allows the compiler to ﬁnd all of
the code that needs to acquire a speculative object, ensuring com-
pleteness. The type system also allows the use of interfaces that
minimize the time spent looking up shadow objects. For example,
when the path name resolution code initially acquires shadow data
objects, it then passes these shadow objects directly to helper func-
tions such as vfs_link and vfs_unlink. The virtual ﬁle sys-
tem code acquires shadow objects once on entry and passes them
to lower layers, minimizing the need for ﬁlesystem-speciﬁc code to
reacquire the shadow objects.

Multiple data objects.

TxOS decomposes an object into multiple data payloads when
it houses data that can be accessed disjointly. For instance, the
inode_header contains both ﬁle metadata (owner, permissions,
etc.) and the mapping of ﬁle blocks to cached pages in memory
(i_data). A process may often read or write a ﬁle without updat-
ing the metadata. TxOS versions these objects separately, allowing
metadata operations and data operations on the same ﬁle to execute
concurrently when it is safe.

Read-only objects.

Many kernel objects are only read in a transaction, such as the
parent directories in a path lookup. To avoid the cost of making
shadow copies, kernel code can specify read-only access to an ob-
ject, which marks the object data as read-only for the length of
the transaction. Each data object has a transactional reader refer-
ence count. If a writer wins a conﬂict for an object with a non-
zero reader count, it must create a new copy of the object and
install it as the new stable version. The OS garbage collects the
old copy via read-copy update (RCU) [29] when all transactional
readers release it and after all non-transactional tasks have been
descheduled. This constraint ensures that all active references to
the old, read-only version have been released before it is freed and
all tasks see a consistent view of kernel data. The only caveat is
that a non-transactional task that blocks must re-acquire any data
objects it was using after waking, as they may have been replaced
and freed by a transaction commit. Although it complicates the
kernel programming model slightly, marking data objects as read-
only in a transaction is a structured way to eliminate substantial
overhead for memory allocation and copying. Special support for
read-mostly transactions is a common optimization in transactional
systems, and RCU is a technique to support efﬁcient, concurrent
access to read-mostly data.

1665.2 Conﬂict detection and resolution

As discussed in Section 4.1, TxOS serializes transactions with
non-transactional activity as well as with other transactions. TxOS
serializes non-transactional accesses to kernel objects with transac-
tions by leveraging the current locking practice in Linux and aug-
menting stable objects with information about transactional read-
ers and writers. Both transactional and non-transactional threads
use this information to detect accesses that would violate conﬂict
serializability when they acquire a kernel object.

Conﬂicts occur when a transaction attempts to write an object
that has been read or written by another transaction. An asym-
metric conﬂict is deﬁned similarly: a non-transactional thread at-
tempts to write an object a transaction has read or written, or vice
versa. TxOS embeds a tx_data object in the header portion of all
shared kernel objects that can be accessed within a transaction. The
tx_data object includes a pointer to a transactional writer and a
reader list. A non-null writer pointer indicates an active transac-
tional writer, and an empty reader list indicates there are no readers.
Locks prevent transactions from acquiring an object that is concur-
rently accessed by a non-transactional thread. When a thread de-
tects a conﬂict, TxOS uses these ﬁelds to determine which transac-
tions are in conﬂict; the conﬂict is then arbitrated by the contention
manager (§5.2.1). Note that the reader list is attached to the stable
header object, whereas the reader count (§5.1) is used for garbage
collecting obsolete data objects. By locking and testing the trans-
actional readers and writer ﬁelds, TxOS detects transactional and
asymmetric conﬂicts.

5.2.1 Contention Management

When a conﬂict is detected between two transactions or between
a transaction and a non-transactional thread, TxOS invokes the con-
tention manager to resolve the conﬂict. The contention manager is
kernel code that implements a policy to arbitrate conﬂicts among
transactions, dictating which of the conﬂicting transactions may
continue. All other conﬂicting transactions must abort.

As a default policy, TxOS adopts the osprio policy [43]. Osprio
always selects the process with the higher scheduling priority as
the winner of a conﬂict, eliminating priority and policy inversion in
transactional conﬂicts. When processes with the same priority con-
ﬂict, the older transaction wins (a policy known as timestamp [40]),
guaranteeing liveness for transactions within a given priority level.

5.2.2 Asymmetric conﬂicts

A conﬂict between a transactional and non-transactional thread
is called an asymmetric conﬂict. Transactional threads can always
be aborted and rolled back, but non-transactional threads cannot be
rolled back. TxOS must have the freedom to resolve an asymmetric
conﬂict in favor of the transactional thread, otherwise asymmetric
conﬂicts will always win, undermining fairness in the system and
possibly starving transactions.

While non-transactional threads cannot be rolled back, they can
often be preempted, which allows them to lose conﬂicts with trans-
actional threads. Kernel preemption is a recent feature of Linux
that allows the kernel to preemptively deschedule threads execut-
ing system calls inside the kernel, unless they are inside of certain
critical regions.
In TxOS, non-transactional threads detect con-
ﬂicts with transactional threads before they actually update state,
usually when they acquire a lock for a kernel data structure. A
non-transactional thread can simply deschedule itself if it loses a
conﬂict and is in a preemptible state. If a non-transactional, non-
preemptible process aborts a transaction too many times, the ker-
nel can still prevent it from starving the transaction by placing the
non-transactional process on a wait queue the next time it makes a

State
exclusive Any attempt to access the list is a conﬂict with the cur-

Description

rent owner

write

read

notx

Any number of insertions and deletions are allowed,
provided they do not access the same entries. Reads
(iterations) are not allowed. Writers may be transac-
tions or non-transactional tasks.
Any number of
transactional or non-
transactional, are allowed, but insertions and deletions
are conﬂicts.

readers,

There are no active transactions,
and a non-
transactional thread may perform any operation. A
transaction must ﬁrst upgrade to read or write
mode.

Table 3: The states for a transactional list in TxOS. Having multiple
states allows TxOS lists to tolerate access patterns that would be con-
ﬂicts in previous transactional systems.

system call. The kernel reschedules the non-transactional process
only after the transaction commits.

Linux can preempt a kernel thread if the thread is not holding a
spinlock and is not in an interrupt handler. TxOS has the additional
restriction that it will not preempt a conﬂicting thread that holds
one or more mutexes (or semaphores). Otherwise, TxOS risks a
deadlock with a transaction that might need that lock to commit. By
using kernel preemption and lazy version management, TxOS has
more ﬂexibility to coordinate transactional and non-transactional
threads than previous transactional operating systems.

5.2.3 Minimizing conﬂicts on lists

The kernel relies heavily on linked list data structures. When ap-
plied to lists, simple read/write conﬂict semantics produce a num-
ber of false positives. For instance, two transactions should both
be allowed to add elements to the same list, even though adding
an element is a list write. TxOS adopts techniques from previous
transactional memory systems to deﬁne conﬂicts on lists more pre-
cisely [21].

TxOS isolates list updates with a lock and deﬁnes conﬂicts ac-
cording to the states described in Table 3. For instance, a list in the
write state allows concurrent transactional and non-transactional
writers, so long as they do not access the same entry. Individual en-
tries that are transactionally added or removed are annotated with
a transaction pointer that is used to detect conﬂicts. If a writing
transaction also attempts to read the list contents, it must upgrade
the list to exclusive mode by aborting all other writers. The
read state behaves similarly. This design allows maximal list con-
currency while preserving correctness.

5.3 Managing transaction state

To manage transactional state, TxOS adds transaction objects to
the kernel, which store metadata and statistics for a transaction.
The kernel thread’s control block (the task_struct in Linux)
points to the transaction object, shown in Figure 3. A thread can
have at most one active transaction, though transactions can ﬂat
nest, meaning that all nested transactions are subsumed into the en-
closing transaction. Each thread in a multithreaded application can
have its own transaction, and multiple threads (even those in differ-
ent processes) may share a transaction, as we discuss in Section 6.2.
Figure 3 summarizes the ﬁelds of the transaction object. The
transaction includes a status word (status).
If another thread
wins a conﬂict with this thread, it will update this word atomically
with a compare-and-swap instruction. The kernel checks the status

167struct transaction {

atomic_t status; // live/aborted/inactive
uint64 tx_start_time;// timestamp
uint32 retry_count;
struct pt_regs *checkpointed_registers;
workset_list
deferred_ops; // operations done at commit
undo_ops;

// operations undone at abort

*workset_list;

};

Figure 3: Data contained in a system transaction object, which is
pointed to by the user area (task_struct).

word when attempting to add a new shadow object to its workset
and checks it before commit.

If a transactional system call reaches a point where it cannot
complete because of a conﬂict with another thread, it must immedi-
ately abort execution. This abort is required because Linux is writ-
ten in an unmanaged language and cannot safely follow pointers if
it does not have a consistent view of memory. To allow roll-back
at arbitrary points during execution, the transaction stores the reg-
ister state on the stack at the beginning of the current system call
in the checkpointed_registers ﬁeld. If the system aborts
the transaction midway through a system call, it restores the reg-
ister state and jumps back to the top of the kernel stack (like the
C library function longjmp). Because a transaction can hold a
lock or other resource when it aborts, supporting the longjmp-
style abort involves a small overhead to track certain events within
a transaction so that they can be cleaned up on abort.

Transactions must defer certain operations until commit time,
such as freeing memory, delivering signals and ﬁle system monitor-
ing events (i.e., inotify and dnotify). The deferred_ops
ﬁeld stores these events. Similarly, some operations must be un-
done if a transaction is aborted, such as releasing the locks it holds
and freeing the memory it allocates. These operations are stored in
the undo_ops ﬁeld. The tx_start_time ﬁeld is used by the
contention manager (see Section 5.2.1), while the retry_count
ﬁeld stores the number of times the transaction aborted.

The workset_list is a skip list [39] that stores references
to all of the objects for which the transaction has private copies.
The workset list is sorted by the kernel locking discipline for fast
commit. Each entry in the workset contains a pointer to the stable
object, a pointer to the shadow copy, information about whether the
object is read-only or read-write, and a set of type-speciﬁc methods
(commit, abort, lock, unlock, release). When a transactional thread
adds an object to its workset, the thread increments the reference
count on the stable copy. This increment prevents the object from
being unexpectedly freed while the transaction still has an active
reference to it. Kernel objects are not dynamically relocatable, so
ensuring a non-zero reference count is sufﬁcient for guaranteeing
that memory addresses remain unchanged for the duration of the
transaction.

5.4 Commit protocol

When a system transaction calls sys_xend(), it is ready to be-
gin the commit protocol. The ﬂow of the commit protocol is shown
in Figure 4. In the ﬁrst step, the transaction acquires locks for all
items in its workset. The workset is kept sorted according to the
kernel locking discipline to enable fast commit and eliminate the
possibility of deadlock among committing transactions. Speciﬁ-
cally, objects are sorted by the kernel virtual address of the header,
followed by lists sorted by kernel virtual address. Lists are locked
last to maintain an ordering with the directory traversal code.

Figure 4: The major steps involved in committing Transaction A with
inode 57 in its workset, changing the mode from 0777 to 0755. The com-
mit code ﬁrst locks the inode. It then replaces the inode header’s data
pointer to the shadow inode. Finally, Transaction A frees the resources
used for transactional bookkeeping and unlocks the inode.

TxOS iterates over the objects twice, once to acquire the block-
ing locks and a second time to acquire non-blocking locks. TxOS
is careful to acquire blocking locks before spinlocks, and to release
spinlocks before blocking locks. Acquiring or releasing a mutex or
semaphore can cause a process to sleep, and sleeping with a held
spinlock can deadlock the system.

After acquiring all locks, the transaction does a ﬁnal check of
its status word with an atomic compare-and-swap instruction. If it
has not been set to ABORTED, then the transaction can success-
fully commit (this CAS instruction is the transaction’s lineariza-
tion point [23]). The committing process holds all relevant object
locks during commit, thereby excluding any transactional or non-
transactional threads that would compete for the same objects.

After acquiring all locks, the transaction copies its updates to
the stable objects. The transaction’s bookkeeping data are removed
from the objects, then the locks are released. Between releasing
spinlocks and mutexes, the transaction performs deferred opera-
tions (like memory allocations/frees and delivering ﬁle system mon-
itoring events) and performs any pending writes to stable storage.

During commit, TxOS holds locks that are not otherwise held at
the same time in the kernel. As a result, TxOS extends the lock-
ing discipline slightly, for instance by requiring that rename locks
inodes entries in order of kernel virtual address. TxOS also in-
troduces additional ﬁne-grained locking on objects, such as lists,
that are not locked in Linux. Although these additional constraints
complicate the locking discipline, they also allow TxOS to elide
coarse-grained locks such as the dcache_lock, which protects
updates to the hash table of directory entries cached in memory.
By eliminating these coarse-grained locks, TxOS improves perfor-
mance scalability for individual system calls.

5.5 Abort Protocol

If a transaction detects that it loses a conﬂict, it must abort. The
abort protocol is similar to the commit protocol, but simpler be-
cause it does not require all objects to be locked at once. If the
transaction is holding any kernel locks, it ﬁrst releases them to
avoid stalling other processes. The transaction then iterates over
its working set and locks each object, removes any references to
itself from the object’s transactional state, and then unlocks the ob-
ject. Next, the transaction frees its shadow objects and decrements
the reference count on their stable counterparts. The transaction
walks its undo log to release any other resources, such as memory
allocated within the transaction.

0777StableInodeHeaderWorkset ListTx A0755ShadowInodeDataLock ObjectsPointer Swap New Data ObjectsUnlock and ReleaseTx Objects57InodeData...0777StableInodeHeaderWorkset ListTx A0755ShadowInodeData57...StableInodeHeader075557NewInodeDataTx A1685.6 User-level transactions

In order for a user-level transactional memory system to use sys-
tem transactions, the TM system must coordinate commit of appli-
cation state with commit of the system transaction. This section
provides commit protocols for the major classes of TM implemen-
tations.

5.6.1 Lock-based STM requirements

TxOS uses a simpliﬁed variant of the two-phase commit pro-
tocol (2PC) [17] to coordinate commit of a lock-based user-level
software (STM) transaction with a system transaction. The TxOS
commit consists of the following steps.
1. The user prepares a transaction.
2. The user requests that the system commit the transaction

through the sys_xend()system call.

3. The system commits or aborts.
4. The system communicates the outcome to the user through

the sys_xend()return code.

5. The user commits or aborts in accordance with the outcome

of the system transaction.

This protocol naturally follows the ﬂow of control between the
user and kernel, but requires the user transaction system to sup-
port the prepared state. We deﬁne a prepared transaction as being
ﬁnished (it will add no more data to its working set), safe to com-
mit (it has not currently lost any conﬂicts with other threads), and
guaranteed to remain able to commit (it will win all future conﬂicts
until the end of the protocol). In other words, once a transaction
is prepared, another thread must stall or rollback if it tries to per-
form a conﬂicting operation. In a system that uses locks to protect a
commit, prepare is accomplished by simply holding all of the locks
required for the commit during the sys_xend()call. On a suc-
cessful commit, the system commits its state before the user, but
any competing accesses to the shared state are serialized after the
user commit.

Depending on the implementation details of the user TM im-
plementation, additional integration effort may be required of the
STM implementation. For instance, a lazy versioned STM needs
to ensure that a transactional write system call is issued with the
correct version of the buffer. As an optimization, the STM runtime
can check the return code on system calls within a transaction to
detect an aborted system transaction sooner. For the TM systems
we examined, coordinating commit and adding extra return checks
were sufﬁcient.

5.6.2 HTM and obstruction-free STM requirements

Hardware transactional memory (HTM) and obstruction-free soft-
ware TM systems [22] use a single instruction (xend and compare-
and-swap, respectively), to perform their commits. For these sys-
tems, a prepare stage is unnecessary. Instead, the commit protocol
should have the kernel issue the commit instruction on behalf of the
user once the kernel has validated its workset. Both the system and
user-level transaction commit or abort together depending upon the
result of this speciﬁc commit instruction.

For HTM support, TxOS requires that the hardware allow the
kernel to suspend user-initialized transactions on entry to the ker-
nel. Every HTM proposal that supports an OS [32, 43, 58] supports
mechanisms that suspend user-initiated transactions, avoiding the
mixture of user and kernel addresses in the same hardware transac-
tion. Mixing user and kernel address creates a security vulnerability
in most HTM proposals. Also, the kernel needs to be able to issue
an xend instruction on behalf of the application.

Though TxOS supports user-level HTM, it runs on commodity

hardware and does not require any special HTM support itself.

6. TxOS KERNEL SUBSYSTEMS

This section discusses how various kernel subsystems support
ACI[D] semantics in TxOS. In several cases, transactional seman-
tics need not be developed from scratch, but are implemented by
extending functionality already present in the subsystem. For ex-
ample, we use the journal in ext3 to provide true, multi-operation
durability. We leverage Linux’s support for deferring signal deliv-
ery to manage signals sent to and from transactional threads.

6.1 Transactional ﬁle system

TxOS simpliﬁes the task of writing a transactional ﬁle system
by detecting conﬂicts and managing versioned data in the virtual
ﬁlesystem layer. The OS provides the transactional semantics—
versioning updates and detecting conﬂicts. The ﬁle system need
only provide the ability to atomically commit updates to stable stor-
age (e.g., via a journal). By ensuring that all committed changes are
written in a single journal transaction, we converted ext3 into a
transactional ﬁle system. Memory-only ﬁle systems, such as proc
and tmpfs, are automatically transactional when used within sys-
tem transactions.

6.2 Multi-process transactions

A dominant paradigm for UNIX application development is the
composition of simple but powerful utility programs into more com-
plex tasks. Following this pattern, applications may wish to trans-
actionally fork a number of child processes to execute utilities and
wait for the results to be returned through a pipe.

To support this programming paradigm in a natural way, TxOS
allows multiple threads to participate in the same transaction. The
threads in a transaction may share an address space, as in a multi-
threaded application, or the threads may reside in different address
spaces. Threads in the same transaction share and synchronize ac-
cess to speculative state.

When a process forks a child inside a transaction, the child pro-
cess executes within the active transaction until it performs a sys_-
xend()or it exits (where an exit is considered an implicit sys_-
xend()). The transaction commits when all tasks in the transac-
tion have issued a sys_xend(). This method of process manage-
ment allows transactional programs to call high-level convenience
functions, like system, to easily create processes using the full
complement of shell functionality. Such execed programs run
with transactional semantics, though they might not contain any
explicitly transactional code. After a child process commits, it is no
longer part of the transaction and subsequent sys_xbegin()calls
will begin transactions that are completely independent from the
parent.

System calls that modify process state, for example by allocating
memory or installing signal handlers, are faster in transactionally
forked tasks because they do not checkpoint the process’s system
state. An abort will simply terminate the process; no other rollback
is required.

6.3 Signal delivery

Signal semantics in TxOS provide isolation among threads in
different transactions, as well as isolation between non-transactional
and transactional threads. Any signal sent to a thread not part of the
source’s transaction is deferred until commit by placing it in a de-
ferral queue, regardless of whether the receiving thread is transac-
tional. Signals in the queue are delivered in order if the transaction
commits, and discarded if the transaction aborts.

When a thread begins a transaction, a ﬂag to sys_xbegin()
speciﬁes whether incoming signals should be delivered specula-
tively within the transaction (speculative delivery) or deferred until

169commit (deferred delivery). Speculative delivery enables transac-
tional applications to be more responsive to input. When signals
are delivered speculatively, they must be logged. If the transaction
aborts, these signals are re-delivered to the receiving thread so that
from the sender’s perspective the signals do not disappear. When
a transaction that has speculatively received a signal commits, the
logged signals are discarded.

When signal delivery is deferred, incoming signals are placed
in a queue and delivered in order when the transaction commits or
aborts. Deferring signals allows transactions to ensure that they are
atomic with respect to signal handlers [57]. Enclosing signal han-
dling code in a transaction ensures that system calls in the handler
are atomic, and forces calls to the same handler to serialize. Trans-
actional handling of signals eliminates race conditions without the
need for the additional API complexity of sigaction. While
the sigaction API addresses signal handler atomicity within a
single thread by making handlers non-reentrant, the API does not
make signal handlers atomic with respect to other threads.

An application cannot block or ignore the SIGSTOP and SIGKILL

signals outside of a transaction. TxOS preserves the special status
of these signals, delivering them directly to transactional threads,
even if the transaction started in deferred delivery mode.

Speculative and deferred delivery apply only to delivery of in-
coming signals sent from non-transactional threads or from a dif-
ferent transaction once it commits. When a transaction sends a sig-
nal to a thread outside of the transaction, it is buffered until commit.
Threads in the same transaction can send and receive signals freely
with other threads in the same transaction.

6.4 Future work

TxOS does not yet provide transactional semantics for several
classes of OS resources. Currently, TxOS either logs a warning
or aborts a transaction that attempts to access an unsupported re-
source: the programmer speciﬁes the behavior via a ﬂag to sys_-
xbegin(). This subsection considers some challenges inherent
in supporting these resources, which we leave for future work.

Networking.

The network is among the most important resources to transac-
tionalize. Within a system transaction, some network communica-
tion could be buffered and delayed until commit, while others could
be sent and logically rolled back by the communication protocol if
the transaction aborts. Network protocols are often written to ex-
plicitly tolerate the kinds of disruptions (e.g., repeated requests,
dropped replies) that would be caused by restarting transactions.
The open challenge is ﬁnding a combination of techniques that is
high performance across a wide range of networking applications,
while retaining a reasonably simple transaction API.

Interprocess communication.

While TxOS currently supports IPC between kernel threads in
the same system transaction, and supports transactional signals and
pipes, a range of IPC abstractions remain that TxOS could sup-
port. These abstractions include System V shared memory, mes-
sage queues, and local sockets.
IPC has much in common with
networking, but presents some additional opportunities because the
relevant tasks are on the same system. IPC on the same system ad-
mits more creative approaches, such as aborting a transaction that
receives a message from a transaction that later aborts.

User interfaces.

Exchanging messages with a user while inside a transaction is
unlikely to become a popular paradigm (although TABS imple-

mented a transaction GUI by crossing out text dialogs from aborted
transactions [48]), because the I/O-centric nature of user interfaces
is not a natural ﬁt with the transactional programming model. Like
other communication channels, however, the OS could naturally
support transactions that only read from or write to a user I/O de-
vice by buffering the relevant data. Maintaining a responsive user
interface will likely mandate that developers keep transactions in-
volving interfaces short.

Logging.

Applications may wish to explicitly exempt certain output from
isolation while inside a transaction, primarily for logging. Logging
is useful for debugging aborted transactions, and it is also impor-
tant for security sensitive applications. For instance, an authentica-
tion utility may wish to log failed attempts to minimize exposure to
password guessing attacks. An attacker should not be able to sub-
vert this policy by wrapping the utility in a transaction that aborts
until the password is guessed.

Most system resources can be reasonably integrated with system
transactions. However, extending transactions to these resources
may complicate the programming interface and slow the imple-
mentation. Future work will determine if system transactions for
these resources are worth the costs.

7. EVALUATION

This section evaluates the overhead of system transactions in
TxOS, as well as its behavior for several case studies:
transac-
tional software installation, a transactional LDAP server, a transac-
tional ext3 ﬁle system, the elimination of TOCTTOU races, scal-
able atomic operations, and integration with hardware and software
transactional memory.

We perform all of our experiments on a server with 1 or 2 quad-
core Intel X5355 processors (total of 4 or 8 cores) running at 2.66
GHz with 4 GB of memory. All single-threaded experiments use
the 4-core machine, and scalability measurements were taken using
the 8 core machine. We compare TxOS to an unmodiﬁed Linux ker-
nel, version 2.6.22.6—the same version extended to create TxOS .

The hardware transactional memory experiments use MetaTM [41]

on Simics version 3.0.27 [27]. The simulated machine has 16 1000
MHz CPUs, each with a 32 KB level 1 and 4 MB level 2 cache.
An L1 miss costs 24 cycles and an L2 miss costs 350 cycles. The
HTM uses the timestamp contention management policy and linear
backoff on restart.

7.1 Single-thread system call overheads

A key goal of TxOS is to make transaction support efﬁcient,
taking special care to minimize the overhead non-transactional ap-
plications incur. To evaluate performance overheads for substan-
tial applications, we measured the average compilation time across
three non-transactional builds of the Linux 2.6.22 kernel on unmod-
iﬁed Linux (3 minutes, 24 seconds), and on TxOS (3 minutes, 28
seconds). This slowdown of less than 2% indicates that for most
applications, the non-transactional overheads will be negligible. At
the scale of a single system call, however, the average overhead is
currently 29%, and could be cut to 14% with improved compiler
support.

Table 4 shows the performance of common ﬁle system system
calls on TxOS. We ran each system call 1 million times, discarding
the ﬁrst and last 100,000 measurements and averaging the remain-
ing times. The elapsed cycles were measured using the rdtsc
instruction. The purpose of the table is to analyze transaction over-
heads in TxOS, but it is not a realistic use case, as most system calls
are already atomic and isolated. Wrapping a single system call in a

170Call
access
stat
open
unlink
link
mkdir
read
write
geomean

Linux
2.4
2.6
2.9
6.1
7.7
64.7
2.6
12.8

Base

Static

NoTx

In Tx

Tx

2.4
2.6
3.1
7.2
9.1
71.4
2.8
9.9

1.0×
2.6
1.0×
2.8
1.1×
3.2
1.2×
8.1
1.2× 12.3
1.1× 73.6
1.1×
2.8
0.7× 10.0
1.03×

1.1×
3.2
1.1×
3.4
1.2×
3.9
1.3×
9.4
1.6× 11.0
1.1× 79.7
1.1×
3.6
0.8× 11.7
1.14×

Bgnd Tx
1.4×
3.2
1.3×
3.4
1.4×
3.7
1.5× 10.8
1.4× 17.0
1.2× 84.1
1.3×
3.6
0.9× 13.8
1.29×

1.4×
11.3
1.3×
11.5
1.3×
16.5
1.7×
18.1
2.2×
57.1
1.3× 297.1
1.3×
11.4
1.1×
16.4
1.42×

4.7×
18.6
4.1×
20.3
5.2×
25.7
3.0×
31.9
7.4×
82.6
4.6× 315.3
4.3×
18.3
1.3×
39.0
3.93×

7.8×
7.3×
8.0×
7.3×
10.7×
4.9×
7.0×
3.0×
6.61×

Table 4: Execution time in thousands of processor cycles of common system calls on TxOS and performance relative to Linux. Base is the basic
overhead introduced by data structure and code modiﬁcations moving from Linux to TxOS, without the overhead of transactional lists. Static
emulates compiling two versions of kernel functions, one for transactional code and one for non-transactional code, and includes transactional list
overheads. These overheads are possible with compiler support. NoTX indicates the current speed of non-transactional system calls on TxOS. Bgnd
Tx indicates the speed of non-transactional system calls when another process is running a transaction in the background. In Tx is the cost of a
system call inside a transaction, excluding sys_xbegin()and sys_xend(), and Tx includes these system calls.

transaction is the worst case for TxOS performance because there
is very little work across which to amortize the cost of creating
shadow objects and commit.

The Base column shows the base overhead from adding trans-
actions to Linux. These overheads have a geometric mean of 3%,
and are all below 20%, including a performance improvement for
write. Overheads are incurred mostly by increased locking in
TxOS and the extra indirection necessitated by data structure reor-
ganization (e.g., separation of header and data objects). These low
overheads show that transactional support does not signiﬁcantly
slow down non-transactional activity.

TxOS replaces simple linked lists with a more complex transac-
tional list (§5.2.3). The transactional list allows more concurrency,
both by eliminating transactional conﬂicts and by introducing ﬁne-
grained locking on lists, at the expense of higher single-thread la-
tency. The Static column adds the latencies due to transactional
lists to the base overheads (roughly 10%, though more for link).
The Static column assumes that TxOS can compile two versions
of all system calls: one used by transactional threads and the other
used by non-transactional threads. Our TxOS prototype uses dy-
namic checks, which are frequent and expensive. With compiler
support, these overheads are achievable.

The NoTx column presents measurements of the current TxOS
prototype, with dynamic checks to determine if a thread is execut-
ing a transaction. The Bgnd Tx column are non-transactional sys-
tem call overheads for TxOS while there is an active system trans-
action in a different thread. Non-transactional system calls need
to perform extra work to detect conﬂicts with background transac-
tions. The In Tx column shows the overhead of the system call in
a system transaction. This overhead is high, but represents a rare
use case. The Tx column includes the overheads of the sys_-
xbegin()and sys_xend()system calls.

7.2 Applications and micro-benchmarks

Table 5 shows the performance of TxOS on a range of applica-
tions and micro-benchmarks. Each measurement is the average of
three runs. The slowdown relative to Linux is also listed. Postmark
is a ﬁle system benchmark that simulates the behavior of an email,
network news, and e-commerce client. We use version 1.51 with
the same transaction boundaries as Amino [56]. The LFS small
ﬁle benchmark operates on 10,000 1024 bytes ﬁles, and the large
ﬁle benchmark reads and writes a 100MB ﬁle. The Reimplemented
Andrew Benchmark (RAB) is a reimplementation of the Modiﬁed

Andrew Benchmark, scaled for modern computers. Initially, RAB
creates 500 ﬁles, each containing 1000 bytes of pseudo-random
printable-ASCII content. Next, the benchmark measures execu-
tion time of four distinct phases: the mkdir phase creates 20,000
directories; the cp phase copies the 500 generated ﬁles into 500
of these directories, resulting in 250,000 copied ﬁles; the du phase
calculates the disk usage of the ﬁles and directories with the du
command; and the grep/sum phase searches the ﬁles for a short
string that is not found and checksums their contents. The sizes
of the mkdir and cp phases are chosen to take roughly similar
amounts of time on our test machines. In the transactional version,
each phase is wrapped in a transaction. Make wraps a software
compilation in a transaction. Dpkg and Install are software instal-
lation benchmarks that wrap the entire installation in a transaction,
as discussed in the following subsection.

Across most workloads, the overhead of system transactions is
quite reasonable (1–2×), and often system transactions speed up
the workload (e.g., postmark, LFS small ﬁle create, RAB mkdir
and cp phases). Benchmarks that repeatedly write ﬁles in a trans-
action, such as the LFS large ﬁle benchmark sequential write or the
LFS small ﬁle create phase, are more efﬁcient than Linux. Transac-
tion commit groups the writes and presents them to the I/O sched-
uler all at once, improving disk arm scheduling and, on ext2 and
ext3, increasing locality in the block allocations. Write-intensive
workloads outperform non-transactional writers by as much as a
factor of 29.7×.

TxOS requires extra memory to buffer updates. We surveyed
several applications’ memory overheads, and focus here on the
LFS small and large benchmarks as two representative samples.
Because the utilization patterns vary across different portions of
physical memory, we consider low memory, which is used for ker-
nel data structures, separately from high memory, which can be
allocated to applications or to the page cache (which buffers ﬁle
contents in memory). High memory overheads are proportional
to the amount data written. For LFS large, which writes a large
stream of data, TxOS uses 13% more high memory than Linux,
whereas LFS small, which writes many small ﬁles, introduced less
than 1% space consumption overhead. Looking at the page cache in
isolation, TxOS allocates 1.2–1.9× as many pages as unmodiﬁed
Linux. The pressure on the kernel’s reserved portion of physical
memory, or low memory, is 5% higher for transactions across all
benchmarks. This overhead comes primarily from the kernel slab
allocator, which allocates 2.4× as much memory. The slab allo-

171Bench

postmark
lfs small
create
read
delete
lfs large
write seq
read seq
write rnd
read rnd
RAB
mkdir
cp
du
grep/sum
dpkg
make
install

Linux
ext2
38.0

TxOS
ACI

Linux
ext3
0.2× 180.9

TxOS
ACID

154.6

0.9×

7.6

0.6
2.2
0.4

2.3
2.5
0.3
3.9
.9
3.3
2.7

4.6
1.7
0.2

1.4
1.3
77.3
75.8

8.7
14.2
0.3
2.7
.8
3.2
1.9

0.3
1.4
2.6
71.8

0.2×
1.1×
0.03×
0.9×

0.1×
1.2×
2.0×

0.3×
0.2×
1.0×
1.4×
1.1×
1.0×
1.4×

10.1
1.7
0.2

3.4
1.5
84.3
70.1

9.4
13.8
0.4
4.2
.8
3.1
1.7

1.4
2.1
0.5

2.0
1.6
4.2
70.2

2.2
2.6
0.3
3.8
.9
3.3
2.9

0.1×
1.3×
2.4×

0.6×
1.1×
0.005×
1.0×

0.2×
0.2×
0.8×
0.9×
1.1×
1.1×
1.7×

Table 5: Execution time in seconds for several transactional bench-
marks on TxOS and slowdown relative to Linux. ACI represents non-
durable transactions, with a baseline of ext2, and ACID represents
durable transactions with a baseline of ext3 with full data journaling.

cator is used for general allocation (via kmalloc) and for com-
mon kernel objects, like inodes. TxOS’s memory use indicates that
buffering transactional updates in memory is practical, especially
considering the trend in newer systems toward larger DRAM and
64-bit addresses.

7.3 Software installation

By wrapping system commands in a transaction, we extend make,
make install, and dpkg, the Debian package manager, to pro-
vide ACID properties to software installation. We ﬁrst test make
with a build of the text editor nano, version 2.0.6. Nano consists
of 82 source ﬁles totaling over 25,000 lines of code. Next, we test
make install with an installation of the Subversion revision
control system, version 1.4.4. Finally, we test dpkg by installing
the package for OpenSSH version 4.6. The OpenSSH package was
modiﬁed not to restart the daemon, as the script responsible sends
a signal and waits for the running daemon to exit, but TxOS defers
the signal until commit. This script could be rewritten to match the
TxOS signal API in a production system.

As Table 5 shows, the overhead for adding transactions is quite
reasonable (1.1–1.7×), especially considering the qualitative bene-
ﬁts. For instance, by checking the return code of dpkg, our transac-
tional wrapper was able to automatically roll back a broken Ubuntu
build of OpenSSH (4.6p1-5ubuntu0.3), and no concurrent tasks
were able to access the invalid package ﬁles during the installation.

7.4 Transactional LDAP server

Many applications have fairly modest concurrency control re-
quirements for their stable data storage, yet use heavyweight solu-
tions, such as a database server. An example is Lightweight Direc-
tory Access Protocol (LDAP) servers, which are commonly used to
authenticate users and maintain contact information for large orga-
nizations. System transactions provide a simple, lightweight stor-
age solution for such applications.

To demonstrate that system transactions can provide lightweight
concurrency control for server applications, we modiﬁed the slapd
server in OpenLDAP 2.3.35’s ﬂat ﬁle storage module (called LDIF)

Back end

BDB
LDIF
LDIF-TxOS

Search
Single
3229
3171
3124

Search
Subtree
2076
2107
2042

Add

Del

203
1032 (5.1×)
413 (2.0×)

172
2458 (14.3×)
714 (4.2×)

Table 6: Throughput in queries per second of OpenLDAP’s slapd
server (higher is better) for a read-only and write-mostly workload.
For the Add and Del workloads, the increase in throughput over BDB
is listed in parentheses. The BDB storage module uses Berkeley DB,
LDIF uses a ﬂat ﬁle with no consistency for updates, and LDIF-TxOS
augments the LDIF storage module use system transactions on a ﬂat
ﬁle. LDIF-TxOS provides the same crash consistency guarantees as
BDB with more than double the write throughput.

to use system transactions. The OpenLDAP server supports a num-
ber of storage modules; the default is Berkeley DB (BDB). We
used the SLAMD distributed load generation engine1 to exercise the
server, running in single-thread mode. Table 6 shows throughput
for the unmodiﬁed Berkeley DB storage module, the LDIF storage
module augmented with a simple cache, and LDIF using system
transactions. The “Search Single” experiment exercises the server
with single item read requests, whereas the “Search Subtree” col-
umn submits requests for all entries in a given directory subtree.
The “Add” test measures throughput of adding entries, and “Del”
measures the throughput of deletions.

The read performance (search single and search subtree) of each
storage module is within 3%, as most reads are served from an
in-memory cache. LDIF has 5–14× the throughput of BDB for re-
quests that modify the LDAP database (add and delete). However,
the LDIF module does not use ﬁle locking, synchronous writes or
any other mechanism to ensure consistency. LDIF-TxOS provides
ACID guarantees for updates. Compared to BDB, the read perfor-
mance is similar, but workloads that update LDAP records using
system transactions outperform BDB by 2–4×. LDIF-TxOS pro-
vides the same guarantees as the BDB storage module with respect
to concurrency and recoverability after a crash.

7.5 Transactional ext3

In addition to measuring the overheads of durable transactions,
we validate the correctness of our transactional ext3 implemen-
tation by powering off the machine during a series of transactions.
After the machine is powered back on, we mount the disk to re-
play any operations in the ext3 journal and run fsck on the disk
to validate that it is in a consistent state. We then verify that all
results from committed transactions are present on the disk, and
that no partial results from uncommitted transactions are visible.
To facilitate scripting, we perform these checks using Simics. Our
system successfully passes over 1,000 trials, giving us a high de-
gree of conﬁdence that TxOS transactions correctly provide atomic,
durable updates to stable storage.

7.6 Eliminating race attacks

System transactions provide a simple, deterministic method for
eliminating races on system resources. To qualitatively validate this
claim, we reproduce several race attacks from recent literature on
Linux and validate that TxOS prevents the exploit.

We downloaded the symlink TOCTTOU attacker code used by
Borisov et al. [6] to defeat Dean and Hu’s probabilistic counter-
measure [11]. This attack code creates memory pressure on the ﬁle

1http://www.slamd.com/

172Execution Time
Linux
TxOS
.05
.05

System Calls
Linux
TxOS
1,084
1,024

Allocated Pages
Linux
TxOS
8,755
25,876

Table 7: Execution Time, number of system calls, and allocated pages
for the genome benchmark on the MetaTM HTM simulator with 16
processors.

Transactions allow the programmer to combine simpler system
calls to perform more complex operations, yielding better perfor-
mance scalability and a simpler implementation. Figure 5 com-
pares the unmodiﬁed Linux implementation of rename to calling
sys_xbegin(), link, unlink, and sys_xend()in TxOS.
In this micro-benchmark, we divide 500,000 cross-directory re-
names across a number of threads.

TxOS has worse single-thread performance because it makes
four system calls for each Linux system call. But TxOS quickly
recovers the performance, performing within 6% at 2 CPUs and
out-performing rename by 3.9× at 8 CPUs. The difference in
scalability is directly due to TxOS using ﬁne-grained locking to
implement transactions, whereas Linux must use coarse-grained
locks to maintain the fast path for rename and keep its imple-
mentation complexity reasonable. While this experiment is not
representative of real workloads, it shows that solving consistency
problems with modestly complex system calls like rename will
either harm performance scalability or introduce substantial imple-
mentation complexity. Because of Linux’s coarse-grained locks,
TxOS’ atomic link/unlink pair outperforms the Linux non-
atomic link/unlink pair by a factor of 1.9× at 8 CPUs.

7.8 Integration with software TM

We qualitatively verify that system transactions can be integrated
with existing transactional memory systems by extending a soft-
ware and hardware TM implementation to use system transactions.
We integrated DATM-J [42], a Java-based STM, with system trans-
actions. The only modiﬁcations to the STM are to follow the com-
mit protocol when committing a user level transaction that invokes
a system call and to add return code checks for aborted system
transactions, as outlined in Section 4.3.

We tested the integration of DATM-J with TxOS by modifying
Tornado, a multi-threaded web server that is publicly available on
sourceforge, to use transactions. Tornado protects its data struc-
tures with STM transactions, and the STM transparently protects
concurrent reads and writes to its data ﬁles from interfering with
each other. The original code uses ﬁle locking. For one synthetic
workload, the STM version is 47% faster at 7 threads.

7.9 Integration with hardware TM

In the genome benchmark from the STAMP transactional mem-
ory benchmark suite [31], the lack of integration between the hard-
ware TM system and the operating system results in an unavoid-
able memory leak. Genome allocates memory during a transaction,
and the allocation sometimes calls mmap. When the transaction
restarts, it rolls back the allocator’s bookkeeping for the mmap, but
not the results of the mmap system call, thereby leaking memory.
When the MetaTM HTM system [41] is integrated with TxOS, the
mmap is made part of a system transaction and is properly rolled
back when the user-level transaction aborts.

Table 7 shows the execution time, number of system calls within
a transaction, and the number of allocated pages at the end of the
benchmark for both TxOS and unmodiﬁed Linux running on Meta-
TM. TxOS rolls back mmap in unsuccessful transactions, allocating

Figure 5: Time to perform 500,000 renames divided across a num-
ber of threads (lower is better). TxOS implements its renames as calls
to sys_xbegin(), link, unlink, and sys_xend(), using 4 system
calls for every Linux rename call. Despite higher single-threaded over-
head, TxOS provides better scalability, outperforming Linux by 3.9×
at 8 CPUs. At 8 CPUs, TxOS also outperforms a simple, non-atomic
link/unlink combination on Linux by 1.9×.

system cache to force the victim to deschedule for disk I/O, thereby
lengthening the amount of time spent between checking the path
name and using it. This additional time allows the attacker to win
nearly every time on Linux.

On TxOS, the victim successfully resists the attacker by read-
ing a consistent view of the directory structure and opening the
correct ﬁle. The attacker’s attempt to interpose a symbolic link cre-
ates a conﬂicting update that occurs after the transactional access
check starts, so TxOS puts the attacker to sleep on the asymmetric
conﬂict. The performance of the safe victim code on TxOS is sta-
tistically indistinguishable from the vulnerable victim on Linux.

To demonstrate that TxOS improves robustness while preserv-
ing simplicity for signal handlers, we reproduced two of the attacks
described by Zalewksi [57]. The ﬁrst attack is representative of a
vulnerability present in sendmail up to 8.11.3 and 8.12.0.Beta7,
in which an attacker induces a double-free in a signal handler. The
second attack, representative of a vulnerability in the screen util-
ity, exploits lack of signal handler atomicity. Both attacks lead to
root compromise; the ﬁrst can be ﬁxed by using the sigaction
API rather than signal, while the second cannot. We modiﬁed
the signal handlers in these attacks by wrapping handler code in
a sys_xbegin, sys_xend pair, which provides signal han-
dler atomicity without requiring the programmer to change the code
to use sigaction. In our experiments, TxOS serializes handler
code with respect to other system operations, and therefore defeats
both attacks.

7.7 Concurrent performance

System calls like rename and open have been used as ad hoc
solutions for the lack of general-purpose atomic actions. These
system calls have strong semantics (a rename is atomic within a ﬁle
system), resulting in complex implementations whose performance
does not scale. As an example in Linux, rename has to serialize
all cross-directory renames on a single ﬁle-system-wide mutex be-
cause ﬁner-grained locking would risk deadlock. The problem is
not that performance tuning rename is difﬁcult, but it would sub-
stantially increase the implementation complexity of the entire ﬁle
system, including unrelated system calls.

1733× less heap memory to the application. Benchmark performance
is not affected. No source code or libc changes are required for
TxOS to detect that mmap is transactional.

The possibility of an mmap leak is a known problem [58], with
several proposed solutions, including open nesting [33] and a trans-
actional pause instruction [58]. All previously proposed solutions
complicate the programming model, the hardware, or both. System
transactions address the memory leak with the simplest hardware
requirements and user API.

Feature
Low overhead kernel
implementation
Can be root fs?
Framework for
transactionalizing other ﬁle
systems
Simple programmer interface
Other kernel resources in a
transaction

Amino
No

TxF Valor
Yes
Yes

TxOS
Yes

No
No

Yes
No 2

Yes
No
No Yes 3

Yes
Yes

No
No

Yes
Yes

Yes
Yes

8. RELATED WORK

In this section we contrast TxOS with previous research in OS
transactions, transactional memory, Speculator, transactional ﬁle
systems, and distributed transactions.

Speculator.

Previous transactional operating systems.

Locus [55] and QuickSilver [20, 45] are operating systems that
support transactions. Both systems use database implementation
techniques for transactions, isolating data structures with two-phase
locking and rolling back failed transactions from an undo log. A
shortcoming of this approach is that simple locks, and even reader-
writer locks, do not capture the semantics of container objects, such
as a directory. Multiple transactions can concurrently and safely
create ﬁles in the same directory so long as none of them use the
same ﬁle name or read the directory. Unfortunately, creating a ﬁle
in these systems requires a write lock on the directory, which seri-
alizes the writing transactions and eliminates concurrency. To com-
pensate for the poor performance of reader-writer locks, both sys-
tems allow directory contents to change during a transaction, which
reintroduces the possibility of the TOCTTOU race conditions that
system transactions ought to eliminate. In contrast, TxOS imple-
ments system transactions with lazy version management, more so-
phisticated containers, and asymmetric conﬂict detection, allowing
it to provide higher isolation levels while minimizing performance
overhead.

Transactional Memory.

Transactional Memory (TM) systems provide a mechanism to
provide atomic and isolated updates to application data structures.
Transactional memory is implemented either as modiﬁcations to
cache coherence hardware (HTM) [19,32], in software (STM) [12],
or as a hybrid of the two [8, 10].

Volos et al. [54] extend the Intel STM compiler with xCalls,
which support deferral or rollback of common system calls when
performed in a memory transaction. Because xCalls are imple-
mented in a single, user-level application, they cannot isolate trans-
action effects from kernel threads in different processes, ensure
durable updates to a ﬁle, or support multi-process transactions, all
of which are needed to perform a transactional software installation
and are supported by TxOS.

The system transactions supported by TxOS solve a fundamen-
tally different problem from those solved by TxLinux [43]. Tx-
Linux is a variant of Linux that uses hardware transactional mem-
ory as a synchronization primitive to protect OS data structures
within the kernel, whereas TxOS exports a transactional API to
user programs. The techniques used to build TxLinux enforce con-
sistency for kernel memory accesses within short critical regions.
However, these techniques are insufﬁcient to implement TxOS, which
must guarantee consistency across heterogeneous system resources,
and which must support system transactions spanning multiple sys-
tem calls. TxLinux requires hardware transactional memory sup-
port, whereas TxOS runs on currently available commodity hard-
ware.

Table 8: A summary of features supported by recent transactional ﬁle
systems.

Speculator [35] applies an isolation and rollback mechanism to
the operating system that is very similar to transactions, allowing
the system to speculate past high-latency remote ﬁle system opera-
tions. The transactional semantics TxOS provides to user programs
is a more complicated endeavor. In TxOS, transactions must be iso-
lated from each other, while Speculator is designed for applications
to share speculative results when they access the same data. Specu-
lator does not eliminate TOCTTOU vulnerabilities. If a TOCTTOU
attack occurred in Speculator, the attacker and victim would be part
of the same speculation, allowing the attack to succeed. Speculator
has been extended to parallelize security checks [36] and to debug
system conﬁguration [50], but does not provide ACID semantics
for user-delimited speculation, and is thus insufﬁcient for applica-
tions like atomic software installation/update.

Transactional ﬁle systems.

TxOS simpliﬁes the task of writing a transactional ﬁle system
by detecting conﬂicts and versioning data in the virtual ﬁle system
layer. Some previous work such as OdeFS [15], Inversion [38],
and DBFS [34] provide a ﬁle system interface to a database, im-
plemented as a user-level NFS server. These systems do not pro-
vide atomic, isolated updates to local disk, and cannot address the
problem of coordinating access to OS-managed resources. Berke-
ley DB and Stasis [46] are transactional libraries, not ﬁle systems.
Amino [56] supports transactional ﬁle operation semantics by inter-
posing on system calls using ptrace and relying on a user-level
database to store and manage ﬁle system data and metadata. Other
ﬁle systems implement all transactional semantics directly in the
ﬁle system, as illustrated by Valor [49], Transactional NTFS (also
known as TxF) [44], and others [14, 45, 47].

Table 8 lists several desirable properties for a transactional ﬁle
system and compares TxOS with recent systems. Because Amino’s
database must be hosted on a native ﬁle system, it cannot be used
as the root ﬁle system. TxF can be used as the root ﬁle system, but
the programmer must ensure that the local system is the two-phase
commit coordinator if it participates in a distributed transaction.

Like TxOS, Valor provides kernel support in the page cache to
simplify the task of adding transactions to new ﬁle systems. Valor
supports transactions larger than memory, which TxOS currently
does not. Valor primarily provides logging and coarse-grained lock-
ing for ﬁles. Because directory operations require locking the direc-
tory, Valor, like QuickSilver, is more conservative than necessary
with respect to concurrent directory updates.

2Windows provides a kernel transaction manager, which coordi-
nates commits across transactional resources, but each individual
ﬁlesystem is still responsible for implementing checkpoint, roll-
back, conﬂict detection, etc.
3Windows supports a transactional registry.

174In addition to TxF, Windows Vista introduced a transactional
registry (TxR) and a kernel transaction manager (KTM) [44]. KTM
allows applications to create kernel transaction objects that can co-
ordinate transactional updates to TxF, TxR, and user-level appli-
cations, such as a database or software updater. KTM coordinates
transaction commit, but each individual ﬁlesystem or other kernel
component must implement its own checkpoint, rollback, conﬂict
detection, etc. In contrast, TxOS minimizes the work required to
transactionalize a ﬁle system by providing conﬂict detection and
isolation in shared virtual ﬁlesystem code.

TxOS and KTM also represent different points in the design
space of transactional application interfaces. KTM requires that
all transactional accesses be explicit, whereas TxOS allows un-
modiﬁed libraries or applications to be wrapped in a transaction.
Requiring each system call to be explicitly transactional is a more
conservative design because unsupported operations do not com-
pile, whereas TxOS detects these dynamically. A key downside
to KTM’s low-level interface is that it requires individual appli-
cation developers to be aware of accesses that can deadlock with
completely unrelated applications on the same system (such as ac-
cessing two ﬁles in opposite order), and implement their own time-
out and backoff system. In contrast, transactions in TxOS cannot
deadlock and TxOS can arbitrate conﬂicts according to scheduler
policies (Section 5.2.1) without any expert knowledge from the de-
veloper.

TxOS provides programmers with a simple, natural interface,
augmenting the POSIX API with only three system calls (Table 2).
Other transactional ﬁle systems require application programmers
to understand implementation details, such as deadlock detection
(TxF) and the logging and locking mechanism (Valor).

Distributed transactions.

A number of systems, including TABS [48], Argus [26], and Sin-
fonia [3], provide support for distributed transactional applications
at the language or library level. User-level services cannot isolate
system resources without OS support.

9. CONCLUSION

This paper argues for system transactions as a general-purpose,
natural way for programmers to synchronize access to system re-
sources, a problem currently solved in an ad hoc manner. TxOS
supports transactions for system resources, including the ﬁle sys-
tem, signals, memory allocation, and process management. Al-
though system transactions in TxOS are limited in size and the
scope of resources involved, they can solve a number of important,
long-standing problems from a number of domains, including ﬁle
system race conditions. This paper describes novel implementation
techniques for system transactions that are efﬁcient and minimize
the effort required to extend transaction support to additional re-
sources, such as converting a given ﬁle system implementation to a
transactional ﬁle system.

10. ACKNOWLEDGMENTS

We extend thanks to Michael Bond, Michael Dahlin, Kathryn
McKinley, Edmund Nightingale, Vitaly Shmatikov, Michael Wal-
ﬁsh, Jean Yang, and the anonymous reviewers for careful reading
of drafts, and to our shepherd Paul Barham for valuable feedback
and suggestions. We also thank Indrajit Roy and Andrew Matsuoka
for help developing TxOS. This research is supported by NSF Ca-
reer Award 0644205 and the DARPA computer science study panel,
phase 1. We thank Virtutech for their Simics academic site license
program and Intel for an equipment donation.

11. REFERENCES
[1]

[2]

http://www.employees.org/˜satch/ssh/faq/TheWholeSSHFAQ.html.

http://plash.beasts.org/wiki/PlashIssues/ConnectRaceCondition.

[3] M. K. Aguilera, A. Merchant, M. Shah, A. Veitch, and
C. Karamanolis. Sinfonia: a new paradigm for building
scalable distributed systems. In SOSP, New York, NY, USA,
2007. ACM.

[4] D. J. Bernstein. Some thoughts on security after ten years of

qmail 1.0. In CSAW, 2007.

[5] C. Blundell, E. C. Lewis, and M. M. K. Martin.

Deconstructing transactions: The subtleties of atomicity. In
Fourth Annual Workshop on Duplicating, Deconstructing,
and Debunking. Jun 2005.

[6] N. Borisov, R. Johnson, N. Sastry, and D. Wagner. Fixing
races for fun and proﬁt: How to abuse atime. In USENIX
Security, 2005.

[7] X. Cai, Y. Gui, and R. Johnson. Exploiting unix ﬁle-system

races via algorithmic complexity attacks. Oakland, 2009.

[8] C. Cao Minh, M. Trautmann, J. Chung, A. McDonald,

N. Bronson, J. Casper, C. Kozyrakis, and K. Olukotun. An
effective hybrid transactional memory system with strong
isolation guarantees. In ISCA. Jun 2007.

[9] C. Cowan, S. Beattie, C. Wright, and G. Kroah-Hartman.

RaceGuard: Kernel protection from temporary ﬁle race
vulnerabilities. In USENIX Security 2001, pages 165–176.

[10] P. Damron, A. Fedorova, Y. Lev, V. Luchangco, M. Moir, and

D. Nussbaum. Hybrid transactional memory. In ASPLOS,
2006.

[11] D. Dean and A. J. Hu. Fixing races for fun and proﬁt: how to

use access(2). In USENIX Security, pages 14–26, 2004.

[12] D. Dice, O. Shalev, and N. Shavit. Transactional locking II.

In DISC, pages 194–208, 2006.

[13] U. Drepper. Secure ﬁle descriptor handling. In LiveJournal,

08.

[14] E. Gal and S. Toledo. A transactional ﬂash ﬁle system for

microcontrollers. In USENIX, 2005.

[15] N. Gehani, H. V. Jagadish, and W. D. Roome. Odefs: A ﬁle

system interface to an object-oriented database. In VLDB,
1994.

[16] S. Ghemawat, H. Gobioff, and S.-T. Leung. The google ﬁle

system. SOSP, 2003.

[17] J. Gray. Notes on data base operating systems. In Operating

Systems, An Advanced Course. Springer-Verlag, 1978.

[18] J. Gray and A. Reuter. Transaction Processing: Concepts

and Techniques. Morgan Kaufmann, 1993.

[19] L. Hammond, V. Wong, M. Chen, B. Carlstrom, J. Davis,

B. Hertzberg, M. Prabhu, H. Wijaya, C. Kozyrakis, and
K. Olukotun. Transactional memory coherence and
consistency. In ISCA, June 2004.

[20] R. Haskin, Y. Malachi, and G. Chan. Recovery management

in QuickSilver. ACM Trans. Comput. Syst., 6(1):82–108,
1988.

[21] M. Herlihy and E. Koskinen. Transactional boosting: A

methodology for highly-concurrent transactional objects. In
PPoPP, 2008.

[22] M. Herlihy, V. Luchangco, M. Moir, and I. William

N. Scherer. Software transactional memory for
dynamic-sized data structures. In PODC, 2003.

175[23] M. P. Herlihy and J. M. Wing. Linearizability: a correctness

condition for concurrent objects. ACM TOPLAS, 12(3), 1990.

Transactional memory for an operating system. In ISCA,
2007.

[24] M. Kulkarni, K. Pingali, B. Walter, G. Ramanarayanan,
K. Bala, and L. P. Chew. Optimistic parallelism requires
abstractions. In PLDI, New York, NY, USA, 2007. ACM
Press.

[25] J. Larus and R. Rajwar. Transactional Memory. Morgan &

Claypool, 2006.

[42] H. E. Ramadan, I. Roy, M. Herlihy, and E. Witchel.

Committing conﬂicting transactions in an STM. PPoPP,
2009.

[43] C. Rossbach, O. Hofmann, D. Porter, H. Ramadan,

A. Bhandari, and E. Witchel. TxLinux: Using and managing
transactional memory in an operating system. In SOSP, 2007.

[26] B. Liskov, D. Curtis, P. Johnson, and R. Scheifer.

[44] M. Russinovich and D. Solomon. Windows Internals.

Implementation of Argus. SOSP, 1987.

Microsoft Press, 2009.

[27] P. Magnusson, M. Christianson, and J. E. et al. Simics: A full

[45] F. Schmuck and J. Wylie. Experience with transactions in

system simulation platform. In IEEE Computer, Feb 2002.

QuickSilver. In SOSP. ACM, 1991.

[28] P. McDougall. Microsoft pulls buggy windows vista sp1

[46] R. Sears and E. Brewer. Stasis: Flexible transactional

ﬁles. In Information Week.
http://www.informationweek.com/story/
showArticle.jhtml?articleID=206800819.

[29] P. E. McKenney. Exploiting Deferred Destruction: An

Analysis of Read-Copy Update Techniques in Operating
System Kernels. PhD thesis, 2004.

[30] Microsoft. What is system restore. 2008.
http://support.microsoft.com/kb/959063.

[31] C. C. Minh, J. Chung, C. Kozyrakis, and K. Olukotun.

Stamp: Stanford transactional applications for
multi-processing. In IISWC, 2008.

[32] K. E. Moore, J. Bobba, M. J. Moravan, M. D. Hill, and D. A.
Wood. LogTM: Log-based transactional memory. In HPCA,
2006.

[33] M. J. Moravan, J. Bobba, K. E. Moore, L. Yen, M. D. Hill,
B. Liblit, M. M. Swift, and D. A. Wood. Supporting nested
transactional memory in LogTM. In ASPLOS, 2006.

[34] N. Murphy, M. Tonkelowitz, and M. Vernal. The design and

implementation of the database ﬁle system, 2002.

[35] E. B. Nightingale, P. M. Chen, and J. Flinn. Speculative

execution in a distributed ﬁle system. In SOSP, 2005.
[36] E. B. Nightingale, D. Peek, P. M. Chen, and J. Flinn.

Parallelizing security checks on commodity hardware. In
ASPLOS, 2008.

[37] NIST. National Vulnerability Database.

http://nvd.nist.gov/, 2008.

[38] M. A. Olson. The design and implementation of the

inversion ﬁle system. In USENIX, 1993.

[39] W. Pugh. Skip lists: a probabilistic alternative to balanced

trees. Communications of the ACM, 33:668–676, 1990.
[40] R. Rajwar and J. R. Goodman. Transactional lock-free

execution of lock-based programs. ASPLOS, 2002.
[41] H. Ramadan, C. Rossbach, D. Porter, O. Hofmann,

A. Bhandari, and E. Witchel. MetaTM/TxLinux:

storage. In OSDI, 2006.

[47] M. I. Seltzer. Transaction support in a log-structured ﬁle

system. In 9th International Conference on Data
Engineering, 1993.

[48] A. Z. Spector, D. Daniels, D. Duchamp, J. L. Eppinger, and
R. Pausch. Distributed transactions for reliable systems. In
SOSP, 1985.

[49] R. Spillane, S. Gaikwad, M. Chinni, E. Zadok, and C. P.
Wright. Enabling transactional ﬁle access via lightweight
kernel extensions. FAST, 2009.

[50] Y.-Y. Su, M. Attariyan, and J. Flinn. Autobash: improving
conﬁguration management with operating system causality
analysis. In SOSP, 2007.

[51] D. Tsafrir, T. Hertz, D. Wagner, and D. D. Silva. Portably

preventing ﬁle race attacks with user-mode path resolution.
Technical report, IBM Research Report, 2008.

[52] D. Tsafrir, T. Hertz, D. Wagner, and D. D. Silva. Portably

solving ﬁle TOCTTOU races with hardness ampliﬁcation. In
FAST, 2008.

[53] E. Tsyrklevich and B. Yee. Dynamic detection and

prevention of race conditions in ﬁle accesses. In USENIX
Security, 2003.

[54] H. Volos, A. J. Tack, N. Goyal, M. M. Swift, and A. Welc.
xCalls: Safe I/O in memory transactions. In EuroSys, 2009.

[55] M. J. Weinstein, J. Thomas W. Page, B. K. Livezey, and G. J.

Popek. Transactions and synchronization in a distributed
operating system. In SOSP, 1985.

[56] C. P. Wright, R. Spillane, G. Sivathanu, and E. Zadok.

Extending ACID semantics to the ﬁle system. Trans.
Storage, 3(2):4, 2007.

[57] M. Zalewski. Delivering signals for fun and proﬁt. 2001.
[58] C. Zilles and L. Baugh. Extending hardware transactional

memory to support non-busy waiting and non-transactional
actions. In TRANSACT, Jun 2006.

176