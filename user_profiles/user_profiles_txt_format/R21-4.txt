2009 30th IEEE Real-Time Systems Symposium
2009 30th IEEE Real-Time Systems Symposium

Timing Analysis of Mixed Time/Event-Triggered

Multi-Mode Systems

Linh T.X. Phan1

Samarjit Chakraborty2

Insup Lee1

1Department of Computer and Information Science, University of Pennsylvania, USA

2Institute for Real-Time Computer Systems, TU Munich, Germany

e-mail: {linhphan, lee}@seas.upenn.edu, samarjit@tum.de

Abstract—Many embedded systems operate in multiple modes,
where mode switches can be both time- as well as event-triggered.
While timing and schedulability analysis of the system when it
is operating in a single mode has been well studied, it is always
difﬁcult to piece together the results from different modes in
order to deduce the timing properties of a multi-mode system.
As a result, often certain restrictive assumptions are made,
e.g., restricting the time instants at which mode changes might
occur. The problem becomes more complex when both time- and
event-triggered mode changes are allowed. Further, for complex
systems that cannot be described by traditional periodic/sporadic
event models (i.e., where event streams are more complex/bursty)
modeling multiple modes is largely an open problem. In this
paper we propose a model and associated analysis techniques to
describe embedded systems that process multiple bursty/complex
event/data streams and in which mode changes are both time-
and event-triggered. Compared to previous studies, our model is
very general and can capture a wide variety of real-life systems.
Our analysis techniques can be used to determine different
performance metrics, such as the maximum ﬁll-levels of different
buffers and the delays suffered by the streams being processed
by the system. The main novelty in our analysis lies in how
we piece together results from the different modes in order to
obtain performance metrics for the full system. Towards this,
we propose both – exact, but computationally expensive, as well
as safe approximation techniques. The utility of our model and
analysis has been illustrated using a detailed smart-phone case
study.

I. INTRODUCTION

The increasing complexity and costs of modern embedded
systems require them to operate in multiple modes, where
each mode – among other things – may be characterized
by a different set of tasks, different data arrival rates, and a
different scheduling policy. Mode switches may be both time-
as well as event-triggered. Examples of the former consist of
servicing time-triggered interrupts, while the latter might be
mode switches triggered by events like an incoming call in a
mobile phone, or a buffer in the system ﬁlling up beyond a
certain level.

Modeling and analyzing such systems have therefore been
a topic of great interest within the real-time and embedded
systems community. Here, the main challenge is to compose
timing/performance analysis results from individual modes in
order to derive the properties of the overall system. In order to
simplify this problem, often some restrictive assumptions are
made. For example, in the time-triggered language Giotto [1],
it is required that tasks which are interrupted by mode switches
should have the same activation rates in both the source as well

as the target modes. A result of this restriction is that timing
constraints of the overall system are guaranteed if the system
is feasible while operating in the individual modes. Hence,
it is sufﬁcient to verify feasibility of the individual modes –
which is a much easier and well-studied problem – and modes
changes need not be explicitly accounted for while performing
timing analysis.

The analysis becomes

substantially more complex if
both time- and event-triggered mode changes are allowed.
Further, if the system in question is to be described using
complex event/data models – i.e.,
those beyond classical
periodic/sporadic
event models – then modeling and
analyzing mode changes for such systems is currently a
largely unexplored problem.
Our contributions: In this paper we propose a model for
describing multi-mode systems which process multiple com-
plex/bursty event/data streams, and in which mode changes
may be both time- as well as event-triggered. A wide variety
of embedded devices have such characteristics. For example,
consider a smart-phone which can be used to play streaming
audio/video, as well as make and receive phone calls. De-
pending on the operating mode of the system – i.e., whether
an incoming call was received while a video application was
running – the priorities of the different tasks may be changed,
or certain tasks might be put to sleep or even terminated.

it

Given the burstiness in the arrival patterns of audio/video
data, as well as the high variability in their execution re-
quirements,
is often overly pessimistic to use standard
periodic/sporadic event models. Hence, mode changes in such
systems need to be modeled in conjunction with more general
event models that are better suited to capture bursty event/data
streams. Towards this, we rely on the Real-Time Calculus
(RTC) framework to describe – in a ﬂexible manner – the
arrival pattern and processing requirements of the different
streams to be processed by the system. The RTC framework
was introduced in [2], [3] and subsequently extended in a
number of other papers (e.g., see [4], [5]). It relies on a count-
based abstraction to model the timing properties of the input
streams, as well as the availability of the resources, and is
more general than classical event/service models.

The systems we study are assumed to consist of multiple
tasks which get triggered by incoming data/event streams. The
arrival patterns of these streams, as well as their processing
requirements – as mentioned above – are described using the

1052-8725/09 $26.00 © 2009 IEEE
1052-8725/09 $26.00 © 2009 IEEE
DOI 10.1109/RTSS.2009.24
DOI 10.1109/RTSS.2009.24

279
271

RTC framework (details of which follow later in the paper).
The arriving streams (which are waiting to be processed)
are stored in input buffers and processed streams in output
buffers that are read out by output devices. Each mode in the
system is deﬁned by the set of active tasks, the arrival rates of
the streams triggering these tasks, and the scheduling policy
according to which these tasks are served. Mode changes,
as already mentioned, can be both time- as well as event-
triggered. For example, certain tasks are activated after pre-
deﬁned time periods, while the task priorities might change
(hence a mode change) depending on the ﬁll-levels of the
different buffers in the system. In this setting, we ask questions
of the form: what is the maximum ﬁll level of a given buffer,
what is the delay suffered by an individual stream, what is the
delay suffered by a stream in a particular mode, etc.

While such questions have been answered before within
the RTC framework (e.g., see [2]) for unimodal systems, the
known techniques do not extend to the case of multi-mode
systems. The main novelty of the analysis techniques that
we propose in this paper lies in how we piece together the
results from individual modes to derive timing/performance
properties of the entire system. Towards this we combine
analysis techniques from the RTC framework with state-space
exploration methods that are used to analyze state-based
models such as timed automata. Besides computing delay
and buffer ﬁll-level metrics exactly – which turn out
to
be computationally expensive – we also propose safe
approximations of these metrics in out setting. Finally, we
illustrate our model and analysis techniques using a realistic
smart-phone case study, where we show that explicitly
modeling the multiple modes (rather than approximating the
system behavior as a unimodal system) results in tighter
estimates of the different performance metrics.
Related work: There has been a number of previous attempts
to extend models and timing analysis techniques from the
real-time systems literature to accommodate more complex
behaviors. For example, the framework presented in [6] allows
certain tasks to intentionally change their execution periods,
which is a type of mode change. The associated scheduling
technique then adapts the periods of the other tasks within
allowable limits in order to maintain a schedulable system.
Similarly, the model proposed in [7] allows a system to be in
multiple modes, where each mode consists of a set of tasks
possibly overlapping with other modes. The system uses Rate
Monotonic scheduling for all the modes. The problem is then
to select suitable parameters for all the tasks, such that the
system is schedulable in all modes.

Different mode change protocols have been studied in [8],
[9] and have been classiﬁed in [10]. Here, again, a system
consists of multiple modes, where each mode consists of a
set of tasks. A mode change is triggered by a mode change
request (MCR), and transitions from an old to a new mode
take non-zero time. During this transition, the system has tasks
from both the old and the new modes, which might produce
a temporal overload. However, MCRs cannot arrive during a
transition period. The goal is to develop techniques that ensure

that no deadlines are violated during the transition periods.
Such techniques consist of suitable mode change protocols
(e.g.,
to restrict mode changes only at pre-speciﬁed time
instants, or allow only synchronous mode changes), as well
as analysis techniques to verify the feasibility of the system in
the different modes and during the transition periods.

In contrast to the above approaches, we make the simplistic
assumption of instantaneous mode changes. However, we have
a richer model for specifying task activation patterns at the
different modes (using the RTC framework). Moreover, –
unlike the above studies – we also accommodate mixed time-
and event-triggered mode changes and our analysis seamlessly
handles both. While mixed time- and event-triggered embed-
ded systems have been studied in the past (see, e.g., [11] and
[12]) they have either been in the context of bus protocols
like FlexRay or in the context of synchronous programming
languages (integrating urgent events that require preemption in
a synchronous programming environment). We, on the other
hand, focus on timing and performance analysis of multi-
mode systems where mode changes can be time- and event-
triggered (rather than formulating the mode change protocols
themselves).

Finally,

it may be noted that we recently proposed a
multi-mode extension to the RTC framework [13], which is a
different model compared to what we study in this paper. In
multi-mode RTC, arrival patterns of streams and availability
patterns of resources are modeled as automata, whose states
are annotated with functions denoting arrival/service rates.
The arrival and service automata in [13] aim at modeling
(independently) complex arrival patterns of event streams
and resource availability patterns; however,
they follow a
relatively simple processing semantics. Here, we are interested
in the system as a whole, thereby having a single model for
the system does not only reduce the analysis complexity but
also provides a better intuition to the system’s behavior. The
concept of “mode” in this current paper is a more natural one,
viz. operating modes of a system. While the arrival/service
patterns considered here are simpler than the ones studied in
[13], we allow a richer processing semantics with different
tasks and scheduling policies explicitly captured and adapted
to the dynamic characteristics of event streams and resources.

Organization of the paper: In the next section we describe
our model, followed by our analysis techniques in Sections III
and IV. Finally, we present a smart-phone case study in Sec-
tion V and conclude with a discussion on possible extensions
of this work. Due to space restrictions, the proofs for all
lemmas may be found in [14].

II. THE SYSTEM DESCRIPTIONS

A. Basic models

The system consists of a ﬁnite set of tasks T = {T1, . . . , Tn}
that are mapped on the same processor, where n ∈ N, n ≥ 1.
Each task Ti processes an input data stream si, item by item,
in a ﬁrst-come ﬁrst-served basis. Upon arriving at the system,
incoming data items from si are stored at an input buffer Bi
before being processed by Ti, and the processed data items

280272

are then written to an output buffer B(cid:4)
i. Fig. 1(a) shows a
system consisting of three tasks T = {T1, T2, T3}, with each
Ti associated with an input buffer Bi and an output buffer B(cid:4)
i.
The backlog (ﬁll-level) of a buffer Bi at time t, denoted by
Bi(t), is the number of items in the buffer at time t. We shall
refer to Bi as the name of the buffer as well as the variable
whose value gives the current ﬁll-level of the buffer.

(a).  A task set   

     (b).  The corresponding TET automaton

s1

s2

s3

d1, e1
T1

d2, e2
T2

d3, e3
T3

B1

B2

B3

′
B1

′
B2

′
B3

τ1 = {T1, T2} 

M1
[5, 20]

b

B2 ≥ 5 

b

a

M2
[9, 30]

τ2 = {T2} 

M3
[10, ∞]
τ3 = {T2, T3} 

B2 ≤ 15  ∧  B3  ≤ 2

M1  = 〈β1, τ1 , TDMA, 5, {(α11, 3), (α12, 2)}〉 
M2  = 〈β2, τ2 , - , 0, {(α22, 1)}〉 
M3  = 〈β3, τ3 , FP, 0, {(α32, 2), (α33, 1)}〉 

Fig. 1: Example of a task set and its TET automaton.

Task models. We assume a data-driven dispatch model
for the tasks, where an instance of a task is immediately
triggered when a data item arrives at the corresponding input
buffer. Each task Ti ∈ T has a ﬁxed relative deadline of
time units and a ﬁxed maximum execution demand of
di
ei processor cycles. In Fig. 1(a), di and ei are the relative
deadline and execution demand of Ti, respectively, ∀ 1 ≤ i ≤ 3.
Data streams modeled as arrival functions. An arrival
pattern of a data stream is speciﬁed as a cumulative function
A(t) which gives the number of items arrived in the interval
[0,t) The set of all arrival patterns of a stream is captured
by an arrival function α = (αu,αl), where αu(Δ) and αl(Δ)
specify the maximum and minimum number of data items that
can arrive from the stream in any time interval of length Δ. In
other words, A(t) is an arrival pattern of a data stream modeled
by α (or simply, of α) iff

αl(Δ) ≤ A(Δ + t) − A(t) ≤ αu(Δ), ∀Δ, t ≥ 0.

Resource availability modeled as service functions. A
service pattern of the processor is captured by a cumulative
function C(t), with C(t) denoting the number of processor
cycles available in the time interval [0,t). The set of all service
patterns of the processor is modeled by a service function
β = (βu,βl), where βu(Δ) and βl(Δ) give the maximum and
minimum number of processor cycles available in any time
interval of length Δ. Thus, C(t) is a service pattern of β iff

βl(Δ) ≤ C(Δ + t) − C(t) ≤ βu(Δ), ∀Δ, t ≥ 0.

Execution semantics modeled as TET automata. The ex-
ecution semantics of a system is described by a multi-mode
mixed time- and event-triggered (TET) automaton. A TET au-
tomaton is a ﬁnite automaton whose states represent different
operating modes of the system and transitions represent mode
changes. Each mode (state) of the automaton is of the form
(cid:2)
β,τ, SP, c,

, which comprises

(αi, ci) | Ti ∈ τ

(cid:4)(cid:5)

(cid:3)

• a service function β that bounds the total resource avail-

able when the system is in this mode;

• a set of tasks τ ⊆ T that are executed at the mode;
• a scheduling policy SP that is used to schedule the tasks
in τ. When τ contains only one task and SP is Fixed
Priority, we omit SP since the system allocates all its
available resource to this task.

• a length c for each TDMA cycle when SP = TDMA,

where c ≥

Ti∈τ ci (and if SP (cid:8)= TDMA, c is unused);

• a pair (αi, ci) for each Ti ∈ τ, where αi is the arrival
function of the input stream si and ci denotes either (i)
the length of the slot allocated to Ti in each TDMA cycle
if SP = TDMA, or (ii) the priority of Ti if SP = FP.

(cid:6)

Note that the speciﬁcation of the scheduling parameters in a
mode can be adapted to the scheduling policy used. In our
model, arrival and service functions remain constant when the
system is in a mode. However, when the system moves to a
new mode, they are reset to the new values associated with the
new mode. Before formally deﬁning TET automata, we ﬁrst
state some relevant notations:

(cid:3)

[a1, a2] | 0 ≤ a1 ≤ a2 ∧ a1, a2 ∈ N

• INT =
• ΦB: the set of all buffer guards ϕ of the form
ϕ = a1 ≤ Bi ≤ a2 | Bi ≥ a1 | ϕ1 ∧ϕ2

(cid:4)
.

where Bi ∈ B, [a1, a2] ∈ INT, and ϕ1,ϕ2 ∈ ΦB. Since Bi
only takes integer values, a1 ≤ Bi ≤ a2 and Bi ∈ [a1, a2]
are equivalent and thus used interchangeably.

• ϕi: the guard on the buffer Bi that appears in ϕ.
• ϕmax

i
contains no guards of the form a1 ≤ Bi ≤ a2, ϕmax

: the maximum value of Bi that satisﬁes ϕ. (If ϕi
= ∞).

i

• ϕmax = {ϕmax

, . . . ,ϕmax

}.

n

1

(cid:3)

(cid:4)

T1, . . . , Tn

Deﬁnition 1 (TET Automata). Given a ﬁnite set of tasks
T =
and its associated sets of input streams
S = {s1, . . . , sn}, input buffers B = {B1, . . . , Bn}, and output
buffers B(cid:4) = {B(cid:4)
}. The multi-mode TET automaton that
1
executes T is a tuple A = (M, Min, Inv, Σ, R) where

, . . . , B(cid:4)
n

(cid:3)

(cid:4)(cid:5)

(cid:2)
βj,τj, SP j, c j,

• M = {M1, . . . , Mm} is the set of modes, with M j =

, τj ⊆ T , j = 1, m.

(αj,i, c j,i) | Ti ∈ τj
• Min ∈ M is the initial mode of A.
• Inv : M → INT is the mode invariant function, where
Inv(M j) = [L j,U j] speciﬁes the interval during which A
can stay at M j (i.e., it must stay at M j
for at least
L j and for no more than U j time units). After U j time
units staying at M j, the automaton must take an enabled
transition to another mode, or it will go to deadlock.

• Σ is the set of signals that trigger the mode changes,

which can be controlled by an external controller.

• R ⊆ M× Σ× ΦB × N×M is the transition relation. Each
transition in R is of the form (M, a,ϕ, D, M(cid:4)) where (i)
M is an origin mode and M(cid:4) is a destination mode, (ii)
a is an external signal that triggers the transition, (iii)
ϕ is a guard on the ﬁll-levels of the input buffers, which
must be satisﬁed for the transition to be enabled, and (iv)
D ∈ Inv(M) is the time at which the transition is enabled
(relative to the instant the automaton enters M).

281273

We assume that if there are more than one enabled out-going
transitions from a mode at the same time, the automaton non-
deterministically selects one. All transitions are not urgent,
unless otherwise speciﬁed. When there is a transition that is
enabled, we say there is a mode change request.

As an example, Fig. 1(b) sketches a TET automaton cor-
responding to the task set given in Fig. 1(a). In the ﬁgure, a
and b denote the external signals that trigger the transitions
of the automaton. Table I details the service function, the
scheduling policy, the active tasks and their corresponding
arrival functions in each mode of the automaton.

Mode M2

Mode M3

Mode M1

β1

TDMA

α1,1 slot = 3
α1,2 slot = 2

β2
-

α2,2

Service

Scheduling

T1
T2
T3

β3
FP

α3,2 prio = 2
α3,3 prio = 1

TABLE I: Mode characteristics for the system in Fig. 1.

Mode change semantics. At the instant when there is a mode
change request, the processor may be executing some task.
There may also be pending data items in the input buffers
which are waiting to be processed. In general, there are various
ways how a system could response. In this paper, we assume
that when there is a mode change request to a new mode M j:

1) The automaton enters M j instantaneously.
2) The arrival functions of the input streams, the service
function of the resource, and the scheduling policy are
reset (to the ones associated with M j) immediately.

3) New items of the streams processed by the tasks in τj
can arrive immediately after mode switching and their
arrival patterns follow the updated arrival functions.

4) The system will continue executing the unﬁnished task
(if any) before scheduling the tasks in τj. Note that this
unﬁnished task may or may not appear in τj.

5) All pending data items in the input buffer of a task Tk /∈
τj will be delayed until the system moves to a mode that
contains Tk.

6) No new data items arrive from the data streams that are

not processed by τj.

The rationale behind the above assumptions is that in a
streaming environment, the currently processed streams are
often paused as the system services more critical tasks and
resumed at some point later. It is hence important to maintain
the buffer state when the system moves to a new mode.
Further, our protocols are more general than the ones where
all pending data of a task in the old mode but not in the
new mode will also be processed. This can be achieved in
our model by including the task into the new mode while
setting its arrival function to be zero. Protocols where there
is some delay D between the arrival of a new task can
also be represented in our model by adding an intermediate
mode between the two modes and associating with it the
same set of tasks as that of the old mode besides a delay D
on the transition from this intermediate mode to the new mode.
Analysis problems. Given a system Sys = (cid:11)T , B, B(cid:4), S, A(cid:12). We
would like to compute:

P1 The maximum backlog of a buffer Bi ∈ B.
P2 The maximum delay experienced by a stream si ∈ S.
P3 The maximum delay of any data item arriving at a mode.
Schedulabiliy of a task set can be derived from the computed
maximum delays, i.e., Ti meets its deadline iff the maximum
delay of si is always less than or equal to di.

In this paper, we consider speciﬁcally Fixed Priority (FP)
and Time Division Multiple Access (TDMA); however, the
same technique can be applied to other scheduling policies.
The main difference would be in the computation of the
execution demand at each node with respect to the chosen
scheduling policy. The details of FP and TDMA scheduling
are explained in [14].

III. EXACT TIMING ANALYSIS

We ﬁrst deﬁne the concept of execution traces of A. Observe
that when the automaton is in a mode, each stream arrives at a
different rate which is controlled by the corresponding arrival
function. We call A = (A1, . . . , An) an arrival pattern of a mode
M =
iff Ai is an arrival pattern
of αi if Ti ∈ τ, and Ai = 0, otherwise. Since there is only one
service function associated with M, C is a service pattern of
mode M iff it is a service pattern of β.

(cid:7)
β,τ, SP, c,

(αi, ci) | Ti ∈ τ

(cid:4)(cid:8)

(cid:3)

(cid:10)

(cid:3)

Deﬁnition 2 (Buffer Mapping). A buffer mapping function Buf
of A is a function that computes the ﬁll-levels of the buffers
at time t + Δ based on the ﬁll-levels of the buffers at time t
when the system stays put at a mode. Speciﬁcally, deﬁne Bi(t)
to be the ﬁll-level of Bi after t time units the automaton spent
at M ∈ M. Denote B(t) =
. Suppose A is
an arrival pattern of M, C is a service pattern of M, and
t + Δ ∈ Inv(M j). Then, B(t + Δ) def= Buf

(cid:9)
B(t), A,C, SP, Δ,t

(cid:4)
B1(t), . . . , Bn(t)

(cid:9)
B(0), A,C, SP, Δ, 0

When t = 0, B(Δ) = Buf
(cid:9)
B(0), A,C, SP, Δ

(cid:10)
, or simply
(cid:10)
Buf
. The function Buf varies with the
scheduling policy SP, however, it
is always deterministic.
Given below are Buf function for FP and TDMA scheduling.
def= (b1, · · · , bn) such that bi =
∀1 ≤ i ≤ n where,
˜o
.

• Buf
max
pi = C(t + Δ) −C(t) −

(cid:9)
B(t), A,C, FP, Δ,t
n
0, Ai(t + Δ) − Ai(t) + Bi(t) −
n
ˆ
ek.
def= (b(cid:4)
1
(cid:12)

ck<ci
(cid:9)
(cid:10)
B(0), A,C, TDMA, Δ

• Buf

) where

Ak(t + Δ) − Ak(t) + Bk(t)
, · · · , b(cid:4)
n
(cid:13)(cid:14)
p(cid:4)
i
ei

= max

(cid:11)
0, Ai(Δ) + Bi(0) −
(cid:12)
Δ
= C(ci).
c

+ C

(cid:12)
ci, Δ − c.

min

(cid:16)

Δ
c

(cid:14)(cid:17)

ko

P

ck

−

pi
ei

(cid:11)

(cid:15)

(cid:13)

(cid:13)

b

p

(cid:10)

j

(cid:4)
i

(cid:4)
i

χk

<χi

assuming χk is the index of slot ck in a TDMA cycle.

Deﬁnition 3 (Mode Execution). A tuple (A,C, B, Δ) is an
execution of a mode M =

(cid:7)
β,τ, SP, c,

(αi, ci) | Ti ∈ τ

(cid:4)(cid:8)

iff

(cid:3)

• A is an arrival pattern of M,
• C is a service pattern of M,
• B(x) = Buf (B(0), A,C, SP, x) for all 0 ≤ x ≤ Δ, and
• Δ ∈ Inv(M).

282274

Deﬁnition 4 (TET Execution). A sequence
(cid:2)
→ · · ·
Mkh

(cid:2)
Mk2
is an execution trace of A iff Mk1

(cid:2)
Mk1

tr =

, tr1

, tr2

→

(cid:5)

(cid:5)

(cid:5)

, trh

≡ Min and for all 1 ≤ j ≤ h:

∈ M,

• Mk j
• tr j = (A j,C j, B j, Δ j) is an execution of Mk j ,
• (Mk j
• B j(Δ j) satisﬁes ϕj and B j(Δ j) = B j+1(0).

, a,ϕj, Mk j+1

) ∈ R for some a ∈ Σ and ϕj ∈ ΦB,

Maximum backlog analysis. To analyze the maximum back-
logs of the buffers, we construct an underlying behavioral
automaton of A, denoted by Beh(A). Beh(A) is a state machine
whose states are conﬁgurations of the form (M, b, A,C,t),
where M is a mode of A, b is a vector of n integers denoting
the ﬁll-levels of the buffers in B after t time units the system
staying put at M j, A is an arrival pattern and C is a service
pattern of M deﬁned to time t, and t ∈ Inv(M). The initial
state is the conﬁguration (Min, bin, Ain,Cin, 0), where Min is the
initial mode of A and bin, Ain, Cin are all zero functions.

There is a transition from (M, b, A,C,t) to (M(cid:4), b(cid:4), A(cid:4),C(cid:4),t(cid:4))

if one of the following holds.

• M(cid:4) = M, t(cid:4) = t + 1, A(cid:4)(Δ) = A(Δ) and C(cid:4)(Δ) = C(Δ) for
all 0 ≤ Δ ≤ t, and b(cid:4) = Buf (b, A,C, SP, 1,t) where SP is
the scheduling policy of M.

• M(cid:4) (cid:8)= M, b(cid:4) = b, A(cid:4)
i

(0) = 0 for all 1 ≤ i ≤ n, C(cid:4)(0) = 0,
t(cid:4) = 0 and there is a transition (M, a,ϕ, M(cid:4)) in A such
that (i) b satisﬁes ϕ or ϕ = /0, and (ii) t = D if there is a
time D associated with the transition.

From the reachable states of Beh(A), we can derive the exact
maximum backlogs of the buffers. Speciﬁcally, the maximum
backlog of Bi is the maximum value of bi(t) for all reachable
states (M, b, A,C,t) in Beh(A).
Maximum delay analysis. The maximum delay experienced
by a stream can be done similarly by introducing additional
variables into the behavioral automaton of the system. These
variables are used to keep track of the waiting time of the
data items.

Discussions. Observe that if there is no upper bound on the
invariant of a mode, A may stay put at at a mode forever (i.e.,
the value of t in each conﬁguration of Beh(A) is not bounded).
As a result, the behavioral automaton of A may potentially be
inﬁnite. To address this, we construct a regional automaton of
A, denoted as Reg(A), which is a time abstract representation
of Beh(A). Each state of Reg(A) corresponds to a set of
reachable conﬁgurations of Beh(A) that have the same TET
mode and the same values of buffer ﬁll-level (i.e., the b vector).
There is a transition from a state (M, b) to a state (M(cid:4), b(cid:4)) in
Reg(A) if there is a transition from a state (M, b, A,C,t) to
a state (M(cid:4), b(cid:4), A(cid:4),C(cid:4),t(cid:4)) in Beh(A). The analysis can then be
done based on Reg(A).

Although the size of Reg(A) is signiﬁcantly smaller than
that of Beh(A),
it might still be inﬁnite since the values
of the buffer ﬁll-level at the state may not be bounded. To
allow feasible computation of Reg(A), we assume that there
is an upper bound N on the size of the buffers. The size

of the Reg(A) automaton will then be O(Nn (cid:14)M(cid:14)). More
efﬁcient abstraction approach such as the zone automata used
in rectangular hybrid automata can be applied. However, we
still require a known upper bound on the size of the buffers
for the automaton to be ﬁnite.

IV. APPROXIMATE TIMING ANALYSIS

The analysis approach presented in the previous section,
though being exact, can be computationally expensive as the
size of the region automaton is exponential in the size of
the buffer and the number of tasks. Further, it is only ﬁnite
assuming an upper bound on the size of the buffer, which must
be speciﬁed a priori. The exact method can verify if a buffer
ﬁll-level exceeds the speciﬁed maximum size, however in the
case the ﬁll-level of the buffer is unbounded, the analysis goes
on forever in searching for the largest backlog value.

In general, there could be scenarios where the maximum
backlog of a buffer is unbounded – in which case the system
is said to be unstable. While stability is often assumed for
single-mode systems, the same might not hold for the case of
multi-mode systems, unless being veriﬁed. As a result of mode
switching, the backlog of a buffer can get accumulated when
executing along a sequence of modes. If the system does not
have enough resource to clear the backlog and/or does not put
any constraint on when the mode switching can take place,
this backlog may potentially become inﬁnite. As a result, we
cannot simply assume that the system is stable. In fact, it is
important for the analysis to be able to detect the instability
of the system quickly and provide diagnosis feedbacks for the
system designer to improve the system.

The above observations have motivated us to develop
an alternative method that is much more efﬁcient, capable
of identifying system instability as well as computing safe
estimations on the system performance properties.

Overview of TET approximate analysis: The key idea of
TET approximate analysis is that – instead of enumerating
all possible values of the buffer backlog during execution as
done in the exact method – we keep track of only the execution
paths that lead to the maximum backlogs of the buffers and
the maximum backlog values at each mode along the paths.
While the exploration of the path is based on the structure
of the input TET automaton A, the maximum backlog of a
buffer at each mode in an explored path is “computed” directly
from the arrival and service functions of the mode using RTC
technique, without having to consider every TET execution to
search for the value. This exploration results in an abstract
tree G = (V, E) which captures all execution traces in A that
will lead to a maximum buffer backlog. G can be viewed as an
abstraction of the region automaton used in the exact method,
and it is used to compute the timing properties of the system.
In the two coming sections, we detail the construction of
G. Section IV-C and IV-D show how maximum backlog and
maximum delay can be computed based on G. It is worth
noting that, since the RTC method is not tight in general, the
method presented here is inherently an approximate analysis.

283275

A. The key idea and basic results for the construction of G

G is formed by a set of nodes V and a set of edges
E. Each node v ∈ V consists of a mode M ∈ M and a
tuple inB = (inB1, . . . , inBn) where inBi speciﬁes the maximum
initial backlog of Bi when the system enters v. In addition, v
is associated with an n-tuple BLv where BLv,i is the maximum
backlog of Bi when the system is at v. Each edge e ∈ E from a
node v = (M, inB) to a node u = (M(cid:4), inB(cid:4)) is associated with
a tuple κ = (κ1, . . . ,κn) where
• κi = 1 if the value of inB(cid:4)

i is always upper bounded by the
buffer guard associated with the transition from M to M(cid:4)
in A, or by the values of the arrival and service functions
associated with M;
• κi = 0, otherwise.

The attributes associated with a node and a transition of G are
summarized in Fig. 2.

κ

BLv

M
 inB 

  node v 

BLu

M′
 inB′ 
  node u

inB  =  ( inB1, … , inBn ) 
BLv =  ( BLv,1 , … , BLv,n )
κ     =  ( κ1 , … , κn )  

inBi     =     maximum initial backlog of Bi  when the system enters M
BLv,i   =     maximum backlog of Bi  when the system stays put at M
κi  =  1,   if  inBi′ is always bounded due to the buffer guard associated with 
      transition M →M’  or values of the arrival and service functions at M.
 
κi  =  0,   otherwise.

Fig. 2: Attributes of a node and a transition in G.

(cid:2)
M, inB

Fig. 3 gives an overview on the construction of G. As high-
lighted in the ﬁgure (by the pointing ﬁngers), at each reachable
(cid:5)
node v =
, we need to compute BLv. Further, for
each mode M(cid:4) reachable from M (by taking an enabled out-
going transition), we need to compute the maximum initial
backlogs when the system enters M(cid:4). Below we describe
the computation of these attributes, which will serve as the
building blocks for the construction of G detailed in the next
section.

Suppose M =

(αi, ci) | Ti ∈ τ

. To obtain
the maximum buffer backlogs at M and the maximum initial
backlogs upon entering M, we compute:
(S1) The service function βi of the resource allocated to each
task Ti ∈ τ based on β, SP, αi, and the initial maximum
buffer backlogs when A enters M.

(cid:7)
β,τ, SP, c,

(cid:4)(cid:8)

(S2) The maximum buffer backlogs when A stays put at M.

(cid:3)

based on βi and Inv(M).

(S3) The maximum buffer backlogs when A moves to M(cid:4),
for every transition from M to M(cid:4) in A that is enabled.
Computing (S1). The service function βi
that bounds the
portion of resource given to stream si when the system is at M
is given by a function called Serv. Typically, Serv is deﬁned
based on β, αi, SP, and the execution demand dfi of Bi (i.e.,
the number of processor cycles required to process the data
items currently in Bi).

Deﬁnition 5. Suppose dfi is execution demand of Bi when
the system enters M and let df = (df1
). The service

, . . . , dfn

TET Automaton

 Add  〈Min, 0〉 into G and unVisited

M

 

 
 
t
a
n
o
i
t
a
t
u
p
m
o
C

 

M
m
o
r
f
 
’

 

 

M
e
d
o
m
e
l
b
a
h
c
a
e
r
 
a
 
t
a
n
o
i
t
a
t
u
p
m
o
C

 

unVisited  = ∅

YES

Finite Tree
G = (V,E)

Take a node v = 〈M, inB〉 from unVisited

Remove all 〈M, inB’〉 with inB’ ≤ inB from unVisited  

  Compute maximum backlogs BLv at v 

(S1, S2)

NO

∃ (M, ϕ, M’ ) :  BLv satisfies ϕ 

NO

YES

Compute maximum initial backlog inB’ of M’

 (S3)

∃〈M’ , inB‘’〉∈G:  

inB’ ≤ inB’’ 

NO

YES

Add u =  〈M’ , inB‘ 〉 into unVisited and G

Find an infinite backlog cycle containing u 

NOT 
FOUND

FOUND

SYSTEM UNSTABLE

Fig. 3: Overview on the construction of G.

function of the resource allocated to each task Ti ∈ τ when
the system is at M is given by Serv(i, df,α,β, SP).

Lemma IV.1 and IV.2 deﬁne Serv for FP and TDMA. The

proofs for the lemmas are available in [14].
Lemma IV.1. Let df = (df1
) with dfi denoting the
execution demand of Bi when the system enters M. Let τi ⊆ τ
be the set of tasks in τ that have higher priority than Ti, i.e.,

, . . . , dfn

(cid:3)

τi =

Tk ∈ τ | ck < ci

(cid:4)

.

The lower service function that bounds the amount of resource
allocated to a task Ti ∈ τ when SP = FP is given by
(cid:4)(cid:17)

(cid:16)

(cid:15)
βl −

(cid:3)
dfk

+ ekαu
k

+

Serv(i, df,α,β, FP) def=

∈τi

Tk

where f+(x) = max{ f (x), 0} for all f : N → N and x ≥ 0.

When SP is TDMA, in each TDMA cycle, Ti may not be
allocated resource during a time interval of length Δ = c − ci,
however it is granted full access to the resource during a time

284276

interval of length ci. As a result, one can compute the service
function of the resource given to Ti using Lemma IV.2 below.

Lemma IV.2. The lower service function that bounds the
amount of resource allocated to a task Ti ∈ τ when SP =
TDMA is given by Serv(i, df,α,β, TDMA) def= βi where

(Δ) = max

βi

(cid:11)(cid:12)

(cid:13)

Δ
c

(cid:9)
ci

(cid:10)
, βl(Δ) −

.βl

(cid:18)

(cid:19)

Δ
c

(cid:10)(cid:14)

(cid:9)
c − ci

.βl

∀ Δ ≥ 0.

Computing (S2). Since the execution demand of Ti is ei, the
following corollary holds.
, . . . , d fv,n) with dfv,i denoting
Corollary IV.3. Let dfv
the maximum execution demand of Bi when the system enters
v. Then, dfv,i

= ei.inBi for all 1 ≤ i ≤ n.

= (dfv,1

Lemma IV.4. Denote [L,U] = Inv(M). The maximum backlog
of Bi when the system stays put at M is given by

(cid:3)
(cid:4)
αi(Δ) −βi(Δ)

, if Ti ∈ τ

BLv,i

def=

(cid:20)

inBi + max
0≤Δ≤U
inBi, otherwise.

(cid:21)
Serv(i, dfv

(cid:22)
.

,α,β, SP)/ei

[L,U] = Inv(M) ∩ [D,U]

where βi =
Computing (S3). Suppose r = (M, a,ϕ, M(cid:4)) is a transition
in A. Let
if there is a time D
associated with r, and [L,U] = Inv(M) otherwise. In other
words, [L,U] is the interval during r can be taken. Recall that
βi =
is the maximum value
of Bi that satisﬁes ϕ.

Serv(i, dfv,α,β, SP)/ei

and ϕmax

(cid:21)

(cid:22)

i

Lemma IV.5. The maximum backlog of Bi when the system
enters M(cid:4) by taking the transition r is given by
(cid:4)
(cid:3)
inBL(v,ϕ, i) = min
outBLv,i, ϕmax

⎧
⎨

i

(cid:3)
(cid:4)
αi(Δ) −βi(Δ)

(cid:3)
(cid:4)
αi(Δ) −βi(Δ)

where:

outBLv,i

max
0≤Δ<L
inBi + max
L≤Δ≤U
if Ti ∈ τj, and outBLv,i = inBi otherwise.

def= max

⎩

B. Construction of the abstract tree G

(cid:5)

(cid:5)

(cid:2)
M, inB
(cid:2)
M, inB(cid:4)

This section gives a detailed description to the tree con-
struction in Fig. 3. We start with the root of the tree vin =
(cid:2)
Min, inBin
where Min is the initial mode of A and inBin is
an n-tuple of zeros (since buffers are initially empty). We add
vin into V and into the set of unvisited nodes termed unVisited.
Both V and unVisited are empty initially.

Let v =
be a node in unVisited . We ﬁrst remove all
(cid:5)
nodes v(cid:4) =
in unVisited such that inB ≥ inB(cid:4). This
is because corresponding to each path ρ from v to a node w,
(cid:4) from v(cid:4) to a node w(cid:4) passing through the
there is a path ρ
same sequence of modes as that of ρ and the maximum initial
backlogs when the system enters w is larger than or equal to
the maximum initial backlogs when the system enters w(cid:4). In
other words, BLw ≥ BLw(cid:4). As we are computing the maximum
backlog, it is sufﬁcient to consider only paths starting from v.
We next compute the maximum backlogs BLv when the
system is at M using Lemma IV.4. Suppose r = (M, a,ϕ, M(cid:4))

is a transition in A such that BLv satisﬁes ϕ. Then, r is enabled
and the maximum backlog of Bi when the system enters M(cid:4) is
given by inB(cid:4)
= inBL(v,ϕ, i) ( Lemma IV.5). We create a new
i
node u =

(cid:2)
M(cid:4), inB(cid:4)

Case 1: If there is a node w =

in G such that
inB(cid:4)(cid:4) ≥ inB(cid:4), there is no need to explore u. Hence, we delete
u and continue with the next transition from M.

(cid:2)
M(cid:4), inB(cid:4)(cid:4)

(cid:5)

(cid:5)

.

Case 2: If no such node w exists, we add u into V and a
new edge (v,κ, u) into E. Here, κi = 0 if ϕmax
is inﬁnite and
(cid:3)
(cid:4)
αi(x) −βi(x)

i

(cid:4)
inB
i

= inBi + max
L≤x≤U

where βi is the service function of the resource given to si, and
[L,U] is the interval during which r can be taken (as computed
in Section IV-A). Otherwise, κi = 1.

If there is an edge (u0, u1) in the path from the root to v
such that u0 contains M and u1 contains M(cid:4), we will check if
this path contains a zero cycle that leads to an inﬁnite buffer
κ2→ u2
κ1→ u1
κ3→ · · · κh→ uh be
backlog. Speciﬁcally, let ρ = u0
(cid:2)
the path from u0 to u in G with uk =
≡ M,
M jk
≡ M(cid:4), v ≡ uh−1 and u ≡ uh. Note that, there exists 1 ≤ i ≤ n
M j1
such that inBh
i (otherwise, u has been deleted earlier
i
in Case 1). There are two cases:

(cid:5)
, M j0

> inB1

, inBk

i If for all i such that inBh
i

= 1 for
some 1 ≤ k ≤ h, then the ﬁll-level of Bi is always upper
bounded. We mark u as a bounded node.

i , there exists κk
i

> inB1

ii Otherwise, there is an i where κk
i

= 0, ∀1 ≤ k ≤ h. We
claim that the maximum backlog of Bi will be inﬁnite if
we repeats ρ for an inﬁnite number of times [14]. Hence,
we report an inﬁnite buffer backlog at Bi, return the path
from the root of G to u, and terminate the construction.
We add u into the set unVisited and continue with the next
transition from v until all the transitions are explored. We then
continue with the next node in unVisited set until it is empty.
Lemma IV.6. The construction of G is decidable.

= 1 if ϕmax

For each mode M that appears in a cycle in A and
τ = (M(cid:4),ϕ, M) is an incoming transition from M, let Xτ
=
i
maxL≤x≤U {αi(x) − βi(x)}, where βi is the service allocated
to Ti assuming zero initial buffer backlogs for the buffers,
and [L,U] is the interval during which τ can be taken. Deﬁne
= ∞ and ϕmax
Kτ
i , otherwise. Further, let Ki
i
be the maximum value of Kτ
i for all incoming transition τ of
M. From the construction, we imply that Ki is the maximum
number of values for the initial maximum backlog of Bi when
A enters M. Thus, the number of times M appears in a node
(cid:26)
n
in G is at most K =
i=1 Ki. As a result, the size of the tree
G is O(K(cid:14)M(cid:14)). Since the number of modes in the automaton
is relatively small, the algorithm is highly scalable.

/Xτ

i

i

C. Computing maximum backlog

The maximum backlog of the buffer Bi at a mode M j is the

maximum value of BLv,i for all v ∈ V that contain M j:
∧ inB ∈ Nn

(cid:3)
BL(Bi, M j) = max
BLv,i | v =
v∈V

(cid:2)
M j, inB

(cid:5)

(cid:4)

The maximum backlog of Bi experienced by the stream is:

(cid:3)
BL(Bi) = max

BL(Bi, M j) | M j ∈ M

(cid:4)

285277

D. Computing maximum delay

V. CASE STUDY

We now present our method for computing the maximum

delay of an event stream si at a mode M ∈ M. Let
(cid:5)
, tr2

tr = (cid:11)Min, trin(cid:12) → · · · →

, tr1

(cid:2)
Mk1

(cid:2)
Mk2

→

(cid:5)

→ · · ·

be an execution trace of A that results in the maximum delay
= (A j,C j, B j, Δ j)
of si at mode M, where Mk1
j ≥ 1. Suppose ev is an event/item of si which has
for all
the longest delay among all items of si that arrive when the
system is at mode M. The maximum delay of si at M is then
the delay delay(M, i) experienced by ev.

≡ M and trk j

Since we only consider systems that have ﬁnite buffer
backlogs, delay(M, i) is ﬁnite. Thus, ev will be fully processed
at some Δh time units after the system enters a mode Mkh with
1 ≤ h ≤ ∞. Denote λ as the amount of time from the instant
A enters M to the instant ev arrives. Then,

(cid:27)
(cid:27)

(cid:5)

(cid:2)
M, inB

delay(M, i) +λ = Δ1 + · · · + Δh

(1)
Further, delay(M, i) is the amount of time needed to process
the B j,i(0) items initially in the buffer Bi when the system
enters M and the data items that arrive during the λ time
units the system is at M. Since the number of items that arrive
from si and the amount of resource allocated to si in M are
independent of the data that arrive from si in previous modes,
the delay of ev is largest implies B j,i(0) equals the maximum
backlog of Bi whenever the system enters M, i.e.,

(cid:14)

(cid:11)

(cid:5)

(cid:5)

=

inBi

∈ V

, tr1

def= inBmax
M,i

→ · · · →

(cid:2)
Mkh

= inBmax

, trh
→ · · · → vkh in G with vk j

B j,i(0) = max
(cid:2)
(cid:5)
∈V
M,inB
(cid:5)
(cid:2)
∈ V be a node containing M at which
M, inB1
Let vk1
(cid:2)
inB1
M,i . Then
Mk1
corresponds
(cid:5)
(cid:2)
i
to a path π = vk1
, inB j
Mk j
for all 1 ≤ j ≤ h. Moreover, the amount of resource given
=
to si when the system is at vp is bounded by βp,i
= (dfvp,1, . . . , dfvp,n) and
Serv(i, dfvp
i for all 1 ≤ i ≤ n. Since ev is fully processed
dfvk j
after the system being at Mkh for Δh units of time, the total
execution demand of the data items that arrive before ev and
ev must be no more than the total resource given by the system
along path π in the worst case. In other words,

,αp,βp, SPp), where dfvp

,i = eiinB j

=

(cid:9)
αu

k1,i

(λ) + inB1
i

(cid:10)
ei ≤ βk1,i

(Δ1 −λ) +

βk j ,i

(Δ j)

(2)

h(cid:16)

j=2

(cid:11)

From Eqs (1) and (2), we imply that
delay(M, i) ≤ max
Mk1
→ · · · →
∧ π =

delay(π, i)
(cid:2)
, inB1
(cid:28)

(cid:27)
(cid:27)
(cid:5)

Mk1
where: delay(π, i) = max

min

≡ M ∧ inB1 = inBmax
M,i
(cid:14)
∈ G

(cid:5)

,

(cid:2)
Mkh
(cid:11) h(cid:16)

, inBh
Δ j − λ

(cid:27)
(cid:27)
(cid:27)

λ∈Inv(M)

Δ j ∈Inv(Mk j

)

(cid:9)
αu

k1,i

(λ) + inB1
i

(cid:10)
ei ≤ βk1,i

j=1
(Δ1 −λ) +

h(cid:16)

j=2

(cid:14)(cid:29)

βk j ,i

(Δ j)

The overall maximum delay experienced by a stream si is

then the maximum value of delay(M, i) for all M ∈ M.

Note that both the computations of backlog and delay are
safe approximation in that the actual maximum backlog of a
buffer and maximum delay of a stream will be less than or
equal to the computed values.

In this section we present a case study to illustrate the
applicability of TET automata in realistic multi-mode real-
time systems. In particular, we look into a smart-phone which
is equipped with advanced features such as emails, Internet
connectivity via Wi-Fi, and media multitasking. We show how
the proposed model can be used to describe such a system and
to derive various performance properties using our analysis
methods. Based on the obtained analysis results, designers are
able to tune the system design to minimize resource usage
while assuring quality of service requirements.

We assume that the system consists of ﬁve main tasks
(Table II) executing on a single processor architecture (Fig. 4).

Task

Tkernel

Tmonitor

Tupdate

Taudio
Tvideo

Functionality

Kernel threads that should be running at all time, for instance,
system clocks and I/O user inputs.
Connection monitoring activities such as telemetry and wire-
less data collection, which is activated periodically.
System updates and maintenance routines such as display
updating, which is executed periodically every Du time units.
Audio processing of voice data when users receive/make calls.
Video processing when users stream video using WiFi.

TABLE II: Different tasks of a smart-phone.

input audio stream
(incoming voice calls)

input video stream 
(via Internet)

NOTATIONS
Tasks:

telemetry 
data stream 

Ta  :  Taudio
Tv  :  Tvideo
Tm :  Tmonitor
Tu  :  Tupdate
Tk  :  Tkernel

Input buffers:

Ba , Bv , Bm ,Bu , Bk 

Output buffers:
′

′
′
Ba , Bv , Bm ,Bu , Bk 

′

′

Ta

Tv

Tm

Tu

Tk

Ba

Bv

Bm

Bu

Bk

′
Ba

′
Bv

′
Bm

′
Bu

′
Bk

APPLICATION TASKS

MULTIMODE SCHEDULER

system 
updates

kernel 
routines

Fig. 4: The system architecture of a smart-phone application.

As in many complex real-time applications,

the smart-
phone has a dynamic scheduler. It is a multi-mode system,
with each operating mode executing a different subset of
the above tasks. The processor frequency is scaled to best
match with the processing requirement of each mode. The
scheduling of the tasks active at each mode is also chosen
with respect to the tasks’ execution patterns and the overall
performance objectives. In this case study, we assume that
Fixed Priority is employed for all modes. Further, voice calls
have higher performance requirements than that of video
streaming. However, the scheduler will allocate more resources
to the video stream to take advantage of idle periods during the
call and hence there is only little voice data (e.g., background
noise). On the whole, we have seven different modes:

• Active: The system is idle and executes only Tkernel and
Tmonitor, with Tkernel having higher priority than Tmonitor.

286278

• Call: The system enters this mode when the user
makes/receives a call. Here, three tasks Tkernel, Tmonitor and
Taudio are executed, with Tkernel having highest priority
and Tmonitor having the lowest priority.

• Video: The system is in this mode when the user watches
streaming video. In this mode, three tasks Tkernel, Tmonitor
and Tvideo are executed, with Tkernel having the highest
priority and Tvideo having the lowest priority.

• Full-A: The system is in this full-on mode when the user
watches video while taking/making a phone call. Thus,
four tasks Tkernel, Tmonitor , Taudio, andTvideo get executed,
in decreasing order of priority.

• Full-V: The system enters this mode if the ﬁll-level of
the audio stream is below a certain threshold and it has
spent at least Da time units in Full-A. This happens when
there is an idle period during the conversation and the
audio trafﬁc contains mainly background noise. Hence,
we assign a higher priority to the video stream. The
system will switch back to Full-A mode if the ﬁll-level
of the audio buffer exceeds a value Ca (i.e., the end of
the idle period).

• Update: In this mode, only two tasks Tkernel and Tupdate

are executed, with Tupdate having higher priority.

• Sleep: The system enters this power saving mode if there
is no activity after a duration of Ds time units. It will
execute only Tkernel and periodically wakes up to perform
system update and returns back to sleep.

When the system is in Sleep mode, the processor runs at
the smallest frequency f0. When it is in Active mode, it runs
at the normal frequency f1. When there are computationally
expensive tasks such as audio and/or video processing, the
processor operates at the maximum frequency f2.

In designing such a system, an important question that
must be addressed is to decide how much buffer space is
required to ensure there will be no buffer overﬂows. A typical
way of doing this is to compute the maximum backlogs
of
these computed
values can then be used as the minimum buffer capacities
that need to be allocated to each task to avoid buffer overﬂows.

the different buffers in the system;

TET model of the smart-phone multi-mode system. We
now demonstrate how TET automata can easily capture the
dynamic behavior of the given multi-mode system. Based on
the resulting model, we compute the maximum backlogs of
the buffers using our proposed analysis methods. Note that
it might be possible to represent the system using a model
that has no mode modeling capability by viewing the system
as having a single mode (with the worst combination of the
properties of the original modes). However, this approach often
leads to overly pessimistic results as we will demonstrate later.
In this case study, we are speciﬁcally focus on the input buffers
of the voice and video streams (due to space restrictions).

Fig. 5 depicts the TET automaton for the smart-phone
system. For ease of presentation, the mode Update is not
shown in the automaton. There should be a transition to and
from each mode of the automaton to mode Update, as shown

TET MODEL OF THE SMARTPHONE MULTI-MODE SYSTEM

Sleep
[1, Du ]

Ds

wake-up

doneC
Ba = 0

Active
[1, Du ]

doneV
Bv = 0

video

Du

Bu = 0

Update

call

video

doneV
Bv = 0

Call
[1, Du ]

Full-A

[Da , Du ]

Video
[1, Du ]

call

doneC
Ba = 0

Ba ≥ Ca  

′
Ba ≤ Ca  

doneV
Bv = 0

Full-V
[1, Du ]

doneC
Ba = 0

τActive = {Tk ,Tm} 
τCall    = {Tk ,Tm ,Ta} 
τVideo = {Tk ,Tm ,Tv} 

τSleep = {Tk}  τUpdate = {Tu ,Tk}
τFull-A = {Tk ,Tm ,Ta ,Tv } 
τFull-V = {Tk ,Tm ,Tv ,Ta }
 

Processor frequency:   f0  <  f1  < f2 
 

f0 :  Sleep;        f1 :  Active;       f2 :   Call, Video, Full-A, Full-V 

Fig. 5: The TET model of the multimode scheduler (cf. Fig. 4).

in the dashed box. In the ﬁgure, the tasks at each mode are
listed from the highest priority to the lowest priority. Du is
the period of Tupdate, Da is the minimum duration the system
must stay at mode Full-A, and Ds is the amount of inactivity
time for the system to go to Sleep mode. In the ﬁgure, Ba and
Bu denote the input buffer of the audio (voice) stream and the
stream of update jobs, respectively. Further, Ca,C(cid:4)
∈ N are the
a
pre-speciﬁed thresholds of the buffer ﬁll-level for which the
system switches between the two full-on modes. We assume
that when the system is in the Update mode, it keeps the
same processor frequency as the previous mode it came from.1

Experimental setup and results. Since Tkernel, Tmonitor and
Tupdate are periodic tasks, their arrival functions are computed
directly from the chosen periods. We assume that the arrival
functions for these tasks remain constant for all the modes.

The input audio and video streams in general can be bursty
and hence, their arrival functions take arbitrary forms. To
obtain the arrival functions of the video stream, we use a
set of representative video clips and simulate their executions
on a customized version of the SimpleScalar instruction set
simulator [15]. From the execution traces, we measured the
execution demands of the decoding tasks for each macroblock
and derived a function A(t) which gives the number of
macroblocks arriving at the input buffer Bv during the time
interval [0,t]. This function is then used to compute the arrival
function αv(Δ) of the video input stream. The arrival function
for the audio stream is obtained in a similar fashion.

1To capture this, instead of having only one shared Update mode in the
automaton, we have one copy UpdateM for each mode M in the automaton
that is shown in Fig. 5 and set the frequency to be the same as that of M.

287279

In our experiment, the arrival function of the video stream
is chosen to be the same for both the modes Full-A and Full-
V. The arrival function of the audio stream at mode Full-V is
smaller than at mode Full-A. This is because the system will
only give higher priority to the audio stream when there is less
input data from the audio stream (to maintain a high level of
service for voice calls at all time).

(Δ) = βu
f

The service function of the system is computed based on
the frequency of the processor. We assume that the processor
does not run any other tasks besides the given task set. Hence,
(Δ) = f .Δ, where
its service function is given by βl
f
f is the frequency of the processor. In our experiment, we set
f1 = 200MHz, f2 = 400MHz, and f3 = 600MHz. The threshold
at which the system moves to mode Full-V is set to C(cid:4)
= 500.
a
For the analysis, we implemented the approximation meth-
ods outlined in Section IV. Additionally, we performed an
analysis without mode modeling using the original RTC model
where we computed the maximum backlog of the video buffer
for each mode individually and took the worst value.

VI. CONCLUDING REMARKS

We have proposed a model called TET automata and a set
of associated techniques for analyzing multi-mode systems
where mode changes are both time- and event-triggered. Our
ﬁrst approach uses automata veriﬁcation techniques that tackle
stringent cases requiring an exact timing analysis. A second
technique was developed – incorporating both Real-Time
Calculus and automata state exploration – to provide approx-
imate performance metrics for the whole system based on the
results derived from the individual modes. This combination
of techniques from two different domains produced a solution
which is more efﬁcient and at the same time is guaranteed
to give safe estimates. The applicability and beneﬁts of our
proposed model have been demonstrated in a smart-phone
multi-mode system, where mode changes are driven by both
time and ﬁll-level of various buffers in the system. It would be
interesting to explore how the TET model can be lifted to an
interface-theoretic setting to enable more efﬁcient/lightweight
compositional analysis and correct by construction design.

SINGLE MODE APPROXIMATION 

7714

This research was supported in part by AFOSR FA9550-

07-1-0216, NSF CNS-0720703, and NSF CNS-0721541.

ACKNOWLEDGMENT

REFERENCES

MULTI-MODE TET ANALYSIS

4428

4342

4257

4186

4737

4598

4513

 
t
u
p
n

 

i
 
e
h
t
 
f
o
g
o
l
k
c
a
b
m
u
m
i
x
a
M

 

]
s
m
e
t
i
[
 

m
a
e
r
t
s
o
e
d
i
v

 

4900

4700

4500

4300

4100

3900

1300

1500

1400
Buffer-fill level threshold Ca [items]

1600

1700

1800

1900

Fig. 6: The maximum of the video input buffer Bv (cf. Fig. 4).

Fig. 6 plots the resulting maximum backlog of the input
video buffer Bv for different values of Ca (see Fig. 5) using
TET model, and using the single-mode RTC approximation.
The bar graphs represent the results of TET analysis, whereas
the horizontal line represents the result from the single-mode
approximation. When comparing the TET results with the
single-mode approximation, it may be seen that explicitly
modeling the dynamic behavior of the system results in sig-
niﬁcantly tighter estimates, thereby leading to better resource
dimensioning (which, here, is the on-chip buffer memory).

Further, it may be observed that the maximum backlog of
Bv given by the TET analysis does not remain constant but
increases with Ca. Based on these computed results, one may
easily determine the amount of buffer memory that should be
provisioned for the video stream, for any chosen threshold
value of Ca. Alternatively, this information can also help the
system developer in tuning the scheduler to minimize resource
usage (e.g., by selecting the best value of Ca that minimizes the
total memory requirement of the system). Such tuning would
not be possible with the simplistic single-mode model.

[1] T. A. Henzinger, B. Horowitz, and C. M. Kirsch, “Giotto: a time-
triggered language for embedded programming,” Proceedings of the
IEEE, vol. 9, no. 1, pp. 84–99, 2003.

[2] S. Chakraborty, S. Künzli, and L. Thiele, “A general framework for
analysing system properties in platform-based embedded system de-
signs,” in DATE, 2003.

[3] L. Thiele, S. Chakraborty, M. Gries, and S. Künzli, “A framework for
evaluating design tradeoffs in packet processing architectures,” in 39th
Design Automation Conference (DAC), 2002.

[4] E. Wandeler, A. Maxiaguine, and L. Thiele, “Quantitative characteriza-
tion of event streams in analysis of hard real-time applications,” Real-
Time Systems, vol. 29, no. 2-3, pp. 205–225, 2005.

[5] E. Wandeler and L. Thiele, “Workload correlations in multi-processor
hard real-time systems,” Journal of Computer and System Sciences
(JCSS), vol. 73, no. 2, pp. 207–224, 2007.

[6] G. C. Buttazzo, G. Lipari, and L. Abeni, “Elastic task model for adaptive

rate control,” in RTSS, 1999.

[7] Y. Shin, D. Kim, and K. Choi, “Schedulability-driven performance
analysis of multiple mode embedded real-time systems,” in Design
Automation Conference (DAC), 2000.

[8] G. Fohler, “Changing operational modes in the context of pre run-time
scheduling,” IEICE Transactions on Information and Systems, vol. E76-
D, no. 11, pp. 1333–1340, 1993.

[9] L. Sha, R. Rajkumar, J. Lehoczsky, and K. Ramamritham, “Mode change
protocols for priority-driven preemptive scheduling,” Real-Time Systems,
vol. 1, no. 3, pp. 244–264, 1989.

[10] J. Real and A. Crespo, “Mode change protocols for real-time systems:
A survey and a new proposal,” Real-Time Systems, vol. 26, pp. 161–197,
2004.

[11] T. Pop, P. Eles, and Z. Peng, “Design optimization of mixed time/event-

triggered distributed embedded systems,” in CODES+ISSS, 2003.

[12] N. Scaife and P. Caspi, “Integrating model-based design and preemp-
tive scheduling in mixed time- and event-triggered systems,” in 16th
Euromicro Conference on Real-Time Systems (ECRTS), 2004.

[13] L. Phan, S. Chakraborty, and P. Thiagarajan, “A multi-mode real-time

calculus,” in RTSS, 2008.

[14] L. T. X. Phan, S. Chakraborty, and I. Lee, “Timing analysis of
mixed time/event-triggered multi-mode systems,” http://www.cis.upenn.
edu/~linhphan/papers/rtss09.pdf, 2009.

[15] T. Austin, E. Larson, and D. Ernst, “SimpleScalar: An infrastructure for
computer system modeling,” IEEE Computer, vol. 35, no. 2, pp. 59–67,
2002.

288280

