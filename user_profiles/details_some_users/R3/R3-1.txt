Ajax-based Report Pages as Incrementally Rendered

Views∗

Yupeng Fu
UC San Diego

Keith Kowalczykowski

app2you, Inc.

Kian Win Ong
UC San Diego

yupeng@cs.ucsd.edu

keith@app2you.com

kianwin@cs.ucsd.edu

Yannis Papakonstantinou

Kevin Keliang Zhao

app2you, Inc. and

UC San Diego

yannis@cs.ucsd.edu

UC San Diego

kezhao@cs.ucsd.edu

ABSTRACT
While Ajax-based programming enables faster performance
and higher interface quality over pure server-side program-
ming, it is demanding and error prone as each action that
partially updates the page requires custom, ad-hoc code.
The problem is exacerbated by distributed programming
between the browser and server, where the developer uses
JavaScript to access the page state and Java/SQL for the
database. The FORWARD framework simpliﬁes the devel-
opment of Ajax pages by treating them as rendered views,
where the developer declares a view using an extension of
SQL and page units, which map to the view and render
the data in the browser. Such a declarative approach leads
to signiﬁcantly less code, as the framework automatically
solves performance optimization problems that the devel-
oper would otherwise hand-code. Since pages are fueled
by views, FORWARD leverages years of database research
on incremental view maintenance by creating optimization
techniques appropriately extended for the needs of pages
(nesting, variability, ordering), thereby achieving performance
comparable to hand-coded JavaScript/Java applications.

Categories and Subject Descriptors
H.2.8 [Information Systems]: Database Management—
Database Applications

General Terms
Languages

Keywords
Ajax, SQL, View Maintenance
∗Supported by NSF IIS-00917379 and a Google Research
Award

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGMOD’10, June 6–11, 2010, Indianapolis, Indiana, USA.
Copyright 2010 ACM 978-1-4503-0032-2/10/06 ...$10.00.

1.

INTRODUCTION

AJAX-based web application pages became popular by
Gmail and Google Suggest in 2004. They are now a re-
quirement for professional level Web 2.0 web application
pages and a cornerstone of Software-as-a-Service applica-
tions, since they enable performance and interface quality
that are equivalent to those of desktop applications. AJAX
(Asynchronous JavaScript And XML) is a conglomerate of
technologies and programming techniques for highly inter-
active web application pages.
Its programming model for
producing web application pages diﬀers from the prior pure
server-side model of the Web 1.0 era, where the page is pro-
duced on its entirety at the server side. Section 1.1 discusses
the advantages that Ajax oﬀers over the pure server-side
model but also the serious complexities and programming
challenges that it introduces.

The FORWARD framework simpliﬁes the programming of
data-driven application pages by treating them as rendered
views, whose data are declared by the developer using a
syntactically minor extension of SQL, while the rendering
is delivered by page units, which are responsible for data
visualization and interaction with the user. The units map
to the views, either by use of an API or by the use of unit
visual (conﬁguration) templates that put together the page
units and the SQL views that feed them with data.

The paper’s key contribution is the introduction of declar-
ative SQL programming for the development of the report
part of data-driven Ajax pages. Drawing a parallel to how
declarative SQL queries simpliﬁed data management dur-
ing the last 30 years, similar productivity beneﬁts can be
delivered by the use of declarative SQL queries for the de-
velopment of data-driven Ajax pages. As has been the case
with SQL in the past, the productivity beneﬁts of the declar-
ative approach are due to the framework automatically solv-
ing performance optimization problems and providing com-
mon functionalities that would otherwise need to be hand-
coded by the developer. In particular, FORWARD leverages
years of database research on incremental view maintenance
and extends it for the needs of pages, as summarized in
the contributions list of Section 1.3. The net eﬀect is that
FORWARD relieves the Ajax page developer from having to
write mundane data synchronization code in order to reﬂect
the eﬀect of the users’ actions on the pages. An online demo
of FORWARD is available at http://www.db.ucsd.edu/
forward.

5671.1 Ajax background

In a pre-Ajax, pure server-side application1 a user action
on an html page leads to an http request to the server. The
server updates its state, computes a new html page and
sends it to the client (i.e., the browser). At a suﬃcient
level of abstraction, the new page computation is a func-
tion that inputs the server state, which includes the request
data, the main memory state of the application (primar-
ily session data), the database(s) and relevant information
from external systems (e.g., a credit card processing sys-
tem) and outputs html. Unfortunately the user experience
in pure server-side applications is interrupted: the browser
blocks synchronously and blanks out (i.e. displays a blank
window) while it waits for the new page. Even in the com-
mon case where the new page is almost identical to the old
page, aspects of the browser state, such as the data of non-
submitted form elements, the cursor and scroll bar positions,
are lost and the user spends time to “anchor” his attention
and focus to the new rendering of the page.

An Ajax page relies on browser-side JavaScript code, in-
cluding extensive use of JavaScript/Ajax library components,
such as maps, calendars and tabbed dialogs. A user action
leads to the browser running an event handling JavaScript
function that collects data from the page (e.g., from forms
and components relevant to the action), and sends an asyn-
chronous Xml Http Request (XHR) with a response handler
callback function speciﬁed. The browser does not blank out:
it keeps showing the old page while the request is processed
and even allows additional user actions and consequent re-
quests to be issued. Later the response handler receives the
server’s response and uses it to partially update the page’s
state. The page state primarily consists of (1) the page DOM
(Document Object Model) object and its subobjects, which
capture the displayed HTML and the state of the HTML
forms (text boxes, radio buttons, etc) and (2) the state of
the JavaScript variables of the page, which are often parts
of third party JavaScript components (such as maps, cal-
endars, tabbed dialogs). The components typically encap-
sulate their state by exporting methods that the JavaScript
functions have to programmatically use for reading and writ-
ing it.
The Ajax advantage The Ajax pages’ “desktop applica-
tion feel” and quick responsiveness is due to three advantages
over the pure server model:

1. Partial update speed: The request processing and the re-
sponse are focused on the relatively few operations needed
to produce the partial update of the page, in contrast to
the pure server model where the whole page must be re-
computed. Since today’s applications are often fueled by
multiple queries (e.g., Amazon’s user page is fueled by
100+ queries [25]) the partial update strategy can dra-
matically decrease the response time.
For example, consider a proposal reviewing application.
On the page shown in Figure 1, the reviewers can see each
other’s reviews as they are submitted and revised. In a
pure server-side model, submitting a review for a proposal

1We also classify as pure server-side applications those that
make simple use of JavaScript for UI purposes but without
the JavaScript contacting the server, as in Ajax. For exam-
ple, an application where JavaScript is used to cause sub-
mission of a form upon clicking the enter key still qualiﬁes
as a pure server-side application for our purposes.

will require the entire page to be recomputed, including
queries for the reviews and average grades of all propos-
als. On an Ajax page, however, a developer will typically
optimize: an asynchronous request will be issued with its
input being the review. The server will issue queries only
in order to ﬁnd the id of the newly inserted review and
the average grade of the corresponding proposal. Upon
receiving the response, the response handler updates sub-
regions of the page’s DOM to reﬂect the small changes.

2. Continous action on browser: In the example, once the
reviewer submits a review, he can continue reviewing by
moving his cursor and scroll bar to the next proposal,
even before the response handling function has updated
the page. Such behavior is a major HCI improvement [15]
over server side applications, where the request is followed
by a loss of the page and of the cursor position. The con-
tinuous action is enabled by two factors: First, the asyn-
chronous nature of the request prevents blanking out. In
the common case where the response handler leaves most
of the page unaﬀected, the user can keep working uninter-
rupted on most of the page. Furthermore, the browser’s
synchronous blocking is reduced to the amount of time
needed for the response handling function to update the
page (after the response has been received), the compo-
nents to update their state, and the browser to reﬂow (i.e,
to redraw the modiﬁed part of the DOM) [29]. In conjunc-
tion with the partial update, which minimizes updates on
the page and consequent reﬂowing operations, this leads
to a typically negligible wait period.

3. JavaScript and Ajax libraries: Third party libraries pro-
vide comprehensive collections of client-side JavaScript
and Ajax components (such as maps, calendars and tabbed
dialogs) that produce large savings in development time
due to code re-use. These component libraries enable
more polished and consistent user experience across dif-
ferent web applications, and also mitigate the API incom-
patibilities between browsers.

The above advantages have led to novel applications and
features, many of which were practically impossible previ-
ously. Such applications capture and quickly respond to
actions of the user on the page.
The Ajax challenge The programming of Ajax pages is
complex, time consuming and error-prone for many reasons.
Indeed, each of the Ajax advantages listed above leads to
corresponding programming challenges:

1. Realizing the beneﬁts of partial update requires the devel-
oper to program custom logic for each action that partially
updates the page. In a pure server-side implementation,
the programmer need only write (1) code that produces
the report and (2) code for the eﬀect of each individual
action on the database. In an Ajax application however,
each action also requires (3) server-side code to retrieve a
subset of the data needed for refresh (4) JavaScript code
to refresh a sub-region of the page. In the running exam-
ple, (3) and (4) are required for each of submitting a new
review, revising an existing review and removing a review.
This is obviously laborious and error-prone, as the devel-
oper needs to correctly assess the data ﬂow dependencies
on the page. For the running example of submitting a re-
view on the page of Figure 1, if the developer had issued
a query for Average Grade, but not Reviews, the page

568will display inconsistent data if another review had been
concurrently inserted into the database.

2. The programmer has to coordinate browser-based JavaScript

code with server-side Java and SQL code. That is, devel-
oping the Ajax pages requires distributed programming
between the browser and server, and involves multiple
languages and data models. Furthermore, JavaScript is
widely criticized (e.g., see [22]) as too unstructured and er-
ror prone. While the lack of strong typing and other con-
ventional programming language features was arguably an
advantage when JavaScript was used just for UI purposes,
it is a liability nowadays, where JavaScript (thanks to
XHR requests) is an integral part of the process that the
application implements.

3. While the developer of the pages of a pure server-side
application needs to only understand HTML (since the
browser automatically parses HTML and turns it into
DOM) the developer of Ajax pages needs to understand
the DOM, in order to update the displayed HTML, and
also understand the component interfaces in order to ﬁrst
write code that initializes components, and then write
code that refreshes the components’ state based on the
nature of each update.

1.2 Framework and language contributions

FORWARD facilitates the development of Ajax pages by
treating them as rendered views. The pages consist of a
page data tree, which captures the data of the page state
at a logical level, and a visual layer, where a page unit tree
maps to the page data tree and renders its data into an html
page, typically including JavaScript and Ajax components
also. The page data tree is populated with data from an
SQL statement, called the page query. SQL has been min-
imally extended with (a) SELECT clause nesting and (b)
variability of schemas in SQL’s CASE statements so that
it creates nested heterogeneous tables that the programmer
easily maps to the page unit tree. A user request from the
context of a unit leads to the invocation of a server-side pro-
gram, which updates the server state. In this paper, which
is focused on the report part of data-driven pages and ap-
plications, we assume that the server state is captured by
the state of an SQL database and therefore the server state
update is fully captured by respective updates of the tables
of the database, which are expressed in SQL. Conceptually,
the updates indirectly lead to a new page data tree, which
is the result of the page query on the new server state, and
consequently to a new rendered page.

FORWARD makes the following contributions towards

rapid, declarative programming of Ajax pages:

• A minimal SQL extension that is used to create the page
data tree, and a page unit tree that renders the page data
tree. The combination enables the developer to avoid mul-
tiple language programming (JavaScript, SQL, Java) in
order to implement Ajax pages.
Instead the developer
declaratively describes the reported data and their ren-
dering into Ajax pages.
We chose SQL over XQuery/XML because (a) SQL has a
much larger programmer audience and installed base (b)
SQL has a smaller feature set, omitting operators such as
// and * that have created challenges for eﬃcient query
processing and view maintenance and do not appear to
be necessary for our problem, and (c) existing database

research and technology provide a great leverage for im-
plementation and optimization (see Section 1.3), which
enables focus on the truly novel research issues without
having to re-express already solved problems in XML/X-
Query or having to re-implement database server func-
tionality. Our experience in creating commercial level ap-
plications and prior academic work in the area (see Sec-
tion 5) indicate that if the application does not interface
with external systems then SQL’s expressive power is typ-
ically suﬃcient. We brieﬂy describe in the Future Work
(Section 6) the issues arising in interfacing to external
systems.

• A FORWARD developer avoids the hassle of programming
JavaScript and Ajax components for partial updates. In-
stead he speciﬁes the unit state using the page data tree,
which is a declarative function expressed in the SQL ex-
tension over the state of the database. For example, a
map unit (which is a wrapper around a Google Maps com-
ponent) is used by specifying the points that should be
shown on the map, without bothering to specify which
points are new, which ones are updated, what methods
the component oﬀers for modiﬁcations, etc.

Roadmap We present the framework in Section 2 with a
running example. Section 2.3 presents the data aspects of
the framework. Section 2.4 presents the visual layer.

1.3 System and optimization contributions

A naive implementation of the FORWARD’s simple pro-
gramming model would exhibit the crippling performance
and interface quality problems of pure server-side applica-
tions.
Instead FORWARD achieves the performance and
interface quality of Ajax pages by solving performance op-
timization problems that would otherwise need to be hand-
coded by the developer. In particular:

• Instead of literally creating the new page data tree, unit
tree and html/JavaScript page from scratch in each step,
FORWARD incrementally computes them using their prior
versions. Since the page data tree is typically fueled by
our extended SQL queries, FORWARD leverages prior
database research on incremental view maintenance, es-
sentially treating the page data tree as a view. We extend
prior work on incremental view maintenance to capture
(a) nesting, (b) variability of the output tuples and (c)
ordering, which has been neglected by prior work focus-
ing on homogeneous sets of tuples.

• FORWARD provides an architecture that enables the use
of massive JavaScript/Ajax component libraries (such as
Dojo [30]) as page units into FORWARD’s framework.
The basic data tree incremental maintenance algorithm is
modiﬁed to account for the fact that a component may
not oﬀer methods to implement each possible data tree
change. Rather a best-eﬀort approach is enabled for wrap-
ping data tree changes into component method calls.

The net eﬀect is that FORWARD’s ease-of-development
is accomplished at an acceptable performance penalty over
hand-crafted programs. As a data point, revising an existing
review and re-rendering the page takes 42 ms in FORWARD,
which compares favorably to WAN network latency (50-100
ms and above), and the average human reaction time of 200
ms.

569Figure 1: Review Proposals page

Roadmap Section 3 presents optimizations for incremen-
tally maintaining the page, with Section 3.1 highlighting
the incremental view maintenance of the page data tree,
and Section 3.2 presenting the architecture for incremen-
tally refreshing the visual layer. Lastly, Section 4 presents
the system implementation and experimental results.

2. THE FORWARD DATABASE-DRIVEN

FRAMEWORK

2.1 Running example

The running example is a simpliﬁed version of the Fast-
Lane web application, which the National Science Founda-
tion (NSF) uses to coordinate the submission and reviewing
of proposals among Principal Investigators (PIs), Review-
ers and Program Directors.2 First, a PI visits a Submit
Proposal page to submit the project description, budget es-
timates and personnel particulars. After the proposal sub-
mission deadline, NSF invites Reviewers to a panel, during
which they collaborate on the Review Proposals page (Fig-
ure 1). Each Reviewer sees the titles of proposals assigned,
and can click on them to access proposal details. For each
proposal, a Reviewer can submit and revise a review com-
prising a textual comment and a grade ranging from 1 to 5.
In addition, a Reviewer can see others’ reviews, a bar chart
visualizing the respective grades, and the average grade. Fi-
nally, the Program Director uses a Recommend Proposals
page to peruse all reviews provided and indicate which pro-
posals are recommended for funding.

2.2 Architecture

Figure 2 shows an overview of the architecture of the FOR-
WARD framework. In FORWARD, each page is described
by a unit tree that has a corresponding page schema. The
unit tree synchronizes between the page data tree, which con-
forms to the page schema, and the browser page state, which
includes the state of JavaScript components and HTML
DOM. As a user interacts with a page, events can hap-
pen which are triggered by either a direct user action (e.g.,
clicking a button) or other mechanisms such as timers, and
leads to an invocation of a server-side program that updates
the server state. A program has access to (1) the context
and form data3 of the program invocation, and (2) a SQL

2A demo of the original Fastlane application is available at
https://www.fldemo.nsf.gov/
3 If the page contains HTML forms that are both initialized

Figure 2: FORWARD architecture

database. Using these data, a program can issue INSERT/UP-
DATE/DELETE commands on the database.
In FORWARD
the server state is completely captured by the state of the
database and therefore the server state update is fully cap-
tured by a modiﬁcation log that stores all DML commands
on the database’s tables. After the program invocation, a
page state computation module creates the data tree of the
new browser page state.

In order to support the Ajax incremental update of a page,
the respective renderers of units translate the data diﬀerence
between the old and the new page data trees to method
calls of JavaScript components, as well as updates to the
HTML DOM. Furthermore, the data diﬀerence is automati-
cally computed in an incremental way without recomputing
the page state from scratch. This is possible because the
computation of a page’s data is speciﬁed using a query, called
the page query. As a result, the page data tree is essentially a
view over base tables. The framework logs the modiﬁcations
to the state of the base tables in the same application, and
employs incremental view maintenance techniques to obtain
the changes to the view.
Incremental page update is the
core focus of this paper, and technical issues are discussed
in detail in Section 3.

2.3 Data layer

The page data tree captures the page’s state at a logical
level using a minimal extension of SQL’s data model with the
following features that will facilitate mapping to the page’s
data from the unit tree. First, the data tree has both sets
and lists to indicate whether the ordering of tuples matters;
e.g., the grade options in Figure 1 and the proposals are a
list while the reviews of the proposal form a set. Second, it
has nested relations; e.g., nested reviews within proposals.
Finally, it allows heterogeneous schemas for the tuples of
a collection; e.g., a tuple corresponding to the input mode
of My Review also carries the nested list of grade options
while a tuple corresponding to the display mode only carries
comments and grades.

The schema of a data tree is captured by a schema tree.

by the query and updatable by the user, interesting chal-
lenges arise around the programs requiring uniﬁed access to
both the database and the user provided data. The details of
such uniﬁed access mechanisms are beyond the scope of this
paper and are brieﬂy discussed in the Future Work section.

Browser pageprogram DOM  & componentsinvocationPage unit treeUnit instance treeVisual layerProgramsServicesServicesServicesControl layerPdtPage state computationData layerDatabaseModification logPage data treePage query570list(

tuple(

list(

tuple(

clause produces a set while a query with ORDER BY produces
a list. The following query produces the Review Proposals
page data tree:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

proposal_id : 509 ,
title
average_grade: 4.5,
reviews
tuple(

:set(

: Flying Cars,

review_id : 1,
comment
grade
reviewer : tom@abc.edu)
...),

: Creative...,
: 3 - Good,

grades

tuple(

: list(

bar_id : 1,
value : 3)),

my_review

: switch(

input_tuple: tuple(

comment : null,
grade

: tuple(

grade_ref
grade_options:list(

: null,

tuple(

: 1,

grade_id
grade_label: 1 - Poor)
...)))

proposal_id : int,
title
average_grade: float,
reviews
tuple(

: set(

: string,

review_id : int,
: string,
comment
: string,
grade
reviewer : string)
),

: list(

grades

tuple(

bar_id : int,
value : int)),

my_review

: switch(

input_tuple: tuple(

comment : string,

grade : tuple(

grade_ref
grade_options:list(

:int,

tuple(

grade_id
grade_label:string)

:int,

))),

display_tuple : tuple(

comment : string
grade
: string

))

...)

)))

)

Figure 3: Page data tree

Figure 4: Page schema

Each data node (also called value) maps to a schema node,
and the data tree is homomorphic to the schema tree. A
value can be one of the following:

1. an atomic value, such as string, integer, boolean etc.

2. a tuple, which is a mapping [a1 : v1, . . . , an : vn] of at-
tribute names to values, whereas attributes a1, . . . , an
are distinct.

3. a collection, which contains tuples v1, . . . , vn such that
v1, . . . , vn are homogeneous, i.e. each maps to the same
schema node. Furthermore, the schema node speciﬁes
a primary key constraint, such that tuples in the collec-
tion are uniquely identiﬁable. An unordered collection
is a set, whereas an ordered collection is a list. The
primary keys will play a key role in the incremental
maintenance of the page.

4. a switch value, which is a tagged union [c1 : v1, . . . , cn :
vn] of case / value pairs, such that only one pair can
be selected. While the switch value represents only the
selected pair, the switch schema represents the schema
of all possible case/value pairs.

5. a null value.

For example, Figure 3 shows the page data tree that rep-
resents the list of proposals at the Review Proposals page.
In a proposal tuple, title is an atomic string value, reviews
is a nested set of review tuples, and my_review is a switch
value where the input_tuple case is selected. Note however
that the corresponding switch schema in Figure 4 contains
both display_tuple and input_tuple cases to indicate that
a reviewer’s review can be either in display mode or input
mode.

We extend SQL for nesting (in the spirit of OQL [5])
and variability. Furthermore, a query without an ORDER BY

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

SELECT P.proposal_id, P.title,

(
SELECT
FROM
WHERE
AND
) AS other_reviews,

*
reviews R
R.proposal_ref = P.proposal_id
R.reviewer <> S.user

(
SELECT
FROM
WHERE
ORDER BY R.grade DESC
) AS grades,

R.review_id AS bar_id, R.grade AS value
reviews R
R.proposal_ref = P.proposal_id

(
SELECT

CASE

SELECT

WHEN (D.mode = ‘input’) THEN ‘input_tuple’ :

D.comment, Tuple(

D.grade_ref,
( SELECT * FROM grade_options )
AS grade_options

) AS grade

ELSE ‘display_tuple’ :

SELECT R.comment, R.grade
FROM
WHERE
AND

reviews R
R.proposal_ref = P.proposal_id
R.reviewer = S.user

END

FROM
WHERE
AND
) AS my_review,

draft_reviews D
D.proposal_ref = P.proposal_id
D.reviewer = S.user

(
SELECT
FROM
WHERE
) AS average_grade

AVG(R.grade)
reviews R
R.proposal_ref = P.proposal_id

FROM proposals P, current_session S
WHERE EXISTS (
*
assignments A
A.proposal_ref = P.proposal_id
A.reviewer = S.user

SELECT
FROM
WHERE
AND

)
ORDER BY P.proposal_id

The query operates over four database tables: proposals,
assignments to reviewers, reviews that have been submit-
ted and draft_reviews that have been saved. It also oper-
ates over a special collection current_session, which pro-
vides a single tuple of HTTP session attributes.

Lines 1-49 is the outer query that produces the list of
proposals. Lines 3-7 shows a sub-query that produces the
set of reviews by reviewers other than the current user.
It is a conventional SQL sub-query that is parameterized
by tuple variables P and S from the outer query. By al-
lowing nested queries in the SELECT clause the query lan-
guage can construct results that have nested collections. The
bar_chart sub-query (lines 9-14) is similar except for the
ORDER BY clause, which makes the result a list instead of
a set. The my_review query (16-34) features a SQL CASE
WHEN ... ELSE ... END conditional expression that de-
termines if a reviewer’s review is an input tuple or display
tuple based on whether the corresponding draft review is
valid or not. The extension for heterogeneity allows the CASE
expression to become a constructor for switch values, when-
ever each branch evaluates to a (potentially heterogeneous)

5711

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

case:value pair. In general, various constructor functions /
operators provide convenience syntax for creating values of
the data model: another example is the tuple constructor on
line 20. Lastly, the average_grade sub-query (lines 36-40)
uses the AVG aggregation function to calculate the average
review grade for a proposal, and the existential sub-query
(lines 43-48) ﬁlters for proposals that have been assigned to
the current user.

2.4 Visual layer

Units capture the logical structure of a page, including
the program invocation requests that may be issued from it.
Furthermore FORWARD units enable the incorporation of
components from JavaScript libraries (such as Dojo [30] and
YUI [35]) into the FORWARD framework.

Each page has a unit tree (comprising units), and each
instance of a page has a corresponding unit instance tree
(comprising unit instances) that conforms to the unit tree
similar to how data trees conform to schema trees. Each
unit has a unit schema, and a homomorphic mapping from
unit schema attributes to nodes in the page schema tree.
Intuitively, the unit schema captures the exported state of
the unit and its descendants. The unit mapping induces a
mapping from the corresponding unit instances to the nodes
in the page data tree, which are termed the unit instance’s
data.

The FORWARD framework provides a textual template
syntax for conﬁguring a unit tree. For example, Figure 5
shows the unit tree for Review Proposals, with mappings
to the page schema tree of Figure 4. Each XML element that
is in the unit namespace encloses a unit conﬁguration, which
contains (1) XML elements in the default namespace for the
unit schema attributes, and (2) nested unit conﬁgurations
for children units. The template also allows HTML elements
in the html namespace, thus a developer can conﬁgure all
visual aspects of a page in a single uniﬁed syntax. The bind
attribute is used to map unit schema attributes to schema
nodes. For example, the (root attribute of the) dropdown
unit maps to the grade tuple of Figure 4, and its ref and
options attributes map respectively to the grade_ref and
grade_options attributes.

A unit can be associated with one or more server-side
programs. When a program is invoked, it has access to (1)
the invocation context, which is the data node mapped from
the unit instance of the program invocation (2) the data of
form units, such as textboxes and dropdowns (3) the SQL
database. Using these data, a program invocation issues IN-
SERT/UPDATE/DELETE commands on the database, which are
captured by the application’s modiﬁcation log. For exam-
ple, the button unit in Figure 5 line 42 associates the click
event with a save_review program. When the save_review
program is invoked, it uses the corresponding proposal from
the invocation context, the grade from unit:dropdown, the
review from unit:textbox, and the current user from the
session, and issues an INSERT command on the reviews ta-
ble.

After program invocation, the page is incrementally re-
freshed in an eﬃcient manner, the details of which will be
fully described in Section 3.

3.

INCREMENTAL PAGE REFRESH

Pure server-side applications often suﬀer from long re-
sponse time, due to the expensive recomputation at the data

<html:html>
<html:h1>List of all proposals.</html:h1>

<unit:table bind="page_state">

<column header="Title">

<unit:print bind="title />

</column>

<column header="Other reviews">

<unit:table bind="other_reviews">

<column header="Comment">

<unit:print bind="comment" />

</column>
<column header="Grade">

<unit:print bind="grade" />

</column>
<column header="Reviewer">

<unit:print bind="reviewer_id" />

</column>
</unit:table>

</column>

<column header="grades">

<unit:barchart bind="grades" />

</column>

<column header="My Review">

<unit:switch bind="my_review">

<case bind="input_tuple">

<html:div>

<unit:dropdown bind="grade">
<ref bind="grade_ref" />
<options bind="grade_options">

<option bind="grade_option" />

</options>

</unit:dropdown>

<unit:textbox bind="comment" />

<unit:button text="Submit"

on_click="save_review"/>

</html:div>

</case>

<case bind="display_tuple">

<html:div>

Comment:
<unit:print bind="comment" />
Grade:
<unit:print bind="grade" />

<unit:button text="Edit"

on_click="edit_review" />
<unit:button text="Remove"

on_click="remove_review" />

</html:div>

</case>

</unit:switch>

</column>

<column header="Avg. Grade">

<unit:print bind="average_grade" />

</column>

</unit:table>
</html:html>

Figure 5: Unit tree conﬁguration

layer and the visual layer, and unfriendly user experience
due to the browser blanking-out. Ajax solves both problems
(see Section 1.1), but at the cost of signiﬁcantly complicating
web programming.

The following strawman approach employs Ajax to avoid
the blanking out, while the programmer only provides a
query that populates the report’s data without having to
provide separate queries and programs for incremental re-

572the new page data tree d2. The current implementation of
RIVM in PSC is built on top of an oﬀ-the-shelf relational
database without modiﬁcation to the database engine. The
framework monitors all data modiﬁcation in an application
to maintain the modiﬁcation log, and expands the log to
capture data changes of each database table. Both the mod-
iﬁcation log and page data trees are stored in main memory
resident tables of DBMS for fast access.

The data diﬀerence Diﬀd2−d1

is encoded as the series of
data modiﬁcation commands that turn d1 into d2. The data
modiﬁcation commands are insert, remove and update. The
remove command remove(t) locates the node identiﬁed by t
in a data tree and removes the subtree rooted at it. The up-
date command update(t, N ) replaces the old subtree rooted
at t with the new subtree N . The insert command has a
set version and a list version for the two diﬀerent types of
collections. The set-version inserts(r, N ) inserts a subtree
N rooted at a tuple into the targeted set identiﬁed by r.
The list-version insertl(r, N, t0) takes one more parameter
t0 which is the adjacent node after which the new subtree
should be inserted.

Section 3.1.1 lists the beneﬁts of PSC for page refresh us-
ing an example. Section 3.1.2 provides background on rela-
tional techniques that are leveraged. Section 3.1.3 describes
how a page schema can be decomposed into ﬂat views, and
how to obtain the SQL queries that deﬁne each ﬂat view.
Section 3.1.4 discusses the handling of order through the
view maintenance process. Finally, Section 3.1.5 describes
how maintenance results on ﬂat views can be translated and
applied to the nested data tree.

3.1.1 Beneﬁts and example

PSC drastically reduces the number of SQL queries that
must run in order to refresh the page by detecting the fol-
lowing opportunities:

• Non-modiﬁcation: PSC may statically prove that certain
data tree nodes are unaﬀected by the data modiﬁcations.
Therefore data of these nodes need not be recomputed.

• Page state self-suﬃciency: In this case, d2 can be com-
puted as a function of d1 and the modiﬁcation log, without
access to the proper database tables. Since PSC stores the
modiﬁcation log and d1 in main memory, fast computation
is achieved by avoiding disk access. Furthermore, as the
OLAP and view maintenance literature has shown self-
suﬃciency opportunities can be greatly increased by the
inclusion of a small amount of additional data in a view.
For example, an average view is not self-maintainable if it
only has the averages but it is maintainable if it also has
the count.

• Incremental maintenance: When the previous two cases
are not available, PSC may need to access database tables
to compute Diﬀd2−d1
and consequently d2. However, com-
puting Diﬀd2−d1
is usually faster than running the page
query from scratch, with the help of modiﬁcation log and
the cached old page data set.

In practice, PSC utilizes more than one opportunities from
above to maintain a page data tree, with each applied to dif-
ferent parts of the page. Suppose the current reviewer Ken
updates the grade and the comment of review #2 of proposal
509 of Figure 1. Therefore the modiﬁcation log includes (a)
an update to the comment and rating of the (509, #2) tuple
in the reviews table, and (b) an update of the mode value

Figure 6: Page state computation

fresh. When a refresh of the page is needed, the page makes
an asynchronous XHR JavaScript call that fetches the new
page in its entirety from the server. The response handler re-
places the old page DOM with the new one. The straw man
approach achieves Ajax behavior only superﬁcially. Com-
pared to the pure server-side model, the server side compu-
tation stays the same, and the browser still needs to reinitial-
ize all JavaScript components and re-render the entire page.
Furthermore, users will still experience loss of focus, of cur-
sor position and of data entered in non-submitted forms.

FORWARD combines the best of both the Ajax model
and the pure server-side model by oﬀering the development
advantage of modeling pages as rendered views so that the
developers need not specify any extra update logic, while the
framework automates the incremental page refresh in both
the data layer and the visual layer to achieve the Ajax per-
formance and preservation of focus, scroll, cursor positions
and form data. This section describes how incremental page
refresh is handled in the data layer (Section 3.1) and the
visual layer (Section 3.2).

3.1 Leveraging and extending incremental view

maintenance

The Page State Computation Module (PSC) of FORWARD
(see Figure 2) treats the page data tree as a view. During
page refresh it uses the log of modiﬁcations that happened
to the database data, and possibly the database data itself
to incrementally maintain the old view instance to the new
view instance.

Figure 6 shows an overview of how PSC incrementally
maintains the page data tree d1 of the old page state s1 to
the page data tree d2 of the new page state s2. Recall that a
page data tree is computed as the result of the page query,
which is a nested query in FORWARD’s extended SQL lan-
guage. At design time, PSC decomposes the nested page
schema into ﬂat relational views denoted by T1, T2 etc, and
rewrites the page query into standalone SQL queries q1, q2
etc that deﬁne the ﬂat views respectively. At run time, the
old page data tree d1 is ﬁrst transformed to instances of
the ﬂat relational views. Then PSC uses a Relational Incre-
mental View Maintenance algorithm (RIVM ) on each ﬂat
view utilizing the modiﬁcation log and possibly database
data. The incremental changes to the ﬂat views computed
by RIVM are translated to the data diﬀerence Diﬀd2−d1
that
can be combined with the old page data tree d1 to calculate

Page schemaPage queryT1Q1T2Q2T3Q3Design timeRun timePage data treed1T1T2∆T1∆T2Page data treedDiffd2‐d1tree d1T3∆T3tree d2RIVMDatabaseModification logg573of the (509, #2) tuple in the draft_review table. Suppose
that the modiﬁcation log also happens to have the following
changes by other users which happened right before the sub-
mission of the update by Ken: (c) an insertion of new review
#3 for proposal 509, (d) an update of a review of another
proposal 456, and (e) an insertion of a recommendation on
another page. Notice that proposal 456 does not appear on
the page since it is not assigned to Ken. Given the modiﬁ-
cation log PSC can statically determine that the change (e)
does not aﬀect the review page (i.e., the non-modiﬁcation
case) since the current page does not show recommenda-
tions at all.
It also determines that the change (d) does
not aﬀect the page because proposal 456 does not appear
in the page data tree shown to Ken. The other changes
in the modiﬁcation log correspond to either the page state
self-suﬃciency case or the incremental maintenance case. In
particular, because of (a) and (b), the input tuple (form) at
proposal 509 will disappear since the switch node will revert
to the display case, and the display tuple at proposal 509
will be set according to the grade and review submitted by
Ken. A new review tuple is inserted into the list of other
reviews for (c). Finally, because of (a) and (c), the average
can be incrementally recomputed from the old average, the
count and the modiﬁcations, if the count is also included in
the view as additional data.

3.1.2 Leveraging relational research

The relational model literature [6, 19, 17, 18, 26] has de-
scribed methods for eﬃciently maintaining a materialized
SQL view V = q(R1, R2, . . . , Rn), where q is a SQL query
and {R1, R2, . . . , Rn} are base tables. One approach imple-
mented by many existing solutions and also by PSC in FOR-
WARD is to model data changes as diﬀerential tables. Let
the old view instance be V1 and the new view instance be V2.
Between V1 and V2, the diﬀerential tables for a base relation
Ri are ∆+Ri containing tuples inserted into Ri, and ∆−Ri
containing tuples deleted from Ri. ∆+Ri and ∆−Ri are cap-
tured in the modiﬁcation log. In the same way ∆+V and
∆−V can be deﬁned. Tuple update is treated as a combina-
tion of insertion and deletion. The view maintenance algo-
rithm RIVM in this approach runs two queries q∆+ and q∆−
over {R1, · · · , Rn, ∆+R1, · · · , ∆+Rn, ∆−R1, · · · , ∆−Rn} that
produce ∆+V and ∆−V respectively.

PSC focuses on the deferred view maintenance [9, 27] that
works with after-modiﬁcation database tables and the mod-
iﬁcation log. The reason is that in data-driven web appli-
cations, although a data modiﬁcation can aﬀect data trees
seen by multiple users, the page view maintenance for a user
can be deferred until the user requests for the page again, so
that the system throughput can be maximized. PSC imple-
ments RIVM on top of the open source PostgreSQL, which
does not have native support of materialized view. In gen-
eral, other implementations of RIVM can be used in PSC
as well.

3.1.3 Reduction of nested queries and switches

PSC uses RIVM as a building block to manage nest-
ing and switches. It transforms a nested page schema into
ﬂat relational views T1, · · · , Tn, and the corresponding page
query into SQL queries q1, · · · , qn, such that each Ti is de-
ﬁned by qi.

Given a page query q and corresponding page schema V ,
PSC takes the ﬁrst step to create ﬂat relations S1, · · · , Sn as

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

follows to represent the decomposition of V with respect to
q. The outer-most collection of V is represented as the rela-
tion S1. Each sub-query in the SELECT clause is mapped to
a new relation. Each case sub-query in CASE WHEN con-
ditional statements is also mapped to a new relation. Notice
that sub-queries in the WHERE clauses are unaﬀected. Let
the corresponding sub-query for each Si be pi. If pa is the
parent (sub-)query of pb, then expand Sb to contain the for-
eign key attributes referencing tuples in Sa, and call Sa the
parent of Sb. Finally, the primary key attributes of each Si
are made to include the foreign key attributes to its parent
relation, if it exists, in addition to the Si’s original primary
key attributes.

At this point, each ﬂat relation Si after decomposition
corresponds to a sub-query pi that may use values from its
ancestor sub-queries. PSC modiﬁes each Si to get ﬂat view
Ti and creates its deﬁning query qi based on pi, so that each
qi is a standalone SQL query without correlation. First,
each Ti is designed to have Si’s schema and also to contain
the attributes whose values are referred by any pk that is
a descendant of pi. Then the deﬁning query qi of each ﬂat
view Ti is modiﬁed from pi by adding Tj, where pj is the
parent of pi, as an additional input table in pi’s WHERE
clause. The original references to values in pj can then be
changed in qi to the joined attributes from Tj. Finally, in
order to ease the discussion, we still call that a ﬂat relation
Ta is the parent of Tb if pa is the parent of pb.

During run time, PSC traverses qi from top down to in-
crementally maintain each Ti as follows: First for the top
level view T1 deﬁned by q1, PSC runs ∆+T1 and ∆−T1
using RIVM . If Ta is the parent of Tb, when Tb is main-
tained by PSC, its parent table Ta would have already been
maintained, so that ∆+Ta and ∆−Ta are available, which is
necessary since Ta is an input relation to Tb’s deﬁnition qb.
For example, the following SQL statements deﬁnes some
of the ﬂat views corresponding to the result of relational
decomposition of the page schema and the page query in
the running example.

CREATE VIEW T1_proposals AS
SELECT
FROM
WHERE

R.proposal_id, P.title, S.user
proposals P, current_session S
EXISTS (

SELECT
FROM
WHERE
AND

*
assignments A
A.proposal_ref = P.proposal_id
A.reviewer = S.user

)
ORDER BY P.proposal_id

CREATE VIEW T2_other_reviews AS
SELECT
FROM
WHERE
AND

R.comment, R.grade, R.review_id, T1.proposal_id
reviews R, T1_proposals T1
R.proposal_ref = T1.proposal_id
R.reviewer <> T1.user

CREATE VIEW T3_average_grade AS
SELECT
FROM
WHERE
GROUP BY T1.proposal_id

T1.proposal_id, AVG(R.grade)
reviews R, T1_proposals T1
R.proposal_ref = T1.proposal_id

Consider the modiﬁcations described in Section 3.1.1. Since
neither proposals nor current_session is changed between
the previous and the current page states, T1 is not changed
and ∆+T1 and ∆−T1 are empty. Because change (c) brings a
non-empty ∆+Rreviews, RIVM is able to compute ∆+T2 by
joining ∆+Rreviews and T1 and then doing the selection. The

574deﬁning queries of all the decomposed ﬂat views of the run-
ning example can be incrementally maintained by RIVM .

3.1.4 Lists and reordering

Since most prior work on relational view maintenance as-
sume bag or set semantics only, PSC is extended to sup-
port ordered list semantics by embedding order information
as data and simulating list-version operators using order-
insensitive ones.

The support of list in the data model of FORWARD al-
lows list-version operators in the query language’s algebra
like the FLWR in XQuery where the inputs, outputs and
intermediate results are treated as lists. Many of these op-
erators only need to preserve the order of tuples from the
input to the output, such as the list-version selection and
projection. For the view maintenance purpose, such opera-
tors can be simulated by their relational counterparts, with
order information embedded as data inside the order speci-
fying attributes. For example, a list can be encoded as a set
of tuples {(1, tom), (2, ken), (3, jane)} with the auxiliary ﬁrst
attribute being the order specifying attribute. In practice,
such system-generated attributes use encodings like LexKey
described in [10] in order to support eﬃcient repositioning.
In this way, these operators can treat order like data and
need not explicitly maintain it.

The ORDER BY operator that creates order is handled
by PSC by statically marking the order-by attributes as the
order specifying attributes. At run time, only the inserted
data changes are sorted, while the reordering of the entire
view is deferred until the ﬁnal result, where the size of data
is usually small as limited by the nature of a web page.
Order-sensitive operators, such as Top-k and MEDIAN, are
often expensive to maintain incrementally. For example, a
deletion of tuple from the input list of a Top-k operator
may incur scanning of the input list if the deleted tuple was
among the top k tuples. Maintenance of Top-k views has
been studied in [34]. How the embedded order information
is restored when the modiﬁcation is applied to the nested
view is discussed next.

3.1.5 Updating the page data tree

After the data changes ∆+Ti and ∆−Ti are obtained for
each Ti, the view maintenance result of the ﬂat views are
translated to Dif fd2−d1 as a series of data modiﬁcation
commands and then applied to the old page data tree d1
to obtain the new data tree d2. The changes to diﬀerent Ti
are applied in a top-down order, so that when changes to a
child data node is applied, its parent data node is guaranteed
to exist. Since every Ti has primary key attributes deﬁned
to contain ancestors’ primary keys in the corresponding data
tree, it is simple to navigate in the data tree to locate the
target of each change in ∆+Ti and ∆−Ti. Notice that a re-
lation in the data tree can be either a list or a set. If it is a
list, tuples from ∆+Ti need to be translated into list-version
insert commands of the data tree which require adjacent tu-
ples to be speciﬁed. Such adjacent tuples can be located
eﬃciently by using binary-search over the order specifying
attributes because the previous sorted list is materialized
and cached as part of the data tree d1. The handling of
other cases is straightforward.

3.2 Incremental maintenance of the visual layer

Given the data layer diﬀerence Diﬀd2−d1

from the PSC,
the incremental maintenance visual layer (IMVL) refreshes
the page through unit instances that translate the data layer
diﬀerence into updates of DOM elements and JavaScript
components. The IMVL is based on the observation that
the browser page state can be divided into fragments, where
each fragment corresponds to the rendering of a unit in-
stance, which in turn depends on one or more corresponding
data tree nodes. Only a unit instance corresponding to an
updated data tree node needs to be re-rendered.
Incremental maintenance of unit instance tree Incre-
mental maintenance of the page is facilitated by the unit in-
stance tree, which is a data structure residing on the browser.
Each unit instance maintains pointers to its underlying DOM
elements and JavaScript components, so that only pertinent
elements / components are re-rendered. From the data layer
diﬀerence, which is encoded as a sequence of insert, update
and delete commands on the page data tree, the IMVL uses
the unit tree to produce unit instance diﬀerences, which are
corresponding encodings for each unit instance. Each in-
sert command that spans multiple units will be fragmented
into insert commands for the respective unit instances; sim-
ilarly so for each delete command. Each update command
that spans multiple units will be fragmented into an up-
date command for the top unit instance, delete commands
for existing descendant unit instances, and insert command
for new descendant unit instances. When initializing a new
page instance, the IMVL will create the unit instance tree
from scratch. However, given an existing page instance, the
IMVL will use the unit instance diﬀerences to incrementally
maintain the unit instance tree, in order to preserve existing
DOM elements and JavaScript components.
Incremental rendering of units With an updated unit
instance tree, the IMVL will invoke in turn each unit in-
stance’s incremental renderer (or renderer), which translates
the unit instance diﬀerence into updates of the underlying
DOM element or method calls of the underlying JavaScript
component. Note that these renderers are implemented by
unit authors, and are automatically utilized by the frame-
work without any eﬀort from the developer. Essentially, ren-
derers modularize and encapsulate the partial update logic
necessary to utilize JavaScript components, so that develop-
ers do not have to provide such custom logic for each page.
Mediating between unit diﬀerences and JavaScript
components Consider the number of possible combina-
tions for a unit instance diﬀerence:
(1) any of the unit
schema’s attributes can be the root of the data diﬀ (2) the
data diﬀ can be encoded as any of the three insert, up-
date and delete commands. For each (attribute, command)
pair, a unit can be associated with a renderer. Since FOR-
WARD units utilize components from existing JavaScript
libraries, the number of possible renderers typically exceed
that of available refresh methods on components. Therefore,
given a unit diﬀerence, if the most speciﬁc renderer for the
(attribute, command) pair is not implemented, the frame-
work will attempt to simulate it on a best-eﬀort basis with
other available renderers. Any renderer can be simulated by
a update renderer of an ancestor attribute, while an update
renderer on a tuple can also be simulated by a combination
of insert and delete renderers on the same tuple. Min-
imally, a unit needs to be associated with an insert and
delete renderer on the unit schema root attribute.

575For example, consider the bar chart unit used on the Re-
view Proposals page, and a reviewer modifying his grade
on a review. If the underlying JavaScript component sup-
ports changing the value of a particular bar, and a update
renderer has been implemented for the value attribute, the
bar chart will be incrementally refreshed where only the af-
fected bar grows/shrinks. Otherwise, the entire bar chart
has to be refreshed.
Implementing speciﬁc renderers im-
proves performance for units that are expensive to initialize
(e.g. a map unit), and avoids overwriting user-provided val-
ues in units that collect values (e.g. a textbox).

4.

IMPLEMENTATION AND EVALUATION
FORWARD operates as an interpreter of an application
speciﬁcation, with static analysis taking place the ﬁrst time
an application is loaded by the system. A proof-of-concept
prototype has been implemented as a Java servlet running
in the Jetty servlet container. Queries are parsed and trans-
lated into conventional SQL statements, which are executed
in a PostgreSQL relational database.

To illustrate the performance characteristics of the proto-
type, we consider the running example where the database
stores 20,000 proposals, each proposal has 6 reviews, the
page displays 20 proposals, and a reviewer submits a revi-
sion to his review for one displayed proposal. Only two other
database modiﬁcations have been made since the reviewer’s
page was last refreshed: one for them is a review update (by
another reviewer) for the same proposal, whereas the other
is a review update for a proposal that is not displayed on
the current page. Consequently, the page refreshes with two
additional reviews on the page.

All measurements are performed on an Intel Core 2 Quad
2.7 GHz desktop running Windows Vista 64-bit. The server
runs under Java VM 1.6 under server mode, whereas pages
are loaded in the Firefox 3.5 browser. Since the JVM’s JIT
compiles hotspot bytecode into native code based on run-
time proﬁling of multiple method invocations, the initial 20-
30 readings for each experiment are discarded until steady
readings can be obtained, in order to approximate a long-
running server. The average of 10 readings are then taken to
smooth out CPU spikes from the JVM’s garbage collection.
To simulate a database server where proposals are not al-
ready cached in memory buﬀers, the currently logged-in user
(and hence the proposals retrieved) is randomly selected for
each reading.

For network measurements, the servlet container enables
gzip compression by default, which accounts for an order of
magnitude reduction in response size. To estimate the time
needed for real network traﬃc, we assume a coast-to-coast
network round-trip time of 100 ms [20], and the average US
upload and download bandwidths of 1 Mbps and 5 Mbps
respectively [24].

To demonstrate the end-to-end performance of a server
roundtrip, Table 1 presents itemized activities and their la-
tencies in the strawman implementation described in the be-
ginning of Section 3, starting from the time the submit but-
ton is clicked till the browser fully refreshes. Table 2 presents
the same activities and their latencies in FORWARD, which
employs the incremental maintenance techniques of Section
3.

In Table 1, (1) is the time spent by JavaScript code in
the browser collecting the data for the invocation context,
(2-3) is the time to transmit the request, and (4) is the

System Description

Server

Invoke request

1 Browser
2 Network Request latency
3
4
5
6
7 Network Response latency
8
9 Browser Rendering

Request transfer time
Update review
Generate page data tree
Response I/O

Response transfer time

Size

0.2 KB

6 KB

Time
14 ms
50 ms
2 ms
5 ms
210 ms
13 ms
50 ms
9 ms
38 ms
391 ms

Total

Table 1: Strawman implementation

System Description

Server

Invoke request

1 Browser
2 Network Request latency
3
4
5
6
7 Network Response latency
8
9 Browser

Request transfer time
Update review
View maintenance
Response I/O

Response transfer time
Incremental rendering
Total

Time
14 ms
50 ms
2 ms
5 ms
7 ms
5 ms
50 ms
1 ms
8 ms
142 ms

Table 2: FORWARD implementation

Size

0.2 KB

0.4 KB

time to invoke the program for updating the review in the
database. Note that (1-4) are outside the scope of the incre-
mental maintenance optimizations, and therefore have iden-
tical values in Table 2. (5) is the time to evaluate the query
to generate the page data tree. Indexes have been created on
foreign key columns so that PostgreSQL can eﬃciently join
tables, but the query is expensive due to the disk accesses in-
curred. (6) is the time to encode the entire page data tree in
JSON. (7-8) is network time. Finally (9) is the time to create
a new unit instance tree and render the DOM elements and
JavaScript components from scratch. We omitted browser
reﬂow time, as browsers do not provide programmatic mech-
anisms to reliably measure it, and the reﬂow time for the
running example is too fast to be measured manually with
a stopwatch.

In Table 2, note that (4) remains the same as in Table 1,
showing that storing the modiﬁcation log in main memory
has no measurable performance penalty. (5) demonstrates
the eﬃcacy of the incremental view maintenance of Section
3.1. Since there are no proposal updates in the modiﬁcation
log, the proposals collection falls in the non-modiﬁcation
case, therefore no SQL queries need to be issued. Other
nested collections, such as other_reviews and grades, fall
in the incremental maintenance case, where both the mod-
iﬁcation log and database need to be accessed to compute
proposals (cid:46)(cid:47) ∆+reviews. As compared to the full query
which requires a join on the 120,000-row reviews table, the
incremental query uses the 3-row modiﬁcation log to yield
a 30x speed up. (6) shows that the data layer diﬀerence is
more eﬃcient to encode than the entire page data tree. Simi-
larly (8) shows that the data layer diﬀerence is also more eﬃ-
cient to transmit. Lastly, (9) shows that incremental main-
tenance of the visual layer (Section 3.2) produces a 4.75x
speed up. The speed up can be attributed to less DOM el-
ements being created and less JavaScript components being

576initialized.
In addition to the speed up, FORWARD’s in-
cremental refresh preserves values that the user may have
entered in other form units, thus providing a user experi-
ence superior to that of the strawman implementation’s full
refresh.

5. RELATED WORK

The data management research community has created
database-driven frameworks for web site [12] and pure server
side web application [8, 33] development. In WebML [8] the
unit structure of a page tracks the database’s E/R schema
and it is easy to create pages that report/update entities
and navigate across them. While these frameworks do not
work with Ajax components, they still provide an important
target, which FORWARD pursued: maintain their clarity of
specifying applications despite the fact that Ajax applica-
tions require distributed programming, multiple languages
and tedious combination of component initialization and re-
fresh. Generally browser side code was neglected (except
for the recent [14] that describes how to run XQuery on the
browser).

Echo2 [11], ZK [38], Backbase [4] and ICEfaces [21] are
Ajax frameworks that also provide to the programmer the
ease of programming in a single language (typically Java)
and exclusively at the server. They mirror the page state
by caching it in its entirety on the server and they keep the
browser and server page states in sync automatically. How-
ever, since the languages of these frameworks are imper-
ative (instead of FORWARD’s SQL-based language), they
cannot perform automatic incremental maintenance of the
page. Therefore one has to program both for the initializa-
tion and the refresh of the components. To the best of our
knowledge FORWARD is the only framework that employs
automatic incremental maintenance of the page.

In the same spirit Microsoft’s ASP.NET [31] is a pure
server-side framework that provides mirroring of page state
by always sending the page state from the browser to the
server in a hidden form ﬁeld. It shares a drawback with the
Ajax frameworks listed above in that the page state includes
styling properties and implementation details and therefore
it has a high memory footprint and slow mirroring. For
example, our measurements have shown that an Echo2 page
for the page of Figure 1 occupies about 300KB, or three
times more memory. FORWARD’s structuring of the page
across the MVC architecture and the sending of the forms
parts of the page data tree is obviously suﬃcient and more
eﬃcient.

Google’s GWT [16] and Cornell’s Hilda [32] achieve the
single language property with the same fundamental tech-
nique: they distribute the processing between the browser
and the server. In GWT’s case this is accomplished by trans-
lating Java (which is the single programming language) into
JavaScript. We believe that the high engineering complex-
ity of distribution is unnecessary since mirroring can be very
performant, as we showed.

For use in pre-Ajax web application infrastructure,

[7]
shows how to manage cached dynamic pages by invalidat-
ing out-dated views in the cache upon relevant updates to
the base tables. Ajax provides a ﬁner-grained opportunity,
which FORWARD exploits: Instead of invalidating the whole
page, incrementally update its invalidated parts.

Relational incremental view maintenance received high at-
tention in the mid 90s, in the context of eﬃcient data ware-

house maintenance (for example, see [37, 2, 23]). More re-
cently, [1, 36, 10, 3, 28, 13] proposed solutions to the view
maintenance problem for query languages and data models
that support nesting and ordering. However, these tech-
niques have limited applicability for FORWARD as they
specialize in immediate view maintenance only, do not sup-
port the sets of required update operations or apply to less
expressive query languages.

6. CONCLUSIONS AND FUTURE WORK

FORWARD allows the development of Ajax data-driven
pages by declaratively describing their data (using an appro-
priately extended SQL) and consequently rendering them in
FORWARD’s page unit structure. The pages are treated
as automatically refreshed rendered views. We showed that
the rendered views approach increases productivity since the
page can be succinctly expressed with a combination of SQL
and (visual) page units while the mundane data synchroniza-
tion issues of the page are automatically resolved.

At the core of the described solution has been the “data-
driven page” assumption, which technically means that the
server state is eﬀectively fully captured by its database state
and the page’s data at a logical level can be described with
a query over the database state. Notice that a partial failure
of this assumption does not lead to a wholesale dismissal of
our approach. Rather, the developer can use FORWARD
just for the parts of pages that are data-driven while he will
need to resort to conventional Ajax programming techniques
for the rest.

The larger task of simplifying Ajax web application pro-
gramming entails a number of additional challenges, de-
scribed next, emerging once we remove the data-driven page
assumption. Some of those challenges will require additional
research often at the intersection of software engineering and
data management. Others (notably integration issues) will
keep being resolved by the developers’ code in practice.
Extending to non-data-driven pages An extension to
the rendered view paradigm may need to be taken when
the user interaction on the Ajax page leads to changes on
the page itself and such page changes are most succinctly ex-
pressed as a direct function of the user interaction. One way,
but not always the best, to accomplish such page changes
is to ﬁrst turn the user interaction’s eﬀects into database
insert/delete/updates so that the page view can be auto-
matically and incrementally maintained by capturing them.
Another direction towards addressing such cases is the ex-
tension of FORWARD to allow the page queries to (a) use
the current page state also as an input database and (b) ex-
tend the page query semantics to allow the expression of a
partial modiﬁcation of itself. We believe that an extension in
this direction can bridge the rendered view paradigm with
a style of programming based on explicitly specifying the
eﬀect of users’ interactions on parts of the page.
Integration between the relationally-driven page and
server side OO components If the server state includes
objects that either do not have an underlying database or
they are exported by OO components that encapsulate their
underlying database (therefore making it unavailable to the
SQL query fueling the rendered view) a conventional inte-
gration problem of objects to relational data emerges. Part
of the problem is mitigated by the fact that the FORWARD
page schemas already include nesting and variability. Nev-
ertheless, we need to work to provide tools, in the spirit

577of object-relational mappers such as Hibernate, to facilitate
this integration, while keeping in mind that the long history
of the OO/relational interfacing problem indicates that a
magic bullet is not found and developers will need to ap-
ply the best practices and methodologies of OO/relational
integration in this domain.

7. REFERENCES
[1] S. Abiteboul, J. McHugh, M. Rys, V. Vassalos, and

J. L. Wiener. Incremental maintenance for
materialized views over semistructured data. In
VLDB, pages 38–49, 1998.

[2] D. Agrawal, A. E. Abbadi, A. K. Singh, and T. Yurek.

Eﬃcient view maintenance at data warehouses. In
SIGMOD, pages 417–427, 1997.

[3] M. A. Ali, A. A. A. Fernandes, and N. W. Paton.

Movie: An incremental maintenance system for
materialized object views. Data Knowl. Eng.,
47(2):131–166, 2003.

[4] Backbase enterprise ajax framework, 2009. http:

//www.backbase.com/products/enterprise-ajax/.

[5] F. Bancilhon, S. Cluet, and C. Delobel. A query

language for the o2 object-oriented database system.
In DBPL, pages 122–138, 1989.

[6] J. A. Blakeley, P.-˚A. Larson, and F. W. Tompa.

Eﬃciently updating materialized views. In SIGMOD,
pages 61–71, 1986.

[7] K. S. Candan, D. Agrawal, W.-S. Li, O. Po, and W.-P.
Hsiung. View invalidation for dynamic content caching
in multitiered architectures. In VLDB, pages 562–573,
2002.

[8] S. Ceri, P. Fraternali, and A. Bongio. Web modeling
language (webml): a modeling language for designing
web sites. Computer Networks, 33(1-6):137–157, 2000.

[9] L. S. Colby, T. Griﬃn, L. Libkin, I. S. Mumick, and

H. Trickey. Algorithms for deferred view maintenance.
In SIGMOD, pages 469–480, 1996.

[10] K. Dimitrova, M. El-Sayed, and E. A. Rundensteiner.

Order-sensitive view maintenance of materialized
xquery views. In ER, pages 144–157, 2003.

[11] Echo web framework, 2009.

http://echo.nextapp.com/site/.

[12] M. F. Fern´andez, D. Florescu, A. Y. Levy, and

D. Suciu. Declarative speciﬁcation of web sites with
strudel. VLDB J., 9(1):38–55, 2000.

[13] J. N. Foster, R. Konuru, J. Sim´eon, and L. Villard. An
algebraic approach to view maintenance for xquery. In
PLAN-X, 2008.

[14] G. Fourny, M. Pilman, D. Florescu, D. Kossmann,

T. Kraska, and D. McBeath. Xquery in the browser.
In WWW, pages 1011–1020, 2009.

[15] J. J. Garrett. Ajax: A new approach to web

applications. http://adaptivepath.com/ideas/
essays/archives/000385.php, February 2005.
[Online; Stand 18.03.2008].

[16] Google widget toolkit, 2009.

http://code.google.com/webtoolkit/.

[17] T. Griﬃn and L. Libkin. Incremental maintenance of

views with duplicates. In M. J. Carey and D. A.
Schneider, editors, SIGMOD, pages 328–339. ACM
Press, 1995.

[18] A. Gupta and I. S. Mumick. Maintenance of

materialized views: Problems, techniques, and
applications. IEEE Data Eng. Bull., 18(2):3–18, 1995.

[19] A. Gupta, I. S. Mumick, and V. S. Subrahmanian.

Maintaining views incrementally. In P. Buneman and
S. Jajodia, editors, SIGMOD, pages 157–166. ACM
Press, 1993.

[20] M. A. Habib and M. Abrams. Analysis of sources of
latency in downloading web pages. In WebNet, pages
227–232, 2000.
[21] Icefaces, 2009.

http://www.icefaces.org/main/home/.

[22] B. Johnson. Reveling in constraints. Queue,

7(6):30–37, 2009.

[23] I. S. Mumick, D. Quass, and B. S. Mumick.

Maintenance of data cubes and summary tables in a
warehouse. In SIGMOD, pages 100–111, 1997.

[24] C. W. of America. 2009 report on internet speeds in

all 50 states, 2009. http:
//cwafiles.org/speedmatters/state_reports_
2009/CWA_Report_on_Internet_Speeds_2009.pdf.

[25] C. O’Hanlon. A conversation with werner vogels.

Queue, 4(4):14–22, 2006.

[26] K. A. Ross, D. Srivastava, and S. Sudarshan.
Materialized view maintenance and integrity
constraint checking: Trading space for time. In
SIGMOD, pages 447–458, 1996.

[27] K. Salem, K. S. Beyer, R. Cochrane, and B. G.

Lindsay. How to roll a join: Asynchronous incremental
view maintenance. In SIGMOD, pages 129–140, 2000.
[28] A. Sawires, J. Tatemura, O. Po, D. Agrawal, and K. S.

Candan. Incremental maintenance of path expression
views. In SIGMOD, pages 443–454, 2005.

[29] L. Simon. Minimizing browser reﬂow. http:

//code.google.com/speed/articles/reflow.html,
June 2009.

[30] The dojo toolkit, 2009.

http://www.dojotoolkit.org/.

[31] Wikipedia. Asp.net, 2009. Accessed Nov 04 2009.

http://en.wikipedia.org/w/index.php?title=ASP.
NET&oldid=323456166.

[32] F. Yang, N. Gupta, N. Gerner, X. Qi, A. J. Demers,

J. Gehrke, and J. Shanmugasundaram. A uniﬁed
platform for data driven web applications with
automatic client-server partitioning. In WWW, pages
341–350, 2007.

[33] F. Yang, J. Shanmugasundaram, M. Riedewald, and

J. Gehrke. Hilda: A high-level language for
data-drivenweb applications. In ICDE, page 32, 2006.
[34] K. Yi, H. Yu, J. Yang, G. Xia, and Y. Chen. Eﬃcient

maintenance of materialized top-k views. In ICDE,
pages 189–200, 2003.

[35] Yui library, 2009. http://developer.yahoo.com/yui/.
[36] Y. Zhuge and H. Garcia-Molina. Graph structured
views and their incremental maintenance. In ICDE,
pages 116–125, 1998.

[37] Y. Zhuge, H. Garcia-Molina, J. Hammer, and

J. Widom. View maintenance in a warehousing
environment. In SIGMOD, pages 316–327, 1995.

[38] Zk direct ria, 2009. http://www.zkoss.org/.

578